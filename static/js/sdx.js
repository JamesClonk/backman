(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

require("../modernizr");

require("./sdx-global");

},{"../modernizr":34,"./sdx-global":4}],2:[function(require,module,exports){
"use strict";
// Math.sign (used in ProgressFull)

if (!("sign" in Math)) {
    Math.sign = function (x) {
        return x > 0 ? 1 : x < 0 ? -1 : +x;
    };
}

},{}],3:[function(require,module,exports){
"use strict";

if (!String.prototype.startsWith) {
    String.prototype.startsWith = function (searchString, position) {
        position = position || 0;
        return this.indexOf(searchString, position) === position;
    };
}

},{}],4:[function(require,module,exports){
"use strict";

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

require("./polyfills/Math.sign");

require("./polyfills/startsWith");

var _sdx = require("./src/sdx");

var sdxExports = _interopRequireWildcard(_sdx);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var sdx = tslib_1.__assign({}, sdxExports, window.sdx || {}, { VERSION: "1.28.0" });
/* Polyfills */

window.sdx = sdx;
sdxExports.utils.onDocumentReady(function () {
    sdxExports.initInputField();
    sdxExports.initTextarea();
    sdxExports.initSelect();
    sdxExports.initLoaderBar();
    sdxExports.initAutocomplete();
    sdxExports.initProgressLight();
    sdxExports.initProgressFull();
    sdxExports.initRange();
    sdxExports.initModal();
    sdxExports.initAccordion();
    sdxExports.initCollapse();
    sdxExports.initMenuFlyout();
    sdxExports.initNavigation();
    sdxExports.initNavigationSide();
    sdxExports.initSearchInput();
    sdxExports.initEmptyState();
    sdxExports.initCarousel();
    sdxExports.initTable();
    sdxExports.initPieChart();
    sdxExports.initBarChartHorizontal();
    sdxExports.initBarChartVertical();
});

},{"./polyfills/Math.sign":2,"./polyfills/startsWith":3,"./src/sdx":30,"tslib":135}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _DomFunctions = require("./DomFunctions");

var Dom = _interopRequireWildcard(_DomFunctions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * A wrapper class for DOM Elements.
 */
var DomElement = /** @class */function () {
    /**
     * Creates a new instance.
     * @param {Element} - The element to wrap.
     * @param {String} - The DOM element to create.
     */
    function DomElement(element) {
        if (typeof element === "string") {
            this.element = document.createElement(element);
        } else {
            this.element = element;
        }
    }
    /**
     * Adds the specified CSS class to the element.
     * @param {String} - The class name to add.
     * @return {DomElement} Returns the current instance for fluent chaining of calls.
     */
    DomElement.prototype.addClass = function (name) {
        Dom.addClass(this.element, name);
        return this;
    };
    /**
     * Removes the specified CSS class from the element.
     * @param {String} - The class name to remove.
     * @return {DomElement} Returns the current instance for fluent chaining of calls.
     */
    DomElement.prototype.removeClass = function (name) {
        Dom.removeClass(this.element, name);
        return this;
    };
    DomElement.prototype.hasClass = function (name) {
        return Dom.hasClass(this.element, name);
    };
    DomElement.prototype.toggleClass = function (name) {
        Dom.toggleClass(this.element, name);
        return this;
    };
    Object.defineProperty(DomElement.prototype, "classes", {
        get: function get() {
            return this.element.classList;
        },
        enumerable: true,
        configurable: true
    });
    DomElement.prototype.setId = function (id) {
        this.element.setAttribute("id", id);
        return this;
    };
    Object.defineProperty(DomElement.prototype, "innerText", {
        get: function get() {
            return Dom.text(this.element);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DomElement.prototype, "innerHtml", {
        get: function get() {
            return this.element.innerHTML;
        },
        enumerable: true,
        configurable: true
    });
    DomElement.prototype.setHtml = function (value) {
        if (typeof value !== "string") {
            throw new Error("Expected HTML string");
        }
        this.element.innerHTML = value;
        return this;
    };
    DomElement.prototype.getAttribute = function (name) {
        return this.element.getAttribute(name);
    };
    DomElement.prototype.setAttribute = function (name, value) {
        this.element.setAttribute(name, value);
        return this;
    };
    /**
     * Registers an event listener.
     */
    DomElement.prototype.addEventListener = function (type, listener) {
        this.element.addEventListener(type, listener);
    };
    /**
     * Unregisters an event listener on the component.
     */
    DomElement.prototype.removeEventListener = function (type, listener) {
        this.element.removeEventListener(type, listener);
    };
    DomElement.prototype.appendChild = function (newChild) {
        if (!(newChild instanceof DomElement)) {
            throw new Error("Only other DomElements can be added as children");
        }
        this.element.appendChild(newChild.element);
        return this;
    };
    DomElement.prototype.prependChild = function (newChild) {
        if (!(newChild instanceof DomElement)) {
            throw new Error("Only other DomElements can be added as children");
        }
        this.element.insertBefore(newChild.element, this.element.firstChild);
        return this;
    };
    DomElement.prototype.insertBefore = function (newChild) {
        if (!(newChild instanceof DomElement)) {
            throw new Error("Only other DomElements can be added as children");
        }
        if (!this.element.parentNode) {
            throw new Error("Element is not attached");
        }
        this.element.parentNode.insertBefore(newChild.element, this.element);
        return this;
    };
    DomElement.prototype.insertAfter = function (newChild) {
        if (!(newChild instanceof DomElement)) {
            throw new Error("Only other DomElements can be added as children");
        }
        if (!this.element.parentNode) {
            throw new Error("Element is not attached");
        }
        this.element.parentNode.insertBefore(newChild.element, this.element.nextSibling);
        return this;
    };
    DomElement.prototype.removeChild = function (oldChild) {
        if (!(oldChild instanceof DomElement)) {
            throw new Error("Only a DomElements child can be removed");
        }
        this.element.removeChild(oldChild.element);
    };
    DomElement.prototype.find = function (selectors) {
        var e = this.element.querySelector(selectors);
        if (e) {
            return new DomElement(e);
        }
        return undefined;
    };
    DomElement.prototype.wrapWithElement = function (wrapperElement) {
        if (!this.element.parentNode) {
            throw new Error("Element is not attached");
        }
        this.element.parentNode.replaceChild(wrapperElement.element, this.element);
        wrapperElement.element.appendChild(this.element);
        return this;
    };
    DomElement.prototype.dispatchEvent = function (eventName) {
        var event;
        var el = this.element;
        if (document.createEvent) {
            event = document.createEvent("HTMLEvents");
            event.initEvent(eventName, true, true);
        } else if (document.createEventObject) {
            // IE < 9
            event = document.createEventObject();
            event.eventType = eventName;
        }
        event.eventName = eventName;
        if (el.dispatchEvent) {
            el.dispatchEvent(event);
        } else if (el.fireEvent && htmlEvents["on" + eventName]) {
            // IE < 9
            el.fireEvent("on" + event.eventType, event); // can trigger only real event (e.g. 'click')
        } else if (el[eventName]) {
            el[eventName]();
        } else if (el["on" + eventName]) {
            el["on" + eventName]();
        }
    };
    DomElement.prototype.css = function (property) {
        return Dom.css(this.element, property);
    };
    /**
     * Removes all child nodes of the current DomElement.
     */
    DomElement.prototype.empty = function () {
        Dom.empty(this.element);
    };
    return DomElement;
}();
exports.default = DomElement;

},{"./DomFunctions":6}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.addClass = addClass;
exports.removeClass = removeClass;
exports.hasClass = hasClass;
exports.toggleClass = toggleClass;
exports.isHidden = isHidden;
exports.text = text;
exports.parentWithClass = parentWithClass;
exports.textWidth = textWidth;
exports.css = css;
exports.getAttributeReference = getAttributeReference;
exports.getRootElement = getRootElement;
exports.empty = empty;
function addClass(element, name) {
    if (typeof name !== "string") {
        throw new Error("Expected string class name");
    }
    element.classList.add(name);
}
function removeClass(element, name) {
    if (typeof name !== "string") {
        throw new Error("Expected string class name");
    }
    element.classList.remove(name);
}
function hasClass(element, name) {
    if (typeof name !== "string") {
        throw new Error("Expected string class name");
    }
    return element.classList.contains(name);
}
function toggleClass(element, name) {
    if (typeof name !== "string") {
        throw new Error("Expected string class name");
    }
    element.classList.toggle(name);
}
/**
 * Determines if the given element is hidden from view.
 * @param {Element} Element The dom element to check.
 * @param {boolean} includeParents If set to `true` searches up the DOM and checks parent visibility as well. Defaults to `false`.
 */
function isHidden(element, includeParents) {
    if (includeParents === void 0) {
        includeParents = false;
    }
    if (includeParents === false) {
        var style = window.getComputedStyle(element);
        return style.display === "none" || element.offsetLeft < 0;
    }
    var result;
    // tslint:disable-next-line:no-conditional-assignment
    while ((result = isHidden(element, false)) === false && element.parentElement) {
        element = element.parentElement;
    }
    return result;
}
/**
 * Gets the text of an element an makes sure this works on all browsers.
 */
function text(element) {
    return element.textContent || element.innerText;
}
function parentWithClass(element, className) {
    var current = element;
    while (!hasClass(current, className) && current.parentElement) {
        current = current.parentElement;
    }
    if (hasClass(current, className)) {
        return current;
    }
    return undefined;
}
function textWidth(text, font) {
    // NOTE: this width measuring algorithm is a lot faster
    // but does unfortunately not work on IE 10...
    // let canvas = document.createElement("canvas")
    // let context = canvas.getContext("2d")
    // context.font = font
    // let metrics = context.measureText(text)
    // return Math.round(metrics.width)
    var div = document.createElement("div");
    div.innerHTML = text;
    div.style.font = font;
    div.style.position = "absolute";
    div.style.visibility = "hidden";
    document.body.appendChild(div);
    var result = div.offsetWidth;
    document.body.removeChild(div);
    return result;
}
function css(element, property) {
    return window.getComputedStyle(element).getPropertyValue(property);
}
/**
 * Gets the single element referenced in an items data-* attribute.
 * @param {DomElement} element - The element containing the reference attribute.
 * @param {string} attribute - The name of the reference attribute.
 * @returns {DomElement} The referenced element; or `undefined` if the reference is invalid
 * or the attribute could not be found.
 */
function getAttributeReference(element, attribute) {
    var attrValue = element.getAttribute(attribute);
    if (!attrValue || attrValue === "") {
        return undefined;
    }
    return document.querySelector(attrValue);
}
/**
 * Gets the document root element (normally the body element)
 * If the document uses a sdx-container wrapper this is returned instead.
 * @returns {Element} The root dom element.
 */
function getRootElement() {
    var element = document.querySelector(".sdx-container");
    if (!element) {
        element = document.body;
    }
    return element;
}
/**
 * Removes all child nodes from the provided element.
 * @param {Element} element The Dom element
 */
function empty(element) {
    while (element.firstChild) {
        element.removeChild(element.firstChild);
    }
}

},{}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
/* Keyboard input keycode definitions */
var KEY_TAB = exports.KEY_TAB = 9;
var KEY_ENTER = exports.KEY_ENTER = 13;
var KEY_ESCAPE = exports.KEY_ESCAPE = 27;
// Arrow keys
var KEY_ARROW_UP = exports.KEY_ARROW_UP = 38;
var KEY_ARROW_DOWN = exports.KEY_ARROW_DOWN = 40;
var KEY_ARROW_LEFT = exports.KEY_ARROW_LEFT = 37;
var KEY_ARROW_RIGHT = exports.KEY_ARROW_RIGHT = 39;
// Page keys
var KEY_PAGE_UP = exports.KEY_PAGE_UP = 33;
var KEY_PAGE_DOWN = exports.KEY_PAGE_DOWN = 34;
// Numbers
var KEY_NR_0 = exports.KEY_NR_0 = 48;
var KEY_NR_1 = exports.KEY_NR_1 = 49;
var KEY_NR_9 = exports.KEY_NR_9 = 57;
// helper functions
var containsKey = exports.containsKey = function containsKey(keycode, inputsKeys) {
    var hasKey = false;
    if (inputsKeys && inputsKeys.length > 0) {
        [].forEach.call(inputsKeys, function (inputsKey) {
            if (keycode === inputsKey) {
                hasKey = true;
            }
        });
    }
    return hasKey;
};
var getKeyValue = exports.getKeyValue = function getKeyValue(keycode) {
    if (keycode < 48 || keycode > 105) {
        return "";
    }
    return String.fromCharCode(96 <= keycode && keycode <= 105 ? keycode - 48 : keycode).toLowerCase();
};

},{}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.onDocumentReady = onDocumentReady;
exports.searchAndInitialize = searchAndInitialize;
exports.clamp = clamp;
exports.preventDefault = preventDefault;
exports.remove = remove;
exports.find = find;
exports.internetExplorerOrEdgeVersion = internetExplorerOrEdgeVersion;
exports.scrollIntoView = scrollIntoView;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Calls the callback function when the document has been completely parsed.
 * @param {callback} value The callback function to execute.
 */
function onDocumentReady(callback) {
    function completed() {
        document.removeEventListener("DOMContentLoaded", completed, false);
        window.removeEventListener("load", completed, false);
        callback();
    }
    if (document.readyState === "complete") {
        setTimeout(callback);
    } else {
        document.addEventListener("DOMContentLoaded", completed, false);
        // A fallback to window.onload, that will always work
        window.addEventListener("load", completed, false);
    }
}
function searchAndInitialize(selector, callback, initSelector) {
    var e_1, _a;
    if (!callback) {
        throw new Error("The callback cannot be undefined");
    }
    var elements = document.querySelectorAll(selector);
    try {
        for (var elements_1 = tslib_1.__values(elements), elements_1_1 = elements_1.next(); !elements_1_1.done; elements_1_1 = elements_1.next()) {
            var e = elements_1_1.value;
            var initElement = e;
            if (initSelector) {
                initElement = initSelector(e);
            }
            if (initElement.getAttribute("data-init") === "auto") {
                callback(e);
            }
        }
    } catch (e_1_1) {
        e_1 = { error: e_1_1 };
    } finally {
        try {
            if (elements_1_1 && !elements_1_1.done && (_a = elements_1.return)) _a.call(elements_1);
        } finally {
            if (e_1) throw e_1.error;
        }
    }
}
/**
 * Returns a number whose value is limited to the given range.
 *
 * Example: limit the output of this computation to between 0 and 255
 * Utils.clamp(number, 0, 255)
 *
 * @param {Number} value The number to clamp
 * @param {Number} min The lower boundary of the output range
 * @param {Number} max The upper boundary of the output range
 * @returns A number in the range [min, max]
 * @type Number
 */
function clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
}
/**
 * A polyfill for Event.preventDefault().
 * @param {Event} event - The event to prevent the default action.
 */
function preventDefault(event) {
    if (event.preventDefault) {
        event.preventDefault();
    } else {
        event.returnValue = false;
    }
}
/**
 * A polyfill for Node.remove().
 * @param {Node} node - The node to remove.
 */
function remove(node) {
    if (!node || !node.parentNode) {
        return;
    }
    node.parentNode.removeChild(node);
}
/**
 * A simple polyfill for the Array.find() method.
 * @param {Array} array - The array to search in.
 * @param {function} expression - The expression to evaluate. Must return true if the element matches.
 */
function find(array, expression) {
    for (var i = 0; i < array.length; i++) {
        var item = array[i];
        if (expression(item) === true) {
            return item;
        }
    }
    return undefined;
}
/**
 * Checks the useragent and returns the Microsoft Internet Explorer / Edge version.
 * If another browser is detected 0 is returned.
 */
function internetExplorerOrEdgeVersion(userAgent) {
    if (userAgent === void 0) {
        userAgent = navigator.userAgent;
    }
    // handle IE and Edge
    var ieOrEdge = userAgent.search(/MSIE |Edge[/]/);
    if (ieOrEdge > 0) {
        return parseInt(userAgent.substring(ieOrEdge + 5, userAgent.indexOf(".", ieOrEdge)), 10);
    }
    // handle IE11
    if (userAgent.indexOf("Trident/") > 0) {
        var rv = userAgent.indexOf("rv:");
        return parseInt(userAgent.substring(rv + 3, userAgent.indexOf(".", rv)), 10);
    }
    return 0;
}
/**
 * Tries to move a child element to the top by scrolling the parent element, if it is not already fully visible.
 */
function scrollIntoView(child) {
    var parent = child.parentNode;
    var parentRect = parent.getBoundingClientRect();
    var childRect = child.getBoundingClientRect();
    var isFullyVisible = childRect.top >= parentRect.top && childRect.bottom <= parentRect.top + parent.clientHeight;
    if (!isFullyVisible) {
        parent.scrollTop = childRect.top + parent.scrollTop - parentRect.top;
    }
}

},{"tslib":135}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _DomFunctions = require("../DomFunctions");

var Dom = _interopRequireWildcard(_DomFunctions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var QUERY_TOGGLE = ".accordion__toggle";
var QUERY_OPEN_SECTION = ".accordion__item.is-open";
var QUERY_COLLAPSE = ".accordion__collapse";
var CLASS_ITEM = "accordion__item";
var CLASS_OPEN = "is-open";
var CLASS_KEEP_OPEN = "accordion__keep-open";
var REGEX_HIDDEN = /accordion--hidden-.*/;
var ANIMATION_OPEN = 300;
var ANIMATION_DELAY_OPEN = 50;
var ANIMATION_VISIBLE = 150;
/**
 * The Accordion component
 */
var Accordion = /** @class */function (_super) {
    tslib_1.__extends(Accordion, _super);
    /**
     * Creates and initializes the Accordion component.
     * @param {DomElement} - The root element of the Accordion component.
     */
    function Accordion(element) {
        var _this = _super.call(this, element) || this;
        _this.easing = {
            // Equivalent to gsap's [ Power1.easeIn, Power4.easeOut ]
            inQuadOutQuint: [0.550, 0.085, 0.320, 1]
        };
        _this._sectionClickHandler = _this._handleSectionClick.bind(_this);
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the Accordion component.
     * @private
     */
    Accordion.prototype._initialize = function () {
        var e_1, _a;
        if (this.element.className.split(" ").some(function (c) {
            return REGEX_HIDDEN.test(c);
        })) {
            var indicator = new _DomElement2.default("input").setAttribute("type", "hidden").addClass("js-hidden");
            this.appendChild(indicator);
            this._hiddenIndicator = indicator.element;
        }
        try {
            for (var _b = tslib_1.__values(this.element.querySelectorAll(QUERY_TOGGLE)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var toggle = _c.value;
                toggle.addEventListener("click", this._sectionClickHandler);
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
    };
    Accordion.prototype._handleSectionClick = function (event) {
        if (this._hiddenIndicator) {
            var style = window.getComputedStyle(this._hiddenIndicator);
            if (style.visibility !== "visible") {
                return;
            }
        }
        var navSection = event.target.parentElement;
        while (!Dom.hasClass(navSection, CLASS_ITEM) && navSection.parentElement) {
            navSection = navSection.parentElement;
        }
        var prevSection = this.element.querySelector(QUERY_OPEN_SECTION);
        if (prevSection && prevSection !== navSection) {
            if (!Dom.hasClass(this.element, CLASS_KEEP_OPEN)) {
                this._toggleSection(prevSection);
            }
        }
        this._toggleSection(navSection);
    };
    Accordion.prototype._toggleSection = function (accSection) {
        var collapseElement = accSection.querySelector(QUERY_COLLAPSE);
        if (Dom.hasClass(accSection, CLASS_OPEN)) {
            Dom.removeClass(accSection, CLASS_OPEN);
            this._closeCollapseSection(collapseElement);
        } else {
            Dom.addClass(accSection, CLASS_OPEN);
            if (collapseElement) {
                // to ignore the case when there is no collapsible element (see sdx doku navigation, "all the basics") in a list of accordion
                this._openCollapseSection(collapseElement);
            }
        }
    };
    Accordion.prototype._openCollapseSection = function (el) {
        this._stopAnimations(el);
        el.style.display = "block";
        this.animation = _animejs2.default.timeline().add({
            targets: el,
            duration: ANIMATION_OPEN,
            height: el.scrollHeight + "px",
            easing: this.easing.inQuadOutQuint,
            complete: function complete() {
                el.style.height = "auto";
                el.setAttribute("aria-expanded", "true");
                el.classList.add(CLASS_OPEN);
            }
        }).add({
            targets: el,
            duration: ANIMATION_VISIBLE,
            opacity: 1,
            easing: "linear",
            offset: ANIMATION_DELAY_OPEN
        });
    };
    Accordion.prototype._closeCollapseSection = function (el) {
        this._stopAnimations(el);
        this.animation = _animejs2.default.timeline().add({
            targets: el,
            duration: ANIMATION_OPEN,
            height: "0px",
            easing: this.easing.inQuadOutQuint,
            complete: function complete() {
                el.style.removeProperty("display");
                el.style.removeProperty("opacity");
                el.style.removeProperty("height");
                el.setAttribute("aria-expanded", "false");
                el.classList.remove(CLASS_OPEN);
            }
        }).add({
            targets: el,
            duration: ANIMATION_VISIBLE,
            opacity: 0,
            easing: "linear",
            offset: 0
        });
    };
    Accordion.prototype._stopAnimations = function (el) {
        if (this.lastAnimatedElement === el) {
            if (this.animation) {
                this.animation.pause();
            }
            _animejs2.default.remove(el);
        }
        this.lastAnimatedElement = el;
    };
    /**
     * Removes all event handlers and clears references.
     */
    Accordion.prototype.destroy = function () {
        var e_2, _a;
        try {
            for (var _b = tslib_1.__values(this.element.querySelectorAll(QUERY_TOGGLE)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var toggle = _c.value;
                toggle.removeEventListener("click", this._sectionClickHandler);
            }
        } catch (e_2_1) {
            e_2 = { error: e_2_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_2) throw e_2.error;
            }
        }
        this._sectionClickHandler = null;
        this.element = null;
    };
    return Accordion;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".accordion", function (e) {
        new Accordion(e);
    });
}
exports.default = Accordion;

},{"../DomElement":5,"../DomFunctions":6,"../Utils":8,"animejs":35,"tslib":135}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _trunc = require("babel-runtime/core-js/math/trunc");

var _trunc2 = _interopRequireDefault(_trunc);

var _from = require("babel-runtime/core-js/array/from");

var _from2 = _interopRequireDefault(_from);

exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _Inputs = require("../Inputs");

var Inputs = _interopRequireWildcard(_Inputs);

var _DomFunctions = require("../DomFunctions");

var Dom = _interopRequireWildcard(_DomFunctions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var QUERY_SLIDER = ".carousel__container";
var QUERY_SLIDE_AREA = ".carousel__slider";
var QUERY_WRAPPER = ".carousel__slider-wrapper";
var QUERY_PAGINATION = ".carousel__pagination";
var CLASS_ACTIVE = "slide--active";
var CLASS_PREV = "slide--prev";
var CLASS_NEXT = "slide--next";
var CLASS_BULLET = "pagination-bullet";
var CLASS_BULLET_ACTIVE = "pagination-bullet--active";
var QUERY_BTN_PREV = ".carousel__button-prev";
var QUERY_BTN_NEXT = ".carousel__button-next";
var QUERY_BTN_WRAPPER = ".carousel__button-wrapper";
var ATTRIBUTE_INDEX = "js-index";
var ANIMATION_DURATION = 350;
var ANIMATION_EASING = "ease-in-out";
var TOUCH_DURATION = 300;
var TOUCH_DELTA_MIN = 25;
/**
 * The carousel component definition.
 */
var Carousel = /** @class */function (_super) {
    tslib_1.__extends(Carousel, _super);
    /**
     * Creates and initializes the carousel component.
     * @param {DomElement} element - The root element of the Carousel component.
     * @param {Number} index - The initial index.
     */
    function Carousel(element, index) {
        if (index === void 0) {
            index = 0;
        }
        var _this = _super.call(this, element) || this;
        _this._slider = _this.element.querySelector(QUERY_SLIDER);
        _this._wrapper = _this._slider.querySelector(QUERY_WRAPPER);
        _this._pagination = _this._slider.querySelector(QUERY_PAGINATION);
        _this._slideArea = _this._slider.querySelector(QUERY_SLIDE_AREA);
        _this._btnWrapper = _this.element.querySelector(QUERY_BTN_WRAPPER);
        _this._prevCtrl = _this.element.querySelector(QUERY_BTN_PREV);
        _this._nextCtrl = _this.element.querySelector(QUERY_BTN_NEXT);
        _this._slides = [];
        _this._index = index || 0;
        _this._slidesPerGroup = 1;
        _this._sliderWrapper = new SliderWrapper(_this._wrapper, _this._slideArea, _this.element);
        _this._sliderWrapper.index = _this._index;
        _this._additionalSlideMargin = 0;
        _this._resizeHandler = _this._onresize.bind(_this);
        _this._prevHandler = _this.prev.bind(_this);
        _this._nextHandler = _this.next.bind(_this);
        _this._paginationClickHandler = _this._handlePaginationClick.bind(_this);
        _this._keydownHandler = _this._handleKeydown.bind(_this);
        _this._handleTouchstart = _this._onTouchstart.bind(_this);
        _this._handleTouchmove = _this._onTouchmove.bind(_this);
        _this._handleTouchend = _this._onTouchend.bind(_this);
        _this._initialize();
        _this.slide(_this._index, 0, false);
        _this._updateCtrlOffsets();
        return _this;
    }
    /**
     * Initializes the carousel component.
     * @private
     */
    Carousel.prototype._initialize = function () {
        // responsive helpers
        this._breakpointPhone = new _DomElement2.default("div").addClass("js-phone").element;
        this._breakpointTablet = new _DomElement2.default("div").addClass("js-tablet").element;
        this._breakpointDesktop = new _DomElement2.default("div").addClass("js-desktop").element;
        this.element.appendChild(this._breakpointPhone);
        this.element.appendChild(this._breakpointTablet);
        this.element.appendChild(this._breakpointDesktop);
        if (this._prevCtrl && this._nextCtrl) {
            this._prevCtrl.addEventListener("click", this._prevHandler);
            this._nextCtrl.addEventListener("click", this._nextHandler);
        }
        if (this._pagination) {
            this._pagination.addEventListener("click", this._paginationClickHandler);
        }
        this._slides = (0, _from2.default)(this._wrapper.children);
        if (this._slides.length === 0) {
            throw Error("Provide at least one slide to the slider");
        }
        for (var i = 0; i < this._slides.length; i++) {
            var slide = this._slides[i];
            slide.setAttribute(ATTRIBUTE_INDEX, String(i));
        }
        this._updateResponsiveOptions();
        this._sliderWrapper.initialize();
        this.reset();
        this.element.addEventListener("keydown", this._keydownHandler);
        this._slideArea.addEventListener("mousedown", this._handleTouchstart);
        this._slideArea.addEventListener("touchstart", this._handleTouchstart);
        window.addEventListener("resize", this._resizeHandler);
        window.addEventListener("orientationchange", this._resizeHandler);
    };
    Carousel.prototype._isBreakpointActive = function (breakpoint) {
        var style = window.getComputedStyle(breakpoint);
        return style.visibility === "visible";
    };
    Carousel.prototype._onresize = function () {
        this.reset();
        this._updateCtrlOffsets();
    };
    /**
     * Makes sure the index is always in the range of available slide
     * In case it's to high or to low it is wrapped around
     * @param {Number} index - The index to adjust and sanitize
     * @returns {Number} index - The adjusted index
     * @private
     */
    Carousel.prototype._adjustIndex = function (index) {
        if (typeof index !== "number") {
            index = 0;
        }
        if (index < 0) {
            index = this._wrapround(index, 0, this._slides.length);
        } else if (index >= this._slides.length) {
            index %= this._slides.length;
        }
        return Math.floor(index / this._slidesPerGroup) * this._slidesPerGroup;
    };
    Carousel.prototype._wrapround = function (n, min, max) {
        if (n >= max) {
            return min;
        }
        if (n < min) {
            return max - 1;
        }
        return n;
    };
    Carousel.prototype._wraproundCount = function (a, b, min, max, direction) {
        if (direction === 0) {
            return 0;
        }
        if (a < min || a >= max) {
            throw new Error("Argument 'a' is out of range, Value: " + a + " Min: " + min + ", Max: " + max);
        }
        if (b < min || b >= max) {
            throw new Error("Argument 'b' is out of range, Value: " + b + " Min: " + min + ", Max: " + max);
        }
        var i = 0;
        while (a !== b) {
            i++;
            a = this._wrapround(a + direction, min, max);
        }
        return i;
    };
    Carousel.prototype._updateCtrlOffsets = function () {
        if (!this._nextCtrl || !this._prevCtrl || !this._btnWrapper) {
            return;
        }
        var prevCtrlMargin = 0;
        var nextCtrlMargin = 0;
        if (this._slidesPerGroup > 1) {
            var wrapperRect = this._btnWrapper.getBoundingClientRect();
            var prevSlideCount = Math.floor(0.5 * this._slidesPerGroup);
            var rightIndex = this._sliderWrapper.index + prevSlideCount + 1;
            var leftIndex = this._sliderWrapper.index - 1;
            if (this._slidesPerGroup % 2 !== 0) {
                leftIndex -= prevSlideCount;
            }
            if (leftIndex >= 0 && leftIndex < this._wrapper.children.length && rightIndex >= 0 && rightIndex < this._wrapper.children.length) {
                var leftSlide = this._sliderWrapper.getSlideProperties(leftIndex);
                var rightSlide = this._sliderWrapper.getSlideProperties(rightIndex);
                var btnWidth = this._prevCtrl.offsetWidth;
                if (btnWidth <= 0) {
                    btnWidth = 60;
                }
                prevCtrlMargin = leftSlide.right - wrapperRect.left - btnWidth;
                nextCtrlMargin = wrapperRect.right - rightSlide.left - btnWidth;
            }
        }
        var left = prevCtrlMargin !== 0 ? prevCtrlMargin + "px" : "";
        this._prevCtrl.style.left = left;
        var right = nextCtrlMargin !== 0 ? nextCtrlMargin + "px" : "";
        this._nextCtrl.style.right = right;
    };
    Carousel.prototype._updateActiveSlides = function (nextIndex) {
        var prevSlideCount = Math.floor(0.5 * (this._slidesPerGroup - 1));
        var evenGroup = this._slidesPerGroup % 2 === 0;
        for (var i = 0; i < this._wrapper.children.length; i++) {
            var slide = this._wrapper.children[i];
            if (i === nextIndex || evenGroup && i === nextIndex + 1) {
                Dom.addClass(slide, CLASS_ACTIVE);
            } else {
                Dom.removeClass(slide, CLASS_ACTIVE);
            }
            if (i < nextIndex && i >= nextIndex - prevSlideCount) {
                Dom.addClass(slide, CLASS_PREV);
            } else {
                Dom.removeClass(slide, CLASS_PREV);
            }
            if (i > nextIndex && (i <= nextIndex + prevSlideCount || evenGroup && i <= nextIndex + 1 + prevSlideCount)) {
                Dom.addClass(slide, CLASS_NEXT);
            } else {
                Dom.removeClass(slide, CLASS_NEXT);
            }
        }
    };
    /**
     * Updates and creates the pagination bullets.
     * @private
     */
    Carousel.prototype._updatePagination = function () {
        if (!this._pagination) {
            return;
        }
        var to = this._index;
        var bullets = this._pagination.children;
        var totalItems = Math.max(this._slides.length, bullets.length);
        var slideCount = Math.ceil(this._slides.length / this._slidesPerGroup);
        var activeSlideIndex = Math.floor(to / this._slidesPerGroup);
        for (var i = 0; i < totalItems; i++) {
            var bullet = void 0;
            if (bullets.length > i) {
                if (bullets.length <= slideCount) {
                    bullet = bullets[i];
                } else {
                    (0, _Utils.remove)(bullets[i]);
                }
            } else if (i < slideCount) {
                bullet = new _DomElement2.default("div").addClass(CLASS_BULLET).element;
                this._pagination.appendChild(bullet);
            }
            if (bullet && i < slideCount) {
                if (i === activeSlideIndex) {
                    Dom.addClass(bullet, CLASS_BULLET_ACTIVE);
                } else {
                    Dom.removeClass(bullet, CLASS_BULLET_ACTIVE);
                }
            }
        }
    };
    Carousel.prototype._handlePaginationClick = function (e) {
        if (!Dom.hasClass(e.target, CLASS_BULLET)) {
            return;
        }
        var index = (0, _from2.default)(this._pagination.children).indexOf(e.target);
        var slideNumber = index * this._slidesPerGroup;
        this.slideTo(slideNumber);
    };
    Carousel.prototype._handleKeydown = function (event) {
        var keycode = event.which || event.keyCode;
        switch (keycode) {
            case Inputs.KEY_ARROW_LEFT:
                this.prev();
                break;
            case Inputs.KEY_ARROW_RIGHT:
                this.next();
                break;
            case Inputs.KEY_ESCAPE:
                this.element.blur();
                break;
            default:
        }
    };
    Carousel.prototype._onTouchstart = function (event) {
        var touch = event.touches ? event.touches[0] : event;
        this._slideArea.removeEventListener("mousedown", this._handleTouchstart);
        this._slideArea.removeEventListener("touchstart", this._handleTouchstart);
        this._sliderWrapper.beginDrag();
        var pageX = touch.pageX;
        this._touchOffset = {
            x: pageX,
            time: Date.now()
        };
        this._delta = {
            x: 0,
            lastMove: pageX
        };
        document.addEventListener("mousemove", this._handleTouchmove);
        document.addEventListener("touchmove", this._handleTouchmove);
        document.addEventListener("mouseup", this._handleTouchend);
        document.addEventListener("mouseleave", this._handleTouchend);
        document.addEventListener("touchend", this._handleTouchend);
    };
    Carousel.prototype._onTouchmove = function (event) {
        var touch = event.touches ? event.touches[0] : event;
        var pageX = touch.pageX;
        var deltaMove = pageX - this._delta.lastMove;
        this._delta = {
            x: pageX - this._touchOffset.x,
            lastMove: pageX
        };
        if (this._touchOffset) {
            (0, _Utils.preventDefault)(event);
            this._sliderWrapper.move(deltaMove);
            this._cloneSlidesToFitWrapper(false, deltaMove);
        }
    };
    Carousel.prototype._onTouchend = function () {
        var duration = this._touchOffset ? Date.now() - this._touchOffset.time : undefined;
        var isValid = Number(duration) < TOUCH_DURATION && Math.abs(this._delta.x) > TOUCH_DELTA_MIN || Math.abs(this._delta.x) > this._frameWidth / 3;
        if (isValid) {
            var direction = (0, _Utils.clamp)(this._delta.x, -1, 1) * -1;
            this.slide(false, direction, true);
            this._sliderWrapper.endDrag();
        } else {
            // Slide back to the starting point of the drag operation
            this._sliderWrapper.cancelDrag();
        }
        this._touchOffset = undefined;
        this._slideArea.addEventListener("mousedown", this._handleTouchstart);
        this._slideArea.addEventListener("touchstart", this._handleTouchstart);
        document.removeEventListener("mousemove", this._handleTouchmove);
        document.removeEventListener("mouseup", this._handleTouchend);
        document.removeEventListener("mouseleave", this._handleTouchend);
        document.removeEventListener("touchmove", this._handleTouchmove);
        document.removeEventListener("touchend", this._handleTouchend);
    };
    /**
     * Updated parameters in regard to the currently active responsive
     * breakpoint.
     * @private
     */
    Carousel.prototype._updateResponsiveOptions = function () {
        if (this._isBreakpointActive(this._breakpointPhone)) {
            this._slidesPerGroup = 1;
        }
        if (this._isBreakpointActive(this._breakpointTablet)) {
            this._slidesPerGroup = 2;
        }
        if (this._isBreakpointActive(this._breakpointDesktop)) {
            this._slidesPerGroup = 3;
        }
        this._sliderWrapper.slidesPerGroup = this._slidesPerGroup;
    };
    /**
     * Clones the requested slide and adds it to the slider.
     * @param {Number} index - The original slide index of the template slide
     * @param {Number} direction - The direction in which to add the slides, -1 for left, 1 for right
     * @private
     */
    Carousel.prototype._cloneSlide = function (index, direction) {
        var clone = this._slides[index].cloneNode(true);
        Dom.removeClass(clone, CLASS_ACTIVE);
        Dom.removeClass(clone, CLASS_PREV);
        Dom.removeClass(clone, CLASS_NEXT);
        this._sliderWrapper.addSlide(clone, direction);
        var slideMargin = this._additionalSlideMargin > 0 ? this._additionalSlideMargin + "px" : "";
        clone.style.marginLeft = slideMargin;
        clone.style.marginRight = slideMargin;
        return clone.offsetWidth;
    };
    /**
     * Clones and adds the requested ammount of slides.
     * @param {Number} slideCount - The number of slides to add
     * @param {Number} direction - The direction in which to add the slides, -1 for left, 1 for right
     * @private
     */
    Carousel.prototype._cloneSlidesByCount = function (slideCount, direction) {
        var originalIndex = direction < 0 ? 0 : this._wrapper.children.length - 1;
        var index = parseInt(this._wrapper.children[originalIndex].getAttribute(ATTRIBUTE_INDEX), 10);
        while (slideCount > 0) {
            index = this._wrapround(index + direction, 0, this._slides.length);
            this._cloneSlide(index, direction);
            slideCount--;
        }
    };
    /**
     * Calculates the scroll clount and inserts the required ammount of slides
     * in the apropriate direction.
     * @param {Number} nextIndex - The slide to scroll to
     * @param {Number} direction - The direction of the scroll
     * @private
     */
    Carousel.prototype._cloneSlidesByScrollCount = function (nextIndex, direction) {
        var scrollCount = this._wraproundCount(this._index, nextIndex, 0, this._slides.length, direction);
        var outerSlideProps = this._sliderWrapper.getSlideProperties(direction > 0 ? this._wrapper.children.length - 1 : 0);
        var indexToOuterSlideCount = this._wraproundCount(this._index, outerSlideProps.index, 0, this._slides.length, direction);
        var slidesToInsert = scrollCount - indexToOuterSlideCount;
        if (slidesToInsert > 0) {
            this._cloneSlidesByCount(slidesToInsert, direction);
        }
    };
    Carousel.prototype._cloneSlidesByToFill = function (spaceToFill, direction) {
        var originalIndex = direction < 0 ? 0 : this._wrapper.children.length - 1;
        var index = parseInt(this._wrapper.children[originalIndex].getAttribute(ATTRIBUTE_INDEX), 10);
        while (spaceToFill > 0) {
            index = this._wrapround(index + direction, 0, this._slides.length);
            spaceToFill -= this._cloneSlide(index, direction);
        }
    };
    Carousel.prototype._cloneSlidesToFitWrapper = function (cleanup, slideDelta) {
        if (cleanup === void 0) {
            cleanup = true;
        }
        if (slideDelta === void 0) {
            slideDelta = 0;
        }
        var realIndex = this._sliderWrapper.index;
        var first;
        var last;
        if (cleanup === false) {
            first = this._sliderWrapper.getSlideProperties(0);
            last = this._sliderWrapper.getSlideProperties(this._wrapper.children.length - 1);
        } else {
            var result = this._sliderWrapper.getRemovableSlides(slideDelta);
            first = result.first;
            last = result.last;
            // Remove the slides from view
            for (var i = result.slides.length - 1; i >= 0; i--) {
                if (result.slides[i] === true) {
                    this._sliderWrapper.removeSlide(i);
                }
            }
        }
        var spaceToFill = this._sliderWrapper.getEmptySpace(first.left, last.right);
        // Check if additional slides are required on the left
        if (first.visible === true && spaceToFill.left > 0) {
            this._cloneSlidesByToFill(spaceToFill.left, -1);
        }
        // Check if additional slides are required on the right
        if (last.visible === true && spaceToFill.right > 0) {
            this._cloneSlidesByToFill(spaceToFill.right, 1);
        }
        return realIndex - this._sliderWrapper.index;
    };
    /**
     * Gets the real (wrapper) index for the slide with the given original index
     * @param {Number} index - The index to search for
     * @param {Number} direction - The direction in which to search
     * @returns {Number} The wrapper index
     * @private
     */
    Carousel.prototype._getRealIndexFor = function (index, direction) {
        var i = this._sliderWrapper.index;
        while (i >= 0 && i < this._wrapper.children.length) {
            var slideIndex = parseInt(this._wrapper.children[i].getAttribute(ATTRIBUTE_INDEX), 10);
            if (slideIndex === index) {
                return i;
            }
            i += direction;
        }
        throw new Error("Cloud not find real index for slide " + index + " in direction " + direction);
    };
    Object.defineProperty(Carousel.prototype, "index", {
        /**
         * Gets the index of the current active slide. If the slides are grouped evenly
         * the active slide is always the first in the group.
         * @returns {Number} The index of the active slide.
         */
        get: function get() {
            return this._index;
        },
        enumerable: true,
        configurable: true
    });
    Carousel.prototype.reset = function () {
        this._frameWidth = this._slider.getBoundingClientRect().width || this._slider.offsetWidth;
        this._updateResponsiveOptions();
        if (this._nextCtrl) {
            this._nextCtrl.disabled = false;
        }
        if (this._prevCtrl) {
            this._prevCtrl.disabled = false;
        }
        if (this._slidesPerGroup === 1) {
            var style = window.getComputedStyle(this._slider.parentElement);
            var parentWidth = this._slider.parentElement.clientWidth + (parseFloat(style.marginLeft) || 0) + (parseFloat(style.marginRight) || 0);
            var outerMargin = Math.ceil(parentWidth - this._frameWidth);
            this._additionalSlideMargin = Math.ceil(outerMargin * 0.5) + 1;
        } else {
            this._additionalSlideMargin = 0;
        }
        var slideMargin = this._additionalSlideMargin > 0 ? this._additionalSlideMargin + "px" : "";
        for (var i = 0; i < this._wrapper.children.length; i++) {
            var slide = this._wrapper.children[i];
            slide.style.marginLeft = slideMargin;
            slide.style.marginRight = slideMargin;
        }
        this._sliderWrapper.onresize();
        this._cloneSlidesToFitWrapper(false);
        this._sliderWrapper.moveTo(this._sliderWrapper.index);
        this._updatePagination();
        this._updateActiveSlides(this._sliderWrapper.index);
    };
    /**
     * Moves the slider to the next item.
     */
    Carousel.prototype.prev = function () {
        this.slide(false, -1);
    };
    /**
     * Moves the slider to the previous item.
     */
    Carousel.prototype.next = function () {
        this.slide(false, 1);
    };
    Carousel.prototype.slide = function (nextIndex, direction, animate) {
        if (animate === void 0) {
            animate = true;
        }
        if (typeof nextIndex !== "number") {
            if (direction > 0) {
                nextIndex = this._index + this._slidesPerGroup;
                direction = 1;
            } else {
                nextIndex = this._index - this._slidesPerGroup;
                direction = -1;
            }
        }
        nextIndex = this._adjustIndex(nextIndex);
        if (!direction) {
            direction = (0, _Utils.clamp)(nextIndex - this._index, -1, 1);
        }
        // Make sure there are enought slides on screen
        this._cloneSlidesToFitWrapper(false);
        // Make sure there are enough slides for the scroll operation
        this._cloneSlidesByScrollCount(nextIndex, direction);
        var realIndex = this._getRealIndexFor(nextIndex, direction);
        var slideDelta = this._sliderWrapper.getSlideDelta(realIndex);
        realIndex = Math.max(realIndex - this._cloneSlidesToFitWrapper(true, slideDelta), 0);
        this._sliderWrapper.moveTo(realIndex, undefined, animate);
        // Update the active index
        this._index = nextIndex;
        // Mark slides as active
        this._updatePagination();
        this._updateActiveSlides(realIndex);
        // console.log(`Performed slide to ${this._index}, realIndex: ${this._sliderWrapper.index}`)
    };
    /**
     * Moves the slider to the selected slide.
     * @param {Number} index - The index of the slide to slide to.
     * @param {Boolean} animate - `True` if the slide should be animated; otherwise `false`. Defaults to `true`.
     */
    Carousel.prototype.slideTo = function (index, animate) {
        if (animate === void 0) {
            animate = true;
        }
        this.slide(index, undefined, animate);
    };
    /**
     * Destroys the components and frees all references.
     */
    Carousel.prototype.destroy = function () {
        window.removeEventListener("resize", this._resizeHandler);
        window.removeEventListener("orientationchange", this._resizeHandler);
        this.element.removeEventListener("keydown", this._keydownHandler);
        this._slideArea.removeEventListener("mousedown", this._handleTouchstart);
        this._slideArea.removeEventListener("touchstart", this._handleTouchstart);
        this._breakpointPhone.remove();
        this._breakpointTablet.remove();
        this._breakpointDesktop.remove();
        if (this._prevCtrl && this._nextCtrl) {
            this._prevCtrl.removeEventListener("click", this._prevHandler);
            this._nextCtrl.removeEventListener("click", this._nextHandler);
        }
        this._prevCtrl = undefined;
        this._nextCtrl = undefined;
        if (this._pagination) {
            this._pagination.removeEventListener("click", this._paginationClickHandler);
            this._pagination = undefined;
        }
        this._sliderWrapper.destroy();
        this._sliderWrapper = undefined;
    };
    return Carousel;
}(_DomElement2.default);
var TRANSFORM = "transform";
var DURATION = "transitionDuration";
var TIMING = "transitionTimingFunction";
var SliderWrapper = /** @class */function () {
    function SliderWrapper(wrapperElement, slideAreaElement, carouselElement) {
        this._wrapperElement = wrapperElement;
        this._slideAreaElement = slideAreaElement;
        this._carouselElement = carouselElement;
        this._position = 0;
        this._index = 0;
        this._isdragging = false;
    }
    SliderWrapper.prototype._getSlide = function (index) {
        if (index < 0 || index >= this._wrapperElement.children.length) {
            throw new Error("Argument 'index' is out of range, Value: " + index + " Min: 0, Max: " + (this._wrapperElement.children.length - 1));
        }
        return this._wrapperElement.children[index];
    };
    SliderWrapper.prototype._setTransform = function (targetPosition, animated, duration, ease) {
        if (animated === void 0) {
            animated = false;
        }
        if (duration === void 0) {
            duration = ANIMATION_DURATION;
        }
        if (ease === void 0) {
            ease = ANIMATION_EASING;
        }
        if (animated === false) {
            duration = 0;
        }
        var style = this._wrapperElement.style;
        if (style) {
            style[DURATION] = duration + "ms";
            style[TIMING] = ease;
            // No sub pixel transitions.
            targetPosition = Math.floor(targetPosition);
            style[TRANSFORM] = "translate(" + targetPosition + "px, 0)";
            this._position = targetPosition;
        }
    };
    SliderWrapper.prototype._getWrapperSlidePosition = function (index) {
        var wrapperCenter = 0.5 * this._wrapperElement.offsetWidth;
        var slide = this._getSlide(index);
        var result = 0;
        // Calculate the position of the slide (centered)
        if (this._slidesPerGroup % 2 === 0) {
            var slideStyle = window.getComputedStyle(slide);
            var slideMargin = slideStyle ? parseInt(slideStyle.marginRight, 10) : 0;
            // Centered to the space between the two center slides of the group
            result = -slide.offsetLeft - slide.clientWidth + wrapperCenter - slideMargin;
        } else {
            result = -slide.offsetLeft - 0.5 * slide.clientWidth + wrapperCenter;
        }
        return result;
    };
    Object.defineProperty(SliderWrapper.prototype, "position", {
        get: function get() {
            return this._position;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderWrapper.prototype, "index", {
        get: function get() {
            return this._index;
        },
        set: function set(index) {
            this._index = index;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderWrapper.prototype, "slidesPerGroup", {
        set: function set(value) {
            this._slidesPerGroup = value;
        },
        enumerable: true,
        configurable: true
    });
    SliderWrapper.prototype.initialize = function () {
        this.onresize();
    };
    SliderWrapper.prototype.onresize = function () {
        // update the area offset for slide position calculation
        this._areaOffset = this._slideAreaElement.getBoundingClientRect().left;
        // Get the container dimensions
        var containerRect = this._carouselElement.getBoundingClientRect();
        this._containerMin = containerRect.left;
        this._containerMax = containerRect.right;
    };
    SliderWrapper.prototype.beginDrag = function () {
        this._isdragging = true;
        this._dragStartPosition = this._position;
    };
    SliderWrapper.prototype.cancelDrag = function () {
        this._isdragging = false;
        this._setTransform(this._dragStartPosition, true, ANIMATION_DURATION, ANIMATION_EASING);
        this._dragStartPosition = undefined;
    };
    SliderWrapper.prototype.endDrag = function () {
        this._isdragging = false;
        this._dragStartPosition = undefined;
    };
    SliderWrapper.prototype.move = function (delta, animated, duration, ease) {
        if (animated === void 0) {
            animated = false;
        }
        if (duration === void 0) {
            duration = ANIMATION_DURATION;
        }
        if (ease === void 0) {
            ease = ANIMATION_EASING;
        }
        delta = (0, _trunc2.default)(delta);
        if (Math.abs(delta) <= 0) {
            return;
        }
        var targetPosition = this._position += delta;
        this._setTransform(targetPosition, animated, duration, ease);
    };
    SliderWrapper.prototype.moveTo = function (index, delta, animated) {
        if (animated === void 0) {
            animated = false;
        }
        var newPosition = 0;
        if (!delta) {
            newPosition = this._getWrapperSlidePosition(index);
        } else {
            newPosition = this._position += delta;
        }
        this._index = index;
        this._setTransform(newPosition, animated);
    };
    SliderWrapper.prototype.addSlide = function (slide, position) {
        if (!slide) {
            throw new Error("Cannot add an undefined slide");
        }
        if (position !== -1 && position !== 1) {
            throw new Error("Argument out of range, 'position' must be either 1 or -1. Value " + position);
        }
        if (position > 0) {
            this._wrapperElement.appendChild(slide);
        } else {
            this._wrapperElement.insertBefore(slide, this._wrapperElement.children[0]);
            this._index++;
        }
        if (position < 0) {
            var width = slide.offsetWidth;
            var style = window.getComputedStyle(slide);
            var marginLeft = style ? parseInt(style.marginLeft, 10) : 0;
            var marginRight = style ? parseInt(style.marginRight, 10) : 0;
            this.move(-(width + marginLeft + marginRight));
        }
    };
    SliderWrapper.prototype.removeSlide = function (index) {
        var slide = this._getSlide(index);
        var width = slide.offsetWidth;
        if (index <= this._index) {
            width *= -1;
            this._index--;
        }
        (0, _Utils.remove)(slide);
        if (width < 0) {
            this.move(-width);
        }
    };
    SliderWrapper.prototype.getSlideDelta = function (index) {
        var currentPosition = this._position;
        if (this._isdragging === true) {
            currentPosition = this._dragStartPosition - this._position;
        }
        var newPosition = this._getWrapperSlidePosition(index);
        return newPosition - currentPosition;
    };
    SliderWrapper.prototype.getSlideProperties = function (index, delta) {
        if (delta === void 0) {
            delta = 0;
        }
        var currentOffset = this._areaOffset + this._position + delta;
        var currentLeft = currentOffset;
        var currentRight = currentOffset;
        var _a = tslib_1.__read([0, 0], 2),
            currentMarginLeft = _a[0],
            currentMarginRight = _a[1];
        var slide = this._getSlide(index);
        var slideIndex = parseInt(slide.getAttribute(ATTRIBUTE_INDEX), 10);
        for (var i = 0; i <= index; i++) {
            slide = this._getSlide(i);
            var slideStyle = window.getComputedStyle(slide);
            currentMarginLeft = parseInt(slideStyle.marginLeft, 10);
            currentMarginRight = parseInt(slideStyle.marginRight, 10);
            currentOffset += currentMarginLeft;
            currentLeft = currentOffset;
            currentRight = currentLeft + slide.offsetWidth;
            if (i < index) {
                currentOffset = currentRight + currentMarginRight;
            }
        }
        var visible = false;
        if (currentLeft > this._containerMin && currentLeft < this._containerMax || currentRight > this._containerMin && currentRight < this._containerMax) {
            visible = true;
        }
        return {
            visible: visible,
            index: slideIndex,
            left: currentLeft,
            right: currentRight,
            width: currentRight - currentLeft,
            marginLeft: currentMarginLeft,
            marginRight: currentMarginRight
        };
    };
    SliderWrapper.prototype.getRemovableSlides = function (delta) {
        var slides = [];
        var first;
        var last;
        var index = this._wrapperElement.children.length;
        while (index > 0) {
            index--;
            var propsNow = this.getSlideProperties(index);
            var propsNew = this.getSlideProperties(index, delta);
            if (index === this._wrapperElement.children.length - 1) {
                last = propsNew;
            }
            if (index === 0) {
                first = propsNew;
            }
            if (propsNow.visible === false && propsNew.visible === false && index !== this._index && this._isdragging === false) {
                slides.push(true);
            } else {
                slides.push(false);
            }
        }
        slides.reverse();
        var firstToKeep = slides.indexOf(false);
        var lastToKeep = slides.lastIndexOf(false);
        for (var i = firstToKeep; i < lastToKeep; i++) {
            slides[i] = false;
        }
        return {
            slides: slides,
            first: first,
            last: last
        };
    };
    SliderWrapper.prototype.getEmptySpace = function (left, right) {
        return {
            left: Math.max(Math.ceil(left - this._containerMin), 0),
            right: Math.max(Math.ceil(this._containerMax - right), 0)
        };
    };
    SliderWrapper.prototype.destroy = function () {
        this._wrapperElement = null;
        this._slideAreaElement = null;
        this._carouselElement = null;
    };
    /**
     * @deprecated use destroy() instead.
     * @todo remove in version 2.0.0
     */
    SliderWrapper.prototype.destory = function () {
        this.destroy();
    };
    return SliderWrapper;
}();
function init() {
    (0, _Utils.searchAndInitialize)(".carousel", function (e) {
        new Carousel(e);
    });
}
exports.default = Carousel;

},{"../DomElement":5,"../DomFunctions":6,"../Inputs":7,"../Utils":8,"babel-runtime/core-js/array/from":36,"babel-runtime/core-js/math/trunc":38,"tslib":135}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _Utils = require("../Utils");

var _DomFunctions = require("../DomFunctions");

var _ChartFunctions = require("./ChartFunctions");

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var QUERY_DETAIL_RIGHT = ".detail-right";
var QUERY_DETAIL_BOTTOM = ".detail-bottom";
var QUERY_PROGRESS = ".bar-chart__progress";
var CLASS_UNLIMITED = "bar-chart-horizontal--unlimited";
var CLASS_LIMITED = "bar-chart-horizontal--limited";
var CLASS_DETAIL_VALUE = "value";
var CLASS_DETAIL_UNIT = "unit";
var CLASS_INDICATOR = "indicator";
var CLASS_INDICATOR_WRAPPER = "indicator-wrapper";
var CLASS_TOOLTIP = "tooltip";
var CLASS_TOOLTIP_MULTILINE = "tooltip--multiline";
var ANIMATION_DURATION = 500;
/**
 * Bar Chart Horizontal Component.
 */
var BarChartHorizontal = /** @class */function (_super) {
    tslib_1.__extends(BarChartHorizontal, _super);
    /**
     * Creates and initializes the bar chart horizontal component.
     * @param {DomElement} - root element of the chart.
     */
    function BarChartHorizontal(element, data) {
        var _this = _super.call(this, element) || this;
        if (data) {
            _this._data = data;
        }
        _this._legendItems = [];
        _this._initialize();
        return _this;
    }
    BarChartHorizontal.prototype._initialize = function () {
        this._unit = this.getAttribute("data-unit") || "";
        this._maxValue = parseFloat(this.getAttribute("data-max"));
        this._precision = parseInt(this.getAttribute("data-precision"), 10) || 0;
        this._isUnlimited = this.hasClass(CLASS_UNLIMITED);
        this._isLimited = this.hasClass(CLASS_LIMITED);
        this._progessWrapper = this.element.querySelector(QUERY_PROGRESS);
        if (this._isLimited === true) {
            this._detailRight = this.element.querySelector(QUERY_DETAIL_BOTTOM);
        } else {
            this._detailRight = this.element.querySelector(QUERY_DETAIL_RIGHT);
        }
        if (this._isUnlimited === false && this._isLimited === false) {
            this._legend = (0, _DomFunctions.getAttributeReference)(this.element, "data-legend");
        }
        if (!this._data) {
            this._data = (0, _ChartFunctions.tryGetData)(this.element);
        }
        this._render();
    };
    BarChartHorizontal.prototype._render = function () {
        var e_1, _a;
        var dataOne = this._data[0];
        var dataTwo = this._data[1];
        var tooltip = this._isLimited === false ? this._getTooltipContent(this._data) : undefined;
        var animatedValueElement;
        // Cleanup
        (0, _ChartFunctions.removeAllChildren)(this._detailRight);
        (0, _ChartFunctions.removeAllChildren)(this._progessWrapper);
        try {
            // Clear only own legend items
            for (var _b = tslib_1.__values(this._legendItems), _c = _b.next(); !_c.done; _c = _b.next()) {
                var item = _c.value;
                (0, _Utils.remove)(item);
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
        this._legendItems = [];
        if (dataOne) {
            if (this._isUnlimited === false || this._isUnlimited === true && !dataTwo) {
                var valElement = animatedValueElement = this._createValueElement(dataOne);
                this._detailRight.appendChild(valElement);
                if (this._isLimited === false) {
                    var separatorElement = new _DomElement2.default("div").addClass(CLASS_DETAIL_UNIT).element;
                    separatorElement.innerText = " " + this._unit;
                    this._detailRight.appendChild(separatorElement);
                }
            }
            // Add the indicator
            var indicator = this._addIndicator(dataOne, tooltip);
            this._animateIndicator(indicator, 0);
            // Animate the value if required
            if (animatedValueElement && this._isLimited === true) {
                this._animateValueElement(animatedValueElement, dataOne.value);
            }
            // Add the legend
            if (this._legend) {
                var legendItem = (0, _ChartFunctions.createLegendItem)(dataOne);
                this._legend.appendChild(legendItem);
                this._legendItems.push(legendItem);
                this._animateLegend(legendItem, 0);
            }
        }
        if (dataTwo) {
            var valElement = this._createValueElement(dataTwo);
            var unitElement = new _DomElement2.default("div").addClass(CLASS_DETAIL_UNIT).element;
            unitElement.innerText = " " + this._unit;
            this._detailRight.appendChild(valElement);
            this._detailRight.appendChild(unitElement);
            // Add the indicator
            var indicator = this._addIndicator(dataTwo, tooltip);
            this._animateIndicator(indicator, ANIMATION_DURATION);
            // Add the legend
            if (this._legend) {
                var legendItem = (0, _ChartFunctions.createLegendItem)(dataTwo);
                this._legend.appendChild(legendItem);
                this._legendItems.push(legendItem);
                this._animateLegend(legendItem, ANIMATION_DURATION);
            }
        }
        if (this._isLimited === true) {
            var valElement = this._createValueElement({ value: this._maxValue });
            var unitElement = new _DomElement2.default("div").addClass(CLASS_DETAIL_UNIT).element;
            unitElement.innerText = " " + this._unit;
            this._detailRight.appendChild(valElement);
            this._detailRight.appendChild(unitElement);
        }
    };
    BarChartHorizontal.prototype._animateValueElement = function (animatedValueElement, toValue) {
        var counter = { var: 0 };
        (0, _animejs2.default)({
            targets: counter,
            var: toValue,
            duration: ANIMATION_DURATION,
            easing: "easeOutQuint",
            round: 1,
            update: function update() {
                animatedValueElement.innerText = "" + counter.var;
            }
        });
    };
    BarChartHorizontal.prototype._animateIndicator = function (indicatorWrapper, animationOffset) {
        var indicator = indicatorWrapper.getElementsByClassName("indicator")[0];
        var indicatorWidth = indicator.scrollWidth;
        indicator.style.width = "0px";
        (0, _animejs2.default)({
            targets: indicator,
            duration: ANIMATION_DURATION,
            width: indicatorWidth + "px",
            easing: "easeInOutQuint",
            delay: animationOffset,
            complete: function complete() {
                indicator.style.width = null;
            }
        });
    };
    BarChartHorizontal.prototype._animateLegend = function (legendItem, animationOffset) {
        legendItem.style.opacity = "0";
        (0, _animejs2.default)({
            targets: legendItem,
            duration: ANIMATION_DURATION,
            opacity: 1,
            easing: "easeInOutQuint",
            delay: animationOffset,
            complete: function complete() {
                legendItem.style.opacity = null;
            }
        });
    };
    BarChartHorizontal.prototype._createValueElement = function (data) {
        var unlimitedPrefix = "";
        if (this._isUnlimited === true) {
            unlimitedPrefix = "+";
        }
        var value = parseFloat(data.value);
        if (value <= 0) {
            if (this._precision === 0) {
                value = "0";
            } else {
                value = ".";
                for (var i = 0; i < this._precision; i++) {
                    value += "0";
                }
            }
        } else {
            value = value.toFixed(this._precision);
        }
        var valueElement = new _DomElement2.default("div").addClass(CLASS_DETAIL_VALUE).element;
        valueElement.innerText = "" + unlimitedPrefix + value;
        return valueElement;
    };
    BarChartHorizontal.prototype._addIndicator = function (data, tooltip) {
        var width = 100.0 / this._maxValue * data.value;
        var indicator = new _DomElement2.default("div").addClass(CLASS_INDICATOR);
        if ((0, _ChartFunctions.isColor)(data.color) === true) {
            indicator.setAttribute("style", "background-color: " + data.color + ";");
        } else {
            indicator.addClass(data.color);
        }
        var indicatorWrapper = new _DomElement2.default("div").addClass(CLASS_INDICATOR_WRAPPER).setAttribute("style", "width: " + width + "%").appendChild(indicator).setAttribute("onclick", "void(0)");
        if (tooltip && tooltip !== "") {
            indicatorWrapper.addClass(CLASS_TOOLTIP).addClass(CLASS_TOOLTIP_MULTILINE).setAttribute("aria-label", tooltip);
        }
        this._progessWrapper.appendChild(indicatorWrapper.element);
        return indicatorWrapper.element;
    };
    BarChartHorizontal.prototype._getTooltipContent = function (dataList) {
        var e_2, _a;
        var tooltip = "";
        try {
            for (var dataList_1 = tslib_1.__values(dataList), dataList_1_1 = dataList_1.next(); !dataList_1_1.done; dataList_1_1 = dataList_1.next()) {
                var data = dataList_1_1.value;
                tooltip += data.title + ": " + data.value + " " + this._unit + "\n";
            }
        } catch (e_2_1) {
            e_2 = { error: e_2_1 };
        } finally {
            try {
                if (dataList_1_1 && !dataList_1_1.done && (_a = dataList_1.return)) _a.call(dataList_1);
            } finally {
                if (e_2) throw e_2.error;
            }
        }
        return tooltip.trim();
    };
    /**
     * Updates the bar chart with the specified data definitions.
     * @param {Array} - bar chart data definitions.
     */
    BarChartHorizontal.prototype.update = function (data) {
        if (data) {
            this._data = data;
        }
        this._render();
    };
    /**
     * Removes all event handlers and clears references.
     */
    BarChartHorizontal.prototype.destroy = function () {
        var e_3, _a;
        this._data = undefined;
        (0, _ChartFunctions.removeAllChildren)(this._detailRight);
        (0, _ChartFunctions.removeAllChildren)(this._progessWrapper);
        this._detailRight = undefined;
        this._progessWrapper = undefined;
        try {
            for (var _b = tslib_1.__values(this._legendItems), _c = _b.next(); !_c.done; _c = _b.next()) {
                var item = _c.value;
                (0, _Utils.remove)(item);
            }
        } catch (e_3_1) {
            e_3 = { error: e_3_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_3) throw e_3.error;
            }
        }
        this._legendItems = undefined;
        this._legend = undefined;
    };
    /**
     * @deprecated use destroy() instead.
     * @todo remove in version 2.0.0
     */
    BarChartHorizontal.prototype.destory = function () {
        this.destroy();
    };
    return BarChartHorizontal;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".bar-chart-horizontal", function (e) {
        new BarChartHorizontal(e);
    });
}
exports.default = BarChartHorizontal;

},{"../DomElement":5,"../DomFunctions":6,"../Utils":8,"./ChartFunctions":13,"animejs":35,"tslib":135}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _Utils = require("../Utils");

var _DomFunctions = require("../DomFunctions");

var _ChartFunctions = require("./ChartFunctions");

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var QUERY_DATA_CATEGORIES = ".js-data-list .js-category";
var QUERY_DATA_ITEMS = ".js-data-list .js-data";
var QUERY_CHART = ".js-chart";
var QUERY_LEGEND = ".bar-chart__legend";
var CLASS_INDICATOR = "indicator";
var CLASS_LABEL_X = "axis-x-label";
var CLASS_INDICATOR_WRAPPER = "indicator-wrapper";
var CLASS_INDICATOR_INNER_WRAPPER = "indicator-wrapper-inner";
var CLASS_INDICATOR_EMPTY = "empty";
var CLASS_TOOLTIP = "tooltip";
var CLASS_TOOLTIP_LEFT = "tooltip--left";
var CLASS_TOOLTIP_RIGHT = "tooltip--right";
var CLASS_TOOLTIP_MULTILINE = "tooltip--multiline";
var ANIMATION_DURATION = 500;
/**
 * Bar Chart Horizontal Component.
 */
var BarChartVertical = /** @class */function (_super) {
    tslib_1.__extends(BarChartVertical, _super);
    /**
     * Creates and initializes the bar chart horizontal component.
     * @param element - root element of the chart.
     * @param data - data for the chart.
     */
    function BarChartVertical(element, data) {
        var _this = _super.call(this, element) || this;
        if (data) {
            _this._data = data;
        }
        _this._initialize();
        return _this;
    }
    BarChartVertical.prototype._initialize = function () {
        this._unit = this.getAttribute("data-unit") || "";
        this._maxValue = parseFloat(this.getAttribute("data-max")) || 100;
        this._chart = this.element.querySelector(QUERY_CHART);
        this._legend = this.element.querySelector(QUERY_LEGEND);
        if (!this._data) {
            this._data = this._tryGetData(this.element);
        }
        this._render();
    };
    BarChartVertical.prototype._tryGetData = function (element) {
        var e_1, _a, e_2, _b, e_3, _c;
        var data = {
            categories: [],
            items: []
        };
        var categories = element.querySelectorAll(QUERY_DATA_CATEGORIES);
        var items = element.querySelectorAll(QUERY_DATA_ITEMS);
        try {
            for (var categories_1 = tslib_1.__values(categories), categories_1_1 = categories_1.next(); !categories_1_1.done; categories_1_1 = categories_1.next()) {
                var category = categories_1_1.value;
                data.categories.push({
                    title: (0, _DomFunctions.text)(category),
                    color: category.getAttribute("data-color")
                });
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (categories_1_1 && !categories_1_1.done && (_a = categories_1.return)) _a.call(categories_1);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
        try {
            for (var items_1 = tslib_1.__values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
                var item = items_1_1.value;
                var dataEnty = {
                    title: (0, _DomFunctions.text)(item),
                    class: item.getAttribute("data-class"),
                    values: []
                };
                var vals = item.getAttribute("data-value");
                if (vals) {
                    try {
                        for (var _d = tslib_1.__values(vals.split(",")), _e = _d.next(); !_e.done; _e = _d.next()) {
                            var val = _e.value;
                            dataEnty.values.push(parseFloat(val));
                        }
                    } catch (e_3_1) {
                        e_3 = { error: e_3_1 };
                    } finally {
                        try {
                            if (_e && !_e.done && (_c = _d.return)) _c.call(_d);
                        } finally {
                            if (e_3) throw e_3.error;
                        }
                    }
                }
                data.items.push(dataEnty);
            }
        } catch (e_2_1) {
            e_2 = { error: e_2_1 };
        } finally {
            try {
                if (items_1_1 && !items_1_1.done && (_b = items_1.return)) _b.call(items_1);
            } finally {
                if (e_2) throw e_2.error;
            }
        }
        return data;
    };
    BarChartVertical.prototype._getTooltipContent = function (entry, categories) {
        var tooltip = "";
        for (var i = 0; i < entry.values.length; i++) {
            tooltip += categories[i].title + ": " + entry.values[i] + " " + this._unit + "\n";
        }
        return tooltip.trim();
    };
    BarChartVertical.prototype._render = function () {
        var e_4, _a, e_5, _b;
        if (this._legend) {
            (0, _ChartFunctions.removeAllChildren)(this._legend);
            try {
                for (var _c = tslib_1.__values(this._data.categories), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var category = _d.value;
                    var legendItem = (0, _ChartFunctions.createLegendItem)(category);
                    this._legend.appendChild(legendItem);
                }
            } catch (e_4_1) {
                e_4 = { error: e_4_1 };
            } finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                } finally {
                    if (e_4) throw e_4.error;
                }
            }
        }
        (0, _ChartFunctions.removeAllChildren)(this._chart);
        var animationStages = [];
        var leftSideItems = Math.floor(this._data.items.length / 2);
        try {
            for (var _e = tslib_1.__values(this._data.items), _f = _e.next(); !_f.done; _f = _e.next()) {
                var item = _f.value;
                var element = new _DomElement2.default("li");
                if (item.class) {
                    element.addClass(item.class);
                }
                var listElement = new _DomElement2.default("ul").addClass(CLASS_INDICATOR_WRAPPER);
                var wrapper = new _DomElement2.default("div").addClass(CLASS_INDICATOR_INNER_WRAPPER);
                listElement.appendChild(wrapper);
                element.appendChild(listElement);
                var tooltip = this._getTooltipContent(item, this._data.categories);
                if (tooltip) {
                    wrapper.addClass(CLASS_TOOLTIP).addClass(leftSideItems <= 0 ? CLASS_TOOLTIP_LEFT : CLASS_TOOLTIP_RIGHT).setAttribute("aria-label", tooltip);
                    if (item.values.length > 1) {
                        wrapper.addClass(CLASS_TOOLTIP_MULTILINE);
                    }
                }
                for (var i = 0; i < item.values.length; i++) {
                    var height = this._chart.offsetHeight / this._maxValue * item.values[i];
                    var indicator = new _DomElement2.default("li").addClass(CLASS_INDICATOR).setAttribute("style", "height: " + height + "px;");
                    if (height > 0) {
                        var color = this._data.categories[i].color;
                        if ((0, _ChartFunctions.isColor)(color)) {
                            indicator.setAttribute("style", "background-color: " + color + ";");
                        } else {
                            indicator.addClass(color);
                        }
                        if (animationStages.length <= i) {
                            animationStages.push([]);
                        }
                        animationStages[i].push(indicator.element);
                    } else {
                        indicator.addClass(CLASS_INDICATOR_EMPTY);
                    }
                    wrapper.appendChild(indicator);
                }
                var titleDomElement = new _DomElement2.default("div").addClass(CLASS_LABEL_X);
                var titleElement = titleDomElement.element;
                titleElement.innerText = item.title;
                element.appendChild(titleDomElement);
                this._chart.appendChild(element.element);
                leftSideItems -= 1;
            }
        } catch (e_5_1) {
            e_5 = { error: e_5_1 };
        } finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            } finally {
                if (e_5) throw e_5.error;
            }
        }
        for (var i = 0; i < animationStages.length; i++) {
            var offset = ANIMATION_DURATION * i;
            this._animateBars(animationStages[i], offset);
            if (this._legend) {
                this._animateLegend(this._legend.children[i], offset);
            }
        }
    };
    BarChartVertical.prototype._animateBars = function (bars, animationOffset) {
        for (var i = 0; i < bars.length; i++) {
            var bar = bars[i];
            var barHeight = bar.style.height;
            bar.style.height = "0";
            (0, _animejs2.default)({
                targets: bars[i],
                height: barHeight,
                easing: "easeInOutQuint",
                duration: ANIMATION_DURATION,
                delay: animationOffset
            });
        }
    };
    BarChartVertical.prototype._animateLegend = function (legend, animationOffset) {
        legend.style.opacity = "0";
        (0, _animejs2.default)({
            targets: legend,
            opacity: 1,
            easing: "easeInOutQuint",
            duration: ANIMATION_DURATION,
            delay: animationOffset
        });
    };
    /**
     * Updates the bar chart with the specified data definitions.
     * @param {Array} - bar chart data definitions.
     */
    BarChartVertical.prototype.update = function (data) {
        if (data) {
            this._data = data;
        }
        this._render();
    };
    /**
     * Removes all event handlers and clears references.
     */
    BarChartVertical.prototype.destroy = function () {
        this._data = undefined;
        if (this._legend) {
            (0, _ChartFunctions.removeAllChildren)(this._legend);
            this._legend = undefined;
        }
    };
    /**
     * @deprecated use destroy() instead.
     * @todo remove in version 2.0.0
     */
    BarChartVertical.prototype.destory = function () {
        this.destroy();
    };
    return BarChartVertical;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".bar-chart-vertical", function (e) {
        new BarChartVertical(e);
    });
}
exports.default = BarChartVertical;

},{"../DomElement":5,"../DomFunctions":6,"../Utils":8,"./ChartFunctions":13,"animejs":35,"tslib":135}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.tryGetData = tryGetData;
exports.removeAllChildren = removeAllChildren;
exports.createLegendItem = createLegendItem;
exports.isColor = isColor;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _DomFunctions = require("../DomFunctions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var QUERY_DATA = ".js-data";
function tryGetData(element) {
    var e_1, _a;
    var data = [];
    var elements = element.querySelectorAll(QUERY_DATA);
    try {
        for (var elements_1 = tslib_1.__values(elements), elements_1_1 = elements_1.next(); !elements_1_1.done; elements_1_1 = elements_1.next()) {
            var entry = elements_1_1.value;
            var value = parseFloat(entry.getAttribute("data-value"));
            var color = entry.getAttribute("data-color");
            var title = (0, _DomFunctions.text)(entry);
            var item = {
                title: title,
                value: value,
                color: color
            };
            data.push(item);
        }
    } catch (e_1_1) {
        e_1 = { error: e_1_1 };
    } finally {
        try {
            if (elements_1_1 && !elements_1_1.done && (_a = elements_1.return)) _a.call(elements_1);
        } finally {
            if (e_1) throw e_1.error;
        }
    }
    return data;
}
function removeAllChildren(node) {
    while (node.firstChild) {
        node.removeChild(node.firstChild);
    }
}
function createLegendItem(data) {
    var bullet = new _DomElement2.default("span").addClass("bullet");
    if (isColor(data.color) === true) {
        bullet.setAttribute("style", "background-color: " + data.color + ";");
    } else {
        bullet.addClass(data.color);
    }
    var caption = new _DomElement2.default("span").setHtml(data.title);
    return new _DomElement2.default("li").appendChild(bullet).appendChild(caption).element;
}
function isColor(str) {
    var pattern = /^#/i;
    return pattern.test(str);
}

},{"../DomElement":5,"../DomFunctions":6,"tslib":135}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _Utils = require("../Utils");

var _ChartFunctions = require("./ChartFunctions");

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var QUERY_CHART = ".js-chart";
var QUERY_LEGEND = ".js-legend";
var DASH_SEPARATOR_WIDTH = 3;
var ANIMATION_DURATION = 1500;
var ANIMATION_DURATION_LEGEND = 500;
var QUERY_META_TITLE = ".meta .title";
var QUERY_META_SUBTITLE = ".meta .subtitle";
/**
 * Pie Chart Component.
 */
var PieChart = /** @class */function (_super) {
    tslib_1.__extends(PieChart, _super);
    /**
     * Creates and initializes the Pie Chart component.
     * @param {DomElement} - root element of the chart.
     * @param {Array} - pie chart data definitions.
     */
    function PieChart(element, data) {
        var _this = _super.call(this, element) || this;
        if (data) {
            _this._data = data;
        }
        _this._initialize();
        return _this;
    }
    PieChart.prototype._initialize = function () {
        this._chart = this.element.querySelector(QUERY_CHART);
        this._legend = this.element.querySelector(QUERY_LEGEND);
        this._title = this.element.querySelector(QUERY_META_TITLE);
        this._subtitle = this.element.querySelector(QUERY_META_SUBTITLE);
        this._unit = this.getAttribute("data-unit") || "";
        this._alwaysShowLegend = this.element.hasAttribute("data-always-show-legend");
        if (!this._data) {
            this._data = (0, _ChartFunctions.tryGetData)(this.element);
        }
        this._render();
    };
    PieChart.prototype._render = function () {
        var total = this._data.reduce(function (a, b) {
            return a + b.value;
        }, 0);
        var r = 16;
        var dashTotal = 2 * r * Math.PI;
        var currentRotate = 9;
        // Cleanup
        (0, _ChartFunctions.removeAllChildren)(this._chart);
        if (this._legend) {
            (0, _ChartFunctions.removeAllChildren)(this._legend);
        }
        var percentageAdjustTotal = 0;
        var percentageAdjust = 0;
        var separatorPercentage = DASH_SEPARATOR_WIDTH / 100;
        for (var i = 0; i < this._data.length; i++) {
            var entry = this._data[i];
            var percentage = entry.value / total;
            if (percentage < separatorPercentage) {
                percentageAdjustTotal += separatorPercentage - percentage;
                percentageAdjust++;
            }
        }
        if (percentageAdjust > 0) {
            percentageAdjust = percentageAdjustTotal / (this._data.length - percentageAdjust);
        }
        var animations = _animejs2.default.timeline();
        var animationOffset = 0;
        var _loop_1 = function _loop_1(i) {
            var entry = this_1._data[i];
            var displayPercentage = entry.value / total;
            var percentage = Math.max(separatorPercentage, displayPercentage - percentageAdjust);
            var dashWidth = percentage * dashTotal - DASH_SEPARATOR_WIDTH;
            var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.setAttribute("viewBox", "0 0 34 34");
            svg.setAttribute("role", "img");
            svg.setAttribute("aria-labelledby", "title desc");
            var title = document.createElementNS("http://www.w3.org/2000/svg", "title");
            title.setAttribute("id", "title");
            title.innerHTML = "Pie chart segment " + Math.floor(displayPercentage * 100) + "%";
            var description = document.createElementNS("http://www.w3.org/2000/svg", "desc");
            description.setAttribute("id", "desc");
            description.innerHTML = entry.title + ": " + entry.value;
            var circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            circle.setAttribute("cx", "17");
            circle.setAttribute("cy", "17");
            circle.setAttribute("r", String(r));
            if ((0, _ChartFunctions.isColor)(entry.color) === true) {
                circle.setAttribute("stroke", "" + entry.color);
            } else {
                circle.setAttribute("class", entry.color);
            }
            circle.setAttribute("role", "presentation");
            svg.setAttribute("style", "transform: rotate(" + currentRotate + "deg);");
            svg.appendChild(title);
            svg.appendChild(description);
            svg.appendChild(circle);
            this_1._chart.appendChild(svg);
            var animationDuration = ANIMATION_DURATION * percentage;
            circle.style.display = "none";
            var counter = { var: 0.5 };
            animations.add({
                targets: counter,
                var: dashWidth,
                begin: function begin() {
                    circle.style.display = "";
                },
                update: function update() {
                    circle.setAttribute("stroke-dasharray", counter.var + " " + dashTotal);
                },
                duration: animationDuration,
                easing: "easeInQuint"
            });
            // Legend
            if (this_1._legend && this_1._data.length > 1 || this_1._alwaysShowLegend) {
                var bullet = new _DomElement2.default("span").addClass("bullet");
                if ((0, _ChartFunctions.isColor)(entry.color) === true) {
                    bullet.setAttribute("style", "background-color: " + entry.color);
                } else {
                    bullet.addClass(entry.color);
                }
                var caption = new _DomElement2.default("span");
                var captionElement = caption.element;
                captionElement.innerText = entry.title;
                var legendItem = new _DomElement2.default("li").appendChild(bullet).appendChild(caption);
                this_1._legend.appendChild(legendItem.element);
                this_1._animateLegend(legendItem.element, animationOffset);
            }
            animationOffset += animationDuration;
            currentRotate += 360 * percentage;
            if (i === this_1._data.length - 1) {
                this_1._title.innerHTML = entry.value + " " + this_1._unit;
                this_1._subtitle.innerHTML = entry.title;
            }
        };
        var this_1 = this;
        for (var i = 0; i < this._data.length; i++) {
            _loop_1(i);
        }
    };
    PieChart.prototype._animateLegend = function (legendItem, animationOffset) {
        legendItem.style.opacity = "0";
        (0, _animejs2.default)({
            targets: legendItem,
            duration: ANIMATION_DURATION_LEGEND,
            opacity: 1,
            easing: "easeInOutQuint",
            delay: animationOffset,
            complete: function complete() {
                legendItem.style.opacity = null;
            }
        });
    };
    /**
     * Updates the pie chart with the specified data definitions.
     * @param {Array} - pie chart data definitions.
     */
    PieChart.prototype.update = function (data) {
        if (data) {
            this._data = data;
        }
        this._render();
    };
    /**
     * Removes all event handlers and clears references.
     */
    PieChart.prototype.destroy = function () {
        this._data = undefined;
        this._title = undefined;
        this._subtitle = undefined;
        this._unit = undefined;
        (0, _ChartFunctions.removeAllChildren)(this._chart);
        this._chart = undefined;
        if (this._legend) {
            (0, _ChartFunctions.removeAllChildren)(this._legend);
            this._legend = undefined;
        }
    };
    /**
     * @deprecated use destroy() instead.
     * @todo remove in version 2.0.0
     */
    PieChart.prototype.destory = function () {
        this.destroy();
    };
    return PieChart;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".pie-chart", function (e) {
        new PieChart(e);
    });
}
exports.default = PieChart;

},{"../DomElement":5,"../Utils":8,"./ChartFunctions":13,"animejs":35,"tslib":135}],15:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _DomFunctions = require("../DomFunctions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var CLASS_OPEN = "is-open";
var ANIMATION_OPEN = 300;
/**
 * The Collapse component.
 */
var Collapse = /** @class */function (_super) {
    tslib_1.__extends(Collapse, _super);
    /**
     * Creates and initializes the Collapse component.
     * @param {DomElement} - The root element of the Collapse component.
     */
    function Collapse(element) {
        var _this = _super.call(this, element) || this;
        _this.easing = {
            // Equivalent to gsap's [ Power1.easeIn, Power4.easeOut ]
            inQuadOutQuint: [0.550, 0.085, 0.320, 1]
        };
        _this._clickHandler = _this._handleClick.bind(_this);
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the Collapse component.
     * @private
     */
    Collapse.prototype._initialize = function () {
        var dataTarget = this.element.getAttribute("data-target");
        if (dataTarget === null || dataTarget === "") {
            /* tslint:disable:no-console */
            console.error("A collapsible element requires a 'data-target' that specifies the element to collapse");
            console.info(this.element);
            /* tslint:enable:no-console */
            return;
        }
        var hiddenTarget = this.element.getAttribute("data-hidden");
        if (hiddenTarget !== null && hiddenTarget !== "") {
            this._hiddenIndicator = document.querySelector(hiddenTarget);
        }
        this._collapsibleElements = document.querySelectorAll(dataTarget);
        this.element.addEventListener("click", this._clickHandler);
    };
    Collapse.prototype._handleClick = function (event) {
        (0, _Utils.preventDefault)(event);
        this.toggle();
    };
    /**
     * Toggles the collapseible.
     */
    Collapse.prototype.toggle = function () {
        var e_1, _a, e_2, _b;
        if (this._hiddenIndicator && (0, _DomFunctions.isHidden)(this._hiddenIndicator, false) === true) {
            return;
        }
        if ((0, _DomFunctions.hasClass)(this.element, CLASS_OPEN) === false) {
            (0, _DomFunctions.addClass)(this.element, CLASS_OPEN);
            try {
                for (var _c = tslib_1.__values(this._collapsibleElements), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var s = _d.value;
                    this._openCollapse(s);
                }
            } catch (e_1_1) {
                e_1 = { error: e_1_1 };
            } finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                } finally {
                    if (e_1) throw e_1.error;
                }
            }
        } else {
            (0, _DomFunctions.removeClass)(this.element, CLASS_OPEN);
            try {
                for (var _e = tslib_1.__values(this._collapsibleElements), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var s = _f.value;
                    this._closeCollapse(s);
                }
            } catch (e_2_1) {
                e_2 = { error: e_2_1 };
            } finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                } finally {
                    if (e_2) throw e_2.error;
                }
            }
        }
    };
    Collapse.prototype._openCollapse = function (el) {
        _animejs2.default.remove(el);
        el.style.display = "block";
        (0, _animejs2.default)({
            targets: el,
            duration: ANIMATION_OPEN,
            height: el.scrollHeight + "px",
            easing: this.easing.inQuadOutQuint,
            complete: function complete() {
                var domEl = new _DomElement2.default(el);
                domEl.addClass(CLASS_OPEN);
                domEl.setAttribute("style", "");
            }
        });
        // set aria expanded
        el.setAttribute("aria-expanded", "true");
    };
    Collapse.prototype._closeCollapse = function (el) {
        _animejs2.default.remove(el);
        (0, _animejs2.default)({
            targets: el,
            duration: ANIMATION_OPEN,
            height: 0,
            easing: this.easing.inQuadOutQuint,
            complete: function complete() {
                var domEl = new _DomElement2.default(el);
                domEl.removeClass(CLASS_OPEN);
                domEl.setAttribute("style", "");
            }
        });
        // set aria expanded
        el.setAttribute("aria-expanded", "false");
    };
    /**
     * Removes all event handlers and clears references.
     */
    Collapse.prototype.destroy = function () {
        this._collapsibleElements = null;
        if (this._clickHandler) {
            this.element.removeEventListener("click", this._clickHandler);
        }
        this.element = null;
    };
    return Collapse;
}(_DomElement2.default);
function init() {
    var e_3, _a;
    var elements = document.querySelectorAll("[data-toggle='collapse']");
    try {
        for (var elements_1 = tslib_1.__values(elements), elements_1_1 = elements_1.next(); !elements_1_1.done; elements_1_1 = elements_1.next()) {
            var e = elements_1_1.value;
            if (e.getAttribute("data-init") === "auto") {
                new Collapse(e);
            }
        }
    } catch (e_3_1) {
        e_3 = { error: e_3_1 };
    } finally {
        try {
            if (elements_1_1 && !elements_1_1.done && (_a = elements_1.return)) _a.call(elements_1);
        } finally {
            if (e_3) throw e_3.error;
        }
    }
}
exports.default = Collapse;

},{"../DomElement":5,"../DomFunctions":6,"../Utils":8,"animejs":35,"tslib":135}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _DomFunctions = require("../DomFunctions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var CLASS_BORDER = "empty-state__border";
var CLASS_BORDER_MODAL = "empty-state__border--modal";
var CLASS_ACTIVE = "is-active";
var CLASS_HASFILES = "has-files";
var CLASS_MODAL = "empty-state--modal";
var CLASS_MODAL_CONTENT = "modal__content";
var QUERY_MODAL_BODY = ".modal__body";
var QUERY_FILE = "input[type='file']";
/**
 * Empty state pattern
 */
var EmptyState = /** @class */function (_super) {
    tslib_1.__extends(EmptyState, _super);
    /**
     * Creates and initializes the Empty-State pattern component.
     * @param {DomElement} - root element of the empty-state pattern.
     */
    function EmptyState(element) {
        var _this = _super.call(this, element) || this;
        _this._fileInput = _this.element.querySelector(QUERY_FILE);
        _this._button = _this.element.querySelector("label");
        _this._fileChangedHandler = _this._handleFileChanged.bind(_this);
        _this._preventEventsHandler = _this._preventDragEvents.bind(_this);
        _this._dragEnterHandler = _this._handleDragEnter.bind(_this);
        _this._dragLeaveHandler = _this._handleDragLeave.bind(_this);
        _this._dropHandler = _this._handleDrop.bind(_this);
        _this._isDragging = false;
        _this._initialize();
        return _this;
    }
    EmptyState.prototype._initialize = function () {
        var e_1, _a;
        if (this.hasClass(CLASS_MODAL)) {
            // handle modal dialogs
            this._dragArea = (0, _DomFunctions.parentWithClass)(this.element, CLASS_MODAL_CONTENT);
            var borderArea = this._dragArea.querySelector(QUERY_MODAL_BODY);
            borderArea.setAttribute("style", "pointer-events: none;");
            this._border = new _DomElement2.default("div").addClass(CLASS_BORDER).addClass(CLASS_BORDER_MODAL);
            borderArea.appendChild(this._border.element);
        } else {
            // normal modal dialog
            this._dragArea = this.element;
            var borderArea = (0, _DomFunctions.getRootElement)();
            this._border = new _DomElement2.default("div").addClass(CLASS_BORDER);
            if (!borderArea.querySelector("." + CLASS_BORDER)) {
                borderArea.appendChild(this._border.element);
            }
        }
        var form = this.element.querySelector("form");
        try {
            for (var _b = tslib_1.__values(["drag", "dragstart", "dragend", "dragover", "dragenter", "dragleave", "drop"]), _c = _b.next(); !_c.done; _c = _b.next()) {
                var event_1 = _c.value;
                this.element.addEventListener(event_1, this._preventEventsHandler);
                form.addEventListener(event_1, this._preventEventsHandler);
                this._dragArea.addEventListener(event_1, this._preventEventsHandler);
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
        this._dragArea.addEventListener("dragover", this._dragEnterHandler);
        this._dragArea.addEventListener("dragenter", this._dragEnterHandler);
        this._dragArea.addEventListener("dragleave", this._dragLeaveHandler);
        this._dragArea.addEventListener("dragend", this._dragLeaveHandler);
        this._dragArea.addEventListener("drop", this._dragLeaveHandler);
        this._dragArea.addEventListener("drop", this._dropHandler);
        this._fileInput.addEventListener("change", this._fileChangedHandler);
    };
    EmptyState.prototype._preventDragEvents = function (e) {
        e.preventDefault();
        e.stopPropagation();
        return false;
    };
    EmptyState.prototype._handleDragEnter = function () {
        if (this._isDragging === true) {
            return;
        }
        this._isDragging = true;
        this._button.setAttribute("style", "pointer-events: none;");
        this.addClass(CLASS_ACTIVE);
        this._border.addClass(CLASS_ACTIVE);
    };
    EmptyState.prototype._handleDragLeave = function () {
        if (this._isDragging === false) {
            return;
        }
        this._isDragging = false;
        this._button.setAttribute("style", "");
        this.removeClass(CLASS_ACTIVE);
        this._border.removeClass(CLASS_ACTIVE);
    };
    EmptyState.prototype._handleDrop = function (e) {
        this._fileInput.files = e.dataTransfer.files;
    };
    EmptyState.prototype._handleFileChanged = function () {
        var files = this._fileInput.files;
        if (files && files.length > 0) {
            this.addClass(CLASS_HASFILES);
        } else {
            this.removeClass(CLASS_HASFILES);
        }
    };
    Object.defineProperty(EmptyState.prototype, "files", {
        /**
         * Gets the currently selected files.
         */
        get: function get() {
            return this._fileInput.files;
        },
        enumerable: true,
        configurable: true
    });
    return EmptyState;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".empty-state", function (e) {
        new EmptyState(e);
    });
}
exports.default = EmptyState;

},{"../DomElement":5,"../DomFunctions":6,"../Utils":8,"tslib":135}],17:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _DomFunctions = require("../DomFunctions");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _Inputs = require("../Inputs");

var Inputs = _interopRequireWildcard(_Inputs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var QUERY_DROPDOWN = ".js-autocomplete";
var CLASS_RESULT = "autocomplete__result";
var CLASS_OPEN = "is-open";
var CLASS_HOVER = "js-hover";
var ATTRIBUTE_VALUE = "data-value";
var TIMEOUT_BLUR = 400;
/**
 * Autocomplete component
 * @fires Autocomplete#change
 */
var Autocomplete = /** @class */function (_super) {
    tslib_1.__extends(Autocomplete, _super);
    function Autocomplete(element, configuration) {
        var _this = _super.call(this, element) || this;
        _this._input = _this.element.querySelector("input");
        _this._dropdown = _this.element.querySelector(QUERY_DROPDOWN);
        // Setup event context
        _this._clickHandler = _this._handleClick.bind(_this);
        _this._windowClickHandler = _this._handleWindowClick.bind(_this);
        _this._keyUpHandler = _this._handleKeyUp.bind(_this);
        _this._keyDownHandler = _this._handleKeyDown.bind(_this);
        _this._blurHandler = _this._handleBlur.bind(_this);
        if (configuration) {
            _this._minChars = configuration.minChars;
            _this._source = configuration.source;
        }
        if (!_this._minChars || _this._minChars < 0) {
            _this._minChars = 2;
        }
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the Autocomplete component.
     * @private
     */
    Autocomplete.prototype._initialize = function () {
        this._clearSuggestions();
        if (this._input.getAttribute("disabled")) {
            this.disable();
        } else {
            this.enable();
        }
        // Disable browser autofill
        this._input.setAttribute("autocomplete", "off");
    };
    /**
     * The Autocomplete component configuration object
     * @callback Autocomplete~Suggest
     * @property {String} term - The current search term.
     * @property {String[]} matches - The list of matching strings.
     */
    /**
     * The Autocomplete component configuration object
     * @callback Autocomplete~Source
     * @property {String} term - The current search term.
     * @property {Autocomplete~Suggest} suggest - The autocomplete callback function to report the results.
     */
    /**
     * The Autocomplete component configuration object
     * @typedef {Object} Autocomplete~Config
     * @property {Number} minChars - The minimal required characters to start querying for autocomplete matches.
     * @property {Autocomplete~Source} source - The autocomplete source function.
     */
    /**
     * Updates the autocomplete component configuration for the current instance
     * @param {Autocomplete~Config} configuration The configuration object
     */
    Autocomplete.prototype.configure = function (configuration) {
        if (!configuration) {
            return;
        }
        if (configuration.minChars) {
            this._minChars = Math.min(configuration.minChars, 1);
        }
        if (configuration.source) {
            this._source = configuration.source;
        }
        this._clearSuggestions();
    };
    /**
     * Sets the select control to the enabled state.
     */
    Autocomplete.prototype.enable = function () {
        if (!this._input) {
            return;
        }
        this._input.removeAttribute("disabled");
        this._input.addEventListener("keyup", this._keyUpHandler);
        this._input.addEventListener("keydown", this._keyDownHandler);
        this._input.addEventListener("blur", this._blurHandler);
    };
    /**
     * Sets the select control to the disabled state.
     */
    Autocomplete.prototype.disable = function () {
        if (!this._input) {
            return;
        }
        this._input.setAttribute("disabled", "true");
        this._input.removeEventListener("keyup", this._keyUpHandler);
        this._input.removeEventListener("keydown", this._keyDownHandler);
        this._input.removeEventListener("blur", this._blurHandler);
        this.close();
    };
    /**
     * Destroys the component and frees all references.
     */
    Autocomplete.prototype.destroy = function () {
        this.disable();
        this._keyUpHandler = undefined;
        this._keyDownHandler = undefined;
        this._windowClickHandler = undefined;
        this._blurHandler = undefined;
        this._input = undefined;
    };
    /**
     * Closes the suggestions dropdown.
     */
    Autocomplete.prototype.open = function () {
        this._dropdown.addEventListener("click", this._clickHandler);
        window.addEventListener("click", this._windowClickHandler);
        this.addClass(CLASS_OPEN);
    };
    /**
     * Opens the suggestions dropdown.
     */
    Autocomplete.prototype.close = function () {
        this._dropdown.removeEventListener("click", this._clickHandler);
        window.removeEventListener("click", this._windowClickHandler);
        this.removeClass(CLASS_OPEN);
    };
    Object.defineProperty(Autocomplete.prototype, "value", {
        /**
         * Gets the value of the input field.
         * @returns {String} The value of the input field.
         */
        get: function get() {
            return this._input.value;
        },
        enumerable: true,
        configurable: true
    });
    Autocomplete.prototype._handleClick = function (event) {
        if (!this._isDropdownTarget(event.target)) {
            return;
        }
        var current = event.target;
        while (current.nodeName !== "LI" && current.parentNode) {
            current = current.parentNode;
        }
        if (current.nodeName === "LI") {
            (0, _Utils.preventDefault)(event);
            this._selectItem(current);
        }
    };
    Autocomplete.prototype._handleBlur = function () {
        var _this = this;
        setTimeout(function () {
            _this.close();
        }, TIMEOUT_BLUR);
    };
    Autocomplete.prototype._handleKeyUp = function (evt) {
        var keycode = evt.which || evt.keyCode;
        if (Inputs.containsKey(keycode, [Inputs.KEY_ARROW_UP, Inputs.KEY_ARROW_DOWN, Inputs.KEY_ENTER, Inputs.KEY_TAB])) {
            // Do not handle these events on keyup
            (0, _Utils.preventDefault)(evt);
            return;
        }
        var target = evt.currentTarget;
        if (evt.currentTarget && target.value && target.value.length >= this._minChars) {
            this._getSuggestion(target.value);
        } else {
            this.close();
        }
    };
    Autocomplete.prototype._handleKeyDown = function (evt) {
        var keycode = evt.which || evt.keyCode;
        var isOpen = (0, _DomFunctions.hasClass)(this.element, CLASS_OPEN);
        if (keycode === Inputs.KEY_ESCAPE && isOpen === true) {
            // handle Escape key (ESC)
            this.close();
            (0, _Utils.preventDefault)(evt);
            return;
        }
        if (isOpen === true && Inputs.containsKey(keycode, [Inputs.KEY_ENTER, Inputs.KEY_TAB])) {
            var focusedElement = this._suggestionList.querySelector("." + CLASS_HOVER);
            (0, _Utils.preventDefault)(evt);
            this._selectItem(focusedElement);
            return;
        }
        if (isOpen === true && Inputs.containsKey(keycode, [Inputs.KEY_ARROW_UP, Inputs.KEY_ARROW_DOWN])) {
            // Up and down arrows
            var focusedElement = this._suggestionList.querySelector("." + CLASS_HOVER);
            if (focusedElement) {
                (0, _DomFunctions.removeClass)(focusedElement, CLASS_HOVER);
                var children = Array.prototype.slice.call(this._suggestionList.childNodes);
                var totalNodes = children.length - 1;
                var direction = keycode === Inputs.KEY_ARROW_UP ? -1 : 1;
                var index = children.indexOf(focusedElement);
                index = Math.max(Math.min(index + direction, totalNodes), 0);
                focusedElement = this._suggestionList.childNodes[index];
            } else {
                focusedElement = this._suggestionList.querySelector("li");
            }
            (0, _DomFunctions.addClass)(focusedElement, CLASS_HOVER);
            (0, _Utils.preventDefault)(evt);
            return;
        }
    };
    Autocomplete.prototype._handleWindowClick = function (event) {
        if (this._isDropdownTarget(event.target)) {
            return;
        }
        this.close();
    };
    Autocomplete.prototype._selectItem = function (item) {
        if (!item) {
            return;
        }
        var text = item.getAttribute(ATTRIBUTE_VALUE);
        if (text) {
            this._input.value = text;
            // Dispatch the changed event
            this.dispatchEvent("change");
        }
        this.close();
    };
    Autocomplete.prototype._isDropdownTarget = function (target) {
        var current = target;
        while (current !== this._dropdown && current.parentNode) {
            current = current.parentNode;
        }
        return current === this._dropdown;
    };
    Autocomplete.prototype._clearSuggestions = function () {
        // Clear the dropdown item
        (0, _DomFunctions.empty)(this._dropdown);
        this._suggestionList = document.createElement("ul");
        this._dropdown.appendChild(this._suggestionList);
    };
    Autocomplete.prototype._addSuggestion = function (text, term) {
        var sanitizedTerm = term.replace(/[-\\^$*+?.()|[\]{}]/g, "\\$&");
        var html = text.replace(new RegExp("(" + sanitizedTerm + ")", "gi"), "<strong>$1</strong>");
        var textElement = new _DomElement2.default("span").setHtml(html);
        var innerElement = new _DomElement2.default("div").addClass(CLASS_RESULT).appendChild(textElement);
        var liElement = new _DomElement2.default("li").setAttribute(ATTRIBUTE_VALUE, text).appendChild(innerElement);
        this._suggestionList.appendChild(liElement.element);
    };
    Autocomplete.prototype._getSuggestion = function (term) {
        var _this = this;
        if (!this._source) {
            throw new Error("The source function is undefined, cannot load suggestions");
        }
        this._source(term, function (matches, termused) {
            _this._onMatchesReceived(matches, termused);
        });
    };
    Autocomplete.prototype._onMatchesReceived = function (matches, term) {
        var e_1, _a;
        this._clearSuggestions();
        if (!matches || matches.length === 0) {
            this.close();
        } else {
            // Clear the dropdown item
            (0, _DomFunctions.empty)(this._suggestionList);
            try {
                for (var matches_1 = tslib_1.__values(matches), matches_1_1 = matches_1.next(); !matches_1_1.done; matches_1_1 = matches_1.next()) {
                    var match = matches_1_1.value;
                    this._addSuggestion(match, term);
                }
            } catch (e_1_1) {
                e_1 = { error: e_1_1 };
            } finally {
                try {
                    if (matches_1_1 && !matches_1_1.done && (_a = matches_1.return)) _a.call(matches_1);
                } finally {
                    if (e_1) throw e_1.error;
                }
            }
            this.open();
        }
    };
    return Autocomplete;
}(_DomElement2.default);
/**
 * Change event
 *
 * @event Autocomplete#change
 * @type {object}
 */
function init() {
    (0, _Utils.searchAndInitialize)(".input-field--autocomplete", function (e) {
        new Autocomplete(e);
    });
}
exports.default = Autocomplete;

},{"../DomElement":5,"../DomFunctions":6,"../Inputs":7,"../Utils":8,"tslib":135}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _assign = require("babel-runtime/core-js/object/assign");

var _assign2 = _interopRequireDefault(_assign);

exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _flatpickr = require("flatpickr");

var _flatpickr2 = _interopRequireDefault(_flatpickr);

var _it = require("flatpickr/dist/l10n/it.js");

var _fr = require("flatpickr/dist/l10n/fr.js");

var _de = require("flatpickr/dist/l10n/de.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_flatpickr2.default.localize(_it.Italian);
_flatpickr2.default.localize(_fr.French);
_flatpickr2.default.localize(_de.German);
var DEFAULTS_FLATPICKR = {
    wrap: true,
    allowInput: true,
    locale: "de",
    dateFormat: "d.m.Y",
    time_24hr: true
};
var CLASS_HAS_VALUE = "is-fixed";
var CLASS_MESSAGE = ".message";
/**
 * Input field component
 */
var InputField = /** @class */function (_super) {
    tslib_1.__extends(InputField, _super);
    function InputField(element, datePickerOptions) {
        var _this = _super.call(this, element) || this;
        _this._changedHandler = _this.onValueChanged.bind(_this);
        _this._animationStartHandler = _this._onAnimationStart.bind(_this);
        _this._datePickerOptions = datePickerOptions;
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the input field component.
     * @private
     */
    InputField.prototype._initialize = function () {
        this.element.addEventListener("input", this._changedHandler);
        if (this.element.getAttribute("type") === "password") {
            this.element.addEventListener("animationstart", this._animationStartHandler);
        }
        this._initializeDatePicker();
        this.onValueChanged();
    };
    InputField.prototype._initializeDatePicker = function () {
        var picker = this.element.parentElement;
        if (!picker || !picker.classList.contains("flatpickr")) {
            return;
        }
        if (!this._datePickerOptions) {
            try {
                this._datePickerOptions = JSON.parse(picker.dataset.options || "{}");
            } catch (e) {
                this._datePickerOptions = {};
                // tslint:disable-next-line:no-console
                console.warn("_initializeDatePicker JSON.parse failed", picker.dataset.options, e);
            }
        }
        this._flatpickrInstance = (0, _flatpickr2.default)(picker, (0, _assign2.default)({}, DEFAULTS_FLATPICKR, this._datePickerOptions));
    };
    InputField.prototype._destroyDatePicker = function () {
        if (this._flatpickrInstance) {
            this._flatpickrInstance.destroy();
        }
    };
    InputField.prototype._onAnimationStart = function (e) {
        if (e.animationName === "onAutoFillStart") {
            this.onValueChanged(true);
        }
    };
    /**
     * Notifies the input field component that it's value has been changed.
     */
    InputField.prototype.onValueChanged = function (force) {
        if (force === void 0) {
            force = false;
        }
        if (this.element.value && this.element.value !== "" || force === true) {
            this.addClass(CLASS_HAS_VALUE);
        } else {
            this.removeClass(CLASS_HAS_VALUE);
            this.element.value = "";
        }
    };
    /**
     * Destroys the component and frees all references.
     */
    InputField.prototype.destroy = function () {
        this.element.removeEventListener("input", this._changedHandler);
        if (this.element.getAttribute("type") === "password") {
            this.element.removeEventListener("animationstart", this._animationStartHandler);
        }
        this._changedHandler = undefined;
        this._animationStartHandler = undefined;
        this._destroyDatePicker();
    };
    /**
     * Displays the specified error text underneath the input field.
     * @param {text} text The error text/html to display; or undefined to hide the message.
     */
    InputField.prototype.showError = function (text) {
        var message;
        if (this.element.parentElement) {
            var msg_1 = this.element.parentElement.querySelector(CLASS_MESSAGE);
            if (msg_1) {
                message = new _DomElement2.default(msg_1);
            }
        }
        if (!text || text === "") {
            if (message) {
                (0, _Utils.remove)(message.element);
            }
            this.removeClass("invalid");
            return;
        }
        this.addClass("invalid");
        if (!message) {
            message = new _DomElement2.default("div").addClass("message");
            this.element.parentElement.appendChild(message.element);
        } else {
            message.empty();
        }
        var icon = new _DomElement2.default("i").addClass("icon").addClass("icon-026-exclamation-mark-circle").setAttribute("aria-hidden", "true");
        var msg = new _DomElement2.default("span").setHtml(text);
        message.appendChild(icon);
        message.appendChild(msg);
    };
    return InputField;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".input-field input", function (e) {
        new InputField(e);
    }, function (e) {
        return e.parentElement;
    });
}
exports.default = InputField;

},{"../DomElement":5,"../Utils":8,"babel-runtime/core-js/object/assign":41,"flatpickr":130,"flatpickr/dist/l10n/de.js":131,"flatpickr/dist/l10n/fr.js":132,"flatpickr/dist/l10n/it.js":133,"tslib":135}],19:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _isNan = require("babel-runtime/core-js/number/is-nan");

var _isNan2 = _interopRequireDefault(_isNan);

exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

var _Utils = require("../Utils");

var _Inputs = require("../Inputs");

var Inputs = _interopRequireWildcard(_Inputs);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MARGIN_TICK = 32;
var CLASS_HTML5 = "html5";
var RANGE_LIGHT = "range--light";
var CLASS_CONTAINER = "range-container";
var CLASS_SLIDER = "range-slider";
var CLASS_ACTIVE = "range--active";
var CLASS_TRACK = "range-track";
var CLASS_TRACK_PROGRESS = "range-track__progress";
var CLASS_TICK = "range-tick";
var CLASS_TICK_LABEL = "range-tick__label";
var CLASS_TICK_ACTIVE = "range-tick--active";
var CLASS_THUMB = "range-thumb";
var CLASS_THUMB_VALUE = "range-thumb__value";
var CLASS_DISABLED = "range--disabled";
var CLASS_DRAGGING = "range--dragging";
/**
 * The range slider component definition.
 */
var Range = /** @class */function (_super) {
    tslib_1.__extends(Range, _super);
    function Range(element) {
        var _this = _super.call(this, element) || this;
        // Setup event context
        _this._downHandler = _this._handleDown.bind(_this);
        _this._moveHandler = _this._handleMove.bind(_this);
        _this._endHandler = _this._handleEnd.bind(_this);
        _this._keydownHandler = _this._handleKeydown.bind(_this);
        _this._focusHandler = _this._handleFocus.bind(_this);
        _this._blurHandler = _this._handleBlur.bind(_this);
        _this._resizeHandler = _this.layout.bind(_this);
        _this._initialize();
        if (_this.element.disabled) {
            _this.disable();
        } else {
            _this.enable();
        }
        return _this;
    }
    /**
     * Initializes the range slider component.
     *
     * This method inspects the select definition and its options and
     * generates new stylable DOM elements around the original range input-element
     * definitions.
     * @private
     */
    Range.prototype._initialize = function () {
        if (this.hasClass(CLASS_HTML5)) {
            // This element uses HTML5 styling, do not touch it...
            return;
        }
        this._wrapperElement = new _DomElement2.default(this.element.parentElement);
        this._rangeContainer = new _DomElement2.default("div").addClass(CLASS_CONTAINER);
        this._rangeTrack = new _DomElement2.default("div").addClass(CLASS_TRACK);
        // check if range--light slider then add progress
        if (this._wrapperElement.hasClass(RANGE_LIGHT)) {
            this._rangeProgress = new _DomElement2.default("div").addClass(CLASS_TRACK_PROGRESS);
            this._rangeTrack.appendChild(this._rangeProgress);
        }
        this._rangeThumb = new _DomElement2.default("div").addClass(CLASS_THUMB);
        this._ticksWrapper = new _DomElement2.default("div").addClass(CLASS_SLIDER);
        this._rangeContainer.appendChild(this._rangeTrack);
        this._rangeContainer.appendChild(this._ticksWrapper);
        this._rangeContainer.appendChild(this._rangeThumb);
        // add container to wrapper
        this._wrapperElement.appendChild(this._rangeContainer);
        // get min & max definitions
        this._minValue = parseFloat(this.element.min) || 0;
        this._maxValue = parseFloat(this.element.max) || 1;
        // get the label/output format string
        this._formatter = window[this.getAttribute("formatter")];
        // get the output label and move it below the container
        if (this.element.id) {
            this._outputLabel = this._wrapperElement.find("output[for='" + this.element.id + "']");
            if (this._outputLabel) {
                this._wrapperElement.appendChild(this._outputLabel);
            }
        }
        if (!this.element.step) {
            // fix issues with float sliders if the step is undefined
            this.element.step = "any";
        }
        var options = this._getOptionsList();
        if (options && options.length > 1) {
            this._addTicks(options);
        }
        if (this._rangeContainer.element.querySelectorAll("." + CLASS_TICK_LABEL).length <= 1) {
            this._thumbValue = new _DomElement2.default("div").addClass(CLASS_THUMB_VALUE);
            this._rangeThumb.appendChild(this._thumbValue);
        }
        this._trackValueTotal = this._maxValue - this._minValue;
        this.layout();
        this._updateTickState();
        // Apply the tab index
        var tabIndex = this.element.getAttribute("tabindex");
        if (tabIndex) {
            this._rangeContainer.setAttribute("tabindex", tabIndex);
        }
        window.addEventListener("resize", this._resizeHandler);
        window.addEventListener("orientationchange", this._resizeHandler);
    };
    Range.prototype._getOptionsList = function () {
        var e_1, _a;
        var options = [];
        var listId = this.getAttribute("list");
        if (listId) {
            var dataList = document.querySelector("#" + listId);
            if (dataList) {
                try {
                    for (var _b = tslib_1.__values(dataList.querySelectorAll("option")), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var entry = _c.value;
                        var value = parseFloat(entry.innerText);
                        var label = entry.getAttribute("label") || parseFloat(value.toFixed(2));
                        options.push({
                            value: value,
                            label: label
                        });
                    }
                } catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                } finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    } finally {
                        if (e_1) throw e_1.error;
                    }
                }
            }
        }
        // Sort the list to enable snapping
        options = options.sort(function (a, b) {
            return a.value - b.value;
        });
        if (options.length > 1) {
            this._minValue = Number.MAX_VALUE;
            this._maxValue = Number.MIN_VALUE;
            for (var i = 0; i < options.length; i++) {
                this._minValue = Math.min(this._minValue, options[i].value);
                this._maxValue = Math.max(this._maxValue, options[i].value);
            }
        }
        return options;
    };
    Range.prototype._addTicks = function (dataItems) {
        var e_2, _a;
        try {
            for (var dataItems_1 = tslib_1.__values(dataItems), dataItems_1_1 = dataItems_1.next(); !dataItems_1_1.done; dataItems_1_1 = dataItems_1.next()) {
                var entry = dataItems_1_1.value;
                var tickElement = new _DomElement2.default("div").setAttribute("data-value", String(entry.value)).addClass(CLASS_TICK);
                var tickLabel = new _DomElement2.default("span").addClass(CLASS_TICK_LABEL).setHtml(String(entry.label));
                tickElement.appendChild(tickLabel);
                this._ticksWrapper.appendChild(tickElement);
            }
        } catch (e_2_1) {
            e_2 = { error: e_2_1 };
        } finally {
            try {
                if (dataItems_1_1 && !dataItems_1_1.done && (_a = dataItems_1.return)) _a.call(dataItems_1);
            } finally {
                if (e_2) throw e_2.error;
            }
        }
    };
    Range.prototype._isEventOnLabel = function (event) {
        return event.target.classList.contains(CLASS_TICK_LABEL);
    };
    Range.prototype._handleDown = function (event) {
        this._wrapperElement.addClass(CLASS_DRAGGING);
        this._rangeContainer.element.addEventListener("mouseup", this._endHandler);
        document.addEventListener("mousemove", this._moveHandler);
        document.addEventListener("mouseup", this._endHandler);
        this._rangeContainer.element.addEventListener("touchmove", this._moveHandler);
        document.addEventListener("touchend", this._endHandler);
        // Ignore clicks directly on the thumb
        if (event.target !== this._rangeThumb.element && !this._isEventOnLabel(event)) {
            var pos = this._getRelativePosition(event);
            this._setPosition(pos, true, false, false);
        }
    };
    Range.prototype._handleMove = function (event) {
        (0, _Utils.preventDefault)(event);
        this._unfocus();
        if (!this._isEventOnLabel(event)) {
            var pos = this._getRelativePosition(event);
            this._setPosition(pos, true, false, false);
        }
    };
    Range.prototype._handleEnd = function (event) {
        this._wrapperElement.removeClass(CLASS_DRAGGING);
        this._rangeContainer.element.removeEventListener("mouseup", this._endHandler);
        document.removeEventListener("mouseup", this._endHandler);
        document.removeEventListener("mousemove", this._moveHandler);
        this._rangeContainer.element.removeEventListener("touchmove", this._moveHandler);
        document.removeEventListener("touchend", this._endHandler);
        var pos = this._getRelativePosition(event);
        this._setPosition(pos, true, true, true);
        this._handleBlur();
    };
    Range.prototype._handleKeydown = function (event) {
        var keycode = event.which || event.keyCode;
        if (keycode === Inputs.KEY_ESCAPE) {
            // handle Escape key (ESC)
            this._rangeContainer.element.blur();
            return;
        }
        var isUp = keycode === Inputs.KEY_ARROW_UP || keycode === Inputs.KEY_ARROW_RIGHT || keycode === Inputs.KEY_PAGE_UP;
        var isDown = keycode === Inputs.KEY_ARROW_DOWN || keycode === Inputs.KEY_ARROW_LEFT || keycode === Inputs.KEY_PAGE_DOWN;
        if (isUp || isDown) {
            event.preventDefault();
            var direction = isDown ? -1 : 1;
            // make a larger step if its the vertical arrow or page keys
            if (keycode === Inputs.KEY_ARROW_UP || keycode === Inputs.KEY_ARROW_DOWN || keycode === Inputs.KEY_PAGE_UP || keycode === Inputs.KEY_PAGE_DOWN) {
                direction *= 10;
            }
            var val = this.value;
            if (this._ticksWrapper.element.childNodes.length > 1) {
                val = this._getNextValue(val, direction);
            } else {
                var step = this.element.step;
                if (!step || step === "any") {
                    step = "0.1";
                }
                var newVal = val + parseFloat(step) * direction;
                val = newVal;
            }
            this._setValue(val, true, true);
            return;
        }
    };
    Range.prototype._handleFocus = function () {
        this._rangeContainer.addClass(CLASS_ACTIVE);
    };
    Range.prototype._handleBlur = function () {
        this._rangeContainer.removeClass(CLASS_ACTIVE);
    };
    Range.prototype._unfocus = function () {
        if (document.selection) {
            document.selection.empty();
        } else {
            window.getSelection().removeAllRanges();
        }
    };
    Range.prototype._getRelativePosition = function (event) {
        var pageX;
        if ("pageX" in event) {
            pageX = event.pageX;
        } else {
            pageX = (event.touches[0] || event.changedTouches[0]).pageX;
        }
        return pageX - this._trackLeftPosition + this._grabPosition;
    };
    /**
     * Validates and updates the position and sets the corresponding value on the slider.
     * @param {position} the new position to set.
     * @param {updateValue} true if the value should be updated as well; otherwise false.
     * @param {snap} true if snapping should be used; otherwise false.
     * @param {animate} true if the UI update should be animated; otherwise false.
     * @private
     */
    Range.prototype._setPosition = function (position, updateValue, snap, animate) {
        if (updateValue === void 0) {
            updateValue = true;
        }
        if (snap === void 0) {
            snap = false;
        }
        if (animate === void 0) {
            animate = true;
        }
        if (position === undefined || position === null || (0, _isNan2.default)(position)) {
            throw new Error("Position is not a number");
        }
        // Clamp to min and max range
        var newPos = (0, _Utils.clamp)(position, this._trackPositionMin, this._trackPositionMax);
        if (updateValue) {
            var value = this._trackValueTotal / this._trackWidth * newPos + this._minValue;
            if (this._ticksWrapper.element.childNodes.length > 1 && snap) {
                var snapPos = this._getSnapPosition(newPos);
                newPos = snapPos.position;
                value = snapPos.value;
            } else if (this.element.step && this.element.step !== "any") {
                var step = parseFloat(this.element.step);
                value = Math.round(value / step) * step;
            }
            this._setValue(value, false, false);
        }
        if (animate && updateValue) {
            this._updateTickState();
        }
        if (animate) {
            (0, _animejs2.default)({
                targets: this._rangeThumb.element,
                duration: 200,
                left: newPos,
                easing: "easeInOutQuint"
            });
            if (this._rangeProgress) {
                (0, _animejs2.default)({
                    targets: this._rangeProgress.element,
                    duration: 200,
                    width: newPos,
                    easing: "easeInOutQuint"
                });
            }
        } else {
            this._rangeThumb.element.style.left = newPos + "px";
            if (this._rangeProgress) {
                this._rangeProgress.element.style.width = newPos + "px";
            }
        }
    };
    /**
     * Gets the snap value corresponding to the given value.
     * @param {value} the target value.
     * @returns an object containing the snap position and the corresponding value.
     * @private
     */
    Range.prototype._getSnapValue = function (value) {
        var ticks = this._ticksWrapper.element.children;
        var currentPosition = 0;
        for (var i = 0; i < ticks.length; i++) {
            var currentElement = new _DomElement2.default(ticks[i]);
            var currentValue = parseFloat(currentElement.getAttribute("data-value"));
            var currentWidth = currentElement.element.clientWidth;
            var nextElement = void 0;
            var nextValue = Number.MAX_VALUE;
            if (i < ticks.length - 1) {
                nextElement = new _DomElement2.default(ticks[i + 1]);
                nextValue = parseFloat(nextElement.getAttribute("data-value"));
            }
            // left most element
            if (i === 0 && value <= currentValue) {
                return {
                    value: currentValue,
                    position: MARGIN_TICK - this._grabPosition
                };
            }
            // right most element
            if (!nextElement && value >= currentValue) {
                return {
                    value: currentValue,
                    position: currentPosition + (currentWidth - MARGIN_TICK) - this._grabPosition - 1
                };
            }
            if (value >= currentValue && value < nextValue) {
                return {
                    value: currentValue,
                    position: currentPosition + 0.5 * currentWidth - this._grabPosition
                };
            }
            currentPosition += currentWidth;
        }
        throw new Error("Could not determine snap value");
    };
    /**
     * Gets the snap position corresponding to the given position.
     * @param {position} the target position.
     * @returns an object containing the snap position and the corresponding value.
     * @private
     */
    Range.prototype._getSnapPosition = function (position) {
        if (position === undefined || position === null || (0, _isNan2.default)(position)) {
            throw new Error("position is not a number");
        }
        var ticks = this._ticksWrapper.element.children;
        var currentPosition = 0;
        for (var i = 0; i < ticks.length; i++) {
            var currentElement = new _DomElement2.default(ticks[i]);
            var currentValue = parseFloat(currentElement.getAttribute("data-value"));
            var currentWidth = currentElement.element.clientWidth;
            var nextElement = void 0;
            if (i < ticks.length - 1) {
                nextElement = new _DomElement2.default(ticks[i + 1]);
            }
            // left most element
            if (i === 0 && position <= currentPosition + currentWidth) {
                return {
                    value: currentValue,
                    position: MARGIN_TICK - this._grabPosition
                };
            }
            // right most element
            if (!nextElement && position >= currentPosition) {
                return {
                    value: currentValue,
                    position: currentPosition + (currentWidth - MARGIN_TICK) - this._grabPosition - 1
                };
            }
            if (position >= currentPosition && position < currentPosition + currentWidth) {
                return {
                    value: currentValue,
                    position: currentPosition + 0.5 * currentWidth - this._grabPosition
                };
            }
            currentPosition += currentWidth;
        }
        throw new Error("Could not determine snap position");
    };
    /**
     * Gets the next value in the given direction with regards to snapping.
     * @param {value} The current value.
     * @param {direction} The direction (positive or negative integer).
     * @returns The next value.
     * @private
     */
    Range.prototype._getNextValue = function (value, direction) {
        var ticks = this._ticksWrapper.element.children;
        for (var i = 0; i < ticks.length; i++) {
            var currentElement = new _DomElement2.default(ticks[i]);
            var currentVal = parseFloat(currentElement.getAttribute("data-value"));
            if (value === currentVal) {
                var index = (0, _Utils.clamp)(i + direction, 0, ticks.length - 1);
                value = parseFloat(ticks[index].getAttribute("data-value"));
            }
        }
        return value;
    };
    Range.prototype._updateTickState = function () {
        if (this._ticksWrapper.element.childNodes.length > 1) {
            var activeTick = this._ticksWrapper.find("." + CLASS_TICK_ACTIVE);
            if (activeTick) {
                activeTick.removeClass(CLASS_TICK_ACTIVE);
            }
            var newActiveTick = this._ticksWrapper.find("." + CLASS_TICK + "[data-value='" + this.value + "']");
            if (newActiveTick) {
                newActiveTick.addClass(CLASS_TICK_ACTIVE);
            }
        }
    };
    Range.prototype._adjustTickLabelPosition = function (tickItem, left) {
        var label = new _DomElement2.default(tickItem.querySelector("." + CLASS_TICK_LABEL));
        var dummyElement = new _DomElement2.default("span").addClass(CLASS_TICK_LABEL).setAttribute("style", "visibility: hidden; display: inline-block;").setHtml(label.innerText);
        this._rangeContainer.appendChild(dummyElement);
        var width = dummyElement.element.clientWidth / 2;
        this._rangeContainer.removeChild(dummyElement);
        var floatPosition = left ? "left" : "right";
        if (width < MARGIN_TICK) {
            // center small items on the tick
            label.setAttribute("style", floatPosition + ": " + (MARGIN_TICK - Math.floor(width)) + "px; text-align: " + floatPosition + ";");
        }
    };
    Range.prototype._formatOutput = function (value, short) {
        if (this._formatter) {
            return this._formatter(value, short);
        }
        var str = parseFloat(value.toFixed(2));
        return str.toString();
    };
    /**
     * Validates and updates the range value.
     * @param {value} the new value to set.
     * @param {update} true if the UI should be updated; otherwise false.
     * @param {animate} true if the UI update should be animated; otherwise false.
     * @private
     */
    Range.prototype._setValue = function (value, update, animate) {
        if (update === void 0) {
            update = true;
        }
        if (animate === void 0) {
            animate = false;
        }
        var val = (0, _Utils.clamp)(value, this._minValue, this._maxValue);
        var position;
        if (this._ticksWrapper.element.childNodes.length > 1) {
            var snapValue = this._getSnapValue(val);
            position = snapValue.position;
            val = snapValue.value;
        } else {
            position = this._trackWidth / this._trackValueTotal * (value - this._minValue);
        }
        this.element.value = String(val);
        if (this._thumbValue) {
            this._thumbValue.setHtml(this._formatOutput(val, true));
        }
        if (this._outputLabel) {
            this._outputLabel.setHtml(this._formatOutput(val, false));
        }
        if (update) {
            this._setPosition(position, false, false, animate);
            this._updateTickState();
        }
        this.dispatchEvent("input");
    };
    Object.defineProperty(Range.prototype, "value", {
        /**
         * Gets the current value.
         */
        get: function get() {
            return parseFloat(this.element.value);
        },
        /**
         * Sets the value of the range slider.
         */
        set: function set(value) {
            this._setValue(value, true, true);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Force the component to re-layout itself.
     */
    Range.prototype.layout = function () {
        this._grabPosition = Math.round(this._rangeThumb.element.offsetWidth / 2);
        var tickItems = this._rangeContainer.element.querySelectorAll("." + CLASS_TICK);
        var ticksOffset = tickItems && tickItems.length > 0 ? 2 * MARGIN_TICK : MARGIN_TICK;
        this._trackWidth = this._rangeTrack.element.offsetWidth - ticksOffset;
        this._trackPositionMin = 0;
        this._trackPositionMax = this._rangeTrack.element.clientWidth - this._rangeThumb.element.offsetWidth + 1;
        this._trackLeftPosition = this._rangeTrack.element.getBoundingClientRect().left + MARGIN_TICK;
        var itemCount = tickItems.length - 1;
        this._itemWidth = this._trackWidth / itemCount;
        var outerItemsWidth = this._itemWidth * 0.5 + MARGIN_TICK;
        for (var i = 0; i <= itemCount; i++) {
            var width = this._itemWidth;
            if (i === 0 || i === itemCount) {
                width = outerItemsWidth;
            }
            var item = new _DomElement2.default(tickItems[i]);
            item.setAttribute("style", "width: " + Math.floor(width) + "px;");
        }
        // adjust first and last label positions
        if (tickItems.length > 1) {
            this._adjustTickLabelPosition(tickItems[0], true);
            this._adjustTickLabelPosition(tickItems[tickItems.length - 1], false);
        }
        // update the value
        this._setValue(parseFloat(this.element.value), true, false);
    };
    /**
     * Destroys the components and frees all references.
     */
    Range.prototype.destroy = function () {
        window.removeEventListener("resize", this._resizeHandler);
        window.removeEventListener("orientationchange", this._resizeHandler);
        this._downHandler = null;
        this._moveHandler = null;
        this._endHandler = null;
        this._focusHandler = null;
        this._blurHandler = null;
        this.element = null;
        this._rangeContainer = null;
        this._wrapperElement = null;
    };
    /**
     * @deprecated use destroy() instead.
     * @todo remove in version 2.0.0
     */
    Range.prototype.destoy = function () {
        this.destroy();
    };
    /**
     * Sets the component to the enabled state.
     */
    Range.prototype.enable = function () {
        this.element.removeAttribute("disabled");
        this._wrapperElement.removeClass(CLASS_DISABLED);
        this._rangeContainer.element.addEventListener("mousedown", this._downHandler);
        this._rangeContainer.element.addEventListener("touchstart", this._downHandler);
        this._rangeContainer.element.addEventListener("keydown", this._keydownHandler);
        this._rangeContainer.element.addEventListener("focus", this._focusHandler);
        this._rangeContainer.element.addEventListener("blur", this._blurHandler);
    };
    /**
     * Sets the component to the disabled state.
     */
    Range.prototype.disable = function () {
        this.element.setAttribute("disabled", "");
        this._wrapperElement.addClass(CLASS_DISABLED);
        this._rangeContainer.element.removeEventListener("mousedown", this._downHandler);
        this._rangeContainer.element.removeEventListener("mouseup", this._endHandler);
        this._rangeContainer.element.removeEventListener("mousemove", this._moveHandler);
        this._rangeContainer.element.removeEventListener("touchstart", this._downHandler);
        this._rangeContainer.element.removeEventListener("focus", this._focusHandler);
        this._rangeContainer.element.removeEventListener("blur", this._blurHandler);
    };
    return Range;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)("input[type='range']", function (e) {
        new Range(e);
    });
}
exports.default = Range;

},{"../DomElement":5,"../Inputs":7,"../Utils":8,"animejs":35,"babel-runtime/core-js/number/is-nan":39,"tslib":135}],20:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _Inputs = require("../Inputs");

var Inputs = _interopRequireWildcard(_Inputs);

var _DomFunctions = require("../DomFunctions");

var Dom = _interopRequireWildcard(_DomFunctions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var CLASS_PLACEHOLDER = "select__placeholder";
var CLASS_THUMB = "select__thumb";
var CLASS_BUTTON = "select__button";
var CLASS_DROPDOWN = "select__dropdown";
var CLASS_OPEN = "select--open";
var CLASS_CLOSED = "select--closed";
var CLASS_DISABLED = "select--disabled";
var CLASS_FILTERABLE = "select--filterable";
var CLASS_ITEM = "dropdown-item";
var CLASS_ITEM_SELECTED = "dropdown-item--selected";
var CLASS_ITEM_FOCUSED = "dropdown-item--focused";
var CLASS_ITEM_DISABLED = "dropdown-item--disabled";
var CLASS_GROUP_ITEM = "dropdown-group";
var CLASS_GROUP_HEADER = "dropdown-group__item";
var QUERY_MESSAGE = ".message";
var TIMEOUT_CLOSE = 150;
var TIMEOUT_BLUR = 400;
/**
 * The select component API.
 */
var Select = /** @class */function (_super) {
    tslib_1.__extends(Select, _super);
    function Select(element) {
        var _this = _super.call(this, element) || this;
        // Minimum filter length
        _this._minFilterLength = 2;
        // The options the Select was initially created upon
        // These will be used as a basis for filtering
        _this._initialOptions = Array.prototype.slice.call(_this.element.children);
        _this._openByFocus = false;
        // Check for multi-selection
        _this._multiselection = _this.element.hasAttribute("multiple") === true;
        // Setup event context
        _this._clickHandler = _this._handleClick.bind(_this);
        _this._handleDropdownClick = _this._handleClick.bind(_this);
        _this._keydownHandler = _this._handleKeydown.bind(_this);
        _this._focusHandler = _this._handleFocus.bind(_this);
        _this._blurHandler = _this._handleBlur.bind(_this);
        _this._windowClickHandler = _this._handleWindowClick.bind(_this);
        _this._filterKeydownHandler = _this._handleFilterKeydown.bind(_this);
        _this._filterKeyupHandler = _this._handleFilterKeyup.bind(_this);
        _this._filterFocusHandler = _this._handleFilterFocus.bind(_this);
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the select component.
     *
     * This method inspects the select definition and its options and
     * generates new stylable DOM elements around the original select-element
     * definitions.
     * @private
     */
    Select.prototype._initialize = function () {
        var e_1, _a;
        var selectedOption = this.element.querySelector("option[selected]");
        var firstOption = this.element.querySelector("option");
        // Per default, set the last selected option to either the option with a "selected" attribute,
        // or, if not found, to the first available option
        this._lastSelectedOption = selectedOption || firstOption;
        this._wrapperElement = new _DomElement2.default(this.element.parentElement).addClass(CLASS_CLOSED);
        try {
            for (var _b = tslib_1.__values(this.classes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var cls = _c.value;
                this._wrapperElement.addClass(cls);
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
        this._dropdownElement = new _DomElement2.default("div").addClass(CLASS_DROPDOWN);
        if ((0, _Utils.internetExplorerOrEdgeVersion)() > 0 && (0, _Utils.internetExplorerOrEdgeVersion)() < 12) {
            // This is a workaround for IE browsers 11 and earlier where focusing
            // a scrollable dropdown list will close the dropdown prematurely.
            this._dropdownElement.element.addEventListener("mousedown", function (event) {
                return event.preventDefault();
            });
        }
        this._setupTarget();
        this._setupPlaceholder();
        this._wrapperElement.appendChild(this._dropdownElement);
        this._createOptions(this.element);
        this._updateSize();
        this._updateMessage();
        if (this.element.disabled) {
            this.disable();
        } else {
            this.enable();
        }
    };
    Select.prototype._setupTarget = function () {
        // move the id from the select element to the wrapper
        var id = this.element.getAttribute("id");
        if (id) {
            this.element.removeAttribute("id");
            this._wrapperElement.setAttribute("id", id);
        }
        // Apply the tab index
        var tabIndex = this.element.getAttribute("tabindex");
        if (tabIndex) {
            this._wrapperElement.setAttribute("tabIndex", tabIndex);
        }
    };
    Select.prototype._setupPlaceholder = function () {
        var _this = this;
        if (!this._selectButtonElement) {
            this._selectButtonElement = new _DomElement2.default("div").addClass(CLASS_BUTTON);
            this._wrapperElement.appendChild(this._selectButtonElement);
        }
        if (!this._thumbElement) {
            this._thumbElement = new _DomElement2.default("div").addClass(CLASS_THUMB);
            var thumbIcon = new _DomElement2.default("div").addClass("thumb-icon");
            var loader = new _DomElement2.default("div").addClass("loader-spinner").addClass("loader-spinner--small");
            this._thumbElement.appendChild(loader);
            this._thumbElement.appendChild(thumbIcon);
            this._selectButtonElement.appendChild(this._thumbElement);
        }
        var placeholderText = "";
        this._placeholderOption = this.element.querySelector("option[selected][disabled]") || undefined;
        if (this._placeholderOption) {
            placeholderText = Dom.text(this._placeholderOption);
            if (this._multiselection === true) {
                this._placeholderOption.selected = false;
            }
        }
        var selectedOption = this.element.querySelector("option[selected]:not([disabled])");
        if (selectedOption) {
            placeholderText = Dom.text(selectedOption);
        }
        if (!this._placeholderElement) {
            // When the Select is filterable, create an "input" as the placeholder element, otherwise a "span"
            if (this._isFilterable()) {
                this._placeholderElement = new _DomElement2.default("input");
                this._placeholderElement.addEventListener("keyup", function (e) {
                    return _this._handleFilterKeyup(e);
                });
                this._placeholderElement.addEventListener("keydown", function (e) {
                    return _this._handleFilterKeydown(e);
                });
                this._placeholderElement.addEventListener("focus", function (e) {
                    return _this._handleFilterFocus(e);
                });
            } else {
                this._placeholderElement = new _DomElement2.default("span");
            }
            this._placeholderElement.addClass(CLASS_PLACEHOLDER);
            this._selectButtonElement.appendChild(this._placeholderElement);
        }
        this._setPlaceholder(placeholderText);
        this._placeholderText = placeholderText;
        if (selectedOption && selectedOption !== this._placeholderOption) {
            this._updatePlaceholder(true);
        }
    };
    Select.prototype._updateMessage = function () {
        var messageNode = this._wrapperElement.element.querySelector(QUERY_MESSAGE);
        if (messageNode !== null) {
            this._wrapperElement.appendChild(new _DomElement2.default(messageNode));
        }
    };
    Select.prototype._isOptGroup = function (element) {
        return element.tagName.toUpperCase() === "OPTGROUP";
    };
    Select.prototype._isOption = function (element) {
        return element.tagName.toUpperCase() === "OPTION";
    };
    Select.prototype._createOptions = function (element) {
        for (var i = 0; i < element.children.length; i++) {
            var child = element.children[i];
            if (this._isOptGroup(child)) {
                this._appendGroup(child);
            }
            if (this._isOption(child)) {
                var option = this._createOption(child);
                if (option) {
                    this._dropdownElement.appendChild(option);
                }
            }
        }
    };
    Select.prototype._createOption = function (option) {
        var html = option.innerHTML;
        if (this._activeFilter) {
            var sanitizedActiveFilter = this._activeFilter.replace(/[-\\^$*+?.()|[\]{}]/g, "\\$&");
            html = html.replace(new RegExp("(" + sanitizedActiveFilter + ")", "gi"), "<strong>$1</strong>");
        }
        var opt = new _DomElement2.default("div").addClass(CLASS_ITEM).setHtml(html);
        if (option.selected) {
            opt.addClass(CLASS_ITEM_SELECTED);
        }
        if (option.disabled) {
            opt.addClass(CLASS_ITEM_DISABLED);
        }
        if (!this._isPlaceholder(option)) {
            opt.setAttribute("data-value", option.value);
            return opt;
        }
        return undefined;
    };
    Select.prototype._appendGroup = function (optgroup) {
        var e_2, _a;
        var label = optgroup.getAttribute("label");
        var group = new _DomElement2.default("div").addClass(CLASS_GROUP_ITEM);
        var groupHeader = new _DomElement2.default("div").addClass(CLASS_GROUP_HEADER).setHtml(label);
        group.appendChild(groupHeader);
        var options = optgroup.querySelectorAll("option");
        try {
            for (var options_1 = tslib_1.__values(options), options_1_1 = options_1.next(); !options_1_1.done; options_1_1 = options_1.next()) {
                var entry = options_1_1.value;
                var option = this._createOption(entry);
                if (option) {
                    group.appendChild(option);
                }
            }
        } catch (e_2_1) {
            e_2 = { error: e_2_1 };
        } finally {
            try {
                if (options_1_1 && !options_1_1.done && (_a = options_1.return)) _a.call(options_1);
            } finally {
                if (e_2) throw e_2.error;
            }
        }
        this._dropdownElement.appendChild(group);
        return group;
    };
    Select.prototype._updateSize = function () {
        var e_3, _a;
        // Note: Mirroring the DOM and measuring the items using their clientWidth was very
        // unreliable, therefore measuring was switched to the new HTML5 measureText method
        // margins and paddings arround the text are copied from the original placeholder items
        // dimension
        var placeholderStyle = window.getComputedStyle(this._placeholderElement.element);
        var paddingRight = parseFloat(placeholderStyle.paddingRight);
        var paddingLeft = parseFloat(placeholderStyle.paddingLeft);
        var font = this._placeholderElement.css("font");
        var textWidth = Dom.textWidth(this._placeholderText, font);
        var maxWidth = paddingLeft + paddingRight + textWidth;
        var options = this._wrapperElement.element.querySelectorAll("." + CLASS_ITEM);
        try {
            for (var options_2 = tslib_1.__values(options), options_2_1 = options_2.next(); !options_2_1.done; options_2_1 = options_2.next()) {
                var entry = options_2_1.value;
                var width = Dom.textWidth(Dom.text(entry), font) + paddingLeft + paddingRight;
                if (width > maxWidth) {
                    maxWidth = width;
                }
            }
        } catch (e_3_1) {
            e_3 = { error: e_3_1 };
        } finally {
            try {
                if (options_2_1 && !options_2_1.done && (_a = options_2.return)) _a.call(options_2);
            } finally {
                if (e_3) throw e_3.error;
            }
        }
    };
    Select.prototype._isButtonTarget = function (target) {
        return target === this._wrapperElement.element || target === this._placeholderElement.element || target === this._selectButtonElement.element || target === this._thumbElement.element;
    };
    Select.prototype._isDropdownTarget = function (target) {
        var current = target;
        while (current !== this._dropdownElement.element && current.parentElement) {
            current = current.parentElement;
        }
        return current === this._dropdownElement.element;
    };
    /**
     * Updates the UI if the selection has changed and makes sure the
     * select control and the generated markup are synchronized.
     * @private
     */
    Select.prototype._selectedItemChanged = function (newItem, autoClose, multiselect) {
        var _this = this;
        if (autoClose === void 0) {
            autoClose = true;
        }
        if (multiselect === void 0) {
            multiselect = false;
        }
        var oldItems = this._dropdownElement.element.querySelectorAll("." + CLASS_ITEM_SELECTED);
        if (!newItem) {
            setTimeout(function () {
                return _this.close();
            }, TIMEOUT_CLOSE);
            return;
        }
        if (Dom.hasClass(newItem, CLASS_ITEM_DISABLED)) {
            return;
        }
        if (oldItems.length === 0 && !newItem) {
            throw new Error("Can not select undefined elements");
        }
        var oldItem = oldItems[0];
        if (multiselect === true) {
            oldItem = (0, _Utils.find)(oldItems, function (x) {
                return x.getAttribute("data-value") === newItem.getAttribute("data-value");
            });
        }
        var isDeselect = false;
        if (newItem && oldItem && oldItem === newItem) {
            // Click on a previously selected element -> deselect
            isDeselect = true;
            if (!this._placeholderOption && !multiselect) {
                // If there is no placeholder option, non multiselect options cannot be deselected
                return;
            }
            delete this._lastSelectedOption;
        }
        if (oldItem) {
            // Remove selection on the element
            var oldValue_1 = oldItem.getAttribute("data-value");
            var optElement = (0, _Utils.find)(this.element.options, function (x) {
                return !x.disabled && x.value === oldValue_1;
            });
            if (!optElement) {
                throw new Error("The option with value " + oldValue_1 + " does not exist");
            }
            // Unset Select value
            optElement.selected = false;
            Dom.removeClass(oldItem, CLASS_ITEM_SELECTED);
        }
        if (!isDeselect) {
            // Select an option
            // Select a new item
            var newValue_1 = newItem.getAttribute("data-value");
            var optElement = (0, _Utils.find)(this.element.options, function (x) {
                return !x.disabled && x.value === newValue_1;
            });
            if (!optElement) {
                throw new Error("The option with value " + newValue_1 + " does not exist");
            }
            // Set Select value
            optElement.selected = true;
            Dom.addClass(newItem, CLASS_ITEM_SELECTED);
            // Preserve selection
            this._lastSelectedOption = optElement;
        } else {
            // Deselect an option
            // Keep track of falling back to the placeholder (if any)
            if (this._placeholderOption) {
                this._lastSelectedOption = this._placeholderOption;
            }
        }
        var hasSelectedItems = true;
        if (this._multiselection === false && isDeselect) {
            // Handle no selection for non-multiselect states
            this._placeholderOption.selected = true;
            hasSelectedItems = false;
        }
        if (this._multiselection === true && this._getSelectedOptions().length === 0) {
            hasSelectedItems = false;
        }
        // Reset the filter if filterable
        if (this._activeFilter) {
            this._clearFilter();
        }
        this._updatePlaceholder(hasSelectedItems);
        // Dispatch the changed event
        this.dispatchEvent("change");
        if (autoClose && !multiselect) {
            setTimeout(function () {
                _this.close();
            }, TIMEOUT_CLOSE);
        }
    };
    Select.prototype._updatePlaceholder = function (hasSelectedItems) {
        var e_4, _a;
        var text = this._placeholderOption ? Dom.text(this._placeholderOption) : " ";
        if (hasSelectedItems === true) {
            var selectedItems = this._getSelectedOptions();
            if (selectedItems.length > 0) {
                text = "";
                try {
                    for (var selectedItems_1 = tslib_1.__values(selectedItems), selectedItems_1_1 = selectedItems_1.next(); !selectedItems_1_1.done; selectedItems_1_1 = selectedItems_1.next()) {
                        var item = selectedItems_1_1.value;
                        text += Dom.text(item) + ", ";
                    }
                } catch (e_4_1) {
                    e_4 = { error: e_4_1 };
                } finally {
                    try {
                        if (selectedItems_1_1 && !selectedItems_1_1.done && (_a = selectedItems_1.return)) _a.call(selectedItems_1);
                    } finally {
                        if (e_4) throw e_4.error;
                    }
                }
                text = text.substring(0, text.length - 2);
            }
        }
        this._setPlaceholder(text);
    };
    Select.prototype._getSelectedOptions = function () {
        var selectedOptions = [];
        if (this.element.options) {
            [].forEach.call(this.element.options, function (option) {
                if (option.selected && !option.disabled) {
                    selectedOptions.push(option);
                }
            });
        }
        return selectedOptions;
    };
    /**
     * Clone all of the initially set options (and optgroups) and returns them in a new array.
     * This serves as the basis for filtering. If a filter is present, it will be respected.
     */
    Select.prototype.getInitialOptions = function () {
        var filter = this._activeFilter || "";
        var filtered = [];
        var initialOptions = this._initialOptions;
        for (var i = 0; i < initialOptions.length; i++) {
            var child = initialOptions[i];
            if (this._isOptGroup(child)) {
                // handle <optgroup>
                var optGroupClone = child.cloneNode(false);
                var found = false;
                for (var j = 0; j < child.children.length; j++) {
                    var optionClone = child.children[j].cloneNode(true);
                    // Append on match
                    if (this._containsWord(optionClone.innerHTML, filter)) {
                        optGroupClone.appendChild(optionClone);
                        found = true;
                    }
                }
                // Push if any matches found
                if (found) {
                    filtered.push(optGroupClone);
                }
            } else if (this._isOption(child)) {
                // handle <option>
                var optionClone = child.cloneNode(true);
                // Push on match
                if (this._containsWord(optionClone.innerHTML, filter)) {
                    filtered.push(optionClone);
                }
            }
        }
        return filtered;
    };
    /**
     * Returns true if a text contains a given keyword, e.g. in "ca" in "Car"
     */
    Select.prototype._containsWord = function (text, keyword) {
        return text.toLowerCase().indexOf(keyword.toLowerCase()) > -1;
    };
    Select.prototype._handleFocus = function () {
        var _this = this;
        this.open();
        this._openByFocus = true;
        setTimeout(function () {
            _this._openByFocus = false;
        }, TIMEOUT_BLUR);
    };
    Select.prototype._handleBlur = function () {
        this.close();
    };
    Select.prototype._handleClick = function (event) {
        var handled = false;
        if (this._lastHandledEvent === event) {
            this._lastHandledEvent = undefined;
            return;
        }
        if (this._isButtonTarget(event.target) && this._openByFocus === false) {
            // handle header item clicks and toggle dropdown
            this.toggle();
            handled = true;
        }
        var newItem = event.target;
        if (!handled && Dom.hasClass(newItem, CLASS_ITEM)) {
            // handle clicks on dropdown items
            this._selectedItemChanged(newItem, true, this._multiselection);
            handled = true;
        }
        if (handled) {
            this._lastHandledEvent = event;
            (0, _Utils.preventDefault)(event);
        }
    };
    Select.prototype._handleWindowClick = function (event) {
        if (this._isDropdownTarget(event.target) || this._isButtonTarget(event.target)) {
            return;
        }
        this.close();
    };
    Select.prototype._focusOptionStartingWith = function (keycode, startIndex, options) {
        for (var index = startIndex; index < options.length; index++) {
            var item = new _DomElement2.default(options[index]);
            var value = item.innerText.toLowerCase();
            if (index > options.length) {
                index = 0;
            }
            if (value.startsWith(Inputs.getKeyValue(keycode))) {
                var newOption = new _DomElement2.default(options[index]);
                if (!newOption.hasClass(CLASS_ITEM_DISABLED)) {
                    (0, _Utils.scrollIntoView)(options[index]);
                    newOption.addClass(CLASS_ITEM_FOCUSED);
                    return newOption;
                }
            }
        }
        return undefined;
    };
    Select.prototype._handleKeydown = function (event) {
        var evt = event || window.event;
        var keycode = event.which || event.keyCode;
        if (keycode === Inputs.KEY_ESCAPE) {
            // handle Escape key (ESC)
            if (this.isOpen()) {
                this.close();
            }
            evt.preventDefault();
            return;
        }
        if (keycode === Inputs.KEY_ARROW_UP || keycode === Inputs.KEY_ARROW_DOWN) {
            // Up and down arrows
            var options = this._wrapperElement.element.querySelectorAll("." + CLASS_ITEM);
            if (options.length > 0) {
                var newIndex = 0;
                var oldOption = void 0;
                var focusedElement = this._wrapperElement.find("." + CLASS_ITEM_FOCUSED);
                var searchFor = focusedElement ? CLASS_ITEM_FOCUSED : CLASS_ITEM_SELECTED;
                var newElement = void 0;
                for (var index = 0; index < options.length; index++) {
                    var direction = keycode === Inputs.KEY_ARROW_DOWN ? 1 : -1;
                    var item = new _DomElement2.default(options[index]);
                    // search for selected or focusedElement elements
                    if (item.hasClass(searchFor)) {
                        oldOption = item;
                        newIndex = index;
                        // get the next not disabled element in the appropriate direction
                        for (var count = 0; count < options.length; count++) {
                            newIndex += direction;
                            newIndex %= options.length;
                            if (newIndex < 0) {
                                newIndex = options.length - 1;
                            }
                            newElement = new _DomElement2.default(options[newIndex]);
                            if (!newElement.hasClass(CLASS_ITEM_DISABLED)) {
                                break;
                            }
                        }
                    }
                }
                // set the new element focused
                (0, _Utils.scrollIntoView)(options[newIndex]);
                var newOption = new _DomElement2.default(options[newIndex]);
                newOption.addClass(CLASS_ITEM_FOCUSED);
                if (oldOption) {
                    oldOption.removeClass(CLASS_ITEM_FOCUSED);
                }
            }
            evt.preventDefault();
            return;
        }
        if (Inputs.getKeyValue(keycode) && !this._isFilterable()) {
            // Keyboard keys
            var options = this._wrapperElement.element.querySelectorAll("." + CLASS_ITEM);
            if (options.length > 0) {
                var oldFocusIndex = 0;
                var hasFocusedOption = false;
                for (var index = 0; index < options.length; index++) {
                    var item = new _DomElement2.default(options[index]);
                    if (item.hasClass(CLASS_ITEM_FOCUSED)) {
                        item.removeClass(CLASS_ITEM_FOCUSED);
                        var value = item.innerText.toLowerCase();
                        if (value.startsWith(Inputs.getKeyValue(keycode))) {
                            hasFocusedOption = true;
                            oldFocusIndex = index;
                        }
                    }
                }
                var newOption = this._focusOptionStartingWith(keycode, hasFocusedOption ? oldFocusIndex + 1 : 0, options);
                if (newOption === undefined) {
                    this._focusOptionStartingWith(keycode, 0, options);
                }
            }
            evt.preventDefault();
            return;
        }
        if (keycode === Inputs.KEY_ENTER || keycode === Inputs.KEY_TAB) {
            // Handle enter and tab key by selecting the currently focused element
            var newItem = this._dropdownElement.element.querySelector("." + CLASS_ITEM_FOCUSED);
            this._selectedItemChanged(newItem, true, this._multiselection);
        }
    };
    /**
     * Fired when the user presses a key in the filter field
     */
    Select.prototype._handleFilterKeydown = function (e) {
        var keycode = e.which || e.keyCode;
        // If the user hits the enter key while filtering and there's a single match, select it
        if (keycode === Inputs.KEY_ENTER) {
            var dropdownElements = this._dropdownElement.element.querySelectorAll("." + CLASS_ITEM);
            if (dropdownElements.length === 1) {
                this._selectedItemChanged(dropdownElements[0], true, this._multiselection);
                e.stopPropagation();
            }
        }
    };
    /**
     * Fired when the user releases a key in the filter field
     */
    Select.prototype._handleFilterKeyup = function (e) {
        var target = e.target;
        // Filter has changed
        if (target.value !== this._activeFilter && target.value !== this._placeholderText && target.value !== this._lastSelectedOption.innerHTML) {
            this._setFilter(target.value);
        }
    };
    /**
     * Fired when the user focusses the filter input field
     */
    Select.prototype._handleFilterFocus = function (e) {
        var target = e.target;
        setTimeout(function () {
            target.select();
        });
    };
    /**
     * Filters the Select by a given filter keyword
     * @param filter Keyword to filter by
     */
    Select.prototype._setFilter = function (filter) {
        if (filter === void 0) {
            filter = "";
        }
        this._activeFilter = filter.length >= this._minFilterLength ? filter : "";
        this.setOptions(this.getInitialOptions());
    };
    /**
     * Resets the filter
     */
    Select.prototype._clearFilter = function () {
        delete this._activeFilter;
        this.setOptions(this.getInitialOptions());
    };
    /**
     * Set new content and reload the Select
     * @param elements Array of new option (or optgroup) elements to display
     */
    Select.prototype.setOptions = function (options) {
        var _this = this;
        this._emptyNode(this.element);
        options.forEach(function (option) {
            _this.element.appendChild(option);
        });
        // Preserve selected value if the selected
        this.element.value = this._lastSelectedOption.value;
        this.reload();
    };
    /**
     * Clear all children of a given node
     * @param node Node
     */
    Select.prototype._emptyNode = function (node) {
        while (node.firstChild) {
            node.removeChild(node.firstChild);
        }
    };
    /**
     * Returns whether an option is a placeholder option
     */
    Select.prototype._isPlaceholder = function (option) {
        return option.hasAttribute("disabled") && option.hasAttribute("selected");
    };
    /**
     * Update placeholder value
     * @param text Content of the placeholder
     */
    Select.prototype._setPlaceholder = function (text) {
        if (this._placeholderElement && text) {
            if (this._isFilterable()) {
                this._placeholderElement.element.value = text;
            } else {
                this._placeholderElement.setHtml(text);
            }
        }
    };
    Object.defineProperty(Select.prototype, "value", {
        /**
         * Gets the value of the currently selected option.
         * If multiple selection is enabled this property returns an array of values.
         */
        get: function get() {
            if (this._multiselection) {
                return this._getSelectedOptions().map(function (x) {
                    return x.value;
                });
            }
            if (this.element.value === "") {
                return null;
            }
            return this.element.value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Select.prototype, "disabled", {
        /**
         * Enables or disables the select component depending on the
         * 'value' parameter.
         * @param {value} If true disables the control; false enables it.
         */
        set: function set(value) {
            if (value) {
                this.disable();
            } else {
                this.enable();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Reloads the dropdown's option data definitions from the DOM and updates
     * the generated dropdown display items.
     */
    Select.prototype.reload = function () {
        // Remove all existing child elements
        this._emptyNode(this._dropdownElement.element);
        if (this._activeFilter === undefined) {
            // If the user is filtering, let the placeholder "input" alive
            this._setupPlaceholder();
        }
        this._createOptions(this.element);
        this._updateSize();
        this._updateMessage();
        if (!this._isFilterable()) {
            this._updatePlaceholder(!!this.value);
        }
    };
    /**
     * Sets the select control to the enabled state.
     */
    Select.prototype.enable = function () {
        this.element.removeAttribute("disabled");
        this._wrapperElement.removeClass(CLASS_DISABLED);
        window.addEventListener("click", this._windowClickHandler);
        this._wrapperElement.element.addEventListener("click", this._clickHandler);
        this._wrapperElement.element.addEventListener("keydown", this._keydownHandler);
        this._wrapperElement.element.addEventListener("focus", this._focusHandler);
        this._wrapperElement.element.addEventListener("blur", this._blurHandler);
    };
    /**
     * Sets the select control to the disabled state.
     */
    Select.prototype.disable = function () {
        this.element.setAttribute("disabled", "");
        this._wrapperElement.addClass(CLASS_DISABLED);
        window.removeEventListener("click", this._windowClickHandler);
        this._wrapperElement.element.removeEventListener("click", this._clickHandler);
        this._wrapperElement.element.removeEventListener("keydown", this._keydownHandler);
        this._wrapperElement.element.removeEventListener("focus", this._focusHandler);
        this._wrapperElement.element.removeEventListener("blur", this._blurHandler);
        this.close();
    };
    /**
     * Toggles the open/closed state of the select dropdown.
     */
    Select.prototype.toggle = function () {
        if (this.isOpen()) {
            this.close();
        } else {
            this.open();
        }
    };
    /**
     * Gets if the select dropdown is open or closed.
     * @return {boolean} True if open; otherwise false.
     */
    Select.prototype.isOpen = function () {
        return this._wrapperElement.hasClass(CLASS_OPEN);
    };
    /**
     * Opens the select dropdown.
     */
    Select.prototype.open = function () {
        if (!this.isOpen()) {
            this._openByFocus = false;
            this._wrapperElement.removeClass(CLASS_CLOSED);
            this._wrapperElement.addClass(CLASS_OPEN);
            this._dropdownElement.element.addEventListener("click", this._handleDropdownClick);
            this._dropdownElement.element.addEventListener("tap", this._handleDropdownClick);
        }
    };
    /**
     * Closes the select dropdown.
     */
    Select.prototype.close = function () {
        if (this.isOpen()) {
            this._openByFocus = false;
            this._wrapperElement.removeClass(CLASS_OPEN);
            this._wrapperElement.addClass(CLASS_CLOSED);
            // If the Select is filterable and therefore has an input field,
            // reset the value of it to the chosen option
            if (this._isFilterable()) {
                // Unfocus input field
                this._placeholderElement.element.blur();
                if (!this._activeFilter || this._activeFilter === this._lastSelectedOption.innerHTML) {
                    this._setPlaceholder(this._lastSelectedOption.innerHTML);
                }
            }
            this._dropdownElement.element.removeEventListener("click", this._handleDropdownClick);
            this._dropdownElement.element.removeEventListener("tap", this._handleDropdownClick);
            var focusedItem = this._wrapperElement.find("." + CLASS_ITEM_FOCUSED);
            if (focusedItem) {
                focusedItem.removeClass(CLASS_ITEM_FOCUSED);
            }
        }
    };
    /**
     * Returns true when the element has the filter modifier class
     */
    Select.prototype._isFilterable = function () {
        return this._wrapperElement.hasClass(CLASS_FILTERABLE);
    };
    /**
     * Destroys the component and clears all references.
     */
    Select.prototype.destroy = function () {
        window.removeEventListener("click", this._windowClickHandler);
        if (this._dropdownElement) {
            this._dropdownElement.element.removeEventListener("click", this._handleDropdownClick);
            this._dropdownElement.element.removeEventListener("tap", this._handleDropdownClick);
            (0, _Utils.remove)(this._dropdownElement.element);
            this._dropdownElement = undefined;
        }
        if (this._placeholderElement) {
            this._placeholderElement.removeEventListener("keydown", this._filterKeydownHandler);
            this._placeholderElement.removeEventListener("keyup", this._filterKeyupHandler);
            this._placeholderElement.removeEventListener("focus", this._filterFocusHandler);
        }
        if (this._wrapperElement) {
            this._wrapperElement.element.removeEventListener("click", this._clickHandler);
            this._wrapperElement.element.removeEventListener("keydown", this._keydownHandler);
            this._wrapperElement.element.removeEventListener("focus", this._focusHandler);
            this._wrapperElement.element.removeEventListener("blur", this._blurHandler);
            this._wrapperElement = undefined;
        }
        if (this._selectButtonElement) {
            (0, _Utils.remove)(this._selectButtonElement.element);
            this._selectButtonElement = undefined;
        }
        this.removeClass(CLASS_CLOSED);
    };
    return Select;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)("select", function (e) {
        new Select(e);
    });
}
exports.default = Select;

},{"../DomElement":5,"../DomFunctions":6,"../Inputs":7,"../Utils":8,"tslib":135}],21:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _maxSafeInteger = require("babel-runtime/core-js/number/max-safe-integer");

var _maxSafeInteger2 = _interopRequireDefault(_maxSafeInteger);

exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _DomFunctions = require("../DomFunctions");

var Dom = _interopRequireWildcard(_DomFunctions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var QUERY_TEXTAREA = "textarea";
var CLASS_HAS_VALUE = "is-fixed";
/**
 * Textarea component
 */
var Textarea = /** @class */function (_super) {
    tslib_1.__extends(Textarea, _super);
    function Textarea(element) {
        var _this = _super.call(this, element) || this;
        _this._area = _this.element.querySelector(QUERY_TEXTAREA);
        _this._focusChangedHandler = _this._focusChanged.bind(_this);
        _this._valueChangedHandler = _this._onValueChanged.bind(_this);
        _this._resizeHandler = _this._updateHeight.bind(_this);
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the textarea component.
     * @private
     */
    Textarea.prototype._initialize = function () {
        this._minRows = parseInt(this._area.getAttribute("data-min-rows") || "3", 10);
        this._maxRows = parseInt(this._area.getAttribute("data-max-rows"), 10) || _maxSafeInteger2.default;
        // Make sure min an max are property specified
        this._minRows = Math.min(this._minRows, this._maxRows);
        this._maxRows = Math.max(this._minRows, this._maxRows);
        this._lineHeight = parseInt(Dom.css(this._area, "line-height"), 10);
        this._updateBaseHeight = Dom.isHidden(this._area, true);
        this._calculateBaseHeight();
        // add event listeners
        this._area.addEventListener("focus", this._focusChangedHandler);
        this._area.addEventListener("blur", this._focusChangedHandler);
        this._area.addEventListener("input", this._valueChangedHandler);
        window.addEventListener("resize", this._resizeHandler);
        window.addEventListener("orientationchange", this._resizeHandler);
        this._onValueChanged();
    };
    Textarea.prototype._calculateBaseHeight = function () {
        // temporary clear the content to take measurements
        var value = this._area.value;
        this._area.value = "";
        this._baseHeight = this._area.offsetHeight - this._lineHeight;
        this._baseScrollHeight = this._area.scrollHeight - this._lineHeight;
        // restore initial content
        this._area.value = value;
    };
    Textarea.prototype._focusChanged = function () {
        this._updateHeight();
    };
    Textarea.prototype._updateHeight = function () {
        var hasFocus = this._area === document.activeElement;
        var maxRows,
            rows = 0;
        if (this._updateBaseHeight === true && Dom.isHidden(this._area, true) === false) {
            this._calculateBaseHeight();
            this._updateBaseHeight = false;
        }
        // Calculate the apropriate size for the control
        if (!this._hasValue()) {
            // Handle empty states
            rows = hasFocus === true ? this._minRows : 1;
            maxRows = rows;
        } else {
            // Reset the height for calculation of the row count
            this._area.style.height = "auto";
            // Get the new height
            rows = Math.ceil((this._area.scrollHeight - this._baseScrollHeight) / this._lineHeight) + 1;
            maxRows = Math.max(Math.min(this._maxRows, rows), this._minRows);
        }
        if (rows > this._maxRows) {
            this._area.style.overflow = "auto";
        } else {
            this._area.style.overflow = "hidden";
        }
        var height = (maxRows - 1) * this._lineHeight + this._baseHeight;
        this._area.style.height = height + "px";
    };
    Textarea.prototype._hasValue = function () {
        return this._area.value && this._area.value.length > 0;
    };
    Textarea.prototype._onValueChanged = function () {
        if (this._hasValue()) {
            Dom.addClass(this._area, CLASS_HAS_VALUE);
        } else {
            Dom.removeClass(this._area, CLASS_HAS_VALUE);
            this._area.value = "";
        }
        this._updateHeight();
    };
    /**
     * Destroys the component and clears all references.
     */
    Textarea.prototype.destroy = function () {
        window.removeEventListener("resize", this._resizeHandler);
        window.removeEventListener("orientationchange", this._resizeHandler);
        this._area.removeEventListener("focus", this._focusChangedHandler);
        this._area.removeEventListener("blur", this._focusChangedHandler);
        this._area.removeEventListener("input", this._valueChangedHandler);
        this._focusChangedHandler = null;
        this._valueChangedHander = null;
        this._area = null;
        this._minRows = null;
        this._maxRows = null;
        this._lineHeight = null;
        this._baseHeight = null;
        this._baseScrollHeight = null;
        this.element = null;
    };
    return Textarea;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".input-multiline, .input-field--multiline", function (e) {
        new Textarea(e);
    });
}
exports.default = Textarea;

},{"../DomElement":5,"../DomFunctions":6,"../Utils":8,"babel-runtime/core-js/number/max-safe-integer":40,"tslib":135}],22:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Loader bar component
 */
var LoaderBar = /** @class */function (_super) {
    tslib_1.__extends(LoaderBar, _super);
    /**
     * Creates and initializes the LoaderBar component.
     * @param {Element} - The root element of the LoaderBar component.
     */
    function LoaderBar(element) {
        var _this = _super.call(this, element) || this;
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the loader bar component.
     * @private
     */
    LoaderBar.prototype._initialize = function () {
        this.progressElement = this.find(".indicator") || this;
        this.fileNameElement = this.find(".detail > .name");
        this.progressLabelElement = this.find(".progress");
        this.totalProgressElement = this.find(".progress > .file-size");
    };
    Object.defineProperty(LoaderBar.prototype, "progress", {
        /**
         * Gets the current progress value in the range of 0..1.
         */
        get: function get() {
            return this.value;
        },
        /**
         * Sets the current progress.
         * @param {number} - The progress in the range of 0..1.
         */
        set: function set(val) {
            // val = clamp(val, 0, 1)
            var percentage = (val * 100).toFixed(0);
            this.value = val;
            this.element.value = String(val);
            this.progressElement.setAttribute("style", "width: " + val * 100 + "%");
            if (this.progressLabelElement) {
                this.progressLabelElement.element.textContent = percentage + "%";
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LoaderBar.prototype, "filename", {
        /**
         * Gets the filename.
         * @returns {string} - The filename.
         */
        get: function get() {
            if (!this.fileNameElement) {
                return undefined;
            }
            return this.fileNameElement.element.innerHTML;
        },
        /**
         * Sets the filename.
         */
        set: function set(val) {
            if (!this.fileNameElement) {
                throw new Error("Cannot set the filename, missing detail element");
            }
            this.fileNameElement.setHtml(val || "");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LoaderBar.prototype, "fileSize", {
        /**
         * Sets the file size label.
         */
        set: function set(val) {
            if (!this.totalProgressElement) {
                throw new Error("Cannot set the fileSize, missing detail element");
            }
            this.totalProgressElement.setHtml(val);
        },
        enumerable: true,
        configurable: true
    });
    return LoaderBar;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".loader-bar", function (e) {
        new LoaderBar(e);
    });
}
exports.default = LoaderBar;

},{"../DomElement":5,"../Utils":8,"tslib":135}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

var _popper = require("popper.js");

var _popper2 = _interopRequireDefault(_popper);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _DomFunctions = require("../DomFunctions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var CLASS_OPEN = "is-open";
var CLASS_MENU = "js-flyout";
var CLASS_TABS = "tabs";
var ANIMATION_OPEN = 300;
var EASE_INQUAD_OUT_QUINT = [0.550, 0.085, 0.320, 1];
/**
 * A component for the flyout menu.
 */
var MenuFlyout = /** @class */function (_super) {
    tslib_1.__extends(MenuFlyout, _super);
    /**
     * Creates and initializes the flyout component.
     * @param element - The root element of the flyout menu component.
     */
    function MenuFlyout(element) {
        var _this = _super.call(this, element) || this;
        _this._animationDuration = ANIMATION_OPEN;
        _this._dynamicPlacement = false;
        _this._clickHandler = _this._handleClick.bind(_this);
        _this._windowClickHandler = _this._handleWindowClick.bind(_this);
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the flyout component.
     * @private
     */
    MenuFlyout.prototype._initialize = function () {
        var dataTarget = this.element.getAttribute("data-target");
        if (dataTarget === null || dataTarget === "") {
            /* tslint:disable:no-console */
            console.error("A flyout menu element requires a 'data-target' that specifies the element to collapse");
            console.info(this.element);
            /* tslint:enable:no-console */
            return;
        }
        if (this._useDynamicPlacement()) {
            this._dynamicPlacement = true;
        }
        var hiddenTarget = this.element.getAttribute("data-hidden");
        if (hiddenTarget !== null && hiddenTarget !== "") {
            this._hiddenIndicator = document.querySelector(hiddenTarget) || undefined;
        }
        this._initFlyoutElement(dataTarget);
        this.element.addEventListener("click", this._clickHandler);
    };
    MenuFlyout.prototype._initFlyoutElement = function (dataTarget) {
        this._flyoutElement = document.querySelector(dataTarget);
        this._flyoutElement.style.opacity = "0";
        this._flyoutElement.style.transform = "translateY(-20px)";
    };
    MenuFlyout.prototype._handleClick = function () {
        this.toggle();
    };
    MenuFlyout.prototype._handleWindowClick = function (event) {
        var target = event.target;
        if ((0, _DomFunctions.parentWithClass)(target, CLASS_MENU) === this._flyoutElement) {
            return false;
        }
        while (target !== this.element && target.parentElement) {
            target = target.parentElement;
        }
        if (target !== this.element) {
            this.close();
            return false;
        }
        return true;
    };
    MenuFlyout.prototype._useDynamicPlacement = function () {
        return (0, _DomFunctions.parentWithClass)(this.element, CLASS_TABS);
    };
    MenuFlyout.prototype._openMenu = function (el) {
        _animejs2.default.remove(el);
        if (this._dynamicPlacement === true) {
            var popperOptions = {
                placement: "bottom",
                modifiers: {
                    flip: {
                        enabled: false
                    }
                },
                eventsEnabled: false
            };
            this._popperInstance = new _popper2.default(this.element, this._flyoutElement, popperOptions);
        }
        (0, _animejs2.default)({
            targets: el,
            duration: this._animationDuration,
            easing: EASE_INQUAD_OUT_QUINT,
            opacity: 1,
            translateY: "0px",
            begin: function begin() {
                el.style.display = "block";
            },
            complete: function complete() {
                (0, _DomFunctions.addClass)(el, CLASS_OPEN);
            }
        });
        // set aria expanded
        el.setAttribute("aria-expanded", "true");
        this.dispatchEvent("opened");
    };
    MenuFlyout.prototype._closeMenu = function (el) {
        _animejs2.default.remove(el);
        if (this._popperInstance) {
            this._popperInstance.destroy();
            this._popperInstance = undefined;
        }
        (0, _animejs2.default)({
            targets: el,
            duration: this._animationDuration,
            easing: EASE_INQUAD_OUT_QUINT,
            opacity: 0,
            translateY: "-20px",
            complete: function complete() {
                el.style.display = "none";
                (0, _DomFunctions.removeClass)(el, CLASS_OPEN);
            }
        });
        // set aria expanded
        el.setAttribute("aria-expanded", "false");
        this.dispatchEvent("closed");
    };
    Object.defineProperty(MenuFlyout.prototype, "animationDuration", {
        /**
         * Sets the opening animation duration.
         * @param {durationInSeconds} - The animation duration in seconds.
         */
        set: function set(durationInSeconds) {
            this._animationDuration = durationInSeconds;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Opens the flyout menu.
     * @fires Modal#opened
     */
    MenuFlyout.prototype.open = function () {
        var _this = this;
        if (this._hiddenIndicator && (0, _DomFunctions.isHidden)(this._hiddenIndicator, false) === true) {
            return;
        }
        if ((0, _DomFunctions.hasClass)(this.element, CLASS_OPEN) === true) {
            return;
        }
        (0, _DomFunctions.addClass)(this.element, CLASS_OPEN);
        this._openMenu(this._flyoutElement);
        setTimeout(function () {
            window.addEventListener("click", _this._windowClickHandler);
            window.addEventListener("touchend", _this._windowClickHandler);
        }, 50);
    };
    /**
     * Closes the flyout menu.
     * @fires Modal#closed
     */
    MenuFlyout.prototype.close = function () {
        if (this._hiddenIndicator && (0, _DomFunctions.isHidden)(this._hiddenIndicator, false) === true) {
            return;
        }
        if ((0, _DomFunctions.hasClass)(this.element, CLASS_OPEN) === false) {
            return;
        }
        (0, _DomFunctions.removeClass)(this.element, CLASS_OPEN);
        window.removeEventListener("click", this._windowClickHandler);
        window.removeEventListener("touchend", this._windowClickHandler);
        this._closeMenu(this._flyoutElement);
    };
    /**
     * Toggles the flyout menu.
     * @fires Modal#opened
     * @fires Modal#closed
     */
    MenuFlyout.prototype.toggle = function () {
        if ((0, _DomFunctions.hasClass)(this.element, CLASS_OPEN) === false) {
            this.open();
        } else {
            this.close();
        }
    };
    /**
     * Removes all event handlers and clears references.
     */
    MenuFlyout.prototype.destroy = function () {
        this._flyoutElement = null;
        window.removeEventListener("click", this._windowClickHandler);
        window.removeEventListener("touchend", this._windowClickHandler);
        if (this._clickHandler) {
            this.element.removeEventListener("click", this._clickHandler);
        }
        if (this._popperInstance) {
            this._popperInstance.destroy();
            this._popperInstance = undefined;
        }
        this._clickHandler = null;
        this._windowClickHandler = null;
        this.element = null;
    };
    return MenuFlyout;
}(_DomElement2.default);
function init() {
    var e_1, _a;
    var elements = document.querySelectorAll("[data-toggle='flyout']");
    try {
        for (var elements_1 = tslib_1.__values(elements), elements_1_1 = elements_1.next(); !elements_1_1.done; elements_1_1 = elements_1.next()) {
            var e = elements_1_1.value;
            if (e.getAttribute("data-init") === "auto") {
                new MenuFlyout(e);
            }
        }
    } catch (e_1_1) {
        e_1 = { error: e_1_1 };
    } finally {
        try {
            if (elements_1_1 && !elements_1_1.done && (_a = elements_1.return)) _a.call(elements_1);
        } finally {
            if (e_1) throw e_1.error;
        }
    }
}
exports.default = MenuFlyout;

},{"../DomElement":5,"../DomFunctions":6,"animejs":35,"popper.js":134,"tslib":135}],24:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _bodyScrollLock = require("body-scroll-lock");

var _Utils = require("../Utils");

var _Inputs = require("../Inputs");

var Inputs = _interopRequireWildcard(_Inputs);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _DomFunctions = require("../DomFunctions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var CLASS_BACKDROP = "backdrop";
var CLASS_BACKDROP_OPEN = "backdrop--open";
var CLASS_OPEN = "modal--open";
var CLASS_TRIGGER = "modal-trigger";
var CLASS_BODY = "modal__body";
var CLASS_BUTTONS_OKAY = ".modal-close";
var CLASS_BUTTONS_CLOSE = ".modal-cancel";
/**
 * A component to open and close modal dialogs. It also handles cancellation and makes
 * sure that the modal background is present in the DOM.
 */
var Modal = /** @class */function (_super) {
    tslib_1.__extends(Modal, _super);
    function Modal(element) {
        var _this = _super.call(this, element) || this;
        _this._okayHandler = _this.close.bind(_this);
        _this._cancelHandler = _this._handleClick.bind(_this);
        _this._keydownHandler = _this._handleKeydown.bind(_this);
        _this._initialize();

        // track class instances
        if (this.constructor.instances === undefined) {
          this.constructor.instances = [this];
        } else {
          this.constructor.instances.push(this);
        }

        return _this;
    }
    /**
     * Initializes the range modal component.
     * @private
     */
    Modal.prototype._initialize = function () {
        // Create the backdrop
        this._backdrop = new _DomElement2.default("div").addClass(CLASS_BACKDROP);
        this._backdropParent = (0, _DomFunctions.getRootElement)();
        this._subscribeToTrigger();


    };
    Modal.prototype._subscribeToTrigger = function () {
        var e_1, _a;
        var triggerId = this.element.id;
        if (!triggerId) {
            return;
        }
        this._triggerClickHandler = this.open.bind(this);
        var triggerElements = document.querySelectorAll("." + CLASS_TRIGGER + "[href=" + triggerId + "]");
        try {
            for (var triggerElements_1 = tslib_1.__values(triggerElements), triggerElements_1_1 = triggerElements_1.next(); !triggerElements_1_1.done; triggerElements_1_1 = triggerElements_1.next()) {
                var triggerElement = triggerElements_1_1.value;
                triggerElement.addEventListener("click", this._triggerClickHandler);
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (triggerElements_1_1 && !triggerElements_1_1.done && (_a = triggerElements_1.return)) _a.call(triggerElements_1);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
    };
    Modal.prototype._unsubscribeFromTrigger = function () {
        var e_2, _a;
        var triggerId = this.element.id;
        if (!triggerId) {
            return;
        }
        var triggerElements = document.querySelectorAll("." + CLASS_TRIGGER + "[href=" + triggerId + "]");
        try {
            for (var triggerElements_2 = tslib_1.__values(triggerElements), triggerElements_2_1 = triggerElements_2.next(); !triggerElements_2_1.done; triggerElements_2_1 = triggerElements_2.next()) {
                var triggerElement = triggerElements_2_1.value;
                triggerElement.removeEventListener("click", this._windowClickHandler);
            }
        } catch (e_2_1) {
            e_2 = { error: e_2_1 };
        } finally {
            try {
                if (triggerElements_2_1 && !triggerElements_2_1.done && (_a = triggerElements_2.return)) _a.call(triggerElements_2);
            } finally {
                if (e_2) throw e_2.error;
            }
        }
        this._triggerClickHandler = undefined;
    };
    Modal.prototype._handleKeydown = function (event) {
        var keycode = event.which || event.keyCode;
        if (keycode === Inputs.KEY_ESCAPE) {
            // handle Escape key (ESC)
            this.cancel();
            return;
        }
    };
    Modal.prototype._handleClick = function (event) {
        (0, _Utils.preventDefault)(event);
        this.cancel();
    };
    Modal.prototype._close = function () {
        var _this = this;
        var e_3, _a, e_4, _b;
        (0, _bodyScrollLock.enableBodyScroll)(this.element);
        document.removeEventListener("keydown", this._keydownHandler);
        this._backdrop.element.removeEventListener("click", this._cancelHandler);
        this._backdrop.removeClass(CLASS_BACKDROP_OPEN);
        this.removeClass(CLASS_OPEN);
        try {
            for (var _c = tslib_1.__values(this.element.querySelectorAll(CLASS_BUTTONS_CLOSE)), _d = _c.next(); !_d.done; _d = _c.next()) {
                var closeButton = _d.value;
                closeButton.removeEventListener("click", this._cancelHandler);
            }
        } catch (e_3_1) {
            e_3 = { error: e_3_1 };
        } finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            } finally {
                if (e_3) throw e_3.error;
            }
        }
        try {
            for (var _e = tslib_1.__values(this.element.querySelectorAll(CLASS_BUTTONS_OKAY)), _f = _e.next(); !_f.done; _f = _e.next()) {
                var okayButton = _f.value;
                okayButton.removeEventListener("click", this._okayHandler);
            }
        } catch (e_4_1) {
            e_4 = { error: e_4_1 };
        } finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            } finally {
                if (e_4) throw e_4.error;
            }
        }
        setTimeout(function () {
            // remove the backdrop from the body
            _this._backdropParent.removeChild(_this._backdrop.element);
        }, 300);
    };
    /**
     * Opens the modal dialog.
     * @fires Modal#opened
     */
    Modal.prototype.open = function () {
        var _this = this;
        (0, _bodyScrollLock.disableBodyScroll)(this.element, {
            allowTouchMove: function allowTouchMove(el) {
                var currentEl = el;
                while (currentEl && currentEl !== document.body) {
                    // Check if the user is scrolling the modal body
                    if (currentEl.classList.contains(CLASS_BODY)) {
                        // Check if the element overflows
                        if (currentEl.scrollHeight > currentEl.clientHeight) {
                            return true;
                        }
                    }
                    currentEl = currentEl.parentNode;
                }
                return false;
            }
        });
        // add the backdrop to the body
        this._backdropParent.appendChild(this._backdrop.element);
        // set the element to flex as it is initially hidden
        this.element.style.display = "flex";
        // remove the style after the animation completes
        setTimeout(function () {
            _this.element.style.display = "";
        }, 800);
        // wait a bit to allow the browser to catch up and show the animation
        setTimeout(function () {
            var e_5, _a, e_6, _b;
            _this.addClass(CLASS_OPEN);
            _this._backdrop.addClass(CLASS_BACKDROP_OPEN);
            document.addEventListener("keydown", _this._keydownHandler);
            _this._backdrop.element.addEventListener("click", _this._cancelHandler);
            try {
                for (var _c = tslib_1.__values(_this.element.querySelectorAll(CLASS_BUTTONS_CLOSE)), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var closeButton = _d.value;
                    closeButton.addEventListener("click", _this._cancelHandler);
                }
            } catch (e_5_1) {
                e_5 = { error: e_5_1 };
            } finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                } finally {
                    if (e_5) throw e_5.error;
                }
            }
            try {
                for (var _e = tslib_1.__values(_this.element.querySelectorAll(CLASS_BUTTONS_OKAY)), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var okayButton = _f.value;
                    okayButton.addEventListener("click", _this._okayHandler);
                }
            } catch (e_6_1) {
                e_6 = { error: e_6_1 };
            } finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                } finally {
                    if (e_6) throw e_6.error;
                }
            }
            _this.dispatchEvent("opened");
        }, 50);
    };
    /**
     * Cancels (and closes) the modal dialog.
     * @fires Modal#cancelled
     * @fires Modal#closed
     */
    Modal.prototype.cancel = function () {
        this.dispatchEvent("cancelled");
        this._close();
    };
    /**
     * Closes the modal dialog.
     * @fires Modal#closed
     */
    Modal.prototype.close = function () {
        this._close();
        this.dispatchEvent("closed");
    };
    /**
     * Destroys the component and frees all references.
     */
    Modal.prototype.destroy = function () {
        this.cancel();
        this._unsubscribeFromTrigger();
    };
    return Modal;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".modal", function (e) {
        new Modal(e);
    });
}
exports.default = Modal;

},{"../DomElement":5,"../DomFunctions":6,"../Inputs":7,"../Utils":8,"body-scroll-lock":45,"tslib":135}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

var _Utils = require("../Utils");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _DomFunctions = require("../DomFunctions");

var Dom = _interopRequireWildcard(_DomFunctions);

var _SearchInput = require("../search/SearchInput");

var _SearchInput2 = _interopRequireDefault(_SearchInput);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var CLASS_OPEN = "is-open";
var CLASS_ACTIVE = "is-active";
var QUERY_NAV_HAMBURGER = ".nav-hamburger";
var QUERY_NAV_HB_BODY = ".nav__primary";
var CLASS_NAV_LINK = "nav-link--header";
var QUERY_NAV_LINK_ACTIVE = ".nav-link--header.is-active";
var QUERY_NAV_MOBILE = ".nav__level1 .nav__mainnav .nav__primary";
var QUERY_NAV_LEVEL0 = ".nav__level0";
var QUERY_NAV_LEVEL0_CONTAINER = ".nav__level0 .nav__subnav";
var QUERY_SECTION_OPEN = ".nav-section.is-open";
var QUERY_NAV_LEVEL1 = ".nav__level1 .nav__mainnav";
var QUERY_NAV_LEVEL0_LINK = ".nav-link.nav-link--header";
var QUERY_NAV_LEVEL1_LINK = ".nav-link--header";
var QUERY_NAV_COLUMN = ".nav-col";
var QUERY_NAV_COLUMN_ACTIVE = ".nav-col.is-active";
var QUERY_NAV_BODY = ".nav-body";
var QUERY_NAV_FOOTER = ".nav-footer";
var QUERY_SEARCH_ICON = ".nav-search";
var QUERY_SEARCH_FIELD = ".search__input";
var CLASS_SEARCH_DESKTOP = "search--desktop";
var ANIMATION_START_DELAY = 200;
var ANIMATION_OFFSET = 50;
var ANIMATION_BODY_DURATION = 300;
var ANIMATION_FOOTER_DURATION = 100;
/**
 * The navigation component definition.
 */
var Navigation = /** @class */function (_super) {
    tslib_1.__extends(Navigation, _super);
    function Navigation(element) {
        var _this = _super.call(this, element) || this;
        _this.animation = _animejs2.default.timeline();
        _this.easing = {
            // Equivalent to gsap's [ Power1.easeIn, Power4.easeOut ]
            inQuadOutQuint: [0.550, 0.085, 0.320, 1]
        };
        _this._navLevel0 = _this.element.querySelector(QUERY_NAV_LEVEL0) || document.createElement("div");
        _this._navLevel0Body = _this.element.querySelector(QUERY_NAV_LEVEL0_CONTAINER) || document.createElement("div");
        _this._navLevel1 = _this.element.querySelector(QUERY_NAV_LEVEL1) || document.createElement("div");
        _this._navMobile = _this.element.querySelector(QUERY_NAV_MOBILE) || document.createElement("div");
        if (!_this._navMobile.parentElement) {
            var dummyParent = document.createElement("div");
            dummyParent.appendChild(_this._navMobile);
        }
        _this._hamburgerElement = _this.element.querySelector(QUERY_NAV_HAMBURGER) || document.createElement("div");
        _this._searchComponents = [];
        _this._level0ClickHandler = _this._handleLevel0Click.bind(_this);
        _this._level1ClickHandler = _this._handleLevel1Click.bind(_this);
        _this._windowClickHandler = _this._handleWindowClick.bind(_this);
        _this._searchClickHandler = _this._handleSearchClick.bind(_this);
        _this._initialize();
        return _this;
    }
    Navigation.prototype._resetMainTimeline = function () {
        var elements = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            elements[_i] = arguments[_i];
        }
        var e_1, _a;
        this.animation.pause();
        try {
            for (var elements_1 = tslib_1.__values(elements), elements_1_1 = elements_1.next(); !elements_1_1.done; elements_1_1 = elements_1.next()) {
                var el = elements_1_1.value;
                _animejs2.default.remove(el);
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (elements_1_1 && !elements_1_1.done && (_a = elements_1.return)) _a.call(elements_1);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
        this.animation = _animejs2.default.timeline();
    };
    Navigation.prototype._isMobile = function () {
        return Dom.isHidden(this._hamburgerElement, true) === false;
    };
    Navigation.prototype._handleLevel0Click = function (event) {
        var isDesktop = !this._isMobile();
        if (isDesktop) {
            var navItems = new NavigationItems(this).fromLevel0(event.target);
            if (!navItems.section) {
                return;
            }
            var previousNavLink = this._navLevel0.querySelector(QUERY_NAV_LINK_ACTIVE);
            var previousNavSection = this._navLevel0.querySelector(QUERY_SECTION_OPEN);
            this._toggleContainer(navItems.link, this._navLevel0Body, navItems.section, undefined, previousNavLink, this._navLevel0Body, previousNavSection, undefined, true);
        }
    };
    Navigation.prototype._handleLevel1Click = function (event) {
        var navItems = new NavigationItems(this).fromLevel1(event.target);
        var prevItems = navItems.previousLevel1();
        this._toggleContainer(navItems.link, navItems.container, navItems.section, navItems.footer, prevItems.link, prevItems.container, prevItems.section, prevItems.footer, false);
        return false;
    };
    Navigation.prototype._toggleContainer = function (navLink, navContainer, navSection, navFooter, previousNavLink, previousNavContainer, previousNavSection, previousNavFooter, animateContainer) {
        if (animateContainer === void 0) {
            animateContainer = false;
        }
        var isDesktop = !this._isMobile();
        if (previousNavLink && previousNavLink !== navLink && navLink !== this._hamburgerElement) {
            Dom.removeClass(previousNavLink, CLASS_ACTIVE);
        }
        this._resetMainTimeline(navContainer, navSection, navFooter, previousNavContainer, previousNavSection, previousNavFooter);
        if (Dom.hasClass(navLink, CLASS_ACTIVE)) {
            Dom.removeClass(navLink, CLASS_ACTIVE);
            if (isDesktop) {
                this._onNavigationClosed();
                this._closeSection(navContainer, navSection, navFooter, true, animateContainer);
            } else if (navLink === this._hamburgerElement) {
                // Close mobile navigation
                this._onNavigationClosed();
                this._closeSection(navContainer, navSection, undefined, false, false);
            } else if (!isDesktop) {
                // Close the section
                this._closeSection(navContainer, navSection, navFooter, true, animateContainer);
            }
        } else {
            Dom.addClass(navLink, CLASS_ACTIVE);
            if (isDesktop) {
                Dom.addClass(this._navMobile, CLASS_OPEN);
                this._onNavigationOpened();
                if (previousNavContainer && previousNavSection) {
                    this._closeSection(previousNavContainer, previousNavSection, previousNavFooter, true, animateContainer);
                }
                this._openSection(navContainer, navSection, navFooter, true, animateContainer);
            } else if (navLink === this._hamburgerElement) {
                // Open mobile navigation
                this._onNavigationOpened();
                this._openSection(navContainer, navSection, undefined, false, false);
            } else if (!isDesktop) {
                // Open section
                if (previousNavContainer && previousNavSection) {
                    this._closeSection(previousNavContainer, previousNavSection, previousNavFooter, true, animateContainer);
                    this.animation = _animejs2.default.timeline();
                }
                this._openSection(navContainer, navSection, navFooter, true, animateContainer);
            }
        }
    };
    Navigation.prototype._onNavigationOpened = function () {
        Dom.addClass(this._navMobile, CLASS_OPEN);
        Dom.addClass(this._navMobile.parentElement, CLASS_OPEN);
        Dom.addClass(this._hamburgerElement, CLASS_ACTIVE);
        window.addEventListener("click", this._windowClickHandler);
        window.addEventListener("touchend", this._windowClickHandler);
    };
    Navigation.prototype._onNavigationClosed = function () {
        Dom.removeClass(this._navMobile, CLASS_OPEN);
        Dom.removeClass(this._navMobile.parentElement, CLASS_OPEN);
        Dom.removeClass(this._hamburgerElement, CLASS_ACTIVE);
        window.removeEventListener("click", this._windowClickHandler);
        window.removeEventListener("touchend", this._windowClickHandler);
    };
    Navigation.prototype._handleWindowClick = function (event) {
        var target = event.target;
        while (target !== this.element && target.parentElement) {
            target = target.parentElement;
        }
        if (target !== this.element) {
            this.close();
            return false;
        }
        return true;
    };
    Navigation.prototype._openSection = function (navContainer, navSection, navFooter, animateColumns, animateContainer) {
        if (animateColumns === void 0) {
            animateColumns = true;
        }
        if (animateContainer === void 0) {
            animateContainer = false;
        }
        var e_2, _a, e_3, _b;
        if (!navSection || !navContainer) {
            return;
        }
        var activeItems = navSection.querySelectorAll(QUERY_NAV_COLUMN);
        if (animateContainer === true) {
            var container = navContainer;
            navContainer = navSection;
            navSection = container;
        }
        Dom.addClass(navContainer, CLASS_OPEN);
        navSection.style.display = "block";
        this.animation.add({
            targets: navSection,
            duration: ANIMATION_BODY_DURATION,
            easing: this.easing.inQuadOutQuint,
            height: animateContainer ? navContainer.scrollHeight : navSection.scrollHeight,
            complete: function complete() {
                Dom.addClass(navSection, CLASS_OPEN);
                new _DomElement2.default(navSection).setAttribute("style", "");
            }
        });
        if (navFooter) {
            var navItems = navFooter.querySelectorAll(QUERY_NAV_COLUMN);
            try {
                for (var navItems_1 = tslib_1.__values(navItems), navItems_1_1 = navItems_1.next(); !navItems_1_1.done; navItems_1_1 = navItems_1.next()) {
                    var item = navItems_1_1.value;
                    Dom.addClass(item, CLASS_ACTIVE);
                }
            } catch (e_2_1) {
                e_2 = { error: e_2_1 };
            } finally {
                try {
                    if (navItems_1_1 && !navItems_1_1.done && (_a = navItems_1.return)) _a.call(navItems_1);
                } finally {
                    if (e_2) throw e_2.error;
                }
            }
            navFooter.style.display = "block";
            this.animation.add({
                targets: navFooter,
                duration: ANIMATION_FOOTER_DURATION,
                easing: this.easing.inQuadOutQuint,
                height: navFooter.scrollHeight,
                offset: "-=" + ANIMATION_FOOTER_DURATION,
                complete: function complete() {
                    Dom.addClass(navFooter, CLASS_OPEN);
                    new _DomElement2.default(navFooter).setAttribute("style", "");
                }
            });
        }
        if (animateColumns === true) {
            var delay = ANIMATION_START_DELAY;
            var _loop_1 = function _loop_1(item) {
                this_1.animation.add({
                    targets: item,
                    duration: 0,
                    offset: delay,
                    complete: function complete() {
                        Dom.addClass(item, CLASS_ACTIVE);
                    }
                });
                delay += ANIMATION_OFFSET;
            };
            var this_1 = this;
            try {
                for (var activeItems_1 = tslib_1.__values(activeItems), activeItems_1_1 = activeItems_1.next(); !activeItems_1_1.done; activeItems_1_1 = activeItems_1.next()) {
                    var item = activeItems_1_1.value;
                    _loop_1(item);
                }
            } catch (e_3_1) {
                e_3 = { error: e_3_1 };
            } finally {
                try {
                    if (activeItems_1_1 && !activeItems_1_1.done && (_b = activeItems_1.return)) _b.call(activeItems_1);
                } finally {
                    if (e_3) throw e_3.error;
                }
            }
        }
    };
    Navigation.prototype._closeSection = function (navContainer, navSection, navFooter, animateColumns, animateContainer) {
        if (animateColumns === void 0) {
            animateColumns = true;
        }
        if (animateContainer === void 0) {
            animateContainer = false;
        }
        var e_4, _a, e_5, _b;
        if (!navSection || !navContainer) {
            return;
        }
        var activeItems = navSection.querySelectorAll(QUERY_NAV_COLUMN_ACTIVE);
        if (animateContainer === true) {
            var container = navContainer;
            navContainer = navSection;
            navSection = container;
        }
        if (animateColumns === true) {
            try {
                for (var activeItems_2 = tslib_1.__values(activeItems), activeItems_2_1 = activeItems_2.next(); !activeItems_2_1.done; activeItems_2_1 = activeItems_2.next()) {
                    var active = activeItems_2_1.value;
                    Dom.removeClass(active, CLASS_ACTIVE);
                }
            } catch (e_4_1) {
                e_4 = { error: e_4_1 };
            } finally {
                try {
                    if (activeItems_2_1 && !activeItems_2_1.done && (_a = activeItems_2.return)) _a.call(activeItems_2);
                } finally {
                    if (e_4) throw e_4.error;
                }
            }
        }
        this.animation.add({
            targets: navSection,
            duration: ANIMATION_BODY_DURATION,
            easing: this.easing.inQuadOutQuint,
            height: 0,
            offset: 0,
            complete: function complete() {
                Dom.removeClass(navContainer, CLASS_OPEN);
                Dom.removeClass(navSection, CLASS_OPEN);
                navSection.style.height = null;
            }
        });
        if (navFooter) {
            try {
                for (var _c = tslib_1.__values(navFooter.querySelectorAll(QUERY_NAV_COLUMN_ACTIVE)), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var active = _d.value;
                    Dom.removeClass(active, CLASS_ACTIVE);
                }
            } catch (e_5_1) {
                e_5 = { error: e_5_1 };
            } finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                } finally {
                    if (e_5) throw e_5.error;
                }
            }
            this.animation.add({
                targets: navFooter,
                duration: ANIMATION_FOOTER_DURATION,
                easing: this.easing.inQuadOutQuint,
                height: 0,
                offset: 0,
                complete: function complete() {
                    Dom.removeClass(navFooter, CLASS_OPEN);
                    navFooter.style.height = null;
                }
            });
        }
    };
    Navigation.prototype._handleSearchClick = function () {
        if (this._searchDesktop) {
            this._searchDesktop.open();
        }
    };
    /**
     * Initializes the navigation component.
     * @private
     */
    Navigation.prototype._initialize = function () {
        var e_6, _a, e_7, _b, e_8, _c;
        try {
            for (var _d = tslib_1.__values(this._navLevel0.querySelectorAll(QUERY_NAV_LEVEL0_LINK)), _e = _d.next(); !_e.done; _e = _d.next()) {
                var navLink = _e.value;
                navLink.addEventListener("click", this._level0ClickHandler);
            }
        } catch (e_6_1) {
            e_6 = { error: e_6_1 };
        } finally {
            try {
                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
            } finally {
                if (e_6) throw e_6.error;
            }
        }
        try {
            for (var _f = tslib_1.__values(this._navLevel1.querySelectorAll(QUERY_NAV_LEVEL1_LINK)), _g = _f.next(); !_g.done; _g = _f.next()) {
                var navLink = _g.value;
                navLink.addEventListener("click", this._level1ClickHandler);
            }
        } catch (e_7_1) {
            e_7 = { error: e_7_1 };
        } finally {
            try {
                if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
            } finally {
                if (e_7) throw e_7.error;
            }
        }
        this._hamburgerElement.addEventListener("click", this._level1ClickHandler);
        // Desktop search icon
        var searchIcon = this.element.querySelector(QUERY_SEARCH_ICON);
        if (searchIcon) {
            searchIcon.addEventListener("click", this._searchClickHandler);
        }
        try {
            for (var _h = tslib_1.__values(this.element.querySelectorAll(QUERY_SEARCH_FIELD)), _j = _h.next(); !_j.done; _j = _h.next()) {
                var search = _j.value;
                var searchComponent = new _SearchInput2.default(search);
                if (Dom.hasClass(search, CLASS_SEARCH_DESKTOP) || Dom.hasClass(search.parentElement, CLASS_SEARCH_DESKTOP)) {
                    this._searchDesktop = searchComponent;
                }
                this._searchComponents.push(searchComponent);
            }
        } catch (e_8_1) {
            e_8 = { error: e_8_1 };
        } finally {
            try {
                if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
            } finally {
                if (e_8) throw e_8.error;
            }
        }
    };
    /**
     * Closes the navigation.
     */
    Navigation.prototype.close = function () {
        var isMoble = this._isMobile();
        var level1 = this._navLevel1.querySelector(QUERY_NAV_LINK_ACTIVE);
        var level0 = this._navLevel0.querySelector(QUERY_NAV_LINK_ACTIVE);
        if (!level1 && isMoble && Dom.hasClass(this._hamburgerElement, CLASS_ACTIVE)) {
            level1 = this._hamburgerElement;
        }
        var navItems;
        if (level1) {
            navItems = new NavigationItems(this).fromLevel1(level1);
        } else if (level0) {
            navItems = new NavigationItems(this).fromLevel0(level0);
        }
        if (navItems) {
            this._resetMainTimeline(navItems.container, navItems.section, navItems.footer);
            Dom.removeClass(navItems.link, CLASS_ACTIVE);
            this._onNavigationClosed();
            this._closeSection(navItems.container, navItems.section, navItems.footer, !isMoble, false);
        }
    };
    return Navigation;
}(_DomElement2.default);
var NavigationItems = /** @class */function () {
    function NavigationItems(nav) {
        this._navigation = nav;
    }
    Object.defineProperty(NavigationItems.prototype, "link", {
        get: function get() {
            return this._link;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NavigationItems.prototype, "container", {
        get: function get() {
            return this._container;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NavigationItems.prototype, "section", {
        get: function get() {
            return this._section;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NavigationItems.prototype, "footer", {
        get: function get() {
            return this._footer;
        },
        enumerable: true,
        configurable: true
    });
    NavigationItems.prototype.fromLevel0 = function (navLink) {
        while (!Dom.hasClass(navLink, CLASS_NAV_LINK) && navLink.parentElement) {
            navLink = navLink.parentElement;
        }
        this._link = navLink;
        var toggleId = navLink.getAttribute("data-toggle");
        this._container = this._navigation._navLevel0Body;
        this._section = this._navigation._navLevel0.querySelector("#" + toggleId);
        return this;
    };
    NavigationItems.prototype.fromLevel1 = function (navLink) {
        while (navLink.parentElement) {
            if (navLink === this._navigation._hamburgerElement || Dom.hasClass(navLink, CLASS_NAV_LINK)) {
                break;
            }
            navLink = navLink.parentElement;
        }
        this._link = navLink;
        this._container = navLink.parentElement;
        this._section = this._container.querySelector(QUERY_NAV_BODY);
        this._footer = this._container.querySelector(QUERY_NAV_FOOTER);
        if (navLink === this._navigation._hamburgerElement) {
            this._container = this._navigation._navLevel1;
            this._section = this._container.querySelector(QUERY_NAV_HB_BODY);
        }
        return this;
    };
    NavigationItems.prototype.previousLevel1 = function () {
        var prev = new NavigationItems(this._navigation);
        prev._link = this._navigation._navLevel1.querySelector(QUERY_NAV_LINK_ACTIVE);
        prev._container = prev._link ? prev._link.parentElement : undefined;
        prev._section = prev._container ? prev._container.querySelector(QUERY_NAV_BODY) : undefined;
        prev._footer = prev._container ? prev._container.querySelector(QUERY_NAV_FOOTER) : undefined;
        return prev;
    };
    NavigationItems.prototype.isHamburger = function () {
        return this._link === this._navigation._hamburgerElement;
    };
    return NavigationItems;
}();
function init() {
    (0, _Utils.searchAndInitialize)(".nav", function (e) {
        new Navigation(e);
    });
}
exports.default = Navigation;

},{"../DomElement":5,"../DomFunctions":6,"../Utils":8,"../search/SearchInput":31,"animejs":35,"tslib":135}],26:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

var _DomFunctions = require("../DomFunctions");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var CLASS_OPEN = "is-open";
var CLASS_ACTIVE = "is-active";
var QUERY_SITE_WRAPPER = ".js-site-wrapper";
var QUERY_NAV_HAMBURGER = ".js-site-wrapper .js-hamburger";
var QUERY_NAV_ITEM = ".js-nav-item";
var NAV_LINK_INITIAL_SCALE = 0.9;
var ANIMATION_DURATION_LINKS = 100;
var ANIMATION_DURATION_NAV = 300;
var ANIMATION_STAGGER_DELAY = 50;
/**
 * The navigation side component definition.
 */
var NavigationSide = /** @class */function (_super) {
    tslib_1.__extends(NavigationSide, _super);
    function NavigationSide(element) {
        var _this = _super.call(this, element) || this;
        _this._clickHandler = _this._handleClick.bind(_this);
        _this._windowClickHandler = _this._handleWindowClick.bind(_this);
        _this._siteWrapper = document.querySelector(QUERY_SITE_WRAPPER);
        _this._hamburgerElement = document.querySelector(QUERY_NAV_HAMBURGER) || document.createElement("div");
        _this._navItems = _this.element.querySelectorAll(QUERY_NAV_ITEM);
        _this._initialize();
        return _this;
    }
    NavigationSide.prototype._initialize = function () {
        this._hamburgerElement.addEventListener("click", this._clickHandler);
        this._hamburgerElement.addEventListener("touchend", this._clickHandler);
    };
    NavigationSide.prototype._handleClick = function (event) {
        (0, _Utils.preventDefault)(event);
        this.toggle();
    };
    NavigationSide.prototype._handleWindowClick = function (event) {
        var target = event.target;
        while (target !== this.element && target.parentElement) {
            target = target.parentElement;
        }
        if (target !== this.element) {
            this.close();
            return false;
        }
        return true;
    };
    /**
     * Toggles the side navigation.
     */
    NavigationSide.prototype.toggle = function () {
        if ((0, _DomFunctions.hasClass)(this.element, CLASS_OPEN) === false) {
            this.open();
        } else {
            this.close();
        }
    };
    /**
     * Opens the slide navigation.
     */
    NavigationSide.prototype.open = function () {
        var _this = this;
        setTimeout(function () {
            window.addEventListener("click", _this._windowClickHandler);
            window.addEventListener("touchend", _this._windowClickHandler);
        }, 50);
        (0, _DomFunctions.addClass)(this._hamburgerElement, CLASS_ACTIVE);
        (0, _DomFunctions.addClass)(this.element, CLASS_OPEN);
        (0, _DomFunctions.addClass)(this._siteWrapper, CLASS_OPEN);
        var x = _animejs2.default.timeline();
        var off = ANIMATION_DURATION_NAV;
        this._navItems.forEach(function (element) {
            var el = element;
            el.style.opacity = "0";
            el.style.transform = "scale(" + NAV_LINK_INITIAL_SCALE + ")";
            x.add({
                targets: el,
                duration: ANIMATION_DURATION_LINKS,
                opacity: 1,
                scale: 1,
                easing: "linear",
                offset: off
            });
            off += ANIMATION_STAGGER_DELAY;
        });
    };
    /**
     * Closes the side navigation.
     */
    NavigationSide.prototype.close = function () {
        window.removeEventListener("click", this._windowClickHandler);
        window.removeEventListener("touchend", this._windowClickHandler);
        (0, _DomFunctions.removeClass)(this._hamburgerElement, CLASS_ACTIVE);
        (0, _DomFunctions.removeClass)(this.element, CLASS_OPEN);
        (0, _DomFunctions.removeClass)(this._siteWrapper, CLASS_OPEN);
    };
    /**
     * Destroys the component and removes all event
     * subscriptions and references.
     */
    NavigationSide.prototype.destroy = function () {
        window.removeEventListener("click", this._windowClickHandler);
        window.removeEventListener("touchend", this._windowClickHandler);
        this._windowClickHandler = null;
        this._clickHandler = null;
        this._siteWrapper = null;
        this._hamburgerElement = null;
        this._navItems = null;
    };
    return NavigationSide;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".nav-side", function (e) {
        new NavigationSide(e);
    });
}
exports.default = NavigationSide;

},{"../DomElement":5,"../DomFunctions":6,"../Utils":8,"animejs":35,"tslib":135}],27:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NotificationHeader = undefined;
exports.showOnHeader = showOnHeader;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var CLASS_NOTIFICATION = "notification-header";
var CLASS_OPEN = "notification--open";
var CLASS_BUTTON_CLOSE = "notification__close";
/**
 * Creates and shows a notification with the specified message.
 * @memberof Notification
 * @param {String} containerId - The id of the container on where to show the notification.
 * @param {String} message - The message to show.
 * @param {Notification~Click} messageClickCallback - The callback that gets called when the user clicks on the notification message text.
 * @param {Notification~Cancel} cancelCallback - The callback that gets called when the user cancels the notification by closing it.
 * @param {String} modifierClass - The css modifier class for the notification; this is an optional parameter
 * @returns {NotificationHeader} The notification header item instance.
 */
function showOnHeader(containerId, message, messageClickCallback, cancelCallback, modifierClass) {
    var containerE = document.querySelector("#" + containerId);
    if (!containerE) {
        throw new Error("Could not find the container with id " + containerId);
    }
    var containerElement = new _DomElement2.default(containerE);
    var notificationElement = new NotificationHeader();
    if (modifierClass) {
        notificationElement.addClass(modifierClass);
    }
    notificationElement.message = message;
    notificationElement.messageClickCallback = messageClickCallback;
    notificationElement.cancelCallback = cancelCallback;
    containerElement.appendChild(notificationElement);
    notificationElement._open();
    return notificationElement;
}
/**
 * A component for displaying notifications on the page-header.
 * @inner
 * @memberof Notification
 */
var NotificationHeader = /** @class */function (_super) {
    tslib_1.__extends(NotificationHeader, _super);
    function NotificationHeader() {
        var _this = _super.call(this, "div") || this;
        _this._closeHandler = _this._handleClose.bind(_this);
        _this._clickHandler = _this._handleClick.bind(_this);
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the range modal component.
     * @private
     */
    NotificationHeader.prototype._initialize = function () {
        this.addClass(CLASS_NOTIFICATION);
        this.addClass(CLASS_OPEN);
        var notificationContent = new _DomElement2.default("div").addClass("notification__content");
        this.appendChild(notificationContent);
        this._notificationBody = new _DomElement2.default("div").addClass("notification__body");
        notificationContent.appendChild(this._notificationBody);
        this._closeButton = new _DomElement2.default("button").addClass(CLASS_BUTTON_CLOSE).addClass("notification-cancel").setAttribute("aria-label", "Close");
        var closeIcon = new _DomElement2.default("i").addClass("icon").addClass("icon-022-close").setAttribute("aria-hidden", "true");
        this._closeButton.appendChild(closeIcon);
        notificationContent.appendChild(this._closeButton);
        this.element.addEventListener("click", this._clickHandler);
    };
    NotificationHeader.prototype._handleClick = function (event) {
        (0, _Utils.preventDefault)(event);
        var closeNotification = true;
        if (this._callback) {
            if (this._callback(this) === false) {
                closeNotification = false;
            }
        }
        if (closeNotification === true) {
            this.close();
        }
    };
    NotificationHeader.prototype._handleClose = function (event) {
        (0, _Utils.preventDefault)(event);
        event.stopPropagation();
        if (this._cancelCallback) {
            this._cancelCallback(this);
        }
        this.close();
    };
    NotificationHeader.prototype._close = function () {
        this.removeClass(CLASS_OPEN);
        this._closeButton.element.removeEventListener("click", this._closeHandler);
        var el = this.element;
        setTimeout(function () {
            // remove the element from the dom
            if (el && el.parentElement) {
                el.parentElement.removeChild(el);
            }
        }, 300);
    };
    // called by showOnHeader
    NotificationHeader.prototype._open = function () {
        this.addClass(CLASS_OPEN);
        this._closeButton.element.addEventListener("click", this._closeHandler);
        this.dispatchEvent("opened");
    };
    Object.defineProperty(NotificationHeader.prototype, "messageClickCallback", {
        set: function set(callback) {
            this._callback = callback;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotificationHeader.prototype, "cancelCallback", {
        /**
         * Sets the cancel callback function.
         * @param {function} - The callback function to call.
         */
        set: function set(callback) {
            this._cancelCallback = callback;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotificationHeader.prototype, "message", {
        /**
         * Sets the notification message.
         * @param {String} - The message to set.
         */
        set: function set(value) {
            this._notificationBody.setHtml(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Closes the notification.
     */
    NotificationHeader.prototype.close = function () {
        this._close();
        this.dispatchEvent("closed");
    };
    return NotificationHeader;
}(_DomElement2.default);
exports.NotificationHeader = NotificationHeader;

},{"../DomElement":5,"../Utils":8,"tslib":135}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _sign = require("babel-runtime/core-js/math/sign");

var _sign2 = _interopRequireDefault(_sign);

exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

var _Utils = require("../Utils");

var _Inputs = require("../Inputs");

var Inputs = _interopRequireWildcard(_Inputs);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CLASS_HEADER = ".progress-full__bar";
var CLASS_SECTIONS = ".progress-full__sections > span";
var CLASS_SECTION_ACTIVE = "section--active";
var CLASS_INDICATOR = "indicator";
var CLASS_INDICATOR_CURRENT = "indicator--current";
var CLASS_INDICATOR_COMPLETED = "indicator--completed";
/**
 * Full progress bar component
 */
var ProgressFull = /** @class */function (_super) {
    tslib_1.__extends(ProgressFull, _super);
    /**
     * Creates and initializes the ProgressFull component.
     * @param {DomElement} - The root element of the ProgressFull component.
     */
    function ProgressFull(element) {
        var _this = _super.call(this, element) || this;
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the loader bar component.
     * @private
     */
    ProgressFull.prototype._initialize = function () {
        this._buttonClickHandler = this._handleButtonClick.bind(this);
        this._keydownHandler = this._handleKeydown.bind(this);
        this._headerElement = this.find(CLASS_HEADER);
        this._pages = this.element.querySelectorAll(CLASS_SECTIONS);
        this._minValue = 1;
        this._value = 1;
        this._total = this._pages.length;
        for (var index = 0; index < this._pages.length; index++) {
            if (this._pages[index].classList.contains(CLASS_SECTION_ACTIVE)) {
                this._value = index + 1;
            }
        }
        this._addIncicators();
        this._update(-1, this._value, false);
        // Apply the tab index
        var tabIndex = this.getAttribute("tabindex");
        if (tabIndex) {
            this.setAttribute("tabindex", "");
            this._headerElement.setAttribute("tabindex", tabIndex);
        }
        this._headerElement.element.addEventListener("click", this._buttonClickHandler);
        this._headerElement.element.addEventListener("keydown", this._keydownHandler);
    };
    ProgressFull.prototype._addIncicators = function () {
        for (var i = this._pages.length - 1; i >= 0; i--) {
            var indicatorElement = new _DomElement2.default("button").addClass(CLASS_INDICATOR).setAttribute("data-value", "" + (i + 1)).setHtml((i + 1).toString());
            this._headerElement.prependChild(indicatorElement);
        }
    };
    ProgressFull.prototype._update = function (oldValue, newValue, animate) {
        if (animate === void 0) {
            animate = true;
        }
        var indicators = this._headerElement.element.childNodes;
        for (var index = 0; index < indicators.length; index++) {
            var indicatorElement = new _DomElement2.default(indicators[index]);
            if (index + 1 < this._value) {
                indicatorElement.removeClass(CLASS_INDICATOR_CURRENT).addClass(CLASS_INDICATOR_COMPLETED);
            }
            if (index + 1 === this._value) {
                indicatorElement.removeClass(CLASS_INDICATOR_COMPLETED).addClass(CLASS_INDICATOR_CURRENT);
            }
            if (index + 1 > this._value) {
                indicatorElement.removeClass(CLASS_INDICATOR_COMPLETED).removeClass(CLASS_INDICATOR_CURRENT);
            }
        }
        if (oldValue !== newValue) {
            var direction = (0, _sign2.default)(oldValue - newValue);
            if (oldValue > 0 && oldValue !== newValue) {
                var oldSection_1 = new _DomElement2.default(this._pages[oldValue - 1]);
                if (animate) {
                    (0, _animejs2.default)({
                        targets: oldSection_1.element,
                        duration: 300,
                        left: 100 * direction,
                        opacity: 0,
                        easing: "easeInOutQuint",
                        complete: function complete() {
                            oldSection_1.removeClass(CLASS_SECTION_ACTIVE);
                            oldSection_1.setAttribute("style", "");
                        }
                    });
                } else {
                    oldSection_1.removeClass(CLASS_SECTION_ACTIVE);
                    oldSection_1.setAttribute("style", "");
                }
            }
            var newSection_1 = new _DomElement2.default(this._pages[newValue - 1]);
            if (animate) {
                var el = newSection_1.element;
                el.style.left = -100 * direction + "px";
                el.style.opacity = "0";
                newSection_1.addClass(CLASS_SECTION_ACTIVE);
                (0, _animejs2.default)({
                    targets: newSection_1.element,
                    duration: 300,
                    left: 0,
                    opacity: 1,
                    easing: "easeInOutQuint",
                    complete: function complete() {
                        newSection_1.setAttribute("style", "");
                    }
                });
            } else {
                newSection_1.addClass(CLASS_SECTION_ACTIVE);
                newSection_1.setAttribute("style", "");
            }
        }
    };
    ProgressFull.prototype._handleButtonClick = function (event) {
        var element = new _DomElement2.default(event.target);
        if (!element.hasClass(CLASS_INDICATOR)) {
            return;
        }
        var value = element.getAttribute("data-value");
        this.value = parseFloat(value);
    };
    ProgressFull.prototype._handleKeydown = function (event) {
        var keycode = event.which || event.keyCode;
        if (keycode === Inputs.KEY_ARROW_RIGHT) {
            this.value++;
            (0, _Utils.preventDefault)(event);
            return;
        }
        if (keycode === Inputs.KEY_ARROW_LEFT) {
            this.value--;
            (0, _Utils.preventDefault)(event);
            return;
        }
        if (keycode >= Inputs.KEY_NR_0 && keycode <= Inputs.KEY_NR_9) {
            this.value = keycode - Inputs.KEY_NR_0;
            (0, _Utils.preventDefault)(event);
            return;
        }
    };
    Object.defineProperty(ProgressFull.prototype, "value", {
        /**
         * Gets the current progress value in the range of 1..total.
         */
        get: function get() {
            return this._value;
        },
        /**
         * Sets the current progress.
         * @param {number} - The progress in the range of 1..total.
         */
        set: function set(val) {
            var oldValue = this._value;
            this._value = (0, _Utils.clamp)(val, this._minValue, this._total);
            this._update(oldValue, this._value, true);
            this.dispatchEvent("changed");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ProgressFull.prototype, "total", {
        /**
         * Gets the total progress value.
         */
        get: function get() {
            return this._total;
        },
        enumerable: true,
        configurable: true
    });
    return ProgressFull;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".progress-full", function (e) {
        new ProgressFull(e);
    });
}
exports.default = ProgressFull;

},{"../DomElement":5,"../Inputs":7,"../Utils":8,"animejs":35,"babel-runtime/core-js/math/sign":37,"tslib":135}],29:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

var _Utils = require("../Utils");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var CLASS_BAR = ".progress-light__bar";
var CLASS_PROGRESS = ".bar__progress";
var CLASS_PROGRESS_COMPLETED = "bar__progress--complete";
var CLASS_TICK = "bar__tick";
var CLASS_PAGE_CURRENT = ".detail__currentpage";
var CLASS_PAGE_TOTAL = ".detail__totalpage";
var CLASS_DISABLED = "arrow--disabled";
var CLASS_BUTTON_LEFT = ".arrow--left";
var CLASS_BUTTON_RIGHT = ".arrow--right";
/**
 * Light progress bar component
 */
var ProgressLight = /** @class */function (_super) {
    tslib_1.__extends(ProgressLight, _super);
    /**
     * Creates and initializes the ProgressLight component.
     * @param {DomElement} - The root element of the ProgressLight component.
     */
    function ProgressLight(element) {
        var _this = _super.call(this, element) || this;
        _this._initialize();
        return _this;
    }
    /**
     * Initializes the loader bar component.
     * @private
     */
    ProgressLight.prototype._initialize = function () {
        this._buttonClickHandler = this._handleButtonClick.bind(this);
        this._animationCompletedHandler = this._handleAnimationCompleted.bind(this);
        this._barElement = this.find(CLASS_BAR);
        this._progressElement = this.find(CLASS_PROGRESS);
        this._pageCurrentElement = this.find(CLASS_PAGE_CURRENT);
        this._pageTotalElement = this.find(CLASS_PAGE_TOTAL);
        this._buttonLeft = this.find(CLASS_BUTTON_LEFT);
        this._buttonRight = this.find(CLASS_BUTTON_RIGHT);
        this._minValue = 1;
        this._total = Math.max(parseInt(this.getAttribute("total") || "100", 10), this._minValue);
        this._value = (0, _Utils.clamp)(parseInt(this.getAttribute("value") || "1", 10), this._minValue, this._total);
        this._layout();
        this._addTicks();
        this._update(false);
        this.enable();
    };
    ProgressLight.prototype._addTicks = function () {
        for (var i = 1; i < this._total; i++) {
            var position = this._itemWidth * i;
            var tickElement = new _DomElement2.default("div").addClass(CLASS_TICK).setAttribute("style", "left: " + position + "%");
            this._barElement.prependChild(tickElement);
        }
    };
    ProgressLight.prototype._update = function (animate) {
        var _this = this;
        if (animate === void 0) {
            animate = true;
        }
        this._pageCurrentElement.setHtml(this._value.toString());
        this._pageTotalElement.setHtml(this._total.toString());
        var position = this._value * this._itemWidth;
        // Add additional width to the last element to make sure
        // the rounded border on the left is filled as well
        if (this._value === this._total) {
            position += 5;
        }
        if (this._value >= this._total) {
            this._buttonRight.addClass(CLASS_DISABLED);
        } else {
            this._buttonRight.removeClass(CLASS_DISABLED);
        }
        if (this._value <= this._minValue) {
            this._buttonLeft.addClass(CLASS_DISABLED);
        } else {
            this._buttonLeft.removeClass(CLASS_DISABLED);
        }
        var el = this._progressElement.element;
        if (animate) {
            (0, _animejs2.default)({
                targets: this._progressElement.element,
                duration: 200,
                easing: "easeInOutQuint",
                width: this._barElement.element.clientWidth * position / 100,
                complete: function complete() {
                    el.style.width = position + "%";
                    _this._animationCompletedHandler({});
                }
            });
        } else {
            el.style.width = position + "%";
            this._animationCompletedHandler({});
        }
    };
    ProgressLight.prototype._layout = function () {
        this._itemWidth = Math.floor(100 / this._total);
    };
    ProgressLight.prototype._handleButtonClick = function (event) {
        if (event.target === this._buttonLeft.element) {
            this.value = this._value - 1;
        } else if (event.target === this._buttonRight.element) {
            this.value = this._value + 1;
        }
    };
    ProgressLight.prototype._handleAnimationCompleted = function () {
        if (this._value === this._total) {
            this._progressElement.addClass(CLASS_PROGRESS_COMPLETED);
        } else {
            this._progressElement.removeClass(CLASS_PROGRESS_COMPLETED);
        }
    };
    Object.defineProperty(ProgressLight.prototype, "value", {
        /**
         * Gets the current progress value in the range of 1..total.
         */
        get: function get() {
            return this._value;
        },
        /**
         * Sets the current progress.
         * @param {number} - The progress in the range of 1..total.
         */
        set: function set(val) {
            this._value = (0, _Utils.clamp)(val, this._minValue, this._total);
            this._update(true);
            this.dispatchEvent("changed");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ProgressLight.prototype, "total", {
        /**
         * Gets the total progress value.
         */
        get: function get() {
            return this._total;
        },
        /**
         * Sets the total progress value and updates the UI accordingly.
         * @param {number} - The total progress positive integer value.
         */
        set: function set(value) {
            var e_1, _a;
            if (this._total === value) {
                return;
            }
            this._total = Math.max(value, this._minValue);
            this._value = (0, _Utils.clamp)(this._value, this._minValue, this._total);
            try {
                // Clear the ticks
                for (var _b = tslib_1.__values(this.element.querySelectorAll("." + CLASS_TICK)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var tick = _c.value;
                    this._barElement.element.removeChild(tick);
                }
            } catch (e_1_1) {
                e_1 = { error: e_1_1 };
            } finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                } finally {
                    if (e_1) throw e_1.error;
                }
            }
            this._layout();
            this._addTicks();
            this._update(false);
            this.dispatchEvent("totalchanged");
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Enables the component.
     */
    ProgressLight.prototype.enable = function () {
        this._buttonLeft.element.addEventListener("click", this._buttonClickHandler);
        this._buttonRight.element.addEventListener("click", this._buttonClickHandler);
    };
    /**
     * Disables the component.
     */
    ProgressLight.prototype.disable = function () {
        this._buttonLeft.element.removeEventListener("click", this._buttonClickHandler);
        this._buttonRight.element.removeEventListener("click", this._buttonClickHandler);
    };
    return ProgressLight;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".progress-light", function (e) {
        new ProgressLight(e);
    });
}
exports.default = ProgressLight;

},{"../DomElement":5,"../Utils":8,"animejs":35,"tslib":135}],30:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initBarChartVertical = exports.BarChartVertical = exports.initBarChartHorizontal = exports.BarChartHorizontal = exports.initPieChart = exports.PieChart = exports.initTable = exports.Table = exports.initCarousel = exports.Carousel = exports.initEmptyState = exports.EmptyState = exports.initSearchInput = exports.SearchInput = exports.initNavigationSide = exports.NavigationSide = exports.initNavigation = exports.Navigation = exports.initMenuFlyout = exports.MenuFlyout = exports.initAccordion = exports.Accordion = exports.initCollapse = exports.Collapse = exports.Notification = exports.Toolbar = exports.initModal = exports.Modal = exports.initProgressFull = exports.ProgressFull = exports.initProgressLight = exports.ProgressLight = exports.initAutocomplete = exports.Autocomplete = exports.initRange = exports.Range = exports.initSelect = exports.Select = exports.initTextarea = exports.Textarea = exports.initInputField = exports.InputField = exports.initLoaderBar = exports.LoaderBar = exports.utils = undefined;

var _Utils = require("./Utils");

var utils = _interopRequireWildcard(_Utils);

var _LoaderBar = require("./loader/LoaderBar");

var _LoaderBar2 = _interopRequireDefault(_LoaderBar);

var _InputField = require("./form/InputField");

var _InputField2 = _interopRequireDefault(_InputField);

var _Textarea = require("./form/Textarea");

var _Textarea2 = _interopRequireDefault(_Textarea);

var _Select = require("./form/Select");

var _Select2 = _interopRequireDefault(_Select);

var _Range = require("./form/Range");

var _Range2 = _interopRequireDefault(_Range);

var _Autocomplete = require("./form/Autocomplete");

var _Autocomplete2 = _interopRequireDefault(_Autocomplete);

var _ProgressLight = require("./progress/ProgressLight");

var _ProgressLight2 = _interopRequireDefault(_ProgressLight);

var _ProgressFull = require("./progress/ProgressFull");

var _ProgressFull2 = _interopRequireDefault(_ProgressFull);

var _Modal = require("./modal/Modal");

var _Modal2 = _interopRequireDefault(_Modal);

var _Toolbar = require("./toolbar/Toolbar");

var _Toolbar2 = _interopRequireDefault(_Toolbar);

var _Notification = require("./notification/Notification");

var Notification = _interopRequireWildcard(_Notification);

var _Collapse = require("./collapse/Collapse");

var _Collapse2 = _interopRequireDefault(_Collapse);

var _Accordion = require("./accordion/Accordion");

var _Accordion2 = _interopRequireDefault(_Accordion);

var _MenuFlyout = require("./menu/MenuFlyout");

var _MenuFlyout2 = _interopRequireDefault(_MenuFlyout);

var _Navigation = require("./navigation/Navigation");

var _Navigation2 = _interopRequireDefault(_Navigation);

var _NavigationSide = require("./navigation/NavigationSide");

var _NavigationSide2 = _interopRequireDefault(_NavigationSide);

var _SearchInput = require("./search/SearchInput");

var _SearchInput2 = _interopRequireDefault(_SearchInput);

var _EmptyState = require("./empty-states/EmptyState");

var _EmptyState2 = _interopRequireDefault(_EmptyState);

var _Carousel = require("./carousel/Carousel");

var _Carousel2 = _interopRequireDefault(_Carousel);

var _Table = require("./table/Table");

var _Table2 = _interopRequireDefault(_Table);

var _PieChart = require("./charts/PieChart");

var _PieChart2 = _interopRequireDefault(_PieChart);

var _BarChartHorizontal = require("./charts/BarChartHorizontal");

var _BarChartHorizontal2 = _interopRequireDefault(_BarChartHorizontal);

var _BarChartVertical = require("./charts/BarChartVertical");

var _BarChartVertical2 = _interopRequireDefault(_BarChartVertical);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/* Form Components */
exports.utils = utils;
exports.LoaderBar = _LoaderBar2.default;
exports.initLoaderBar = _LoaderBar.init;
exports.InputField = _InputField2.default;
exports.initInputField = _InputField.init;
exports.Textarea = _Textarea2.default;
exports.initTextarea = _Textarea.init;
exports.Select = _Select2.default;
exports.initSelect = _Select.init;
exports.Range = _Range2.default;
exports.initRange = _Range.init;
exports.Autocomplete = _Autocomplete2.default;
exports.initAutocomplete = _Autocomplete.init;
exports.ProgressLight = _ProgressLight2.default;
exports.initProgressLight = _ProgressLight.init;
exports.ProgressFull = _ProgressFull2.default;
exports.initProgressFull = _ProgressFull.init;
exports.Modal = _Modal2.default;
exports.initModal = _Modal.init;
exports.Toolbar = _Toolbar2.default;
exports.Notification = Notification;
exports.Collapse = _Collapse2.default;
exports.initCollapse = _Collapse.init;
exports.Accordion = _Accordion2.default;
exports.initAccordion = _Accordion.init;
exports.MenuFlyout = _MenuFlyout2.default;
exports.initMenuFlyout = _MenuFlyout.init;
exports.Navigation = _Navigation2.default;
exports.initNavigation = _Navigation.init;
exports.NavigationSide = _NavigationSide2.default;
exports.initNavigationSide = _NavigationSide.init;
exports.SearchInput = _SearchInput2.default;
exports.initSearchInput = _SearchInput.init;
exports.EmptyState = _EmptyState2.default;
exports.initEmptyState = _EmptyState.init;
exports.Carousel = _Carousel2.default;
exports.initCarousel = _Carousel.init;
exports.Table = _Table2.default;
exports.initTable = _Table.init;
exports.PieChart = _PieChart2.default;
exports.initPieChart = _PieChart.init;
exports.BarChartHorizontal = _BarChartHorizontal2.default;
exports.initBarChartHorizontal = _BarChartHorizontal.init;
exports.BarChartVertical = _BarChartVertical2.default;
exports.initBarChartVertical = _BarChartVertical.init;

},{"./Utils":8,"./accordion/Accordion":9,"./carousel/Carousel":10,"./charts/BarChartHorizontal":11,"./charts/BarChartVertical":12,"./charts/PieChart":14,"./collapse/Collapse":15,"./empty-states/EmptyState":16,"./form/Autocomplete":17,"./form/InputField":18,"./form/Range":19,"./form/Select":20,"./form/Textarea":21,"./loader/LoaderBar":22,"./menu/MenuFlyout":23,"./modal/Modal":24,"./navigation/Navigation":25,"./navigation/NavigationSide":26,"./notification/Notification":27,"./progress/ProgressFull":28,"./progress/ProgressLight":29,"./search/SearchInput":31,"./table/Table":32,"./toolbar/Toolbar":33}],31:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _Inputs = require("../Inputs");

var Inputs = _interopRequireWildcard(_Inputs);

var _Utils = require("../Utils");

var _DomFunctions = require("../DomFunctions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var QUERY_SEARCH_INPUT = "input.search__field";
var QUERY_BTN_CLOSE = ".search__icon-close";
var QUERY_LIVE_SUGESTIONS = ".js-suggestions";
var QUERY_LIVE_FOOTER = ".js-footer";
var CLASS_ACTIVE = "is-active";
var CLASS_OPEN = "is-open";
var CLASS_SEARCH = "search";
var ANIMATION_SUGGESTIONS_DURATION = 300;
var ANIMATION_FOOTER_DURATION = 100;
var ANIMATION_FOOTER_DELAY = ANIMATION_SUGGESTIONS_DURATION - ANIMATION_FOOTER_DURATION;
/**
 * The search input component definition.
 */
var SearchInput = /** @class */function (_super) {
    tslib_1.__extends(SearchInput, _super);
    function SearchInput(element) {
        var _this = _super.call(this, element) || this;
        _this._isOpen = false;
        _this.easing = {
            // Equivalent to gsap's [ Power1.easeIn, Power4.easeOut ]
            inQuadOutQuint: [0.550, 0.085, 0.320, 1]
        };
        _this._input = _this.element.querySelector(QUERY_SEARCH_INPUT);
        _this._form = _this.element.querySelector("form");
        _this._btnClose = _this.element.querySelector(QUERY_BTN_CLOSE);
        var liveSearch = (0, _DomFunctions.getAttributeReference)(_this.element, "data-live");
        if (liveSearch) {
            _this._liveSuggestions = liveSearch.querySelector(QUERY_LIVE_SUGESTIONS) || undefined;
            _this._liveFooter = liveSearch.querySelector(QUERY_LIVE_FOOTER) || undefined;
            if (_this._liveSuggestions) {
                _this._liveContainer = _this._liveSuggestions.parentNode || undefined;
            }
        }
        _this._focusHandler = _this._handleInputFocus.bind(_this);
        _this._blurHandler = _this._handleInputBlur.bind(_this);
        _this._closeHandler = _this.close.bind(_this);
        _this._windowClickHandler = _this._handleWindowClick.bind(_this);
        _this._keydownHandler = _this._handleKeydown.bind(_this);
        _this._resizeHandler = _this._handleResize.bind(_this);
        _this._initialize();
        return _this;
    }
    SearchInput.prototype._initialize = function () {
        this._input.addEventListener("focus", this._focusHandler);
        this._input.addEventListener("blur", this._blurHandler);
        if ((0, _Utils.internetExplorerOrEdgeVersion)() > 0) {
            // This is a workaround for IE browsers where a focused
            // input's cursor bleeds trough even if hidden
            window.addEventListener("resize", this._resizeHandler);
            window.addEventListener("orientationchange", this._resizeHandler);
        }
        if (this._btnClose) {
            this._btnClose.addEventListener("click", this._closeHandler);
        }
    };
    SearchInput.prototype._handleInputFocus = function () {
        this.addClass(CLASS_ACTIVE);
    };
    SearchInput.prototype._handleInputBlur = function () {
        this.removeClass(CLASS_ACTIVE);
    };
    SearchInput.prototype._handleWindowClick = function (event) {
        var target = event.target;
        if (!(0, _DomFunctions.parentWithClass)(target, CLASS_SEARCH)) {
            this.close();
            return false;
        }
        return true;
    };
    SearchInput.prototype._handleKeydown = function (event) {
        var keycode = event.which || event.keyCode;
        if (keycode === Inputs.KEY_ESCAPE) {
            this.close();
            (0, _Utils.preventDefault)(event);
        }
    };
    SearchInput.prototype._handleResize = function () {
        var style = window.getComputedStyle(this.element);
        if (style.display === "none") {
            this._input.blur();
        }
    };
    SearchInput.prototype._resetMainTimeline = function () {
        if (this.animation) {
            this.animation.pause();
        }
        _animejs2.default.remove(this._liveSuggestions);
        _animejs2.default.remove(this._liveFooter);
        this.animation = _animejs2.default.timeline();
    };
    Object.defineProperty(SearchInput.prototype, "value", {
        /**
         * Gets the search input text content.
         * @returns {String} The input text.
         */
        get: function get() {
            return this._input.value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Opens/activates the search input.
     */
    SearchInput.prototype.open = function () {
        var _this = this;
        this.addClass(CLASS_OPEN);
        this._input.focus();
        setTimeout(function () {
            window.addEventListener("click", _this._windowClickHandler);
            window.addEventListener("touchend", _this._windowClickHandler);
            window.addEventListener("keydown", _this._keydownHandler);
        }, 50);
    };
    /**
     * Closes/deactivates the search input.
     */
    SearchInput.prototype.close = function () {
        this._form.reset();
        this.removeClass(CLASS_OPEN);
        this.closeLiveSearch();
        window.removeEventListener("click", this._windowClickHandler);
        window.removeEventListener("touchend", this._windowClickHandler);
        window.removeEventListener("keydown", this._keydownHandler);
    };
    /**
     * Opens the live search suggestions.
     */
    SearchInput.prototype.openLiveSearch = function () {
        var _this = this;
        if (!this._liveSuggestions || this._isOpen) {
            return;
        }
        this._isOpen = true;
        (0, _DomFunctions.addClass)(this._liveContainer, CLASS_OPEN);
        this._resetMainTimeline();
        this._liveSuggestions.style.display = "block";
        this.animation.add({
            targets: this._liveSuggestions,
            duration: ANIMATION_SUGGESTIONS_DURATION,
            height: this._liveSuggestions.scrollHeight + "px",
            easing: this.easing.inQuadOutQuint,
            complete: function complete() {
                var domEl = new _DomElement2.default(_this._liveSuggestions);
                domEl.addClass(CLASS_OPEN);
                domEl.setAttribute("style", "");
            }
        });
        if (this._liveFooter) {
            this._liveFooter.style.display = "block";
            this.animation.add({
                targets: this._liveFooter,
                duration: ANIMATION_FOOTER_DURATION,
                height: this._liveFooter.scrollHeight + "px",
                easing: this.easing.inQuadOutQuint,
                offset: ANIMATION_FOOTER_DELAY,
                complete: function complete() {
                    var domEl = new _DomElement2.default(_this._liveFooter);
                    domEl.addClass(CLASS_OPEN);
                    domEl.setAttribute("style", "");
                }
            });
        }
    };
    /**
     * Closes the live search suggestions.
     */
    SearchInput.prototype.closeLiveSearch = function () {
        var _this = this;
        if (!this._liveSuggestions || !this.isOpen) {
            return;
        }
        this._isOpen = false;
        this._resetMainTimeline();
        this._liveSuggestions.style.display = "block";
        this.animation.add({
            targets: this._liveSuggestions,
            duration: ANIMATION_SUGGESTIONS_DURATION,
            height: 0,
            easing: this.easing.inQuadOutQuint,
            complete: function complete() {
                var domEl = new _DomElement2.default(_this._liveSuggestions);
                domEl.removeClass(CLASS_OPEN);
                domEl.setAttribute("style", "");
                (0, _DomFunctions.removeClass)(_this._liveContainer, CLASS_OPEN);
            }
        });
        if (this._liveFooter) {
            this._liveFooter.style.display = "block";
            this.animation.add({
                targets: this._liveFooter,
                duration: ANIMATION_FOOTER_DURATION,
                height: 0,
                easing: this.easing.inQuadOutQuint,
                offset: 0,
                complete: function complete() {
                    var domEl = new _DomElement2.default(_this._liveFooter);
                    domEl.removeClass(CLASS_OPEN);
                    domEl.setAttribute("style", "");
                }
            });
        }
    };
    /**
     * Destroys the component and clears all references.
     */
    SearchInput.prototype.destroy = function () {
        window.removeEventListener("click", this._windowClickHandler);
        window.removeEventListener("touchend", this._windowClickHandler);
        window.removeEventListener("keydown", this._keydownHandler);
        this._input.removeEventListener("focus", this._focusHandler);
        this._input.removeEventListener("blur", this._blurHandler);
        window.removeEventListener("resize", this._resizeHandler);
        window.removeEventListener("orientationchange", this._resizeHandler);
        if (this._btnClose) {
            this._btnClose.removeEventListener("click", this._closeHandler);
        }
        this._input = null;
        this._form = null;
        this._btnClose = null;
        this._focusHandler = null;
        this._blurHandler = null;
        this._closeHandler = null;
        this._windowClickHandler = null;
        this._keydownHandler = null;
        this._liveSuggestions = null;
        this._liveFooter = null;
    };
    /**
     * Determines if the SearchInput is open/visible.
     * @return {Boolean} - True if open; otherwise false.
     */
    SearchInput.prototype.isOpen = function () {
        return this.hasClass(CLASS_OPEN);
    };
    return SearchInput;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)(".search.search__input", function (e) {
        new SearchInput(e);
    });
}
exports.default = SearchInput;

},{"../DomElement":5,"../DomFunctions":6,"../Inputs":7,"../Utils":8,"animejs":35,"tslib":135}],32:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = init;

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _Utils = require("../Utils");

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

var _DomFunctions = require("../DomFunctions");

var Dom = _interopRequireWildcard(_DomFunctions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var QUERY_HEADER = "thead th";
var CLASS_SORTED_ASCENDING = "js-ascending";
var CLASS_SORTED_DESCENDING = "js-descending";
var CLASS_ARROW = "arrow-icon";
/**
 * The Table component. Adds additional capabilities to standard HTML 5 tables.
 */
var Table = /** @class */function (_super) {
    tslib_1.__extends(Table, _super);
    /**
     * Creates a new instance of the table component.
     */
    function Table(element) {
        var _this = _super.call(this, element) || this;
        _this._headerClickHandler = _this._handleHeaderClick.bind(_this);
        _this._body = _this.element.querySelector("tbody");
        _this._rows = _this._body.getElementsByTagName("tr");
        _this._initialize();
        return _this;
    }
    Table.prototype._initialize = function () {
        var e_1, _a;
        try {
            for (var _b = tslib_1.__values(this.element.querySelectorAll(QUERY_HEADER)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var header = _c.value;
                if (header.getAttribute("data-type")) {
                    header.addEventListener("click", this._headerClickHandler);
                    var arrowElement = new _DomElement2.default("div").addClass(CLASS_ARROW).element;
                    header.appendChild(arrowElement);
                }
            }
        } catch (e_1_1) {
            e_1 = { error: e_1_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_1) throw e_1.error;
            }
        }
    };
    Table.prototype._handleHeaderClick = function (e) {
        var th = e.target;
        this.sort(th);
    };
    /**
     * Sorts the table according to the specified table header element.
     * The column is sorted ascending by default if no direction is specified and no
     * existing sort order class is found in the markup.
     *
     * If the displayed data is not suitable for sorting `<td/>` elements can define a `data-value` attribute
     * which is then used for the data-source.
     *
     * @param {TableHeader} tableHeader The header element of the row to sort by.
     * @param {Number} direction The direction to sort, `1` for ascending, `-1` for descending order. This parameter is optional.
     * @param {function} equalityComparer The equiality comparer function to compare individual cell values.
     */
    Table.prototype.sort = function (tableHeader, direction, equalityComparer) {
        var e_2, _a;
        if (!tableHeader || tableHeader.tagName !== "TH") {
            throw new Error("The parameter 'tableHeader' must be a valid column header node");
        }
        if (direction !== 1 && direction !== -1 && direction) {
            throw new Error("Parameter out of range, parameter 'direction' with value '" + direction + "' must be either -1, 1 or undefined");
        }
        var columnIndex = tableHeader.cellIndex;
        if (!equalityComparer) {
            var dataType = tableHeader.getAttribute("data-type");
            equalityComparer = this._getComparer(dataType);
        }
        if (columnIndex >= this.element.querySelectorAll(QUERY_HEADER).length) {
            throw new Error("Column out of range");
        }
        try {
            for (var _b = tslib_1.__values(this.element.querySelectorAll(QUERY_HEADER)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var header = _c.value;
                if (header !== tableHeader) {
                    Dom.removeClass(header, CLASS_SORTED_ASCENDING);
                    Dom.removeClass(header, CLASS_SORTED_DESCENDING);
                }
            }
        } catch (e_2_1) {
            e_2 = { error: e_2_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_2) throw e_2.error;
            }
        }
        if (Dom.hasClass(tableHeader, CLASS_SORTED_ASCENDING)) {
            Dom.removeClass(tableHeader, CLASS_SORTED_ASCENDING);
            Dom.addClass(tableHeader, CLASS_SORTED_DESCENDING);
            direction = direction || -1;
        } else {
            Dom.removeClass(tableHeader, CLASS_SORTED_DESCENDING);
            Dom.addClass(tableHeader, CLASS_SORTED_ASCENDING);
            direction = direction || 1;
        }
        this._quicksort(columnIndex, 0, this._rows.length - 1, direction, equalityComparer);
    };
    Table.prototype._getCell = function (column, row) {
        return this._rows[row].cells[column];
    };
    Table.prototype._getRow = function (row) {
        return this._rows[row];
    };
    Table.prototype._getComparer = function (dataType) {
        switch (dataType) {
            case "number":
                {
                    // parse the string as a number
                    return function (a, b) {
                        return parseFloat(a) - parseFloat(b);
                    };
                }
            default:
                {
                    // compare strings
                    return function (a, b) {
                        if (a < b) {
                            return -1;
                        }
                        if (a > b) {
                            return 1;
                        }
                        return 0;
                    };
                }
        }
    };
    Table.prototype._quicksort = function (column, left, right, direction, equalityComparer) {
        if (direction === void 0) {
            direction = 1;
        }
        if (right - left > 0) {
            var partition = this._partition(column, left, right, direction, equalityComparer);
            if (left < partition - 1) {
                this._quicksort(column, left, partition - 1, direction, equalityComparer);
            }
            if (partition < right) {
                this._quicksort(column, partition, right, direction, equalityComparer);
            }
        }
    };
    Table.prototype._partition = function (column, left, right, direction, equalityComparer) {
        if (direction === void 0) {
            direction = 1;
        }
        var pivot = this._getCell(column, Math.floor((right + left) / 2));
        var i = left;
        var j = right;
        while (i <= j) {
            while (this._equals(this._getCell(column, i), pivot, equalityComparer) * direction < 0) {
                i++;
            }
            while (this._equals(this._getCell(column, j), pivot, equalityComparer) * direction > 0) {
                j--;
            }
            if (i <= j) {
                this._swap(i, j);
                i++;
                j--;
            }
        }
        return i;
    };
    Table.prototype._equals = function (a, b, equalityComparer) {
        var dataA = a.getAttribute("data-value");
        var dataB = b.getAttribute("data-value");
        dataA = dataA || a.textContent || a.innerText;
        dataB = dataB || b.textContent || b.innerText;
        return equalityComparer(dataA, dataB);
    };
    Table.prototype._swap = function (i, j) {
        var tmpNode = this._body.replaceChild(this._getRow(i), this._getRow(j));
        var referenceRow = this._getRow(i);
        if (!referenceRow) {
            this._body.appendChild(tmpNode);
        } else {
            this._body.insertBefore(tmpNode, referenceRow);
        }
    };
    /**
     * Destroys the component and clears all references.
     */
    Table.prototype.destroy = function () {
        var e_3, _a;
        try {
            for (var _b = tslib_1.__values(this.element.querySelectorAll(QUERY_HEADER)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var header = _c.value;
                header.removeEventListener("click", this._headerClickHandler);
            }
        } catch (e_3_1) {
            e_3 = { error: e_3_1 };
        } finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
                if (e_3) throw e_3.error;
            }
        }
        this._headerClickHandler = null;
        this._body = null;
        this._rows = null;
    };
    return Table;
}(_DomElement2.default);
function init() {
    (0, _Utils.searchAndInitialize)("table", function (e) {
        new Table(e);
    });
}
exports.default = Table;

},{"../DomElement":5,"../DomFunctions":6,"../Utils":8,"tslib":135}],33:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _tslib = require("tslib");

var tslib_1 = _interopRequireWildcard(_tslib);

var _animejs = require("animejs");

var _animejs2 = _interopRequireDefault(_animejs);

var _DomElement = require("../DomElement");

var _DomElement2 = _interopRequireDefault(_DomElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var CLASS_ITEMS = ".toolbar__item";
var CLASS_SHOW = "item--show";
var ANIMATION_START_DELAY = 100;
var ANIMATION_OFFSET = 50;
/**
 * Toolbar component. Use this component to show and hide the
 * individual toolbar items.
 */
var Toolbar = /** @class */function (_super) {
    tslib_1.__extends(Toolbar, _super);
    function Toolbar() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Makes the toolbar items visible.
     */
    Toolbar.prototype.show = function () {
        var delay = ANIMATION_START_DELAY;
        var items = this.element.querySelectorAll(CLASS_ITEMS);
        var timeline = _animejs2.default.timeline();
        var _loop_1 = function _loop_1(index) {
            timeline.add({
                targets: items[index],
                duration: 0,
                offset: delay,
                complete: function complete() {
                    items[index].classList.add(CLASS_SHOW);
                }
            });
            delay += ANIMATION_OFFSET;
        };
        for (var index = 0; index < items.length; index++) {
            _loop_1(index);
        }
    };
    /**
     * Hides the toolbar items.
     */
    Toolbar.prototype.hide = function () {
        var delay = ANIMATION_START_DELAY;
        var items = this.element.querySelectorAll(CLASS_ITEMS);
        var timeline = _animejs2.default.timeline();
        var _loop_2 = function _loop_2(index) {
            timeline.add({
                targets: items[index],
                duration: 0,
                offset: delay,
                complete: function complete() {
                    items[index].classList.remove(CLASS_SHOW);
                }
            });
            delay += ANIMATION_OFFSET;
        };
        for (var index = items.length - 1; index >= 0; index--) {
            _loop_2(index);
        }
    };
    /**
     * Toggles the toolbar items visibility.
     */
    Toolbar.prototype.toggle = function () {
        if (this.element.querySelectorAll("." + CLASS_SHOW).length === 0) {
            this.show();
        } else {
            this.hide();
        }
    };
    return Toolbar;
}(_DomElement2.default);
exports.default = Toolbar;

},{"../DomElement":5,"animejs":35,"tslib":135}],34:[function(require,module,exports){
'use strict';

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * modernizr v3.6.0
 * Build https://modernizr.com/download?-hiddenscroll-touchevents-setclasses-dontmin
 *
 * Copyright (c)
 *  Faruk Ates
 *  Paul Irish
 *  Alex Sexton
 *  Ryan Seddon
 *  Patrick Kettner
 *  Stu Cox
 *  Richard Herrera

 * MIT License
 */

/*
 * Modernizr tests which native CSS3 and HTML5 features are available in the
 * current UA and makes the results available to you in two ways: as properties on
 * a global `Modernizr` object, and as classes on the `<html>` element. This
 * information allows you to progressively enhance your pages with a granular level
 * of control over the experience.
*/

;(function (window, document, undefined) {
  var tests = [];

  /**
   *
   * ModernizrProto is the constructor for Modernizr
   *
   * @class
   * @access public
   */

  var ModernizrProto = {
    // The current version, dummy
    _version: '3.6.0',

    // Any settings that don't work as separate modules
    // can go in here as configuration.
    _config: {
      'classPrefix': '',
      'enableClasses': true,
      'enableJSClass': true,
      'usePrefixes': true
    },

    // Queue of tests
    _q: [],

    // Stub these for people who are listening
    on: function on(test, cb) {
      // I don't really think people should do this, but we can
      // safe guard it a bit.
      // -- NOTE:: this gets WAY overridden in src/addTest for actual async tests.
      // This is in case people listen to synchronous tests. I would leave it out,
      // but the code to *disallow* sync tests in the real version of this
      // function is actually larger than this.
      var self = this;
      setTimeout(function () {
        cb(self[test]);
      }, 0);
    },

    addTest: function addTest(name, fn, options) {
      tests.push({ name: name, fn: fn, options: options });
    },

    addAsyncTest: function addAsyncTest(fn) {
      tests.push({ name: null, fn: fn });
    }
  };

  // Fake some of Object.create so we can force non test results to be non "own" properties.
  var Modernizr = function Modernizr() {};
  Modernizr.prototype = ModernizrProto;

  // Leak modernizr globally when you `require` it rather than force it here.
  // Overwrite name so constructor name is nicer :D
  Modernizr = new Modernizr();

  var classes = [];

  /**
   * is returns a boolean if the typeof an obj is exactly type.
   *
   * @access private
   * @function is
   * @param {*} obj - A thing we want to check the type of
   * @param {string} type - A string to compare the typeof against
   * @returns {boolean}
   */

  function is(obj, type) {
    return (typeof obj === 'undefined' ? 'undefined' : (0, _typeof3.default)(obj)) === type;
  }
  ;

  /**
   * Run through all tests and detect their support in the current UA.
   *
   * @access private
   */

  function testRunner() {
    var featureNames;
    var feature;
    var aliasIdx;
    var result;
    var nameIdx;
    var featureName;
    var featureNameSplit;

    for (var featureIdx in tests) {
      if (tests.hasOwnProperty(featureIdx)) {
        featureNames = [];
        feature = tests[featureIdx];
        // run the test, throw the return value into the Modernizr,
        // then based on that boolean, define an appropriate className
        // and push it into an array of classes we'll join later.
        //
        // If there is no name, it's an 'async' test that is run,
        // but not directly added to the object. That should
        // be done with a post-run addTest call.
        if (feature.name) {
          featureNames.push(feature.name.toLowerCase());

          if (feature.options && feature.options.aliases && feature.options.aliases.length) {
            // Add all the aliases into the names list
            for (aliasIdx = 0; aliasIdx < feature.options.aliases.length; aliasIdx++) {
              featureNames.push(feature.options.aliases[aliasIdx].toLowerCase());
            }
          }
        }

        // Run the test, or use the raw value if it's not a function
        result = is(feature.fn, 'function') ? feature.fn() : feature.fn;

        // Set each of the names on the Modernizr object
        for (nameIdx = 0; nameIdx < featureNames.length; nameIdx++) {
          featureName = featureNames[nameIdx];
          // Support dot properties as sub tests. We don't do checking to make sure
          // that the implied parent tests have been added. You must call them in
          // order (either in the test, or make the parent test a dependency).
          //
          // Cap it to TWO to make the logic simple and because who needs that kind of subtesting
          // hashtag famous last words
          featureNameSplit = featureName.split('.');

          if (featureNameSplit.length === 1) {
            Modernizr[featureNameSplit[0]] = result;
          } else {
            // cast to a Boolean, if not one already
            if (Modernizr[featureNameSplit[0]] && !(Modernizr[featureNameSplit[0]] instanceof Boolean)) {
              Modernizr[featureNameSplit[0]] = new Boolean(Modernizr[featureNameSplit[0]]);
            }

            Modernizr[featureNameSplit[0]][featureNameSplit[1]] = result;
          }

          classes.push((result ? '' : 'no-') + featureNameSplit.join('-'));
        }
      }
    }
  }
  ;

  /**
   * docElement is a convenience wrapper to grab the root element of the document
   *
   * @access private
   * @returns {HTMLElement|SVGElement} The root element of the document
   */

  var docElement = document.documentElement;

  /**
   * A convenience helper to check if the document we are running in is an SVG document
   *
   * @access private
   * @returns {boolean}
   */

  var isSVG = docElement.nodeName.toLowerCase() === 'svg';

  /**
   * setClasses takes an array of class names and adds them to the root element
   *
   * @access private
   * @function setClasses
   * @param {string[]} classes - Array of class names
   */

  // Pass in an and array of class names, e.g.:
  //  ['no-webp', 'borderradius', ...]
  function setClasses(classes) {
    var className = docElement.className;
    var classPrefix = Modernizr._config.classPrefix || '';

    if (isSVG) {
      className = className.baseVal;
    }

    // Change `no-js` to `js` (independently of the `enableClasses` option)
    // Handle classPrefix on this too
    if (Modernizr._config.enableJSClass) {
      var reJS = new RegExp('(^|\\s)' + classPrefix + 'no-js(\\s|$)');
      className = className.replace(reJS, '$1' + classPrefix + 'js$2');
    }

    if (Modernizr._config.enableClasses) {
      // Add the new classes
      className += ' ' + classPrefix + classes.join(' ' + classPrefix);
      if (isSVG) {
        docElement.className.baseVal = className;
      } else {
        docElement.className = className;
      }
    }
  }

  ;

  /**
   * createElement is a convenience wrapper around document.createElement. Since we
   * use createElement all over the place, this allows for (slightly) smaller code
   * as well as abstracting away issues with creating elements in contexts other than
   * HTML documents (e.g. SVG documents).
   *
   * @access private
   * @function createElement
   * @returns {HTMLElement|SVGElement} An HTML or SVG element
   */

  function createElement() {
    if (typeof document.createElement !== 'function') {
      // This is the case in IE7, where the type of createElement is "object".
      // For this reason, we cannot call apply() as Object is not a Function.
      return document.createElement(arguments[0]);
    } else if (isSVG) {
      return document.createElementNS.call(document, 'http://www.w3.org/2000/svg', arguments[0]);
    } else {
      return document.createElement.apply(document, arguments);
    }
  }

  ;

  /**
   * getBody returns the body of a document, or an element that can stand in for
   * the body if a real body does not exist
   *
   * @access private
   * @function getBody
   * @returns {HTMLElement|SVGElement} Returns the real body of a document, or an
   * artificially created element that stands in for the body
   */

  function getBody() {
    // After page load injecting a fake body doesn't work so check if body exists
    var body = document.body;

    if (!body) {
      // Can't use the real body create a fake one.
      body = createElement(isSVG ? 'svg' : 'body');
      body.fake = true;
    }

    return body;
  }

  ;

  /**
   * injectElementWithStyles injects an element with style element and some CSS rules
   *
   * @access private
   * @function injectElementWithStyles
   * @param {string} rule - String representing a css rule
   * @param {function} callback - A function that is used to test the injected element
   * @param {number} [nodes] - An integer representing the number of additional nodes you want injected
   * @param {string[]} [testnames] - An array of strings that are used as ids for the additional nodes
   * @returns {boolean}
   */

  function injectElementWithStyles(rule, callback, nodes, testnames) {
    var mod = 'modernizr';
    var style;
    var ret;
    var node;
    var docOverflow;
    var div = createElement('div');
    var body = getBody();

    if (parseInt(nodes, 10)) {
      // In order not to give false positives we create a node for each test
      // This also allows the method to scale for unspecified uses
      while (nodes--) {
        node = createElement('div');
        node.id = testnames ? testnames[nodes] : mod + (nodes + 1);
        div.appendChild(node);
      }
    }

    style = createElement('style');
    style.type = 'text/css';
    style.id = 's' + mod;

    // IE6 will false positive on some tests due to the style element inside the test div somehow interfering offsetHeight, so insert it into body or fakebody.
    // Opera will act all quirky when injecting elements in documentElement when page is served as xml, needs fakebody too. #270
    (!body.fake ? div : body).appendChild(style);
    body.appendChild(div);

    if (style.styleSheet) {
      style.styleSheet.cssText = rule;
    } else {
      style.appendChild(document.createTextNode(rule));
    }
    div.id = mod;

    if (body.fake) {
      //avoid crashing IE8, if background image is used
      body.style.background = '';
      //Safari 5.13/5.1.4 OSX stops loading if ::-webkit-scrollbar is used and scrollbars are visible
      body.style.overflow = 'hidden';
      docOverflow = docElement.style.overflow;
      docElement.style.overflow = 'hidden';
      docElement.appendChild(body);
    }

    ret = callback(div, rule);
    // If this is done after page load we don't want to remove the body so check if body exists
    if (body.fake) {
      body.parentNode.removeChild(body);
      docElement.style.overflow = docOverflow;
      // Trigger layout so kinetic scrolling isn't disabled in iOS6+
      // eslint-disable-next-line
      docElement.offsetHeight;
    } else {
      div.parentNode.removeChild(div);
    }

    return !!ret;
  }

  ;

  /**
   * testStyles injects an element with style element and some CSS rules
   *
   * @memberof Modernizr
   * @name Modernizr.testStyles
   * @optionName Modernizr.testStyles()
   * @optionProp testStyles
   * @access public
   * @function testStyles
   * @param {string} rule - String representing a css rule
   * @param {function} callback - A function that is used to test the injected element
   * @param {number} [nodes] - An integer representing the number of additional nodes you want injected
   * @param {string[]} [testnames] - An array of strings that are used as ids for the additional nodes
   * @returns {boolean}
   * @example
   *
   * `Modernizr.testStyles` takes a CSS rule and injects it onto the current page
   * along with (possibly multiple) DOM elements. This lets you check for features
   * that can not be detected by simply checking the [IDL](https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/Interface_development_guide/IDL_interface_rules).
   *
   * ```js
   * Modernizr.testStyles('#modernizr { width: 9px; color: papayawhip; }', function(elem, rule) {
   *   // elem is the first DOM node in the page (by default #modernizr)
   *   // rule is the first argument you supplied - the CSS rule in string form
   *
   *   addTest('widthworks', elem.style.width === '9px')
   * });
   * ```
   *
   * If your test requires multiple nodes, you can include a third argument
   * indicating how many additional div elements to include on the page. The
   * additional nodes are injected as children of the `elem` that is returned as
   * the first argument to the callback.
   *
   * ```js
   * Modernizr.testStyles('#modernizr {width: 1px}; #modernizr2 {width: 2px}', function(elem) {
   *   document.getElementById('modernizr').style.width === '1px'; // true
   *   document.getElementById('modernizr2').style.width === '2px'; // true
   *   elem.firstChild === document.getElementById('modernizr2'); // true
   * }, 1);
   * ```
   *
   * By default, all of the additional elements have an ID of `modernizr[n]`, where
   * `n` is its index (e.g. the first additional, second overall is `#modernizr2`,
   * the second additional is `#modernizr3`, etc.).
   * If you want to have more meaningful IDs for your function, you can provide
   * them as the fourth argument, as an array of strings
   *
   * ```js
   * Modernizr.testStyles('#foo {width: 10px}; #bar {height: 20px}', function(elem) {
   *   elem.firstChild === document.getElementById('foo'); // true
   *   elem.lastChild === document.getElementById('bar'); // true
   * }, 2, ['foo', 'bar']);
   * ```
   *
   */

  var testStyles = ModernizrProto.testStyles = injectElementWithStyles;

  /*!
  {
    "name": "Hidden Scrollbar",
    "property": "hiddenscroll",
    "authors": ["Oleg Korsunsky"],
    "tags": ["overlay"],
    "notes": [{
      "name": "Overlay Scrollbar description",
      "href": "https://developer.apple.com/library/mac/releasenotes/MacOSX/WhatsNewInOSX/Articles/MacOSX10_7.html#//apple_ref/doc/uid/TP40010355-SW39"
    },{
      "name": "Video example of overlay scrollbars",
      "href": "https://gfycat.com/FoolishMeaslyAtlanticsharpnosepuffer"
    }]
  }
  !*/
  /* DOC
  Detects overlay scrollbars (when scrollbars on overflowed blocks are visible). This is found most commonly on mobile and OS X.
  */

  Modernizr.addTest('hiddenscroll', function () {
    return testStyles('#modernizr {width:100px;height:100px;overflow:scroll}', function (elem) {
      return elem.offsetWidth === elem.clientWidth;
    });
  });

  /**
   * List of property values to set for css tests. See ticket #21
   * http://git.io/vUGl4
   *
   * @memberof Modernizr
   * @name Modernizr._prefixes
   * @optionName Modernizr._prefixes
   * @optionProp prefixes
   * @access public
   * @example
   *
   * Modernizr._prefixes is the internal list of prefixes that we test against
   * inside of things like [prefixed](#modernizr-prefixed) and [prefixedCSS](#-code-modernizr-prefixedcss). It is simply
   * an array of kebab-case vendor prefixes you can use within your code.
   *
   * Some common use cases include
   *
   * Generating all possible prefixed version of a CSS property
   * ```js
   * var rule = Modernizr._prefixes.join('transform: rotate(20deg); ');
   *
   * rule === 'transform: rotate(20deg); webkit-transform: rotate(20deg); moz-transform: rotate(20deg); o-transform: rotate(20deg); ms-transform: rotate(20deg);'
   * ```
   *
   * Generating all possible prefixed version of a CSS value
   * ```js
   * rule = 'display:' +  Modernizr._prefixes.join('flex; display:') + 'flex';
   *
   * rule === 'display:flex; display:-webkit-flex; display:-moz-flex; display:-o-flex; display:-ms-flex; display:flex'
   * ```
   */

  // we use ['',''] rather than an empty array in order to allow a pattern of .`join()`ing prefixes to test
  // values in feature detects to continue to work
  var prefixes = ModernizrProto._config.usePrefixes ? ' -webkit- -moz- -o- -ms- '.split(' ') : ['', ''];

  // expose these for the plugin API. Look in the source for how to join() them against your input
  ModernizrProto._prefixes = prefixes;

  /*!
  {
    "name": "Touch Events",
    "property": "touchevents",
    "caniuse" : "touch",
    "tags": ["media", "attribute"],
    "notes": [{
      "name": "Touch Events spec",
      "href": "https://www.w3.org/TR/2013/WD-touch-events-20130124/"
    }],
    "warnings": [
      "Indicates if the browser supports the Touch Events spec, and does not necessarily reflect a touchscreen device"
    ],
    "knownBugs": [
      "False-positive on some configurations of Nokia N900",
      "False-positive on some BlackBerry 6.0 builds  https://github.com/Modernizr/Modernizr/issues/372#issuecomment-3112695"
    ]
  }
  !*/
  /* DOC
  Indicates if the browser supports the W3C Touch Events API.

  This *does not* necessarily reflect a touchscreen device:

  * Older touchscreen devices only emulate mouse events
  * Modern IE touch devices implement the Pointer Events API instead: use `Modernizr.pointerevents` to detect support for that
  * Some browsers & OS setups may enable touch APIs when no touchscreen is connected
  * Future browsers may implement other event models for touch interactions

  See this article: [You Can't Detect A Touchscreen](http://www.stucox.com/blog/you-cant-detect-a-touchscreen/).

  It's recommended to bind both mouse and touch/pointer events simultaneously  see [this HTML5 Rocks tutorial](http://www.html5rocks.com/en/mobile/touchandmouse/).

  This test will also return `true` for Firefox 4 Multitouch support.
  */

  // Chrome (desktop) used to lie about its support on this, but that has since been rectified: http://crbug.com/36415
  Modernizr.addTest('touchevents', function () {
    var bool;
    if ('ontouchstart' in window || window.DocumentTouch && document instanceof DocumentTouch) {
      bool = true;
    } else {
      // include the 'heartz' as a way to have a non matching MQ to help terminate the join
      // https://git.io/vznFH
      var query = ['@media (', prefixes.join('touch-enabled),('), 'heartz', ')', '{#modernizr{top:9px;position:absolute}}'].join('');
      testStyles(query, function (node) {
        bool = node.offsetTop === 9;
      });
    }
    return bool;
  });

  // Run each test
  testRunner();

  // Remove the "no-js" class if it exists
  setClasses(classes);

  delete ModernizrProto.addTest;
  delete ModernizrProto.addAsyncTest;

  // Run the things that are supposed to run after the tests
  for (var i = 0; i < Modernizr._q.length; i++) {
    Modernizr._q[i]();
  }

  // Leak Modernizr namespace
  window.Modernizr = Modernizr;

  ;
})(window, document);

},{"babel-runtime/helpers/typeof":44}],35:[function(require,module,exports){
(function (global){
/*
 2017 Julian Garnier
 Released under the MIT license
*/
var $jscomp={scope:{}};$jscomp.defineProperty="function"==typeof Object.defineProperties?Object.defineProperty:function(e,r,p){if(p.get||p.set)throw new TypeError("ES3 does not support getters and setters.");e!=Array.prototype&&e!=Object.prototype&&(e[r]=p.value)};$jscomp.getGlobal=function(e){return"undefined"!=typeof window&&window===e?e:"undefined"!=typeof global&&null!=global?global:e};$jscomp.global=$jscomp.getGlobal(this);$jscomp.SYMBOL_PREFIX="jscomp_symbol_";
$jscomp.initSymbol=function(){$jscomp.initSymbol=function(){};$jscomp.global.Symbol||($jscomp.global.Symbol=$jscomp.Symbol)};$jscomp.symbolCounter_=0;$jscomp.Symbol=function(e){return $jscomp.SYMBOL_PREFIX+(e||"")+$jscomp.symbolCounter_++};
$jscomp.initSymbolIterator=function(){$jscomp.initSymbol();var e=$jscomp.global.Symbol.iterator;e||(e=$jscomp.global.Symbol.iterator=$jscomp.global.Symbol("iterator"));"function"!=typeof Array.prototype[e]&&$jscomp.defineProperty(Array.prototype,e,{configurable:!0,writable:!0,value:function(){return $jscomp.arrayIterator(this)}});$jscomp.initSymbolIterator=function(){}};$jscomp.arrayIterator=function(e){var r=0;return $jscomp.iteratorPrototype(function(){return r<e.length?{done:!1,value:e[r++]}:{done:!0}})};
$jscomp.iteratorPrototype=function(e){$jscomp.initSymbolIterator();e={next:e};e[$jscomp.global.Symbol.iterator]=function(){return this};return e};$jscomp.array=$jscomp.array||{};$jscomp.iteratorFromArray=function(e,r){$jscomp.initSymbolIterator();e instanceof String&&(e+="");var p=0,m={next:function(){if(p<e.length){var u=p++;return{value:r(u,e[u]),done:!1}}m.next=function(){return{done:!0,value:void 0}};return m.next()}};m[Symbol.iterator]=function(){return m};return m};
$jscomp.polyfill=function(e,r,p,m){if(r){p=$jscomp.global;e=e.split(".");for(m=0;m<e.length-1;m++){var u=e[m];u in p||(p[u]={});p=p[u]}e=e[e.length-1];m=p[e];r=r(m);r!=m&&null!=r&&$jscomp.defineProperty(p,e,{configurable:!0,writable:!0,value:r})}};$jscomp.polyfill("Array.prototype.keys",function(e){return e?e:function(){return $jscomp.iteratorFromArray(this,function(e){return e})}},"es6-impl","es3");var $jscomp$this=this;
(function(e,r){"function"===typeof define&&define.amd?define([],r):"object"===typeof module&&module.exports?module.exports=r():e.anime=r()})(this,function(){function e(a){if(!h.col(a))try{return document.querySelectorAll(a)}catch(c){}}function r(a,c){for(var d=a.length,b=2<=arguments.length?arguments[1]:void 0,f=[],n=0;n<d;n++)if(n in a){var k=a[n];c.call(b,k,n,a)&&f.push(k)}return f}function p(a){return a.reduce(function(a,d){return a.concat(h.arr(d)?p(d):d)},[])}function m(a){if(h.arr(a))return a;
h.str(a)&&(a=e(a)||a);return a instanceof NodeList||a instanceof HTMLCollection?[].slice.call(a):[a]}function u(a,c){return a.some(function(a){return a===c})}function C(a){var c={},d;for(d in a)c[d]=a[d];return c}function D(a,c){var d=C(a),b;for(b in a)d[b]=c.hasOwnProperty(b)?c[b]:a[b];return d}function z(a,c){var d=C(a),b;for(b in c)d[b]=h.und(a[b])?c[b]:a[b];return d}function T(a){a=a.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i,function(a,c,d,k){return c+c+d+d+k+k});var c=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(a);
a=parseInt(c[1],16);var d=parseInt(c[2],16),c=parseInt(c[3],16);return"rgba("+a+","+d+","+c+",1)"}function U(a){function c(a,c,b){0>b&&(b+=1);1<b&&--b;return b<1/6?a+6*(c-a)*b:.5>b?c:b<2/3?a+(c-a)*(2/3-b)*6:a}var d=/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(a)||/hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(a);a=parseInt(d[1])/360;var b=parseInt(d[2])/100,f=parseInt(d[3])/100,d=d[4]||1;if(0==b)f=b=a=f;else{var n=.5>f?f*(1+b):f+b-f*b,k=2*f-n,f=c(k,n,a+1/3),b=c(k,n,a);a=c(k,n,a-1/3)}return"rgba("+
255*f+","+255*b+","+255*a+","+d+")"}function y(a){if(a=/([\+\-]?[0-9#\.]+)(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(a))return a[2]}function V(a){if(-1<a.indexOf("translate")||"perspective"===a)return"px";if(-1<a.indexOf("rotate")||-1<a.indexOf("skew"))return"deg"}function I(a,c){return h.fnc(a)?a(c.target,c.id,c.total):a}function E(a,c){if(c in a.style)return getComputedStyle(a).getPropertyValue(c.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase())||"0"}function J(a,c){if(h.dom(a)&&
u(W,c))return"transform";if(h.dom(a)&&(a.getAttribute(c)||h.svg(a)&&a[c]))return"attribute";if(h.dom(a)&&"transform"!==c&&E(a,c))return"css";if(null!=a[c])return"object"}function X(a,c){var d=V(c),d=-1<c.indexOf("scale")?1:0+d;a=a.style.transform;if(!a)return d;for(var b=[],f=[],n=[],k=/(\w+)\((.+?)\)/g;b=k.exec(a);)f.push(b[1]),n.push(b[2]);a=r(n,function(a,b){return f[b]===c});return a.length?a[0]:d}function K(a,c){switch(J(a,c)){case "transform":return X(a,c);case "css":return E(a,c);case "attribute":return a.getAttribute(c)}return a[c]||
0}function L(a,c){var d=/^(\*=|\+=|-=)/.exec(a);if(!d)return a;var b=y(a)||0;c=parseFloat(c);a=parseFloat(a.replace(d[0],""));switch(d[0][0]){case "+":return c+a+b;case "-":return c-a+b;case "*":return c*a+b}}function F(a,c){return Math.sqrt(Math.pow(c.x-a.x,2)+Math.pow(c.y-a.y,2))}function M(a){a=a.points;for(var c=0,d,b=0;b<a.numberOfItems;b++){var f=a.getItem(b);0<b&&(c+=F(d,f));d=f}return c}function N(a){if(a.getTotalLength)return a.getTotalLength();switch(a.tagName.toLowerCase()){case "circle":return 2*
Math.PI*a.getAttribute("r");case "rect":return 2*a.getAttribute("width")+2*a.getAttribute("height");case "line":return F({x:a.getAttribute("x1"),y:a.getAttribute("y1")},{x:a.getAttribute("x2"),y:a.getAttribute("y2")});case "polyline":return M(a);case "polygon":var c=a.points;return M(a)+F(c.getItem(c.numberOfItems-1),c.getItem(0))}}function Y(a,c){function d(b){b=void 0===b?0:b;return a.el.getPointAtLength(1<=c+b?c+b:0)}var b=d(),f=d(-1),n=d(1);switch(a.property){case "x":return b.x;case "y":return b.y;
case "angle":return 180*Math.atan2(n.y-f.y,n.x-f.x)/Math.PI}}function O(a,c){var d=/-?\d*\.?\d+/g,b;b=h.pth(a)?a.totalLength:a;if(h.col(b))if(h.rgb(b)){var f=/rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(b);b=f?"rgba("+f[1]+",1)":b}else b=h.hex(b)?T(b):h.hsl(b)?U(b):void 0;else f=(f=y(b))?b.substr(0,b.length-f.length):b,b=c&&!/\s/g.test(b)?f+c:f;b+="";return{original:b,numbers:b.match(d)?b.match(d).map(Number):[0],strings:h.str(a)||c?b.split(d):[]}}function P(a){a=a?p(h.arr(a)?a.map(m):m(a)):[];return r(a,
function(a,d,b){return b.indexOf(a)===d})}function Z(a){var c=P(a);return c.map(function(a,b){return{target:a,id:b,total:c.length}})}function aa(a,c){var d=C(c);if(h.arr(a)){var b=a.length;2!==b||h.obj(a[0])?h.fnc(c.duration)||(d.duration=c.duration/b):a={value:a}}return m(a).map(function(a,b){b=b?0:c.delay;a=h.obj(a)&&!h.pth(a)?a:{value:a};h.und(a.delay)&&(a.delay=b);return a}).map(function(a){return z(a,d)})}function ba(a,c){var d={},b;for(b in a){var f=I(a[b],c);h.arr(f)&&(f=f.map(function(a){return I(a,
c)}),1===f.length&&(f=f[0]));d[b]=f}d.duration=parseFloat(d.duration);d.delay=parseFloat(d.delay);return d}function ca(a){return h.arr(a)?A.apply(this,a):Q[a]}function da(a,c){var d;return a.tweens.map(function(b){b=ba(b,c);var f=b.value,e=K(c.target,a.name),k=d?d.to.original:e,k=h.arr(f)?f[0]:k,w=L(h.arr(f)?f[1]:f,k),e=y(w)||y(k)||y(e);b.from=O(k,e);b.to=O(w,e);b.start=d?d.end:a.offset;b.end=b.start+b.delay+b.duration;b.easing=ca(b.easing);b.elasticity=(1E3-Math.min(Math.max(b.elasticity,1),999))/
1E3;b.isPath=h.pth(f);b.isColor=h.col(b.from.original);b.isColor&&(b.round=1);return d=b})}function ea(a,c){return r(p(a.map(function(a){return c.map(function(b){var c=J(a.target,b.name);if(c){var d=da(b,a);b={type:c,property:b.name,animatable:a,tweens:d,duration:d[d.length-1].end,delay:d[0].delay}}else b=void 0;return b})})),function(a){return!h.und(a)})}function R(a,c,d,b){var f="delay"===a;return c.length?(f?Math.min:Math.max).apply(Math,c.map(function(b){return b[a]})):f?b.delay:d.offset+b.delay+
b.duration}function fa(a){var c=D(ga,a),d=D(S,a),b=Z(a.targets),f=[],e=z(c,d),k;for(k in a)e.hasOwnProperty(k)||"targets"===k||f.push({name:k,offset:e.offset,tweens:aa(a[k],d)});a=ea(b,f);return z(c,{children:[],animatables:b,animations:a,duration:R("duration",a,c,d),delay:R("delay",a,c,d)})}function q(a){function c(){return window.Promise&&new Promise(function(a){return p=a})}function d(a){return g.reversed?g.duration-a:a}function b(a){for(var b=0,c={},d=g.animations,f=d.length;b<f;){var e=d[b],
k=e.animatable,h=e.tweens,n=h.length-1,l=h[n];n&&(l=r(h,function(b){return a<b.end})[0]||l);for(var h=Math.min(Math.max(a-l.start-l.delay,0),l.duration)/l.duration,w=isNaN(h)?1:l.easing(h,l.elasticity),h=l.to.strings,p=l.round,n=[],m=void 0,m=l.to.numbers.length,t=0;t<m;t++){var x=void 0,x=l.to.numbers[t],q=l.from.numbers[t],x=l.isPath?Y(l.value,w*x):q+w*(x-q);p&&(l.isColor&&2<t||(x=Math.round(x*p)/p));n.push(x)}if(l=h.length)for(m=h[0],w=0;w<l;w++)p=h[w+1],t=n[w],isNaN(t)||(m=p?m+(t+p):m+(t+" "));
else m=n[0];ha[e.type](k.target,e.property,m,c,k.id);e.currentValue=m;b++}if(b=Object.keys(c).length)for(d=0;d<b;d++)H||(H=E(document.body,"transform")?"transform":"-webkit-transform"),g.animatables[d].target.style[H]=c[d].join(" ");g.currentTime=a;g.progress=a/g.duration*100}function f(a){if(g[a])g[a](g)}function e(){g.remaining&&!0!==g.remaining&&g.remaining--}function k(a){var k=g.duration,n=g.offset,w=n+g.delay,r=g.currentTime,x=g.reversed,q=d(a);if(g.children.length){var u=g.children,v=u.length;
if(q>=g.currentTime)for(var G=0;G<v;G++)u[G].seek(q);else for(;v--;)u[v].seek(q)}if(q>=w||!k)g.began||(g.began=!0,f("begin")),f("run");if(q>n&&q<k)b(q);else if(q<=n&&0!==r&&(b(0),x&&e()),q>=k&&r!==k||!k)b(k),x||e();f("update");a>=k&&(g.remaining?(t=h,"alternate"===g.direction&&(g.reversed=!g.reversed)):(g.pause(),g.completed||(g.completed=!0,f("complete"),"Promise"in window&&(p(),m=c()))),l=0)}a=void 0===a?{}:a;var h,t,l=0,p=null,m=c(),g=fa(a);g.reset=function(){var a=g.direction,c=g.loop;g.currentTime=
0;g.progress=0;g.paused=!0;g.began=!1;g.completed=!1;g.reversed="reverse"===a;g.remaining="alternate"===a&&1===c?2:c;b(0);for(a=g.children.length;a--;)g.children[a].reset()};g.tick=function(a){h=a;t||(t=h);k((l+h-t)*q.speed)};g.seek=function(a){k(d(a))};g.pause=function(){var a=v.indexOf(g);-1<a&&v.splice(a,1);g.paused=!0};g.play=function(){g.paused&&(g.paused=!1,t=0,l=d(g.currentTime),v.push(g),B||ia())};g.reverse=function(){g.reversed=!g.reversed;t=0;l=d(g.currentTime)};g.restart=function(){g.pause();
g.reset();g.play()};g.finished=m;g.reset();g.autoplay&&g.play();return g}var ga={update:void 0,begin:void 0,run:void 0,complete:void 0,loop:1,direction:"normal",autoplay:!0,offset:0},S={duration:1E3,delay:0,easing:"easeOutElastic",elasticity:500,round:0},W="translateX translateY translateZ rotate rotateX rotateY rotateZ scale scaleX scaleY scaleZ skewX skewY perspective".split(" "),H,h={arr:function(a){return Array.isArray(a)},obj:function(a){return-1<Object.prototype.toString.call(a).indexOf("Object")},
pth:function(a){return h.obj(a)&&a.hasOwnProperty("totalLength")},svg:function(a){return a instanceof SVGElement},dom:function(a){return a.nodeType||h.svg(a)},str:function(a){return"string"===typeof a},fnc:function(a){return"function"===typeof a},und:function(a){return"undefined"===typeof a},hex:function(a){return/(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a)},rgb:function(a){return/^rgb/.test(a)},hsl:function(a){return/^hsl/.test(a)},col:function(a){return h.hex(a)||h.rgb(a)||h.hsl(a)}},A=function(){function a(a,
d,b){return(((1-3*b+3*d)*a+(3*b-6*d))*a+3*d)*a}return function(c,d,b,f){if(0<=c&&1>=c&&0<=b&&1>=b){var e=new Float32Array(11);if(c!==d||b!==f)for(var k=0;11>k;++k)e[k]=a(.1*k,c,b);return function(k){if(c===d&&b===f)return k;if(0===k)return 0;if(1===k)return 1;for(var h=0,l=1;10!==l&&e[l]<=k;++l)h+=.1;--l;var l=h+(k-e[l])/(e[l+1]-e[l])*.1,n=3*(1-3*b+3*c)*l*l+2*(3*b-6*c)*l+3*c;if(.001<=n){for(h=0;4>h;++h){n=3*(1-3*b+3*c)*l*l+2*(3*b-6*c)*l+3*c;if(0===n)break;var m=a(l,c,b)-k,l=l-m/n}k=l}else if(0===
n)k=l;else{var l=h,h=h+.1,g=0;do m=l+(h-l)/2,n=a(m,c,b)-k,0<n?h=m:l=m;while(1e-7<Math.abs(n)&&10>++g);k=m}return a(k,d,f)}}}}(),Q=function(){function a(a,b){return 0===a||1===a?a:-Math.pow(2,10*(a-1))*Math.sin(2*(a-1-b/(2*Math.PI)*Math.asin(1))*Math.PI/b)}var c="Quad Cubic Quart Quint Sine Expo Circ Back Elastic".split(" "),d={In:[[.55,.085,.68,.53],[.55,.055,.675,.19],[.895,.03,.685,.22],[.755,.05,.855,.06],[.47,0,.745,.715],[.95,.05,.795,.035],[.6,.04,.98,.335],[.6,-.28,.735,.045],a],Out:[[.25,
.46,.45,.94],[.215,.61,.355,1],[.165,.84,.44,1],[.23,1,.32,1],[.39,.575,.565,1],[.19,1,.22,1],[.075,.82,.165,1],[.175,.885,.32,1.275],function(b,c){return 1-a(1-b,c)}],InOut:[[.455,.03,.515,.955],[.645,.045,.355,1],[.77,0,.175,1],[.86,0,.07,1],[.445,.05,.55,.95],[1,0,0,1],[.785,.135,.15,.86],[.68,-.55,.265,1.55],function(b,c){return.5>b?a(2*b,c)/2:1-a(-2*b+2,c)/2}]},b={linear:A(.25,.25,.75,.75)},f={},e;for(e in d)f.type=e,d[f.type].forEach(function(a){return function(d,f){b["ease"+a.type+c[f]]=h.fnc(d)?
d:A.apply($jscomp$this,d)}}(f)),f={type:f.type};return b}(),ha={css:function(a,c,d){return a.style[c]=d},attribute:function(a,c,d){return a.setAttribute(c,d)},object:function(a,c,d){return a[c]=d},transform:function(a,c,d,b,f){b[f]||(b[f]=[]);b[f].push(c+"("+d+")")}},v=[],B=0,ia=function(){function a(){B=requestAnimationFrame(c)}function c(c){var b=v.length;if(b){for(var d=0;d<b;)v[d]&&v[d].tick(c),d++;a()}else cancelAnimationFrame(B),B=0}return a}();q.version="2.2.0";q.speed=1;q.running=v;q.remove=
function(a){a=P(a);for(var c=v.length;c--;)for(var d=v[c],b=d.animations,f=b.length;f--;)u(a,b[f].animatable.target)&&(b.splice(f,1),b.length||d.pause())};q.getValue=K;q.path=function(a,c){var d=h.str(a)?e(a)[0]:a,b=c||100;return function(a){return{el:d,property:a,totalLength:N(d)*(b/100)}}};q.setDashoffset=function(a){var c=N(a);a.setAttribute("stroke-dasharray",c);return c};q.bezier=A;q.easings=Q;q.timeline=function(a){var c=q(a);c.pause();c.duration=0;c.add=function(d){c.children.forEach(function(a){a.began=
!0;a.completed=!0});m(d).forEach(function(b){var d=z(b,D(S,a||{}));d.targets=d.targets||a.targets;b=c.duration;var e=d.offset;d.autoplay=!1;d.direction=c.direction;d.offset=h.und(e)?b:L(e,b);c.began=!0;c.completed=!0;c.seek(d.offset);d=q(d);d.began=!0;d.completed=!0;d.duration>b&&(c.duration=d.duration);c.children.push(d)});c.seek(0);c.reset();c.autoplay&&c.restart();return c};return c};q.random=function(a,c){return Math.floor(Math.random()*(c-a+1))+a};return q});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],36:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/array/from"), __esModule: true };
},{"core-js/library/fn/array/from":46}],37:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/math/sign"), __esModule: true };
},{"core-js/library/fn/math/sign":47}],38:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/math/trunc"), __esModule: true };
},{"core-js/library/fn/math/trunc":48}],39:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/number/is-nan"), __esModule: true };
},{"core-js/library/fn/number/is-nan":49}],40:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/number/max-safe-integer"), __esModule: true };
},{"core-js/library/fn/number/max-safe-integer":50}],41:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/assign"), __esModule: true };
},{"core-js/library/fn/object/assign":51}],42:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol"), __esModule: true };
},{"core-js/library/fn/symbol":52}],43:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol/iterator"), __esModule: true };
},{"core-js/library/fn/symbol/iterator":53}],44:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _iterator = require("../core-js/symbol/iterator");

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = require("../core-js/symbol");

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};
},{"../core-js/symbol":42,"../core-js/symbol/iterator":43}],45:[function(require,module,exports){
!function(e,t){if("function"==typeof define&&define.amd)define(["exports"],t);else if("undefined"!=typeof exports)t(exports);else{var o={};t(o),e.bodyScrollLock=o}}(this,function(exports){"use strict";function r(e){if(Array.isArray(e)){for(var t=0,o=Array(e.length);t<e.length;t++)o[t]=e[t];return o}return Array.from(e)}Object.defineProperty(exports,"__esModule",{value:!0});var l=!1;if("undefined"!=typeof window){var e={get passive(){l=!0}};window.addEventListener("testPassive",null,e),window.removeEventListener("testPassive",null,e)}var d="undefined"!=typeof window&&window.navigator&&window.navigator.platform&&/iP(ad|hone|od)/.test(window.navigator.platform),c=[],u=!1,a=-1,s=void 0,v=void 0,f=function(t){return c.some(function(e){return!(!e.options.allowTouchMove||!e.options.allowTouchMove(t))})},m=function(e){var t=e||window.event;return!!f(t.target)||(1<t.touches.length||(t.preventDefault&&t.preventDefault(),!1))},o=function(){setTimeout(function(){void 0!==v&&(document.body.style.paddingRight=v,v=void 0),void 0!==s&&(document.body.style.overflow=s,s=void 0)})};exports.disableBodyScroll=function(i,e){if(d){if(!i)return void console.error("disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.");if(i&&!c.some(function(e){return e.targetElement===i})){var t={targetElement:i,options:e||{}};c=[].concat(r(c),[t]),i.ontouchstart=function(e){1===e.targetTouches.length&&(a=e.targetTouches[0].clientY)},i.ontouchmove=function(e){var t,o,n,r;1===e.targetTouches.length&&(o=i,r=(t=e).targetTouches[0].clientY-a,!f(t.target)&&(o&&0===o.scrollTop&&0<r?m(t):(n=o)&&n.scrollHeight-n.scrollTop<=n.clientHeight&&r<0?m(t):t.stopPropagation()))},u||(document.addEventListener("touchmove",m,l?{passive:!1}:void 0),u=!0)}}else{n=e,setTimeout(function(){if(void 0===v){var e=!!n&&!0===n.reserveScrollBarGap,t=window.innerWidth-document.documentElement.clientWidth;e&&0<t&&(v=document.body.style.paddingRight,document.body.style.paddingRight=t+"px")}void 0===s&&(s=document.body.style.overflow,document.body.style.overflow="hidden")});var o={targetElement:i,options:e||{}};c=[].concat(r(c),[o])}var n},exports.clearAllBodyScrollLocks=function(){d?(c.forEach(function(e){e.targetElement.ontouchstart=null,e.targetElement.ontouchmove=null}),u&&(document.removeEventListener("touchmove",m,l?{passive:!1}:void 0),u=!1),c=[],a=-1):(o(),c=[])},exports.enableBodyScroll=function(t){if(d){if(!t)return void console.error("enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.");t.ontouchstart=null,t.ontouchmove=null,c=c.filter(function(e){return e.targetElement!==t}),u&&0===c.length&&(document.removeEventListener("touchmove",m,l?{passive:!1}:void 0),u=!1)}else 1===c.length&&c[0].targetElement===t?(o(),c=[]):c=c.filter(function(e){return e.targetElement!==t})}});

},{}],46:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/es6.array.from');
module.exports = require('../../modules/_core').Array.from;

},{"../../modules/_core":60,"../../modules/es6.array.from":117,"../../modules/es6.string.iterator":125}],47:[function(require,module,exports){
require('../../modules/es6.math.sign');
module.exports = require('../../modules/_core').Math.sign;

},{"../../modules/_core":60,"../../modules/es6.math.sign":119}],48:[function(require,module,exports){
require('../../modules/es6.math.trunc');
module.exports = require('../../modules/_core').Math.trunc;

},{"../../modules/_core":60,"../../modules/es6.math.trunc":120}],49:[function(require,module,exports){
require('../../modules/es6.number.is-nan');
module.exports = require('../../modules/_core').Number.isNaN;

},{"../../modules/_core":60,"../../modules/es6.number.is-nan":121}],50:[function(require,module,exports){
require('../../modules/es6.number.max-safe-integer');
module.exports = 0x1fffffffffffff;

},{"../../modules/es6.number.max-safe-integer":122}],51:[function(require,module,exports){
require('../../modules/es6.object.assign');
module.exports = require('../../modules/_core').Object.assign;

},{"../../modules/_core":60,"../../modules/es6.object.assign":123}],52:[function(require,module,exports){
require('../../modules/es6.symbol');
require('../../modules/es6.object.to-string');
require('../../modules/es7.symbol.async-iterator');
require('../../modules/es7.symbol.observable');
module.exports = require('../../modules/_core').Symbol;

},{"../../modules/_core":60,"../../modules/es6.object.to-string":124,"../../modules/es6.symbol":126,"../../modules/es7.symbol.async-iterator":127,"../../modules/es7.symbol.observable":128}],53:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/web.dom.iterable');
module.exports = require('../../modules/_wks-ext').f('iterator');

},{"../../modules/_wks-ext":114,"../../modules/es6.string.iterator":125,"../../modules/web.dom.iterable":129}],54:[function(require,module,exports){
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],55:[function(require,module,exports){
module.exports = function () { /* empty */ };

},{}],56:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":78}],57:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-absolute-index":106,"./_to-iobject":108,"./_to-length":109}],58:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":59,"./_wks":115}],59:[function(require,module,exports){
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],60:[function(require,module,exports){
var core = module.exports = { version: '2.6.5' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],61:[function(require,module,exports){
'use strict';
var $defineProperty = require('./_object-dp');
var createDesc = require('./_property-desc');

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};

},{"./_object-dp":90,"./_property-desc":100}],62:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":54}],63:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],64:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":69}],65:[function(require,module,exports){
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_global":70,"./_is-object":78}],66:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],67:[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};

},{"./_object-gops":95,"./_object-keys":98,"./_object-pie":99}],68:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var ctx = require('./_ctx');
var hide = require('./_hide');
var has = require('./_has');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_core":60,"./_ctx":62,"./_global":70,"./_has":71,"./_hide":72}],69:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],70:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],71:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],72:[function(require,module,exports){
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_descriptors":64,"./_object-dp":90,"./_property-desc":100}],73:[function(require,module,exports){
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":70}],74:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":64,"./_dom-create":65,"./_fails":69}],75:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":59}],76:[function(require,module,exports){
// check on default Array iterator
var Iterators = require('./_iterators');
var ITERATOR = require('./_wks')('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"./_iterators":84,"./_wks":115}],77:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

},{"./_cof":59}],78:[function(require,module,exports){
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],79:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

},{"./_an-object":56}],80:[function(require,module,exports){
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_hide":72,"./_object-create":89,"./_property-desc":100,"./_set-to-string-tag":102,"./_wks":115}],81:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_export":68,"./_hide":72,"./_iter-create":80,"./_iterators":84,"./_library":85,"./_object-gpo":96,"./_redefine":101,"./_set-to-string-tag":102,"./_wks":115}],82:[function(require,module,exports){
var ITERATOR = require('./_wks')('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

},{"./_wks":115}],83:[function(require,module,exports){
module.exports = function (done, value) {
  return { value: value, done: !!done };
};

},{}],84:[function(require,module,exports){
module.exports = {};

},{}],85:[function(require,module,exports){
module.exports = true;

},{}],86:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

},{}],87:[function(require,module,exports){
var META = require('./_uid')('meta');
var isObject = require('./_is-object');
var has = require('./_has');
var setDesc = require('./_object-dp').f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !require('./_fails')(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

},{"./_fails":69,"./_has":71,"./_is-object":78,"./_object-dp":90,"./_uid":112}],88:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;

},{"./_fails":69,"./_iobject":75,"./_object-gops":95,"./_object-keys":98,"./_object-pie":99,"./_to-object":110}],89:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":56,"./_dom-create":65,"./_enum-bug-keys":66,"./_html":73,"./_object-dps":91,"./_shared-key":103}],90:[function(require,module,exports){
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":56,"./_descriptors":64,"./_ie8-dom-define":74,"./_to-primitive":111}],91:[function(require,module,exports){
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"./_an-object":56,"./_descriptors":64,"./_object-dp":90,"./_object-keys":98}],92:[function(require,module,exports){
var pIE = require('./_object-pie');
var createDesc = require('./_property-desc');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var has = require('./_has');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"./_descriptors":64,"./_has":71,"./_ie8-dom-define":74,"./_object-pie":99,"./_property-desc":100,"./_to-iobject":108,"./_to-primitive":111}],93:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject');
var gOPN = require('./_object-gopn').f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":94,"./_to-iobject":108}],94:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = require('./_object-keys-internal');
var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

},{"./_enum-bug-keys":66,"./_object-keys-internal":97}],95:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;

},{}],96:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"./_has":71,"./_shared-key":103,"./_to-object":110}],97:[function(require,module,exports){
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_array-includes":57,"./_has":71,"./_shared-key":103,"./_to-iobject":108}],98:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_enum-bug-keys":66,"./_object-keys-internal":97}],99:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;

},{}],100:[function(require,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],101:[function(require,module,exports){
module.exports = require('./_hide');

},{"./_hide":72}],102:[function(require,module,exports){
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"./_has":71,"./_object-dp":90,"./_wks":115}],103:[function(require,module,exports){
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":104,"./_uid":112}],104:[function(require,module,exports){
var core = require('./_core');
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: require('./_library') ? 'pure' : 'global',
  copyright: ' 2019 Denis Pushkarev (zloirock.ru)'
});

},{"./_core":60,"./_global":70,"./_library":85}],105:[function(require,module,exports){
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"./_defined":63,"./_to-integer":107}],106:[function(require,module,exports){
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":107}],107:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],108:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_defined":63,"./_iobject":75}],109:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":107}],110:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":63}],111:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":78}],112:[function(require,module,exports){
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],113:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var LIBRARY = require('./_library');
var wksExt = require('./_wks-ext');
var defineProperty = require('./_object-dp').f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

},{"./_core":60,"./_global":70,"./_library":85,"./_object-dp":90,"./_wks-ext":114}],114:[function(require,module,exports){
exports.f = require('./_wks');

},{"./_wks":115}],115:[function(require,module,exports){
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_global":70,"./_shared":104,"./_uid":112}],116:[function(require,module,exports){
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"./_classof":58,"./_core":60,"./_iterators":84,"./_wks":115}],117:[function(require,module,exports){
'use strict';
var ctx = require('./_ctx');
var $export = require('./_export');
var toObject = require('./_to-object');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var toLength = require('./_to-length');
var createProperty = require('./_create-property');
var getIterFn = require('./core.get-iterator-method');

$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"./_create-property":61,"./_ctx":62,"./_export":68,"./_is-array-iter":76,"./_iter-call":79,"./_iter-detect":82,"./_to-length":109,"./_to-object":110,"./core.get-iterator-method":116}],118:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables');
var step = require('./_iter-step');
var Iterators = require('./_iterators');
var toIObject = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"./_add-to-unscopables":55,"./_iter-define":81,"./_iter-step":83,"./_iterators":84,"./_to-iobject":108}],119:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
var $export = require('./_export');

$export($export.S, 'Math', { sign: require('./_math-sign') });

},{"./_export":68,"./_math-sign":86}],120:[function(require,module,exports){
// 20.2.2.34 Math.trunc(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

},{"./_export":68}],121:[function(require,module,exports){
// 20.1.2.4 Number.isNaN(number)
var $export = require('./_export');

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

},{"./_export":68}],122:[function(require,module,exports){
// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });

},{"./_export":68}],123:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });

},{"./_export":68,"./_object-assign":88}],124:[function(require,module,exports){

},{}],125:[function(require,module,exports){
'use strict';
var $at = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

},{"./_iter-define":81,"./_string-at":105}],126:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global = require('./_global');
var has = require('./_has');
var DESCRIPTORS = require('./_descriptors');
var $export = require('./_export');
var redefine = require('./_redefine');
var META = require('./_meta').KEY;
var $fails = require('./_fails');
var shared = require('./_shared');
var setToStringTag = require('./_set-to-string-tag');
var uid = require('./_uid');
var wks = require('./_wks');
var wksExt = require('./_wks-ext');
var wksDefine = require('./_wks-define');
var enumKeys = require('./_enum-keys');
var isArray = require('./_is-array');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var createDesc = require('./_property-desc');
var _create = require('./_object-create');
var gOPNExt = require('./_object-gopn-ext');
var $GOPD = require('./_object-gopd');
var $DP = require('./_object-dp');
var $keys = require('./_object-keys');
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f = $propertyIsEnumerable;
  require('./_object-gops').f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !require('./_library')) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

},{"./_an-object":56,"./_descriptors":64,"./_enum-keys":67,"./_export":68,"./_fails":69,"./_global":70,"./_has":71,"./_hide":72,"./_is-array":77,"./_is-object":78,"./_library":85,"./_meta":87,"./_object-create":89,"./_object-dp":90,"./_object-gopd":92,"./_object-gopn":94,"./_object-gopn-ext":93,"./_object-gops":95,"./_object-keys":98,"./_object-pie":99,"./_property-desc":100,"./_redefine":101,"./_set-to-string-tag":102,"./_shared":104,"./_to-iobject":108,"./_to-primitive":111,"./_uid":112,"./_wks":115,"./_wks-define":113,"./_wks-ext":114}],127:[function(require,module,exports){
require('./_wks-define')('asyncIterator');

},{"./_wks-define":113}],128:[function(require,module,exports){
require('./_wks-define')('observable');

},{"./_wks-define":113}],129:[function(require,module,exports){
require('./es6.array.iterator');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var TO_STRING_TAG = require('./_wks')('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}

},{"./_global":70,"./_hide":72,"./_iterators":84,"./_wks":115,"./es6.array.iterator":118}],130:[function(require,module,exports){
/* flatpickr v4.5.7, @license MIT */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = global || self, global.flatpickr = factory());
}(this, function () { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    var HOOKS = [
        "onChange",
        "onClose",
        "onDayCreate",
        "onDestroy",
        "onKeyDown",
        "onMonthChange",
        "onOpen",
        "onParseConfig",
        "onReady",
        "onValueUpdate",
        "onYearChange",
        "onPreCalendarPosition",
    ];
    var defaults = {
        _disable: [],
        _enable: [],
        allowInput: false,
        altFormat: "F j, Y",
        altInput: false,
        altInputClass: "form-control input",
        animate: typeof window === "object" &&
            window.navigator.userAgent.indexOf("MSIE") === -1,
        ariaDateFormat: "F j, Y",
        clickOpens: true,
        closeOnSelect: true,
        conjunction: ", ",
        dateFormat: "Y-m-d",
        defaultHour: 12,
        defaultMinute: 0,
        defaultSeconds: 0,
        disable: [],
        disableMobile: false,
        enable: [],
        enableSeconds: false,
        enableTime: false,
        errorHandler: function (err) {
            return typeof console !== "undefined" && console.warn(err);
        },
        getWeek: function (givenDate) {
            var date = new Date(givenDate.getTime());
            date.setHours(0, 0, 0, 0);
            // Thursday in current week decides the year.
            date.setDate(date.getDate() + 3 - ((date.getDay() + 6) % 7));
            // January 4 is always in week 1.
            var week1 = new Date(date.getFullYear(), 0, 4);
            // Adjust to Thursday in week 1 and count number of weeks from date to week1.
            return (1 +
                Math.round(((date.getTime() - week1.getTime()) / 86400000 -
                    3 +
                    ((week1.getDay() + 6) % 7)) /
                    7));
        },
        hourIncrement: 1,
        ignoredFocusElements: [],
        inline: false,
        locale: "default",
        minuteIncrement: 5,
        mode: "single",
        nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
        noCalendar: false,
        now: new Date(),
        onChange: [],
        onClose: [],
        onDayCreate: [],
        onDestroy: [],
        onKeyDown: [],
        onMonthChange: [],
        onOpen: [],
        onParseConfig: [],
        onReady: [],
        onValueUpdate: [],
        onYearChange: [],
        onPreCalendarPosition: [],
        plugins: [],
        position: "auto",
        positionElement: undefined,
        prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
        shorthandCurrentMonth: false,
        showMonths: 1,
        static: false,
        time_24hr: false,
        weekNumbers: false,
        wrap: false
    };

    var english = {
        weekdays: {
            shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            longhand: [
                "Sunday",
                "Monday",
                "Tuesday",
                "Wednesday",
                "Thursday",
                "Friday",
                "Saturday",
            ]
        },
        months: {
            shorthand: [
                "Jan",
                "Feb",
                "Mar",
                "Apr",
                "May",
                "Jun",
                "Jul",
                "Aug",
                "Sep",
                "Oct",
                "Nov",
                "Dec",
            ],
            longhand: [
                "January",
                "February",
                "March",
                "April",
                "May",
                "June",
                "July",
                "August",
                "September",
                "October",
                "November",
                "December",
            ]
        },
        daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        firstDayOfWeek: 0,
        ordinal: function (nth) {
            var s = nth % 100;
            if (s > 3 && s < 21)
                return "th";
            switch (s % 10) {
                case 1:
                    return "st";
                case 2:
                    return "nd";
                case 3:
                    return "rd";
                default:
                    return "th";
            }
        },
        rangeSeparator: " to ",
        weekAbbreviation: "Wk",
        scrollTitle: "Scroll to increment",
        toggleTitle: "Click to toggle",
        amPM: ["AM", "PM"],
        yearAriaLabel: "Year"
    };

    var pad = function (number) { return ("0" + number).slice(-2); };
    var int = function (bool) { return (bool === true ? 1 : 0); };
    /* istanbul ignore next */
    function debounce(func, wait, immediate) {
        if (immediate === void 0) { immediate = false; }
        var timeout;
        return function () {
            var context = this, args = arguments;
            timeout !== null && clearTimeout(timeout);
            timeout = window.setTimeout(function () {
                timeout = null;
                if (!immediate)
                    func.apply(context, args);
            }, wait);
            if (immediate && !timeout)
                func.apply(context, args);
        };
    }
    var arrayify = function (obj) {
        return obj instanceof Array ? obj : [obj];
    };

    function toggleClass(elem, className, bool) {
        if (bool === true)
            return elem.classList.add(className);
        elem.classList.remove(className);
    }
    function createElement(tag, className, content) {
        var e = window.document.createElement(tag);
        className = className || "";
        content = content || "";
        e.className = className;
        if (content !== undefined)
            e.textContent = content;
        return e;
    }
    function clearNode(node) {
        while (node.firstChild)
            node.removeChild(node.firstChild);
    }
    function findParent(node, condition) {
        if (condition(node))
            return node;
        else if (node.parentNode)
            return findParent(node.parentNode, condition);
        return undefined; // nothing found
    }
    function createNumberInput(inputClassName, opts) {
        var wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
        if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
            numInput.type = "number";
        }
        else {
            numInput.type = "text";
            numInput.pattern = "\\d*";
        }
        if (opts !== undefined)
            for (var key in opts)
                numInput.setAttribute(key, opts[key]);
        wrapper.appendChild(numInput);
        wrapper.appendChild(arrowUp);
        wrapper.appendChild(arrowDown);
        return wrapper;
    }
    function getEventTarget(event) {
        if (typeof event.composedPath === "function") {
            var path = event.composedPath();
            return path[0];
        }
        return event.target;
    }

    var do_nothing = function () { return undefined; };
    var monthToStr = function (monthNumber, shorthand, locale) { return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber]; };
    var revFormat = {
        D: do_nothing,
        F: function (dateObj, monthName, locale) {
            dateObj.setMonth(locale.months.longhand.indexOf(monthName));
        },
        G: function (dateObj, hour) {
            dateObj.setHours(parseFloat(hour));
        },
        H: function (dateObj, hour) {
            dateObj.setHours(parseFloat(hour));
        },
        J: function (dateObj, day) {
            dateObj.setDate(parseFloat(day));
        },
        K: function (dateObj, amPM, locale) {
            dateObj.setHours((dateObj.getHours() % 12) +
                12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
        },
        M: function (dateObj, shortMonth, locale) {
            dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
        },
        S: function (dateObj, seconds) {
            dateObj.setSeconds(parseFloat(seconds));
        },
        U: function (_, unixSeconds) { return new Date(parseFloat(unixSeconds) * 1000); },
        W: function (dateObj, weekNum) {
            var weekNumber = parseInt(weekNum);
            return new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
        },
        Y: function (dateObj, year) {
            dateObj.setFullYear(parseFloat(year));
        },
        Z: function (_, ISODate) { return new Date(ISODate); },
        d: function (dateObj, day) {
            dateObj.setDate(parseFloat(day));
        },
        h: function (dateObj, hour) {
            dateObj.setHours(parseFloat(hour));
        },
        i: function (dateObj, minutes) {
            dateObj.setMinutes(parseFloat(minutes));
        },
        j: function (dateObj, day) {
            dateObj.setDate(parseFloat(day));
        },
        l: do_nothing,
        m: function (dateObj, month) {
            dateObj.setMonth(parseFloat(month) - 1);
        },
        n: function (dateObj, month) {
            dateObj.setMonth(parseFloat(month) - 1);
        },
        s: function (dateObj, seconds) {
            dateObj.setSeconds(parseFloat(seconds));
        },
        u: function (_, unixMillSeconds) {
            return new Date(parseFloat(unixMillSeconds));
        },
        w: do_nothing,
        y: function (dateObj, year) {
            dateObj.setFullYear(2000 + parseFloat(year));
        }
    };
    var tokenRegex = {
        D: "(\\w+)",
        F: "(\\w+)",
        G: "(\\d\\d|\\d)",
        H: "(\\d\\d|\\d)",
        J: "(\\d\\d|\\d)\\w+",
        K: "",
        M: "(\\w+)",
        S: "(\\d\\d|\\d)",
        U: "(.+)",
        W: "(\\d\\d|\\d)",
        Y: "(\\d{4})",
        Z: "(.+)",
        d: "(\\d\\d|\\d)",
        h: "(\\d\\d|\\d)",
        i: "(\\d\\d|\\d)",
        j: "(\\d\\d|\\d)",
        l: "(\\w+)",
        m: "(\\d\\d|\\d)",
        n: "(\\d\\d|\\d)",
        s: "(\\d\\d|\\d)",
        u: "(.+)",
        w: "(\\d\\d|\\d)",
        y: "(\\d{2})"
    };
    var formats = {
        // get the date in UTC
        Z: function (date) { return date.toISOString(); },
        // weekday name, short, e.g. Thu
        D: function (date, locale, options) {
            return locale.weekdays.shorthand[formats.w(date, locale, options)];
        },
        // full month name e.g. January
        F: function (date, locale, options) {
            return monthToStr(formats.n(date, locale, options) - 1, false, locale);
        },
        // padded hour 1-12
        G: function (date, locale, options) {
            return pad(formats.h(date, locale, options));
        },
        // hours with leading zero e.g. 03
        H: function (date) { return pad(date.getHours()); },
        // day (1-30) with ordinal suffix e.g. 1st, 2nd
        J: function (date, locale) {
            return locale.ordinal !== undefined
                ? date.getDate() + locale.ordinal(date.getDate())
                : date.getDate();
        },
        // AM/PM
        K: function (date, locale) { return locale.amPM[int(date.getHours() > 11)]; },
        // shorthand month e.g. Jan, Sep, Oct, etc
        M: function (date, locale) {
            return monthToStr(date.getMonth(), true, locale);
        },
        // seconds 00-59
        S: function (date) { return pad(date.getSeconds()); },
        // unix timestamp
        U: function (date) { return date.getTime() / 1000; },
        W: function (date, _, options) {
            return options.getWeek(date);
        },
        // full year e.g. 2016
        Y: function (date) { return date.getFullYear(); },
        // day in month, padded (01-30)
        d: function (date) { return pad(date.getDate()); },
        // hour from 1-12 (am/pm)
        h: function (date) { return (date.getHours() % 12 ? date.getHours() % 12 : 12); },
        // minutes, padded with leading zero e.g. 09
        i: function (date) { return pad(date.getMinutes()); },
        // day in month (1-30)
        j: function (date) { return date.getDate(); },
        // weekday name, full, e.g. Thursday
        l: function (date, locale) {
            return locale.weekdays.longhand[date.getDay()];
        },
        // padded month number (01-12)
        m: function (date) { return pad(date.getMonth() + 1); },
        // the month number (1-12)
        n: function (date) { return date.getMonth() + 1; },
        // seconds 0-59
        s: function (date) { return date.getSeconds(); },
        // Unix Milliseconds
        u: function (date) { return date.getTime(); },
        // number of the day of the week
        w: function (date) { return date.getDay(); },
        // last two digits of year e.g. 16 for 2016
        y: function (date) { return String(date.getFullYear()).substring(2); }
    };

    var createDateFormatter = function (_a) {
        var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;
        return function (dateObj, frmt, overrideLocale) {
            var locale = overrideLocale || l10n;
            if (config.formatDate !== undefined) {
                return config.formatDate(dateObj, frmt, locale);
            }
            return frmt
                .split("")
                .map(function (c, i, arr) {
                return formats[c] && arr[i - 1] !== "\\"
                    ? formats[c](dateObj, locale, config)
                    : c !== "\\"
                        ? c
                        : "";
            })
                .join("");
        };
    };
    var createDateParser = function (_a) {
        var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;
        return function (date, givenFormat, timeless, customLocale) {
            if (date !== 0 && !date)
                return undefined;
            var locale = customLocale || l10n;
            var parsedDate;
            var date_orig = date;
            if (date instanceof Date)
                parsedDate = new Date(date.getTime());
            else if (typeof date !== "string" &&
                date.toFixed !== undefined // timestamp
            )
                // create a copy
                parsedDate = new Date(date);
            else if (typeof date === "string") {
                // date string
                var format = givenFormat || (config || defaults).dateFormat;
                var datestr = String(date).trim();
                if (datestr === "today") {
                    parsedDate = new Date();
                    timeless = true;
                }
                else if (/Z$/.test(datestr) ||
                    /GMT$/.test(datestr) // datestrings w/ timezone
                )
                    parsedDate = new Date(date);
                else if (config && config.parseDate)
                    parsedDate = config.parseDate(date, format);
                else {
                    parsedDate =
                        !config || !config.noCalendar
                            ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0)
                            : new Date(new Date().setHours(0, 0, 0, 0));
                    var matched = void 0, ops = [];
                    for (var i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
                        var token_1 = format[i];
                        var isBackSlash = token_1 === "\\";
                        var escaped = format[i - 1] === "\\" || isBackSlash;
                        if (tokenRegex[token_1] && !escaped) {
                            regexStr += tokenRegex[token_1];
                            var match = new RegExp(regexStr).exec(date);
                            if (match && (matched = true)) {
                                ops[token_1 !== "Y" ? "push" : "unshift"]({
                                    fn: revFormat[token_1],
                                    val: match[++matchIndex]
                                });
                            }
                        }
                        else if (!isBackSlash)
                            regexStr += "."; // don't really care
                        ops.forEach(function (_a) {
                            var fn = _a.fn, val = _a.val;
                            return (parsedDate = fn(parsedDate, val, locale) || parsedDate);
                        });
                    }
                    parsedDate = matched ? parsedDate : undefined;
                }
            }
            /* istanbul ignore next */
            if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
                config.errorHandler(new Error("Invalid date provided: " + date_orig));
                return undefined;
            }
            if (timeless === true)
                parsedDate.setHours(0, 0, 0, 0);
            return parsedDate;
        };
    };
    /**
     * Compute the difference in dates, measured in ms
     */
    function compareDates(date1, date2, timeless) {
        if (timeless === void 0) { timeless = true; }
        if (timeless !== false) {
            return (new Date(date1.getTime()).setHours(0, 0, 0, 0) -
                new Date(date2.getTime()).setHours(0, 0, 0, 0));
        }
        return date1.getTime() - date2.getTime();
    }
    var isBetween = function (ts, ts1, ts2) {
        return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
    };
    var duration = {
        DAY: 86400000
    };

    if (typeof Object.assign !== "function") {
        Object.assign = function (target) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (!target) {
                throw TypeError("Cannot convert undefined or null to object");
            }
            var _loop_1 = function (source) {
                if (source) {
                    Object.keys(source).forEach(function (key) { return (target[key] = source[key]); });
                }
            };
            for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
                var source = args_1[_a];
                _loop_1(source);
            }
            return target;
        };
    }

    var DEBOUNCED_CHANGE_MS = 300;
    function FlatpickrInstance(element, instanceConfig) {
        var self = {
            config: __assign({}, flatpickr.defaultConfig),
            l10n: english
        };
        self.parseDate = createDateParser({ config: self.config, l10n: self.l10n });
        self._handlers = [];
        self._bind = bind;
        self._setHoursFromDate = setHoursFromDate;
        self._positionCalendar = positionCalendar;
        self.changeMonth = changeMonth;
        self.changeYear = changeYear;
        self.clear = clear;
        self.close = close;
        self._createElement = createElement;
        self.destroy = destroy;
        self.isEnabled = isEnabled;
        self.jumpToDate = jumpToDate;
        self.open = open;
        self.redraw = redraw;
        self.set = set;
        self.setDate = setDate;
        self.toggle = toggle;
        function setupHelperFunctions() {
            self.utils = {
                getDaysInMonth: function (month, yr) {
                    if (month === void 0) { month = self.currentMonth; }
                    if (yr === void 0) { yr = self.currentYear; }
                    if (month === 1 && ((yr % 4 === 0 && yr % 100 !== 0) || yr % 400 === 0))
                        return 29;
                    return self.l10n.daysInMonth[month];
                }
            };
        }
        function init() {
            self.element = self.input = element;
            self.isOpen = false;
            parseConfig();
            setupLocale();
            setupInputs();
            setupDates();
            setupHelperFunctions();
            if (!self.isMobile)
                build();
            bindEvents();
            if (self.selectedDates.length || self.config.noCalendar) {
                if (self.config.enableTime) {
                    setHoursFromDate(self.config.noCalendar
                        ? self.latestSelectedDateObj || self.config.minDate
                        : undefined);
                }
                updateValue(false);
            }
            setCalendarWidth();
            self.showTimeInput =
                self.selectedDates.length > 0 || self.config.noCalendar;
            var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
            /* TODO: investigate this further

              Currently, there is weird positioning behavior in safari causing pages
              to scroll up. https://github.com/chmln/flatpickr/issues/563

              However, most browsers are not Safari and positioning is expensive when used
              in scale. https://github.com/chmln/flatpickr/issues/1096
            */
            if (!self.isMobile && isSafari) {
                positionCalendar();
            }
            triggerEvent("onReady");
        }
        function bindToInstance(fn) {
            return fn.bind(self);
        }
        function setCalendarWidth() {
            var config = self.config;
            if (config.weekNumbers === false && config.showMonths === 1)
                return;
            else if (config.noCalendar !== true) {
                window.requestAnimationFrame(function () {
                    if (self.calendarContainer !== undefined) {
                        self.calendarContainer.style.visibility = "hidden";
                        self.calendarContainer.style.display = "block";
                    }
                    if (self.daysContainer !== undefined) {
                        var daysWidth = (self.days.offsetWidth + 1) * config.showMonths;
                        self.daysContainer.style.width = daysWidth + "px";
                        self.calendarContainer.style.width =
                            daysWidth +
                                (self.weekWrapper !== undefined
                                    ? self.weekWrapper.offsetWidth
                                    : 0) +
                                "px";
                        self.calendarContainer.style.removeProperty("visibility");
                        self.calendarContainer.style.removeProperty("display");
                    }
                });
            }
        }
        /**
         * The handler for all events targeting the time inputs
         */
        function updateTime(e) {
            if (self.selectedDates.length === 0) {
                setDefaultTime();
            }
            if (e !== undefined && e.type !== "blur") {
                timeWrapper(e);
            }
            var prevValue = self._input.value;
            setHoursFromInputs();
            updateValue();
            if (self._input.value !== prevValue) {
                self._debouncedChange();
            }
        }
        function ampm2military(hour, amPM) {
            return (hour % 12) + 12 * int(amPM === self.l10n.amPM[1]);
        }
        function military2ampm(hour) {
            switch (hour % 24) {
                case 0:
                case 12:
                    return 12;
                default:
                    return hour % 12;
            }
        }
        /**
         * Syncs the selected date object time with user's time input
         */
        function setHoursFromInputs() {
            if (self.hourElement === undefined || self.minuteElement === undefined)
                return;
            var hours = (parseInt(self.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60, seconds = self.secondElement !== undefined
                ? (parseInt(self.secondElement.value, 10) || 0) % 60
                : 0;
            if (self.amPM !== undefined) {
                hours = ampm2military(hours, self.amPM.textContent);
            }
            var limitMinHours = self.config.minTime !== undefined ||
                (self.config.minDate &&
                    self.minDateHasTime &&
                    self.latestSelectedDateObj &&
                    compareDates(self.latestSelectedDateObj, self.config.minDate, true) ===
                        0);
            var limitMaxHours = self.config.maxTime !== undefined ||
                (self.config.maxDate &&
                    self.maxDateHasTime &&
                    self.latestSelectedDateObj &&
                    compareDates(self.latestSelectedDateObj, self.config.maxDate, true) ===
                        0);
            if (limitMaxHours) {
                var maxTime = self.config.maxTime !== undefined
                    ? self.config.maxTime
                    : self.config.maxDate;
                hours = Math.min(hours, maxTime.getHours());
                if (hours === maxTime.getHours())
                    minutes = Math.min(minutes, maxTime.getMinutes());
                if (minutes === maxTime.getMinutes())
                    seconds = Math.min(seconds, maxTime.getSeconds());
            }
            if (limitMinHours) {
                var minTime = self.config.minTime !== undefined
                    ? self.config.minTime
                    : self.config.minDate;
                hours = Math.max(hours, minTime.getHours());
                if (hours === minTime.getHours())
                    minutes = Math.max(minutes, minTime.getMinutes());
                if (minutes === minTime.getMinutes())
                    seconds = Math.max(seconds, minTime.getSeconds());
            }
            setHours(hours, minutes, seconds);
        }
        /**
         * Syncs time input values with a date
         */
        function setHoursFromDate(dateObj) {
            var date = dateObj || self.latestSelectedDateObj;
            if (date)
                setHours(date.getHours(), date.getMinutes(), date.getSeconds());
        }
        function setDefaultHours() {
            var hours = self.config.defaultHour;
            var minutes = self.config.defaultMinute;
            var seconds = self.config.defaultSeconds;
            if (self.config.minDate !== undefined) {
                var min_hr = self.config.minDate.getHours();
                var min_minutes = self.config.minDate.getMinutes();
                hours = Math.max(hours, min_hr);
                if (hours === min_hr)
                    minutes = Math.max(min_minutes, minutes);
                if (hours === min_hr && minutes === min_minutes)
                    seconds = self.config.minDate.getSeconds();
            }
            if (self.config.maxDate !== undefined) {
                var max_hr = self.config.maxDate.getHours();
                var max_minutes = self.config.maxDate.getMinutes();
                hours = Math.min(hours, max_hr);
                if (hours === max_hr)
                    minutes = Math.min(max_minutes, minutes);
                if (hours === max_hr && minutes === max_minutes)
                    seconds = self.config.maxDate.getSeconds();
            }
            setHours(hours, minutes, seconds);
        }
        /**
         * Sets the hours, minutes, and optionally seconds
         * of the latest selected date object and the
         * corresponding time inputs
         * @param {Number} hours the hour. whether its military
         *                 or am-pm gets inferred from config
         * @param {Number} minutes the minutes
         * @param {Number} seconds the seconds (optional)
         */
        function setHours(hours, minutes, seconds) {
            if (self.latestSelectedDateObj !== undefined) {
                self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
            }
            if (!self.hourElement || !self.minuteElement || self.isMobile)
                return;
            self.hourElement.value = pad(!self.config.time_24hr
                ? ((12 + hours) % 12) + 12 * int(hours % 12 === 0)
                : hours);
            self.minuteElement.value = pad(minutes);
            if (self.amPM !== undefined)
                self.amPM.textContent = self.l10n.amPM[int(hours >= 12)];
            if (self.secondElement !== undefined)
                self.secondElement.value = pad(seconds);
        }
        /**
         * Handles the year input and incrementing events
         * @param {Event} event the keyup or increment event
         */
        function onYearInput(event) {
            var year = parseInt(event.target.value) + (event.delta || 0);
            if (year / 1000 > 1 ||
                (event.key === "Enter" && !/[^\d]/.test(year.toString()))) {
                changeYear(year);
            }
        }
        /**
         * Essentially addEventListener + tracking
         * @param {Element} element the element to addEventListener to
         * @param {String} event the event name
         * @param {Function} handler the event handler
         */
        function bind(element, event, handler, options) {
            if (event instanceof Array)
                return event.forEach(function (ev) { return bind(element, ev, handler, options); });
            if (element instanceof Array)
                return element.forEach(function (el) { return bind(el, event, handler, options); });
            element.addEventListener(event, handler, options);
            self._handlers.push({
                element: element,
                event: event,
                handler: handler,
                options: options
            });
        }
        /**
         * A mousedown handler which mimics click.
         * Minimizes latency, since we don't need to wait for mouseup in most cases.
         * Also, avoids handling right clicks.
         *
         * @param {Function} handler the event handler
         */
        function onClick(handler) {
            return function (evt) {
                evt.which === 1 && handler(evt);
            };
        }
        function triggerChange() {
            triggerEvent("onChange");
        }
        /**
         * Adds all the necessary event listeners
         */
        function bindEvents() {
            if (self.config.wrap) {
                ["open", "close", "toggle", "clear"].forEach(function (evt) {
                    Array.prototype.forEach.call(self.element.querySelectorAll("[data-" + evt + "]"), function (el) {
                        return bind(el, "click", self[evt]);
                    });
                });
            }
            if (self.isMobile) {
                setupMobile();
                return;
            }
            var debouncedResize = debounce(onResize, 50);
            self._debouncedChange = debounce(triggerChange, DEBOUNCED_CHANGE_MS);
            if (self.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
                bind(self.daysContainer, "mouseover", function (e) {
                    if (self.config.mode === "range")
                        onMouseOver(e.target);
                });
            bind(window.document.body, "keydown", onKeyDown);
            if (!self.config.static)
                bind(self._input, "keydown", onKeyDown);
            if (!self.config.inline && !self.config.static)
                bind(window, "resize", debouncedResize);
            if (window.ontouchstart !== undefined)
                bind(window.document, "click", documentClick);
            else
                bind(window.document, "mousedown", onClick(documentClick));
            bind(window.document, "focus", documentClick, { capture: true });
            if (self.config.clickOpens === true) {
                bind(self._input, "focus", self.open);
                bind(self._input, "mousedown", onClick(self.open));
            }
            if (self.daysContainer !== undefined) {
                bind(self.monthNav, "mousedown", onClick(onMonthNavClick));
                bind(self.monthNav, ["keyup", "increment"], onYearInput);
                bind(self.daysContainer, "mousedown", onClick(selectDate));
            }
            if (self.timeContainer !== undefined &&
                self.minuteElement !== undefined &&
                self.hourElement !== undefined) {
                var selText = function (e) {
                    return e.target.select();
                };
                bind(self.timeContainer, ["increment"], updateTime);
                bind(self.timeContainer, "blur", updateTime, { capture: true });
                bind(self.timeContainer, "mousedown", onClick(timeIncrement));
                bind([self.hourElement, self.minuteElement], ["focus", "click"], selText);
                if (self.secondElement !== undefined)
                    bind(self.secondElement, "focus", function () { return self.secondElement && self.secondElement.select(); });
                if (self.amPM !== undefined) {
                    bind(self.amPM, "mousedown", onClick(function (e) {
                        updateTime(e);
                        triggerChange();
                    }));
                }
            }
        }
        /**
         * Set the calendar view to a particular date.
         * @param {Date} jumpDate the date to set the view to
         */
        function jumpToDate(jumpDate) {
            var jumpTo = jumpDate !== undefined
                ? self.parseDate(jumpDate)
                : self.latestSelectedDateObj ||
                    (self.config.minDate && self.config.minDate > self.now
                        ? self.config.minDate
                        : self.config.maxDate && self.config.maxDate < self.now
                            ? self.config.maxDate
                            : self.now);
            try {
                if (jumpTo !== undefined) {
                    self.currentYear = jumpTo.getFullYear();
                    self.currentMonth = jumpTo.getMonth();
                }
            }
            catch (e) {
                /* istanbul ignore next */
                e.message = "Invalid date supplied: " + jumpTo;
                self.config.errorHandler(e);
            }
            self.redraw();
        }
        /**
         * The up/down arrow handler for time inputs
         * @param {Event} e the click event
         */
        function timeIncrement(e) {
            if (~e.target.className.indexOf("arrow"))
                incrementNumInput(e, e.target.classList.contains("arrowUp") ? 1 : -1);
        }
        /**
         * Increments/decrements the value of input associ-
         * ated with the up/down arrow by dispatching an
         * "increment" event on the input.
         *
         * @param {Event} e the click event
         * @param {Number} delta the diff (usually 1 or -1)
         * @param {Element} inputElem the input element
         */
        function incrementNumInput(e, delta, inputElem) {
            var target = e && e.target;
            var input = inputElem ||
                (target && target.parentNode && target.parentNode.firstChild);
            var event = createEvent("increment");
            event.delta = delta;
            input && input.dispatchEvent(event);
        }
        function build() {
            var fragment = window.document.createDocumentFragment();
            self.calendarContainer = createElement("div", "flatpickr-calendar");
            self.calendarContainer.tabIndex = -1;
            if (!self.config.noCalendar) {
                fragment.appendChild(buildMonthNav());
                self.innerContainer = createElement("div", "flatpickr-innerContainer");
                if (self.config.weekNumbers) {
                    var _a = buildWeeks(), weekWrapper = _a.weekWrapper, weekNumbers = _a.weekNumbers;
                    self.innerContainer.appendChild(weekWrapper);
                    self.weekNumbers = weekNumbers;
                    self.weekWrapper = weekWrapper;
                }
                self.rContainer = createElement("div", "flatpickr-rContainer");
                self.rContainer.appendChild(buildWeekdays());
                if (!self.daysContainer) {
                    self.daysContainer = createElement("div", "flatpickr-days");
                    self.daysContainer.tabIndex = -1;
                }
                buildDays();
                self.rContainer.appendChild(self.daysContainer);
                self.innerContainer.appendChild(self.rContainer);
                fragment.appendChild(self.innerContainer);
            }
            if (self.config.enableTime) {
                fragment.appendChild(buildTime());
            }
            toggleClass(self.calendarContainer, "rangeMode", self.config.mode === "range");
            toggleClass(self.calendarContainer, "animate", self.config.animate === true);
            toggleClass(self.calendarContainer, "multiMonth", self.config.showMonths > 1);
            self.calendarContainer.appendChild(fragment);
            var customAppend = self.config.appendTo !== undefined &&
                self.config.appendTo.nodeType !== undefined;
            if (self.config.inline || self.config.static) {
                self.calendarContainer.classList.add(self.config.inline ? "inline" : "static");
                if (self.config.inline) {
                    if (!customAppend && self.element.parentNode)
                        self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling);
                    else if (self.config.appendTo !== undefined)
                        self.config.appendTo.appendChild(self.calendarContainer);
                }
                if (self.config.static) {
                    var wrapper = createElement("div", "flatpickr-wrapper");
                    if (self.element.parentNode)
                        self.element.parentNode.insertBefore(wrapper, self.element);
                    wrapper.appendChild(self.element);
                    if (self.altInput)
                        wrapper.appendChild(self.altInput);
                    wrapper.appendChild(self.calendarContainer);
                }
            }
            if (!self.config.static && !self.config.inline)
                (self.config.appendTo !== undefined
                    ? self.config.appendTo
                    : window.document.body).appendChild(self.calendarContainer);
        }
        function createDay(className, date, dayNumber, i) {
            var dateIsEnabled = isEnabled(date, true), dayElement = createElement("span", "flatpickr-day " + className, date.getDate().toString());
            dayElement.dateObj = date;
            dayElement.$i = i;
            dayElement.setAttribute("aria-label", self.formatDate(date, self.config.ariaDateFormat));
            if (className.indexOf("hidden") === -1 &&
                compareDates(date, self.now) === 0) {
                self.todayDateElem = dayElement;
                dayElement.classList.add("today");
                dayElement.setAttribute("aria-current", "date");
            }
            if (dateIsEnabled) {
                dayElement.tabIndex = -1;
                if (isDateSelected(date)) {
                    dayElement.classList.add("selected");
                    self.selectedDateElem = dayElement;
                    if (self.config.mode === "range") {
                        toggleClass(dayElement, "startRange", self.selectedDates[0] &&
                            compareDates(date, self.selectedDates[0], true) === 0);
                        toggleClass(dayElement, "endRange", self.selectedDates[1] &&
                            compareDates(date, self.selectedDates[1], true) === 0);
                        if (className === "nextMonthDay")
                            dayElement.classList.add("inRange");
                    }
                }
            }
            else {
                dayElement.classList.add("disabled");
            }
            if (self.config.mode === "range") {
                if (isDateInRange(date) && !isDateSelected(date))
                    dayElement.classList.add("inRange");
            }
            if (self.weekNumbers &&
                self.config.showMonths === 1 &&
                className !== "prevMonthDay" &&
                dayNumber % 7 === 1) {
                self.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self.config.getWeek(date) + "</span>");
            }
            triggerEvent("onDayCreate", dayElement);
            return dayElement;
        }
        function focusOnDayElem(targetNode) {
            targetNode.focus();
            if (self.config.mode === "range")
                onMouseOver(targetNode);
        }
        function getFirstAvailableDay(delta) {
            var startMonth = delta > 0 ? 0 : self.config.showMonths - 1;
            var endMonth = delta > 0 ? self.config.showMonths : -1;
            for (var m = startMonth; m != endMonth; m += delta) {
                var month = self.daysContainer.children[m];
                var startIndex = delta > 0 ? 0 : month.children.length - 1;
                var endIndex = delta > 0 ? month.children.length : -1;
                for (var i = startIndex; i != endIndex; i += delta) {
                    var c = month.children[i];
                    if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj))
                        return c;
                }
            }
            return undefined;
        }
        function getNextAvailableDay(current, delta) {
            var givenMonth = current.className.indexOf("Month") === -1
                ? current.dateObj.getMonth()
                : self.currentMonth;
            var endMonth = delta > 0 ? self.config.showMonths : -1;
            var loopDelta = delta > 0 ? 1 : -1;
            for (var m = givenMonth - self.currentMonth; m != endMonth; m += loopDelta) {
                var month = self.daysContainer.children[m];
                var startIndex = givenMonth - self.currentMonth === m
                    ? current.$i + delta
                    : delta < 0
                        ? month.children.length - 1
                        : 0;
                var numMonthDays = month.children.length;
                for (var i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
                    var c = month.children[i];
                    if (c.className.indexOf("hidden") === -1 &&
                        isEnabled(c.dateObj) &&
                        Math.abs(current.$i - i) >= Math.abs(delta))
                        return focusOnDayElem(c);
                }
            }
            self.changeMonth(loopDelta);
            focusOnDay(getFirstAvailableDay(loopDelta), 0);
            return undefined;
        }
        function focusOnDay(current, offset) {
            var dayFocused = isInView(document.activeElement || document.body);
            var startElem = current !== undefined
                ? current
                : dayFocused
                    ? document.activeElement
                    : self.selectedDateElem !== undefined && isInView(self.selectedDateElem)
                        ? self.selectedDateElem
                        : self.todayDateElem !== undefined && isInView(self.todayDateElem)
                            ? self.todayDateElem
                            : getFirstAvailableDay(offset > 0 ? 1 : -1);
            if (startElem === undefined)
                return self._input.focus();
            if (!dayFocused)
                return focusOnDayElem(startElem);
            getNextAvailableDay(startElem, offset);
        }
        function buildMonthDays(year, month) {
            var firstOfMonth = (new Date(year, month, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7;
            var prevMonthDays = self.utils.getDaysInMonth((month - 1 + 12) % 12);
            var daysInMonth = self.utils.getDaysInMonth(month), days = window.document.createDocumentFragment(), isMultiMonth = self.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
            var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
            // prepend days from the ending of previous month
            for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
                days.appendChild(createDay(prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
            }
            // Start at 1 since there is no 0th day
            for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
                days.appendChild(createDay("", new Date(year, month, dayNumber), dayNumber, dayIndex));
            }
            // append days from the next month
            for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth &&
                (self.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
                days.appendChild(createDay(nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
            }
            //updateNavigationCurrentMonth();
            var dayContainer = createElement("div", "dayContainer");
            dayContainer.appendChild(days);
            return dayContainer;
        }
        function buildDays() {
            if (self.daysContainer === undefined) {
                return;
            }
            clearNode(self.daysContainer);
            // TODO: week numbers for each month
            if (self.weekNumbers)
                clearNode(self.weekNumbers);
            var frag = document.createDocumentFragment();
            for (var i = 0; i < self.config.showMonths; i++) {
                var d = new Date(self.currentYear, self.currentMonth, 1);
                d.setMonth(self.currentMonth + i);
                frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
            }
            self.daysContainer.appendChild(frag);
            self.days = self.daysContainer.firstChild;
            if (self.config.mode === "range" && self.selectedDates.length === 1) {
                onMouseOver();
            }
        }
        function buildMonth() {
            var container = createElement("div", "flatpickr-month");
            var monthNavFragment = window.document.createDocumentFragment();
            var monthElement = createElement("span", "cur-month");
            var yearInput = createNumberInput("cur-year", { tabindex: "-1" });
            var yearElement = yearInput.getElementsByTagName("input")[0];
            yearElement.setAttribute("aria-label", self.l10n.yearAriaLabel);
            if (self.config.minDate) {
                yearElement.setAttribute("min", self.config.minDate.getFullYear().toString());
            }
            if (self.config.maxDate) {
                yearElement.setAttribute("max", self.config.maxDate.getFullYear().toString());
                yearElement.disabled =
                    !!self.config.minDate &&
                        self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();
            }
            var currentMonth = createElement("div", "flatpickr-current-month");
            currentMonth.appendChild(monthElement);
            currentMonth.appendChild(yearInput);
            monthNavFragment.appendChild(currentMonth);
            container.appendChild(monthNavFragment);
            return {
                container: container,
                yearElement: yearElement,
                monthElement: monthElement
            };
        }
        function buildMonths() {
            clearNode(self.monthNav);
            self.monthNav.appendChild(self.prevMonthNav);
            if (self.config.showMonths) {
                self.yearElements = [];
                self.monthElements = [];
            }
            for (var m = self.config.showMonths; m--;) {
                var month = buildMonth();
                self.yearElements.push(month.yearElement);
                self.monthElements.push(month.monthElement);
                self.monthNav.appendChild(month.container);
            }
            self.monthNav.appendChild(self.nextMonthNav);
        }
        function buildMonthNav() {
            self.monthNav = createElement("div", "flatpickr-months");
            self.yearElements = [];
            self.monthElements = [];
            self.prevMonthNav = createElement("span", "flatpickr-prev-month");
            self.prevMonthNav.innerHTML = self.config.prevArrow;
            self.nextMonthNav = createElement("span", "flatpickr-next-month");
            self.nextMonthNav.innerHTML = self.config.nextArrow;
            buildMonths();
            Object.defineProperty(self, "_hidePrevMonthArrow", {
                get: function () { return self.__hidePrevMonthArrow; },
                set: function (bool) {
                    if (self.__hidePrevMonthArrow !== bool) {
                        toggleClass(self.prevMonthNav, "disabled", bool);
                        self.__hidePrevMonthArrow = bool;
                    }
                }
            });
            Object.defineProperty(self, "_hideNextMonthArrow", {
                get: function () { return self.__hideNextMonthArrow; },
                set: function (bool) {
                    if (self.__hideNextMonthArrow !== bool) {
                        toggleClass(self.nextMonthNav, "disabled", bool);
                        self.__hideNextMonthArrow = bool;
                    }
                }
            });
            self.currentYearElement = self.yearElements[0];
            updateNavigationCurrentMonth();
            return self.monthNav;
        }
        function buildTime() {
            self.calendarContainer.classList.add("hasTime");
            if (self.config.noCalendar)
                self.calendarContainer.classList.add("noCalendar");
            self.timeContainer = createElement("div", "flatpickr-time");
            self.timeContainer.tabIndex = -1;
            var separator = createElement("span", "flatpickr-time-separator", ":");
            var hourInput = createNumberInput("flatpickr-hour");
            self.hourElement = hourInput.getElementsByTagName("input")[0];
            var minuteInput = createNumberInput("flatpickr-minute");
            self.minuteElement = minuteInput.getElementsByTagName("input")[0];
            self.hourElement.tabIndex = self.minuteElement.tabIndex = -1;
            self.hourElement.value = pad(self.latestSelectedDateObj
                ? self.latestSelectedDateObj.getHours()
                : self.config.time_24hr
                    ? self.config.defaultHour
                    : military2ampm(self.config.defaultHour));
            self.minuteElement.value = pad(self.latestSelectedDateObj
                ? self.latestSelectedDateObj.getMinutes()
                : self.config.defaultMinute);
            self.hourElement.setAttribute("step", self.config.hourIncrement.toString());
            self.minuteElement.setAttribute("step", self.config.minuteIncrement.toString());
            self.hourElement.setAttribute("min", self.config.time_24hr ? "0" : "1");
            self.hourElement.setAttribute("max", self.config.time_24hr ? "23" : "12");
            self.minuteElement.setAttribute("min", "0");
            self.minuteElement.setAttribute("max", "59");
            self.timeContainer.appendChild(hourInput);
            self.timeContainer.appendChild(separator);
            self.timeContainer.appendChild(minuteInput);
            if (self.config.time_24hr)
                self.timeContainer.classList.add("time24hr");
            if (self.config.enableSeconds) {
                self.timeContainer.classList.add("hasSeconds");
                var secondInput = createNumberInput("flatpickr-second");
                self.secondElement = secondInput.getElementsByTagName("input")[0];
                self.secondElement.value = pad(self.latestSelectedDateObj
                    ? self.latestSelectedDateObj.getSeconds()
                    : self.config.defaultSeconds);
                self.secondElement.setAttribute("step", self.minuteElement.getAttribute("step"));
                self.secondElement.setAttribute("min", "0");
                self.secondElement.setAttribute("max", "59");
                self.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
                self.timeContainer.appendChild(secondInput);
            }
            if (!self.config.time_24hr) {
                // add self.amPM if appropriate
                self.amPM = createElement("span", "flatpickr-am-pm", self.l10n.amPM[int((self.latestSelectedDateObj
                    ? self.hourElement.value
                    : self.config.defaultHour) > 11)]);
                self.amPM.title = self.l10n.toggleTitle;
                self.amPM.tabIndex = -1;
                self.timeContainer.appendChild(self.amPM);
            }
            return self.timeContainer;
        }
        function buildWeekdays() {
            if (!self.weekdayContainer)
                self.weekdayContainer = createElement("div", "flatpickr-weekdays");
            else
                clearNode(self.weekdayContainer);
            for (var i = self.config.showMonths; i--;) {
                var container = createElement("div", "flatpickr-weekdaycontainer");
                self.weekdayContainer.appendChild(container);
            }
            updateWeekdays();
            return self.weekdayContainer;
        }
        function updateWeekdays() {
            var firstDayOfWeek = self.l10n.firstDayOfWeek;
            var weekdays = self.l10n.weekdays.shorthand.slice();
            if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
                weekdays = weekdays.splice(firstDayOfWeek, weekdays.length).concat(weekdays.splice(0, firstDayOfWeek));
            }
            for (var i = self.config.showMonths; i--;) {
                self.weekdayContainer.children[i].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
            }
        }
        /* istanbul ignore next */
        function buildWeeks() {
            self.calendarContainer.classList.add("hasWeeks");
            var weekWrapper = createElement("div", "flatpickr-weekwrapper");
            weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self.l10n.weekAbbreviation));
            var weekNumbers = createElement("div", "flatpickr-weeks");
            weekWrapper.appendChild(weekNumbers);
            return {
                weekWrapper: weekWrapper,
                weekNumbers: weekNumbers
            };
        }
        function changeMonth(value, is_offset) {
            if (is_offset === void 0) { is_offset = true; }
            var delta = is_offset ? value : value - self.currentMonth;
            if ((delta < 0 && self._hidePrevMonthArrow === true) ||
                (delta > 0 && self._hideNextMonthArrow === true))
                return;
            self.currentMonth += delta;
            if (self.currentMonth < 0 || self.currentMonth > 11) {
                self.currentYear += self.currentMonth > 11 ? 1 : -1;
                self.currentMonth = (self.currentMonth + 12) % 12;
                triggerEvent("onYearChange");
            }
            buildDays();
            triggerEvent("onMonthChange");
            updateNavigationCurrentMonth();
        }
        function clear(triggerChangeEvent, toInitial) {
            if (triggerChangeEvent === void 0) { triggerChangeEvent = true; }
            if (toInitial === void 0) { toInitial = true; }
            self.input.value = "";
            if (self.altInput !== undefined)
                self.altInput.value = "";
            if (self.mobileInput !== undefined)
                self.mobileInput.value = "";
            self.selectedDates = [];
            self.latestSelectedDateObj = undefined;
            if (toInitial === true) {
                self.currentYear = self._initialDate.getFullYear();
                self.currentMonth = self._initialDate.getMonth();
            }
            self.showTimeInput = false;
            if (self.config.enableTime === true) {
                setDefaultHours();
            }
            self.redraw();
            if (triggerChangeEvent)
                // triggerChangeEvent is true (default) or an Event
                triggerEvent("onChange");
        }
        function close() {
            self.isOpen = false;
            if (!self.isMobile) {
                if (self.calendarContainer !== undefined) {
                    self.calendarContainer.classList.remove("open");
                }
                if (self._input !== undefined) {
                    self._input.classList.remove("active");
                }
            }
            triggerEvent("onClose");
        }
        function destroy() {
            if (self.config !== undefined)
                triggerEvent("onDestroy");
            for (var i = self._handlers.length; i--;) {
                var h = self._handlers[i];
                h.element.removeEventListener(h.event, h.handler, h.options);
            }
            self._handlers = [];
            if (self.mobileInput) {
                if (self.mobileInput.parentNode)
                    self.mobileInput.parentNode.removeChild(self.mobileInput);
                self.mobileInput = undefined;
            }
            else if (self.calendarContainer && self.calendarContainer.parentNode) {
                if (self.config.static && self.calendarContainer.parentNode) {
                    var wrapper = self.calendarContainer.parentNode;
                    wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
                    if (wrapper.parentNode) {
                        while (wrapper.firstChild)
                            wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
                        wrapper.parentNode.removeChild(wrapper);
                    }
                }
                else
                    self.calendarContainer.parentNode.removeChild(self.calendarContainer);
            }
            if (self.altInput) {
                self.input.type = "text";
                if (self.altInput.parentNode)
                    self.altInput.parentNode.removeChild(self.altInput);
                delete self.altInput;
            }
            if (self.input) {
                self.input.type = self.input._type;
                self.input.classList.remove("flatpickr-input");
                self.input.removeAttribute("readonly");
                self.input.value = "";
            }
            [
                "_showTimeInput",
                "latestSelectedDateObj",
                "_hideNextMonthArrow",
                "_hidePrevMonthArrow",
                "__hideNextMonthArrow",
                "__hidePrevMonthArrow",
                "isMobile",
                "isOpen",
                "selectedDateElem",
                "minDateHasTime",
                "maxDateHasTime",
                "days",
                "daysContainer",
                "_input",
                "_positionElement",
                "innerContainer",
                "rContainer",
                "monthNav",
                "todayDateElem",
                "calendarContainer",
                "weekdayContainer",
                "prevMonthNav",
                "nextMonthNav",
                "currentMonthElement",
                "currentYearElement",
                "navigationCurrentMonth",
                "selectedDateElem",
                "config",
            ].forEach(function (k) {
                try {
                    delete self[k];
                }
                catch (_) { }
            });
        }
        function isCalendarElem(elem) {
            if (self.config.appendTo && self.config.appendTo.contains(elem))
                return true;
            return self.calendarContainer.contains(elem);
        }
        function documentClick(e) {
            if (self.isOpen && !self.config.inline) {
                var eventTarget_1 = getEventTarget(e);
                var isCalendarElement = isCalendarElem(eventTarget_1);
                var isInput = eventTarget_1 === self.input ||
                    eventTarget_1 === self.altInput ||
                    self.element.contains(eventTarget_1) ||
                    // web components
                    // e.path is not present in all browsers. circumventing typechecks
                    (e.path &&
                        e.path.indexOf &&
                        (~e.path.indexOf(self.input) ||
                            ~e.path.indexOf(self.altInput)));
                var lostFocus = e.type === "blur"
                    ? isInput &&
                        e.relatedTarget &&
                        !isCalendarElem(e.relatedTarget)
                    : !isInput &&
                        !isCalendarElement &&
                        !isCalendarElem(e.relatedTarget);
                var isIgnored = !self.config.ignoredFocusElements.some(function (elem) {
                    return elem.contains(eventTarget_1);
                });
                if (lostFocus && isIgnored) {
                    self.close();
                    if (self.config.mode === "range" && self.selectedDates.length === 1) {
                        self.clear(false);
                        self.redraw();
                    }
                }
            }
        }
        function changeYear(newYear) {
            if (!newYear ||
                (self.config.minDate && newYear < self.config.minDate.getFullYear()) ||
                (self.config.maxDate && newYear > self.config.maxDate.getFullYear()))
                return;
            var newYearNum = newYear, isNewYear = self.currentYear !== newYearNum;
            self.currentYear = newYearNum || self.currentYear;
            if (self.config.maxDate &&
                self.currentYear === self.config.maxDate.getFullYear()) {
                self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);
            }
            else if (self.config.minDate &&
                self.currentYear === self.config.minDate.getFullYear()) {
                self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);
            }
            if (isNewYear) {
                self.redraw();
                triggerEvent("onYearChange");
            }
        }
        function isEnabled(date, timeless) {
            if (timeless === void 0) { timeless = true; }
            var dateToCheck = self.parseDate(date, undefined, timeless); // timeless
            if ((self.config.minDate &&
                dateToCheck &&
                compareDates(dateToCheck, self.config.minDate, timeless !== undefined ? timeless : !self.minDateHasTime) < 0) ||
                (self.config.maxDate &&
                    dateToCheck &&
                    compareDates(dateToCheck, self.config.maxDate, timeless !== undefined ? timeless : !self.maxDateHasTime) > 0))
                return false;
            if (self.config.enable.length === 0 && self.config.disable.length === 0)
                return true;
            if (dateToCheck === undefined)
                return false;
            var bool = self.config.enable.length > 0, array = bool ? self.config.enable : self.config.disable;
            for (var i = 0, d = void 0; i < array.length; i++) {
                d = array[i];
                if (typeof d === "function" &&
                    d(dateToCheck) // disabled by function
                )
                    return bool;
                else if (d instanceof Date &&
                    dateToCheck !== undefined &&
                    d.getTime() === dateToCheck.getTime())
                    // disabled by date
                    return bool;
                else if (typeof d === "string" && dateToCheck !== undefined) {
                    // disabled by date string
                    var parsed = self.parseDate(d, undefined, true);
                    return parsed && parsed.getTime() === dateToCheck.getTime()
                        ? bool
                        : !bool;
                }
                else if (
                // disabled by range
                typeof d === "object" &&
                    dateToCheck !== undefined &&
                    d.from &&
                    d.to &&
                    dateToCheck.getTime() >= d.from.getTime() &&
                    dateToCheck.getTime() <= d.to.getTime())
                    return bool;
            }
            return !bool;
        }
        function isInView(elem) {
            if (self.daysContainer !== undefined)
                return (elem.className.indexOf("hidden") === -1 &&
                    self.daysContainer.contains(elem));
            return false;
        }
        function onKeyDown(e) {
            // e.key                      e.keyCode
            // "Backspace"                        8
            // "Tab"                              9
            // "Enter"                           13
            // "Escape"     (IE "Esc")           27
            // "ArrowLeft"  (IE "Left")          37
            // "ArrowUp"    (IE "Up")            38
            // "ArrowRight" (IE "Right")         39
            // "ArrowDown"  (IE "Down")          40
            // "Delete"     (IE "Del")           46
            var isInput = e.target === self._input;
            var allowInput = self.config.allowInput;
            var allowKeydown = self.isOpen && (!allowInput || !isInput);
            var allowInlineKeydown = self.config.inline && isInput && !allowInput;
            if (e.keyCode === 13 && isInput) {
                if (allowInput) {
                    self.setDate(self._input.value, true, e.target === self.altInput
                        ? self.config.altFormat
                        : self.config.dateFormat);
                    return e.target.blur();
                }
                else
                    self.open();
            }
            else if (isCalendarElem(e.target) ||
                allowKeydown ||
                allowInlineKeydown) {
                var isTimeObj = !!self.timeContainer &&
                    self.timeContainer.contains(e.target);
                switch (e.keyCode) {
                    case 13:
                        if (isTimeObj) {
                            updateTime();
                            focusAndClose();
                        }
                        else
                            selectDate(e);
                        break;
                    case 27: // escape
                        e.preventDefault();
                        focusAndClose();
                        break;
                    case 8:
                    case 46:
                        if (isInput && !self.config.allowInput) {
                            e.preventDefault();
                            self.clear();
                        }
                        break;
                    case 37:
                    case 39:
                        if (!isTimeObj) {
                            e.preventDefault();
                            if (self.daysContainer !== undefined &&
                                (allowInput === false ||
                                    (document.activeElement && isInView(document.activeElement)))) {
                                var delta_1 = e.keyCode === 39 ? 1 : -1;
                                if (!e.ctrlKey)
                                    focusOnDay(undefined, delta_1);
                                else {
                                    e.stopPropagation();
                                    changeMonth(delta_1);
                                    focusOnDay(getFirstAvailableDay(1), 0);
                                }
                            }
                        }
                        else if (self.hourElement)
                            self.hourElement.focus();
                        break;
                    case 38:
                    case 40:
                        e.preventDefault();
                        var delta = e.keyCode === 40 ? 1 : -1;
                        if ((self.daysContainer && e.target.$i !== undefined) ||
                            e.target === self.input) {
                            if (e.ctrlKey) {
                                e.stopPropagation();
                                changeYear(self.currentYear - delta);
                                focusOnDay(getFirstAvailableDay(1), 0);
                            }
                            else if (!isTimeObj)
                                focusOnDay(undefined, delta * 7);
                        }
                        else if (self.config.enableTime) {
                            if (!isTimeObj && self.hourElement)
                                self.hourElement.focus();
                            updateTime(e);
                            self._debouncedChange();
                        }
                        break;
                    case 9:
                        if (isTimeObj) {
                            var elems = [
                                self.hourElement,
                                self.minuteElement,
                                self.secondElement,
                                self.amPM,
                            ].filter(function (x) { return x; });
                            var i = elems.indexOf(e.target);
                            if (i !== -1) {
                                var target = elems[i + (e.shiftKey ? -1 : 1)];
                                if (target !== undefined) {
                                    e.preventDefault();
                                    target.focus();
                                }
                                else if (e.shiftKey) {
                                    e.preventDefault();
                                    self._input.focus();
                                }
                            }
                        }
                        break;
                    default:
                        break;
                }
            }
            if (self.amPM !== undefined && e.target === self.amPM) {
                switch (e.key) {
                    case self.l10n.amPM[0].charAt(0):
                    case self.l10n.amPM[0].charAt(0).toLowerCase():
                        self.amPM.textContent = self.l10n.amPM[0];
                        setHoursFromInputs();
                        updateValue();
                        break;
                    case self.l10n.amPM[1].charAt(0):
                    case self.l10n.amPM[1].charAt(0).toLowerCase():
                        self.amPM.textContent = self.l10n.amPM[1];
                        setHoursFromInputs();
                        updateValue();
                        break;
                }
            }
            triggerEvent("onKeyDown", e);
        }
        function onMouseOver(elem) {
            if (self.selectedDates.length !== 1 ||
                (elem &&
                    (!elem.classList.contains("flatpickr-day") ||
                        elem.classList.contains("disabled"))))
                return;
            var hoverDate = elem
                ? elem.dateObj.getTime()
                : self.days.firstElementChild.dateObj.getTime(), initialDate = self.parseDate(self.selectedDates[0], undefined, true).getTime(), rangeStartDate = Math.min(hoverDate, self.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self.selectedDates[0].getTime()), lastDate = self.daysContainer.lastChild
                .lastChild.dateObj.getTime();
            var containsDisabled = false;
            var minRange = 0, maxRange = 0;
            for (var t = rangeStartDate; t < lastDate; t += duration.DAY) {
                if (!isEnabled(new Date(t), true)) {
                    containsDisabled =
                        containsDisabled || (t > rangeStartDate && t < rangeEndDate);
                    if (t < initialDate && (!minRange || t > minRange))
                        minRange = t;
                    else if (t > initialDate && (!maxRange || t < maxRange))
                        maxRange = t;
                }
            }
            for (var m = 0; m < self.config.showMonths; m++) {
                var month = self.daysContainer.children[m];
                var prevMonth = self.daysContainer.children[m - 1];
                var _loop_1 = function (i, l) {
                    var dayElem = month.children[i], date = dayElem.dateObj;
                    var timestamp = date.getTime();
                    var outOfRange = (minRange > 0 && timestamp < minRange) ||
                        (maxRange > 0 && timestamp > maxRange);
                    if (outOfRange) {
                        dayElem.classList.add("notAllowed");
                        ["inRange", "startRange", "endRange"].forEach(function (c) {
                            dayElem.classList.remove(c);
                        });
                        return "continue";
                    }
                    else if (containsDisabled && !outOfRange)
                        return "continue";
                    ["startRange", "inRange", "endRange", "notAllowed"].forEach(function (c) {
                        dayElem.classList.remove(c);
                    });
                    if (elem !== undefined) {
                        elem.classList.add(hoverDate < self.selectedDates[0].getTime()
                            ? "startRange"
                            : "endRange");
                        if (month.contains(elem) ||
                            !(m > 0 &&
                                prevMonth &&
                                prevMonth.lastChild.dateObj.getTime() >= timestamp)) {
                            if (initialDate < hoverDate && timestamp === initialDate)
                                dayElem.classList.add("startRange");
                            else if (initialDate > hoverDate && timestamp === initialDate)
                                dayElem.classList.add("endRange");
                            if (timestamp >= minRange &&
                                (maxRange === 0 || timestamp <= maxRange) &&
                                isBetween(timestamp, initialDate, hoverDate))
                                dayElem.classList.add("inRange");
                        }
                    }
                };
                for (var i = 0, l = month.children.length; i < l; i++) {
                    _loop_1(i, l);
                }
            }
        }
        function onResize() {
            if (self.isOpen && !self.config.static && !self.config.inline)
                positionCalendar();
        }
        function setDefaultTime() {
            self.setDate(self.config.minDate !== undefined
                ? new Date(self.config.minDate.getTime())
                : new Date(), false);
            setDefaultHours();
            updateValue();
        }
        function open(e, positionElement) {
            if (positionElement === void 0) { positionElement = self._positionElement; }
            if (self.isMobile === true) {
                if (e) {
                    e.preventDefault();
                    e.target && e.target.blur();
                }
                if (self.mobileInput !== undefined) {
                    self.mobileInput.focus();
                    self.mobileInput.click();
                }
                triggerEvent("onOpen");
                return;
            }
            if (self._input.disabled || self.config.inline)
                return;
            var wasOpen = self.isOpen;
            self.isOpen = true;
            if (!wasOpen) {
                self.calendarContainer.classList.add("open");
                self._input.classList.add("active");
                triggerEvent("onOpen");
                positionCalendar(positionElement);
            }
            if (self.config.enableTime === true && self.config.noCalendar === true) {
                if (self.selectedDates.length === 0) {
                    setDefaultTime();
                }
                if (self.config.allowInput === false &&
                    (e === undefined ||
                        !self.timeContainer.contains(e.relatedTarget))) {
                    setTimeout(function () { return self.hourElement.select(); }, 50);
                }
            }
        }
        function minMaxDateSetter(type) {
            return function (date) {
                var dateObj = (self.config["_" + type + "Date"] = self.parseDate(date, self.config.dateFormat));
                var inverseDateObj = self.config["_" + (type === "min" ? "max" : "min") + "Date"];
                if (dateObj !== undefined) {
                    self[type === "min" ? "minDateHasTime" : "maxDateHasTime"] =
                        dateObj.getHours() > 0 ||
                            dateObj.getMinutes() > 0 ||
                            dateObj.getSeconds() > 0;
                }
                if (self.selectedDates) {
                    self.selectedDates = self.selectedDates.filter(function (d) { return isEnabled(d); });
                    if (!self.selectedDates.length && type === "min")
                        setHoursFromDate(dateObj);
                    updateValue();
                }
                if (self.daysContainer) {
                    redraw();
                    if (dateObj !== undefined)
                        self.currentYearElement[type] = dateObj.getFullYear().toString();
                    else
                        self.currentYearElement.removeAttribute(type);
                    self.currentYearElement.disabled =
                        !!inverseDateObj &&
                            dateObj !== undefined &&
                            inverseDateObj.getFullYear() === dateObj.getFullYear();
                }
            };
        }
        function parseConfig() {
            var boolOpts = [
                "wrap",
                "weekNumbers",
                "allowInput",
                "clickOpens",
                "time_24hr",
                "enableTime",
                "noCalendar",
                "altInput",
                "shorthandCurrentMonth",
                "inline",
                "static",
                "enableSeconds",
                "disableMobile",
            ];
            var userConfig = __assign({}, instanceConfig, JSON.parse(JSON.stringify(element.dataset || {})));
            var formats = {};
            self.config.parseDate = userConfig.parseDate;
            self.config.formatDate = userConfig.formatDate;
            Object.defineProperty(self.config, "enable", {
                get: function () { return self.config._enable; },
                set: function (dates) {
                    self.config._enable = parseDateRules(dates);
                }
            });
            Object.defineProperty(self.config, "disable", {
                get: function () { return self.config._disable; },
                set: function (dates) {
                    self.config._disable = parseDateRules(dates);
                }
            });
            var timeMode = userConfig.mode === "time";
            if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
                formats.dateFormat =
                    userConfig.noCalendar || timeMode
                        ? "H:i" + (userConfig.enableSeconds ? ":S" : "")
                        : flatpickr.defaultConfig.dateFormat +
                            " H:i" +
                            (userConfig.enableSeconds ? ":S" : "");
            }
            if (userConfig.altInput &&
                (userConfig.enableTime || timeMode) &&
                !userConfig.altFormat) {
                formats.altFormat =
                    userConfig.noCalendar || timeMode
                        ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K")
                        : flatpickr.defaultConfig.altFormat +
                            (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
            }
            Object.defineProperty(self.config, "minDate", {
                get: function () { return self.config._minDate; },
                set: minMaxDateSetter("min")
            });
            Object.defineProperty(self.config, "maxDate", {
                get: function () { return self.config._maxDate; },
                set: minMaxDateSetter("max")
            });
            var minMaxTimeSetter = function (type) { return function (val) {
                self.config[type === "min" ? "_minTime" : "_maxTime"] = self.parseDate(val, "H:i");
            }; };
            Object.defineProperty(self.config, "minTime", {
                get: function () { return self.config._minTime; },
                set: minMaxTimeSetter("min")
            });
            Object.defineProperty(self.config, "maxTime", {
                get: function () { return self.config._maxTime; },
                set: minMaxTimeSetter("max")
            });
            if (userConfig.mode === "time") {
                self.config.noCalendar = true;
                self.config.enableTime = true;
            }
            Object.assign(self.config, formats, userConfig);
            for (var i = 0; i < boolOpts.length; i++)
                self.config[boolOpts[i]] =
                    self.config[boolOpts[i]] === true ||
                        self.config[boolOpts[i]] === "true";
            HOOKS.filter(function (hook) { return self.config[hook] !== undefined; }).forEach(function (hook) {
                self.config[hook] = arrayify(self.config[hook] || []).map(bindToInstance);
            });
            self.isMobile =
                !self.config.disableMobile &&
                    !self.config.inline &&
                    self.config.mode === "single" &&
                    !self.config.disable.length &&
                    !self.config.enable.length &&
                    !self.config.weekNumbers &&
                    /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            for (var i = 0; i < self.config.plugins.length; i++) {
                var pluginConf = self.config.plugins[i](self) || {};
                for (var key in pluginConf) {
                    if (HOOKS.indexOf(key) > -1) {
                        self.config[key] = arrayify(pluginConf[key])
                            .map(bindToInstance)
                            .concat(self.config[key]);
                    }
                    else if (typeof userConfig[key] === "undefined")
                        self.config[key] = pluginConf[key];
                }
            }
            triggerEvent("onParseConfig");
        }
        function setupLocale() {
            if (typeof self.config.locale !== "object" &&
                typeof flatpickr.l10ns[self.config.locale] === "undefined")
                self.config.errorHandler(new Error("flatpickr: invalid locale " + self.config.locale));
            self.l10n = __assign({}, flatpickr.l10ns["default"], (typeof self.config.locale === "object"
                ? self.config.locale
                : self.config.locale !== "default"
                    ? flatpickr.l10ns[self.config.locale]
                    : undefined));
            tokenRegex.K = "(" + self.l10n.amPM[0] + "|" + self.l10n.amPM[1] + "|" + self.l10n.amPM[0].toLowerCase() + "|" + self.l10n.amPM[1].toLowerCase() + ")";
            self.formatDate = createDateFormatter(self);
            self.parseDate = createDateParser({ config: self.config, l10n: self.l10n });
        }
        function positionCalendar(customPositionElement) {
            if (self.calendarContainer === undefined)
                return;
            triggerEvent("onPreCalendarPosition");
            var positionElement = customPositionElement || self._positionElement;
            var calendarHeight = Array.prototype.reduce.call(self.calendarContainer.children, (function (acc, child) { return acc + child.offsetHeight; }), 0), calendarWidth = self.calendarContainer.offsetWidth, configPos = self.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" ||
                (configPosVertical !== "below" &&
                    distanceFromBottom < calendarHeight &&
                    inputBounds.top > calendarHeight);
            var top = window.pageYOffset +
                inputBounds.top +
                (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
            toggleClass(self.calendarContainer, "arrowTop", !showOnTop);
            toggleClass(self.calendarContainer, "arrowBottom", showOnTop);
            if (self.config.inline)
                return;
            var left = window.pageXOffset +
                inputBounds.left -
                (configPosHorizontal != null && configPosHorizontal === "center"
                    ? (calendarWidth - inputBounds.width) / 2
                    : 0);
            var right = window.document.body.offsetWidth - inputBounds.right;
            var rightMost = left + calendarWidth > window.document.body.offsetWidth;
            var centerMost = right + calendarWidth > window.document.body.offsetWidth;
            toggleClass(self.calendarContainer, "rightMost", rightMost);
            if (self.config.static)
                return;
            self.calendarContainer.style.top = top + "px";
            if (!rightMost) {
                self.calendarContainer.style.left = left + "px";
                self.calendarContainer.style.right = "auto";
            }
            else if (!centerMost) {
                self.calendarContainer.style.left = "auto";
                self.calendarContainer.style.right = right + "px";
            }
            else {
                var doc = document.styleSheets[0];
                // some testing environments don't have css support
                if (doc === undefined)
                    return;
                var bodyWidth = window.document.body.offsetWidth;
                var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
                var centerBefore = ".flatpickr-calendar.centerMost:before";
                var centerAfter = ".flatpickr-calendar.centerMost:after";
                var centerIndex = doc.cssRules.length;
                var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
                toggleClass(self.calendarContainer, "rightMost", false);
                toggleClass(self.calendarContainer, "centerMost", true);
                doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
                self.calendarContainer.style.left = centerLeft + "px";
                self.calendarContainer.style.right = "auto";
            }
        }
        function redraw() {
            if (self.config.noCalendar || self.isMobile)
                return;
            updateNavigationCurrentMonth();
            buildDays();
        }
        function focusAndClose() {
            self._input.focus();
            if (window.navigator.userAgent.indexOf("MSIE") !== -1 ||
                navigator.msMaxTouchPoints !== undefined) {
                // hack - bugs in the way IE handles focus keeps the calendar open
                setTimeout(self.close, 0);
            }
            else {
                self.close();
            }
        }
        function selectDate(e) {
            e.preventDefault();
            e.stopPropagation();
            var isSelectable = function (day) {
                return day.classList &&
                    day.classList.contains("flatpickr-day") &&
                    !day.classList.contains("disabled") &&
                    !day.classList.contains("notAllowed");
            };
            var t = findParent(e.target, isSelectable);
            if (t === undefined)
                return;
            var target = t;
            var selectedDate = (self.latestSelectedDateObj = new Date(target.dateObj.getTime()));
            var shouldChangeMonth = (selectedDate.getMonth() < self.currentMonth ||
                selectedDate.getMonth() >
                    self.currentMonth + self.config.showMonths - 1) &&
                self.config.mode !== "range";
            self.selectedDateElem = target;
            if (self.config.mode === "single")
                self.selectedDates = [selectedDate];
            else if (self.config.mode === "multiple") {
                var selectedIndex = isDateSelected(selectedDate);
                if (selectedIndex)
                    self.selectedDates.splice(parseInt(selectedIndex), 1);
                else
                    self.selectedDates.push(selectedDate);
            }
            else if (self.config.mode === "range") {
                if (self.selectedDates.length === 2) {
                    self.clear(false, false);
                }
                self.latestSelectedDateObj = selectedDate;
                self.selectedDates.push(selectedDate);
                // unless selecting same date twice, sort ascendingly
                if (compareDates(selectedDate, self.selectedDates[0], true) !== 0)
                    self.selectedDates.sort(function (a, b) { return a.getTime() - b.getTime(); });
            }
            setHoursFromInputs();
            if (shouldChangeMonth) {
                var isNewYear = self.currentYear !== selectedDate.getFullYear();
                self.currentYear = selectedDate.getFullYear();
                self.currentMonth = selectedDate.getMonth();
                if (isNewYear)
                    triggerEvent("onYearChange");
                triggerEvent("onMonthChange");
            }
            updateNavigationCurrentMonth();
            buildDays();
            updateValue();
            if (self.config.enableTime)
                setTimeout(function () { return (self.showTimeInput = true); }, 50);
            // maintain focus
            if (!shouldChangeMonth &&
                self.config.mode !== "range" &&
                self.config.showMonths === 1)
                focusOnDayElem(target);
            else if (self.selectedDateElem !== undefined &&
                self.hourElement === undefined) {
                self.selectedDateElem && self.selectedDateElem.focus();
            }
            if (self.hourElement !== undefined)
                self.hourElement !== undefined && self.hourElement.focus();
            if (self.config.closeOnSelect) {
                var single = self.config.mode === "single" && !self.config.enableTime;
                var range = self.config.mode === "range" &&
                    self.selectedDates.length === 2 &&
                    !self.config.enableTime;
                if (single || range) {
                    focusAndClose();
                }
            }
            triggerChange();
        }
        var CALLBACKS = {
            locale: [setupLocale, updateWeekdays],
            showMonths: [buildMonths, setCalendarWidth, buildWeekdays]
        };
        function set(option, value) {
            if (option !== null && typeof option === "object")
                Object.assign(self.config, option);
            else {
                self.config[option] = value;
                if (CALLBACKS[option] !== undefined)
                    CALLBACKS[option].forEach(function (x) { return x(); });
                else if (HOOKS.indexOf(option) > -1)
                    self.config[option] = arrayify(value);
            }
            self.redraw();
            updateValue(false);
        }
        function setSelectedDate(inputDate, format) {
            var dates = [];
            if (inputDate instanceof Array)
                dates = inputDate.map(function (d) { return self.parseDate(d, format); });
            else if (inputDate instanceof Date || typeof inputDate === "number")
                dates = [self.parseDate(inputDate, format)];
            else if (typeof inputDate === "string") {
                switch (self.config.mode) {
                    case "single":
                    case "time":
                        dates = [self.parseDate(inputDate, format)];
                        break;
                    case "multiple":
                        dates = inputDate
                            .split(self.config.conjunction)
                            .map(function (date) { return self.parseDate(date, format); });
                        break;
                    case "range":
                        dates = inputDate
                            .split(self.l10n.rangeSeparator)
                            .map(function (date) { return self.parseDate(date, format); });
                        break;
                    default:
                        break;
                }
            }
            else
                self.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
            self.selectedDates = dates.filter(function (d) { return d instanceof Date && isEnabled(d, false); });
            if (self.config.mode === "range")
                self.selectedDates.sort(function (a, b) { return a.getTime() - b.getTime(); });
        }
        function setDate(date, triggerChange, format) {
            if (triggerChange === void 0) { triggerChange = false; }
            if (format === void 0) { format = self.config.dateFormat; }
            if ((date !== 0 && !date) || (date instanceof Array && date.length === 0))
                return self.clear(triggerChange);
            setSelectedDate(date, format);
            self.showTimeInput = self.selectedDates.length > 0;
            self.latestSelectedDateObj = self.selectedDates[0];
            self.redraw();
            jumpToDate();
            setHoursFromDate();
            updateValue(triggerChange);
            if (triggerChange)
                triggerEvent("onChange");
        }
        function parseDateRules(arr) {
            return arr
                .slice()
                .map(function (rule) {
                if (typeof rule === "string" ||
                    typeof rule === "number" ||
                    rule instanceof Date) {
                    return self.parseDate(rule, undefined, true);
                }
                else if (rule &&
                    typeof rule === "object" &&
                    rule.from &&
                    rule.to)
                    return {
                        from: self.parseDate(rule.from, undefined),
                        to: self.parseDate(rule.to, undefined)
                    };
                return rule;
            })
                .filter(function (x) { return x; }); // remove falsy values
        }
        function setupDates() {
            self.selectedDates = [];
            self.now = self.parseDate(self.config.now) || new Date();
            // Workaround IE11 setting placeholder as the input's value
            var preloadedDate = self.config.defaultDate ||
                ((self.input.nodeName === "INPUT" ||
                    self.input.nodeName === "TEXTAREA") &&
                    self.input.placeholder &&
                    self.input.value === self.input.placeholder
                    ? null
                    : self.input.value);
            if (preloadedDate)
                setSelectedDate(preloadedDate, self.config.dateFormat);
            self._initialDate =
                self.selectedDates.length > 0
                    ? self.selectedDates[0]
                    : self.config.minDate &&
                        self.config.minDate.getTime() > self.now.getTime()
                        ? self.config.minDate
                        : self.config.maxDate &&
                            self.config.maxDate.getTime() < self.now.getTime()
                            ? self.config.maxDate
                            : self.now;
            self.currentYear = self._initialDate.getFullYear();
            self.currentMonth = self._initialDate.getMonth();
            if (self.selectedDates.length > 0)
                self.latestSelectedDateObj = self.selectedDates[0];
            if (self.config.minTime !== undefined)
                self.config.minTime = self.parseDate(self.config.minTime, "H:i");
            if (self.config.maxTime !== undefined)
                self.config.maxTime = self.parseDate(self.config.maxTime, "H:i");
            self.minDateHasTime =
                !!self.config.minDate &&
                    (self.config.minDate.getHours() > 0 ||
                        self.config.minDate.getMinutes() > 0 ||
                        self.config.minDate.getSeconds() > 0);
            self.maxDateHasTime =
                !!self.config.maxDate &&
                    (self.config.maxDate.getHours() > 0 ||
                        self.config.maxDate.getMinutes() > 0 ||
                        self.config.maxDate.getSeconds() > 0);
            Object.defineProperty(self, "showTimeInput", {
                get: function () { return self._showTimeInput; },
                set: function (bool) {
                    self._showTimeInput = bool;
                    if (self.calendarContainer)
                        toggleClass(self.calendarContainer, "showTimeInput", bool);
                    self.isOpen && positionCalendar();
                }
            });
        }
        function setupInputs() {
            self.input = self.config.wrap
                ? element.querySelector("[data-input]")
                : element;
            /* istanbul ignore next */
            if (!self.input) {
                self.config.errorHandler(new Error("Invalid input element specified"));
                return;
            }
            // hack: store previous type to restore it after destroy()
            self.input._type = self.input.type;
            self.input.type = "text";
            self.input.classList.add("flatpickr-input");
            self._input = self.input;
            if (self.config.altInput) {
                // replicate self.element
                self.altInput = createElement(self.input.nodeName, self.input.className + " " + self.config.altInputClass);
                self._input = self.altInput;
                self.altInput.placeholder = self.input.placeholder;
                self.altInput.disabled = self.input.disabled;
                self.altInput.required = self.input.required;
                self.altInput.tabIndex = self.input.tabIndex;
                self.altInput.type = "text";
                self.input.setAttribute("type", "hidden");
                if (!self.config.static && self.input.parentNode)
                    self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);
            }
            if (!self.config.allowInput)
                self._input.setAttribute("readonly", "readonly");
            self._positionElement = self.config.positionElement || self._input;
        }
        function setupMobile() {
            var inputType = self.config.enableTime
                ? self.config.noCalendar
                    ? "time"
                    : "datetime-local"
                : "date";
            self.mobileInput = createElement("input", self.input.className + " flatpickr-mobile");
            self.mobileInput.step = self.input.getAttribute("step") || "any";
            self.mobileInput.tabIndex = 1;
            self.mobileInput.type = inputType;
            self.mobileInput.disabled = self.input.disabled;
            self.mobileInput.required = self.input.required;
            self.mobileInput.placeholder = self.input.placeholder;
            self.mobileFormatStr =
                inputType === "datetime-local"
                    ? "Y-m-d\\TH:i:S"
                    : inputType === "date"
                        ? "Y-m-d"
                        : "H:i:S";
            if (self.selectedDates.length > 0) {
                self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);
            }
            if (self.config.minDate)
                self.mobileInput.min = self.formatDate(self.config.minDate, "Y-m-d");
            if (self.config.maxDate)
                self.mobileInput.max = self.formatDate(self.config.maxDate, "Y-m-d");
            self.input.type = "hidden";
            if (self.altInput !== undefined)
                self.altInput.type = "hidden";
            try {
                if (self.input.parentNode)
                    self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);
            }
            catch (_a) { }
            bind(self.mobileInput, "change", function (e) {
                self.setDate(e.target.value, false, self.mobileFormatStr);
                triggerEvent("onChange");
                triggerEvent("onClose");
            });
        }
        function toggle(e) {
            if (self.isOpen === true)
                return self.close();
            self.open(e);
        }
        function triggerEvent(event, data) {
            // If the instance has been destroyed already, all hooks have been removed
            if (self.config === undefined)
                return;
            var hooks = self.config[event];
            if (hooks !== undefined && hooks.length > 0) {
                for (var i = 0; hooks[i] && i < hooks.length; i++)
                    hooks[i](self.selectedDates, self.input.value, self, data);
            }
            if (event === "onChange") {
                self.input.dispatchEvent(createEvent("change"));
                // many front-end frameworks bind to the input event
                self.input.dispatchEvent(createEvent("input"));
            }
        }
        function createEvent(name) {
            var e = document.createEvent("Event");
            e.initEvent(name, true, true);
            return e;
        }
        function isDateSelected(date) {
            for (var i = 0; i < self.selectedDates.length; i++) {
                if (compareDates(self.selectedDates[i], date) === 0)
                    return "" + i;
            }
            return false;
        }
        function isDateInRange(date) {
            if (self.config.mode !== "range" || self.selectedDates.length < 2)
                return false;
            return (compareDates(date, self.selectedDates[0]) >= 0 &&
                compareDates(date, self.selectedDates[1]) <= 0);
        }
        function updateNavigationCurrentMonth() {
            if (self.config.noCalendar || self.isMobile || !self.monthNav)
                return;
            self.yearElements.forEach(function (yearElement, i) {
                var d = new Date(self.currentYear, self.currentMonth, 1);
                d.setMonth(self.currentMonth + i);
                self.monthElements[i].textContent =
                    monthToStr(d.getMonth(), self.config.shorthandCurrentMonth, self.l10n) +
                        " ";
                yearElement.value = d.getFullYear().toString();
            });
            self._hidePrevMonthArrow =
                self.config.minDate !== undefined &&
                    (self.currentYear === self.config.minDate.getFullYear()
                        ? self.currentMonth <= self.config.minDate.getMonth()
                        : self.currentYear < self.config.minDate.getFullYear());
            self._hideNextMonthArrow =
                self.config.maxDate !== undefined &&
                    (self.currentYear === self.config.maxDate.getFullYear()
                        ? self.currentMonth + 1 > self.config.maxDate.getMonth()
                        : self.currentYear > self.config.maxDate.getFullYear());
        }
        function getDateStr(format) {
            return self.selectedDates
                .map(function (dObj) { return self.formatDate(dObj, format); })
                .filter(function (d, i, arr) {
                return self.config.mode !== "range" ||
                    self.config.enableTime ||
                    arr.indexOf(d) === i;
            })
                .join(self.config.mode !== "range"
                ? self.config.conjunction
                : self.l10n.rangeSeparator);
        }
        /**
         * Updates the values of inputs associated with the calendar
         */
        function updateValue(triggerChange) {
            if (triggerChange === void 0) { triggerChange = true; }
            if (self.selectedDates.length === 0)
                return self.clear(triggerChange);
            if (self.mobileInput !== undefined && self.mobileFormatStr) {
                self.mobileInput.value =
                    self.latestSelectedDateObj !== undefined
                        ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr)
                        : "";
            }
            self.input.value = getDateStr(self.config.dateFormat);
            if (self.altInput !== undefined) {
                self.altInput.value = getDateStr(self.config.altFormat);
            }
            if (triggerChange !== false)
                triggerEvent("onValueUpdate");
        }
        function onMonthNavClick(e) {
            e.preventDefault();
            var isPrevMonth = self.prevMonthNav.contains(e.target);
            var isNextMonth = self.nextMonthNav.contains(e.target);
            if (isPrevMonth || isNextMonth) {
                changeMonth(isPrevMonth ? -1 : 1);
            }
            else if (self.yearElements.indexOf(e.target) >= 0) {
                e.target.select();
            }
            else if (e.target.classList.contains("arrowUp")) {
                self.changeYear(self.currentYear + 1);
            }
            else if (e.target.classList.contains("arrowDown")) {
                self.changeYear(self.currentYear - 1);
            }
        }
        function timeWrapper(e) {
            e.preventDefault();
            var isKeyDown = e.type === "keydown", input = e.target;
            if (self.amPM !== undefined && e.target === self.amPM) {
                self.amPM.textContent =
                    self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
            }
            var min = parseFloat(input.getAttribute("min")), max = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e.delta ||
                (isKeyDown ? (e.which === 38 ? 1 : -1) : 0);
            var newValue = curValue + step * delta;
            if (typeof input.value !== "undefined" && input.value.length === 2) {
                var isHourElem = input === self.hourElement, isMinuteElem = input === self.minuteElement;
                if (newValue < min) {
                    newValue =
                        max +
                            newValue +
                            int(!isHourElem) +
                            (int(isHourElem) && int(!self.amPM));
                    if (isMinuteElem)
                        incrementNumInput(undefined, -1, self.hourElement);
                }
                else if (newValue > max) {
                    newValue =
                        input === self.hourElement ? newValue - max - int(!self.amPM) : min;
                    if (isMinuteElem)
                        incrementNumInput(undefined, 1, self.hourElement);
                }
                if (self.amPM &&
                    isHourElem &&
                    (step === 1
                        ? newValue + curValue === 23
                        : Math.abs(newValue - curValue) > step)) {
                    self.amPM.textContent =
                        self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
                }
                input.value = pad(newValue);
            }
        }
        init();
        return self;
    }
    /* istanbul ignore next */
    function _flatpickr(nodeList, config) {
        // static list
        var nodes = Array.prototype.slice
            .call(nodeList)
            .filter(function (x) { return x instanceof HTMLElement; });
        var instances = [];
        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            try {
                if (node.getAttribute("data-fp-omit") !== null)
                    continue;
                if (node._flatpickr !== undefined) {
                    node._flatpickr.destroy();
                    node._flatpickr = undefined;
                }
                node._flatpickr = FlatpickrInstance(node, config || {});
                instances.push(node._flatpickr);
            }
            catch (e) {
                console.error(e);
            }
        }
        return instances.length === 1 ? instances[0] : instances;
    }
    /* istanbul ignore next */
    if (typeof HTMLElement !== "undefined") {
        // browser env
        HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function (config) {
            return _flatpickr(this, config);
        };
        HTMLElement.prototype.flatpickr = function (config) {
            return _flatpickr([this], config);
        };
    }
    /* istanbul ignore next */
    var flatpickr = function (selector, config) {
        if (typeof selector === "string") {
            return _flatpickr(window.document.querySelectorAll(selector), config);
        }
        else if (selector instanceof Node) {
            return _flatpickr([selector], config);
        }
        else {
            return _flatpickr(selector, config);
        }
    };
    /* istanbul ignore next */
    flatpickr.defaultConfig = defaults;
    flatpickr.l10ns = {
        en: __assign({}, english),
        "default": __assign({}, english)
    };
    flatpickr.localize = function (l10n) {
        flatpickr.l10ns["default"] = __assign({}, flatpickr.l10ns["default"], l10n);
    };
    flatpickr.setDefaults = function (config) {
        flatpickr.defaultConfig = __assign({}, flatpickr.defaultConfig, config);
    };
    flatpickr.parseDate = createDateParser({});
    flatpickr.formatDate = createDateFormatter({});
    flatpickr.compareDates = compareDates;
    /* istanbul ignore next */
    if (typeof jQuery !== "undefined") {
        jQuery.fn.flatpickr = function (config) {
            return _flatpickr(this, config);
        };
    }
    Date.prototype.fp_incr = function (days) {
        return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
    };
    if (typeof window !== "undefined") {
        window.flatpickr = flatpickr;
    }

    return flatpickr;

}));

},{}],131:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.de = {}));
}(this, function (exports) { 'use strict';

  var fp = typeof window !== "undefined" && window.flatpickr !== undefined
      ? window.flatpickr
      : {
          l10ns: {}
      };
  var German = {
      weekdays: {
          shorthand: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
          longhand: [
              "Sonntag",
              "Montag",
              "Dienstag",
              "Mittwoch",
              "Donnerstag",
              "Freitag",
              "Samstag",
          ]
      },
      months: {
          shorthand: [
              "Jan",
              "Feb",
              "Mr",
              "Apr",
              "Mai",
              "Jun",
              "Jul",
              "Aug",
              "Sep",
              "Okt",
              "Nov",
              "Dez",
          ],
          longhand: [
              "Januar",
              "Februar",
              "Mrz",
              "April",
              "Mai",
              "Juni",
              "Juli",
              "August",
              "September",
              "Oktober",
              "November",
              "Dezember",
          ]
      },
      firstDayOfWeek: 1,
      weekAbbreviation: "KW",
      rangeSeparator: " bis ",
      scrollTitle: "Zum ndern scrollen",
      toggleTitle: "Zum Umschalten klicken"
  };
  fp.l10ns.de = German;
  var de = fp.l10ns;

  exports.German = German;
  exports.default = de;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],132:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.fr = {}));
}(this, function (exports) { 'use strict';

  var fp = typeof window !== "undefined" && window.flatpickr !== undefined
      ? window.flatpickr
      : {
          l10ns: {}
      };
  var French = {
      firstDayOfWeek: 1,
      weekdays: {
          shorthand: ["dim", "lun", "mar", "mer", "jeu", "ven", "sam"],
          longhand: [
              "dimanche",
              "lundi",
              "mardi",
              "mercredi",
              "jeudi",
              "vendredi",
              "samedi",
          ]
      },
      months: {
          shorthand: [
              "janv",
              "fvr",
              "mars",
              "avr",
              "mai",
              "juin",
              "juil",
              "aot",
              "sept",
              "oct",
              "nov",
              "dc",
          ],
          longhand: [
              "janvier",
              "fvrier",
              "mars",
              "avril",
              "mai",
              "juin",
              "juillet",
              "aot",
              "septembre",
              "octobre",
              "novembre",
              "dcembre",
          ]
      },
      ordinal: function (nth) {
          if (nth > 1)
              return "";
          return "er";
      },
      rangeSeparator: " au ",
      weekAbbreviation: "Sem",
      scrollTitle: "Dfiler pour augmenter la valeur",
      toggleTitle: "Cliquer pour basculer"
  };
  fp.l10ns.fr = French;
  var fr = fp.l10ns;

  exports.French = French;
  exports.default = fr;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],133:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.it = {}));
}(this, function (exports) { 'use strict';

  var fp = typeof window !== "undefined" && window.flatpickr !== undefined
      ? window.flatpickr
      : {
          l10ns: {}
      };
  var Italian = {
      weekdays: {
          shorthand: ["Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"],
          longhand: [
              "Domenica",
              "Luned",
              "Marted",
              "Mercoled",
              "Gioved",
              "Venerd",
              "Sabato",
          ]
      },
      months: {
          shorthand: [
              "Gen",
              "Feb",
              "Mar",
              "Apr",
              "Mag",
              "Giu",
              "Lug",
              "Ago",
              "Set",
              "Ott",
              "Nov",
              "Dic",
          ],
          longhand: [
              "Gennaio",
              "Febbraio",
              "Marzo",
              "Aprile",
              "Maggio",
              "Giugno",
              "Luglio",
              "Agosto",
              "Settembre",
              "Ottobre",
              "Novembre",
              "Dicembre",
          ]
      },
      firstDayOfWeek: 1,
      ordinal: function () { return ""; },
      rangeSeparator: " al ",
      weekAbbreviation: "Se",
      scrollTitle: "Scrolla per aumentare",
      toggleTitle: "Clicca per cambiare"
  };
  fp.l10ns.it = Italian;
  var it = fp.l10ns;

  exports.Italian = Italian;
  exports.default = it;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],134:[function(require,module,exports){
(function (global){
/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.12.9
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.Popper = factory());
}(this, (function () { 'use strict';

var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
var timeoutDuration = 0;
for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
    timeoutDuration = 1;
    break;
  }
}

function microtaskDebounce(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }
    called = true;
    window.Promise.resolve().then(function () {
      called = false;
      fn();
    });
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

var supportsMicroTasks = isBrowser && window.Promise;

/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */
function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  }
  // NOTE: 1 DOM access here
  var css = getComputedStyle(element, null);
  return property ? css[property] : css;
}

/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */
function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }
  return element.parentNode || element.host;
}

/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */
function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element) {
    return document.body;
  }

  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
      return element.ownerDocument.body;
    case '#document':
      return element.body;
  }

  // Firefox want us to check `-x` and `-y` variations as well

  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}

/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */
function getOffsetParent(element) {
  // NOTE: 1 DOM access here
  var offsetParent = element && element.offsetParent;
  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    if (element) {
      return element.ownerDocument.documentElement;
    }

    return document.documentElement;
  }

  // .offsetParent will return the closest TD or TABLE in case
  // no offsetParent is present, I hate this job...
  if (['TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }
  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}

/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}

/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */
function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  }

  // Here we make sure to give as "start" the element that comes first in the DOM
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;

  // Get common ancestor container
  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer;

  // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  }

  // one of the nodes is inside shadowDOM, find which one
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}

/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}

/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}

/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */

function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

  return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
}

/**
 * Tells if you are running Internet Explorer 10
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean} isIE10
 */
var isIE10 = undefined;

var isIE10$1 = function () {
  if (isIE10 === undefined) {
    isIE10 = navigator.appVersion.indexOf('MSIE 10') !== -1;
  }
  return isIE10;
};

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE10$1() ? html['offset' + axis] + computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')] + computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')] : 0);
}

function getWindowSizes() {
  var body = document.body;
  var html = document.documentElement;
  var computedStyle = isIE10$1() && getComputedStyle(html);

  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}

/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */
function getBoundingClientRect(element) {
  var rect = {};

  // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11
  if (isIE10$1()) {
    try {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } catch (err) {}
  } else {
    rect = element.getBoundingClientRect();
  }

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };

  // subtract scrollbar size from sizes
  var sizes = element.nodeName === 'HTML' ? getWindowSizes() : {};
  var width = sizes.width || element.clientWidth || result.right - result.left;
  var height = sizes.height || element.clientHeight || result.bottom - result.top;

  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;

  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');

    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var isIE10 = isIE10$1();
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);

  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);

  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;

  // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.
  if (!isIE10 && isHTML) {
    var marginTop = parseFloat(styles.marginTop, 10);
    var marginLeft = parseFloat(styles.marginLeft, 10);

    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;

    // Attach marginTop and marginLeft because in some circumstances we may need them
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);

  var scrollTop = getScroll(html);
  var scrollLeft = getScroll(html, 'left');

  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };

  return getClientRect(offset);
}

/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }
  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }
  return isFixed(getParentNode(element));
}

/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @returns {Object} Coordinates of the boundaries
 */
function getBoundaries(popper, reference, padding, boundariesElement) {
  // NOTE: 1 DOM access here
  var boundaries = { top: 0, left: 0 };
  var offsetParent = findCommonOffsetParent(popper, reference);

  // Handle viewport case
  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;
    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(reference));
      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent);

    // In case of HTML, we need a different computation
    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  }

  // Add paddings
  boundaries.left += padding;
  boundaries.top += padding;
  boundaries.right -= padding;
  boundaries.bottom -= padding;

  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;

  return width * height;
}

/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };

  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });

  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });

  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

  var variation = placement.split('-')[1];

  return computedPlacement + (variation ? '-' + variation : '');
}

/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */
function getReferenceOffsets(state, popper, reference) {
  var commonOffsetParent = findCommonOffsetParent(popper, reference);
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent);
}

/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */
function getOuterSizes(element) {
  var styles = getComputedStyle(element);
  var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
  var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}

/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */
function getOppositePlacement(placement) {
  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0];

  // Get popper node sizes
  var popperRect = getOuterSizes(popper);

  // Add position, width and height to our offsets object
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };

  // depending by the popper placement we have to compute its offsets slightly differently
  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';

  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }

  return popperOffsets;
}

/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  }

  // use `filter` to obtain the same behavior of `find`
  return arr.filter(check)[0];
}

/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function findIndex(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  }

  // use `find` + `indexOf` if `findIndex` isn't supported
  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}

/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */
function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

  modifiersToRun.forEach(function (modifier) {
    if (modifier['function']) {
      // eslint-disable-line dot-notation
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }
    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
    if (modifier.enabled && isFunction(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);

      data = fn(data, modifier);
    }
  });

  return data;
}

/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */
function update() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }

  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };

  // compute reference element offsets
  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

  // store the computed placement inside `originalPlacement`
  data.originalPlacement = data.placement;

  // compute the popper offsets
  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
  data.offsets.popper.position = 'absolute';

  // run the modifiers
  data = runModifiers(this.modifiers, data);

  // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}

/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */
function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}

/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */
function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length - 1; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;
    if (typeof document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }
  return null;
}

/**
 * Destroy the popper
 * @method
 * @memberof Popper
 */
function destroy() {
  this.state.isDestroyed = true;

  // touch DOM only if `applyStyle` modifier is enabled
  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.left = '';
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners();

  // remove the popper if user explicity asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}

/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */
function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, { passive: true });

  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}

/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

  // Scroll event listener on scroll parents
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;

  return state;
}

/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}

/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  getWindow(reference).removeEventListener('resize', state.updateBound);

  // Remove scroll event listener on scroll parents
  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  });

  // Reset state
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}

/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger onUpdate callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}

/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */
function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}

/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = '';
    // add unit if the value is numeric and is one of the following
    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }
    element.style[prop] = styles[prop] + unit;
  });
}

/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */
function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles);

  // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element
  setAttributes(data.instance.popper, data.attributes);

  // if arrowElement is defined and arrowStyles has some properties
  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}

/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper.
 * @param {Object} options - Popper.js options
 */
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

  popper.setAttribute('x-placement', placement);

  // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations
  setStyles(popper, { position: 'absolute' });

  return options;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper;

  // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);

  // Styles
  var styles = {
    position: popper.position
  };

  // floor sides to avoid blurry text
  var offsets = {
    left: Math.floor(popper.left),
    top: Math.floor(popper.top),
    bottom: Math.floor(popper.bottom),
    right: Math.floor(popper.right)
  };

  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right';

  // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed
  var prefixedProperty = getSupportedPropertyName('transform');

  // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.
  var left = void 0,
      top = void 0;
  if (sideA === 'bottom') {
    top = -offsetParentRect.height + offsets.bottom;
  } else {
    top = offsets.top;
  }
  if (sideB === 'right') {
    left = -offsetParentRect.width + offsets.right;
  } else {
    left = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  }

  // Attributes
  var attributes = {
    'x-placement': data.placement
  };

  // Update `data` attributes, styles and arrowStyles
  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

  return data;
}

/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */
function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });

  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';
    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }
  return isRequired;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function arrow(data, options) {
  var _data$offsets$arrow;

  // arrow depends on keepTogether in order to work
  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element;

  // if arrowElement is a string, suppose it's a CSS selector
  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement);

    // if arrowElement is not found, don't run the modifier
    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isVertical = ['left', 'right'].indexOf(placement) !== -1;

  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len];

  //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjuction
  //

  // top/left side
  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  }
  // bottom/right side
  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }
  data.offsets.popper = getClientRect(data.offsets.popper);

  // compute center of the popper
  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

  // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available
  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

  // prevent arrowElement from being placed not contiguously to its popper
  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

  return data;
}

/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */
function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }
  return variation;
}

/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-right` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */
var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

// Get rid of `auto` `auto-start` and `auto-end`
var validPlacements = placements.slice(3);

/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }

  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement);

  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';

  var flipOrder = [];

  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);

    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference;

    // using floor because the reference offsets may contain decimals we are not going to consider here
    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

    // flip the variation if required
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
    var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : '');

      // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future
      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }
  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}

/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2];

  // If it's not a number it's an operator, I guess
  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;
    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;
      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;
    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}

/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */
function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0];

  // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one
  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

  // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  });

  // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space
  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  }

  // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

  // Convert the values with units to absolute pixels to allow our computations
  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op
    // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, [])
    // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });

  // Loop trough the offsets arrays and execute the operations
  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */
function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var basePlacement = placement.split('-')[0];

  var offsets = void 0;
  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }

  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }

  data.popper = popper;
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

  // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken
  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement);
  options.boundaries = boundaries;

  var order = options.priority;
  var popper = data.offsets.popper;

  var check = {
    primary: function primary(placement) {
      var value = popper[placement];
      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }
      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];
      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }
      return defineProperty({}, mainSide, value);
    }
  };

  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends({}, popper, check[side](placement));
  });

  data.offsets.popper = popper;

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1];

  // if shift shiftvariation is specified, run the modifier
  if (shiftvariation) {
    var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;

    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };

    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }

  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;

  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }

    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }

    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);

  return data;
}

/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */
var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: shift
  },

  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unitless, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the height.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > More on this [reading this issue](https://github.com/FezVrasta/popper.js/issues/373)
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: offset,
    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * An scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries"  or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: preventOverflow,
    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],
    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper this makes sure the popper has always a little padding
     * between the edges of its container
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier, can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near eachothers
   * without leaving any gap between the two. Expecially useful when the arrow is
   * enabled and you want to assure it to point to its reference element.
   * It cares only about the first axis, you can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjuction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: arrow,
    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },

  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: flip,
    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations).
     */
    behavior: 'flip',
    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position,
     * the popper will never be placed outside of the defined boundaries
     * (except if keepTogether is enabled)
     */
    boundariesElement: 'viewport'
  },

  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,
    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,
    /** @prop {ModifierFn} */
    fn: inner
  },

  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: hide
  },

  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: computeStyle,
    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3d transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties.
     */
    gpuAcceleration: true,
    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',
    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define you own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: applyStyle,
    /** @prop {Function} */
    onLoad: applyStyleOnLoad,
    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3d transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties.
     */
    gpuAcceleration: undefined
  }
};

/**
 * The `dataObject` is an object containing all the informations used by Popper.js
 * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow, it expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements.
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overriden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass as 3rd argument an object with the same
 * structure of this object, example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
var Defaults = {
  /**
   * Popper's placement
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Whether events (resize, scroll) are initially enabled
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated, this callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js
   * @prop {modifiers}
   */
  modifiers: modifiers
};

/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */

// Utils
// Methods
var Popper = function () {
  /**
   * Create a new Popper.js instance
   * @class Popper
   * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper
   * @param {HTMLElement} popper - The HTML element used as popper.
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    };

    // make update() debounced, so that it only runs at most once-per-tick
    this.update = debounce(this.update.bind(this));

    // with {} we create a new object with the options inside it
    this.options = _extends({}, Popper.Defaults, options);

    // init state
    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    };

    // get reference and popper elements (allow jQuery wrappers)
    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper;

    // Deep merge modifiers options
    this.options.modifiers = {};
    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    });

    // Refactoring modifiers' list (Object => Array)
    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends({
        name: name
      }, _this.options.modifiers[name]);
    })
    // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    });

    // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    });

    // fire the first update to position the popper in the right place
    this.update();

    var eventsEnabled = this.options.eventsEnabled;
    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  }

  // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }

    /**
     * Schedule an update, it will run on the next UI update available
     * @method scheduleUpdate
     * @memberof Popper
     */


    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();

/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;

return Popper;

})));


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],135:[function(require,module,exports){
(function (global){
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global global, define, System, Reflect, Promise */
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __await;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
var __makeTemplateObject;
(function (factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function (exports) { factory(createExporter(root, createExporter(exports))); });
    }
    else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
    }
    else {
        factory(createExporter(root));
    }
    function createExporter(exports, previous) {
        if (exports !== root) {
            if (typeof Object.create === "function") {
                Object.defineProperty(exports, "__esModule", { value: true });
            }
            else {
                exports.__esModule = true;
            }
        }
        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
    }
})
(function (exporter) {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

    __extends = function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };

    __rest = function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    };

    __decorate = function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    __param = function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };

    __metadata = function (metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    };

    __awaiter = function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };

    __generator = function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [0, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };

    __exportStar = function (m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    };

    __values = function (o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    };

    __read = function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    __spread = function () {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    };

    __await = function (v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    };

    __asyncGenerator = function (thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    };

    __asyncDelegator = function (o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; }; }
    };

    __asyncValues = function (o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator];
        return m ? m.call(o) : typeof __values === "function" ? __values(o) : o[Symbol.iterator]();
    };

    __makeTemplateObject = function (cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJtYWluL2J1bmRsZS50cyIsIm1haW4vcG9seWZpbGxzL01hdGguc2lnbi50cyIsIm1haW4vcG9seWZpbGxzL3N0YXJ0c1dpdGgudHMiLCJtYWluL3NkeC1nbG9iYWwudHMiLCJtYWluL3NyYy9Eb21FbGVtZW50LnRzIiwibWFpbi9zcmMvRG9tRnVuY3Rpb25zLnRzIiwibWFpbi9zcmMvSW5wdXRzLnRzIiwibWFpbi9zcmMvVXRpbHMudHMiLCJtYWluL3NyYy9hY2NvcmRpb24vQWNjb3JkaW9uLnRzIiwibWFpbi9zcmMvY2Fyb3VzZWwvQ2Fyb3VzZWwudHMiLCJtYWluL3NyYy9jaGFydHMvQmFyQ2hhcnRIb3Jpem9udGFsLnRzIiwibWFpbi9zcmMvY2hhcnRzL0JhckNoYXJ0VmVydGljYWwudHMiLCJtYWluL3NyYy9jaGFydHMvQ2hhcnRGdW5jdGlvbnMudHMiLCJtYWluL3NyYy9jaGFydHMvUGllQ2hhcnQudHMiLCJtYWluL3NyYy9jb2xsYXBzZS9Db2xsYXBzZS50cyIsIm1haW4vc3JjL2VtcHR5LXN0YXRlcy9FbXB0eVN0YXRlLnRzIiwibWFpbi9zcmMvZm9ybS9BdXRvY29tcGxldGUudHMiLCJtYWluL3NyYy9mb3JtL0lucHV0RmllbGQudHMiLCJtYWluL3NyYy9mb3JtL1JhbmdlLnRzIiwibWFpbi9zcmMvZm9ybS9TZWxlY3QudHMiLCJtYWluL3NyYy9mb3JtL1RleHRhcmVhLnRzIiwibWFpbi9zcmMvbG9hZGVyL0xvYWRlckJhci50cyIsIm1haW4vc3JjL21lbnUvTWVudUZseW91dC50cyIsIm1haW4vc3JjL21vZGFsL01vZGFsLnRzIiwibWFpbi9zcmMvbmF2aWdhdGlvbi9OYXZpZ2F0aW9uLnRzIiwibWFpbi9zcmMvbmF2aWdhdGlvbi9OYXZpZ2F0aW9uU2lkZS50cyIsIm1haW4vc3JjL25vdGlmaWNhdGlvbi9Ob3RpZmljYXRpb24udHMiLCJtYWluL3NyYy9wcm9ncmVzcy9Qcm9ncmVzc0Z1bGwudHMiLCJtYWluL3NyYy9wcm9ncmVzcy9Qcm9ncmVzc0xpZ2h0LnRzIiwibWFpbi9zcmMvc2R4LnRzIiwibWFpbi9zcmMvc2VhcmNoL1NlYXJjaElucHV0LnRzIiwibWFpbi9zcmMvdGFibGUvVGFibGUudHMiLCJtYWluL3NyYy90b29sYmFyL1Rvb2xiYXIudHMiLCJidWlsZC90cy9tb2Rlcm5penIuanMiLCJub2RlX21vZHVsZXMvYW5pbWVqcy9hbmltZS5taW4uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2FycmF5L2Zyb20uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL21hdGgvc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvbWF0aC90cnVuYy5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvbnVtYmVyL2lzLW5hbi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvbnVtYmVyL21heC1zYWZlLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJub2RlX21vZHVsZXMvYm9keS1zY3JvbGwtbG9jay9saWIvYm9keVNjcm9sbExvY2subWluLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9hcnJheS9mcm9tLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9tYXRoL3NpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL21hdGgvdHJ1bmMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL251bWJlci9pcy1uYW4uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL251bWJlci9tYXgtc2FmZS1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jbGFzc29mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ZhaWxzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19nbG9iYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hhcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGlkZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faHRtbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY2FsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1zdGVwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyYXRvcnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2xpYnJhcnkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21hdGgtc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWV0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHBzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1ncG8uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWxlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3VpZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWV4dC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm1hdGguc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYubWF0aC50cnVuYy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYubnVtYmVyLmlzLW5hbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJub2RlX21vZHVsZXMvZmxhdHBpY2tyL2Rpc3QvZmxhdHBpY2tyLmpzIiwibm9kZV9tb2R1bGVzL2ZsYXRwaWNrci9kaXN0L2wxMG4vZGUuanMiLCJub2RlX21vZHVsZXMvZmxhdHBpY2tyL2Rpc3QvbDEwbi9mci5qcyIsIm5vZGVfbW9kdWxlcy9mbGF0cGlja3IvZGlzdC9sMTBuL2l0LmpzIiwibm9kZV9tb2R1bGVzL3BvcHBlci5qcy9kaXN0L3VtZC9wb3BwZXIuanMiLCJub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0FDT0E7Ozs7QUNQQTs7QUFDQSxJQUFJLEVBQUUsVUFBTixJQUFJLENBQUosRUFBdUI7QUFDcEIsU0FBQSxJQUFBLEdBQW9CLFVBQUEsQ0FBQSxFQUFrQjtBQUNyQyxlQUFRLElBQUQsQ0FBQyxHQUFELENBQUMsR0FBZSxJQUFELENBQUMsR0FBUyxDQUFWLENBQUMsR0FBYyxDQUFyQyxDQUFBO0FBREQsS0FBQTtBQUdGOzs7OztBQ0hELElBQUksQ0FBQyxPQUFBLFNBQUEsQ0FBTCxVQUFBLEVBQWtDO0FBQ2hDLFdBQUEsU0FBQSxDQUFBLFVBQUEsR0FBOEIsVUFBQSxZQUFBLEVBQUEsUUFBQSxFQUErQjtBQUMzRCxtQkFBVyxZQUFYLENBQUE7QUFDQSxlQUFPLEtBQUEsT0FBQSxDQUFBLFlBQUEsRUFBQSxRQUFBLE1BQVAsUUFBQTtBQUZGLEtBQUE7QUFJRDs7Ozs7Ozs7O0FDTkQ7O0FBQ0E7O0FBRUE7O0lBQUEsVTs7OztBQTRDQSxJQUFJLE1BQUcsUUFBQSxRQUFBLENBQUEsRUFBQSxFQUFBLFVBQUEsRUFFRCxPQUFBLEdBQUEsSUFGQyxFQUFBLEVBRXVCLEVBQzVCLFNBSEYsV0FFOEIsRUFGdkIsQ0FBUDtBQWhEQTs7QUFzREEsT0FBQSxHQUFBLEdBQUEsR0FBQTtBQUVBLFdBQUEsS0FBQSxDQUFBLGVBQUEsQ0FBaUMsWUFBQTtBQUMvQixlQUFBLGNBQUE7QUFDQSxlQUFBLFlBQUE7QUFDQSxlQUFBLFVBQUE7QUFDQSxlQUFBLGFBQUE7QUFDQSxlQUFBLGdCQUFBO0FBRUEsZUFBQSxpQkFBQTtBQUNBLGVBQUEsZ0JBQUE7QUFF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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoQ0E7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxT0E7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ244RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzc0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIvKipcbiAqIFRoZSBtYWluIFNEWCBidW5kbGUuIFRoaXMgaW5jbHVkZXMgYWxsIGRlcGVuZGVuY2llcyByZXF1aXJlZCB0b1xuICogdXNlIHRoZSBTRFggbGlicmFyeSBhbmQgaXMgaW50ZW5kZWQgdG8gdXNlIGluIHN0YXRpYyBjb250ZXh0cy5cbiAqL1xuXG5pbXBvcnQgXCIuLi9tb2Rlcm5penJcIlxuXG5pbXBvcnQgXCIuL3NkeC1nbG9iYWxcIlxuIiwiLy8gTWF0aC5zaWduICh1c2VkIGluIFByb2dyZXNzRnVsbClcbmlmICghKFwic2lnblwiIGluIE1hdGgpKSB7XG4gIChNYXRoIGFzIGFueSkuc2lnbiA9IGZ1bmN0aW9uKHg6IG51bWJlcikge1xuICAgIHJldHVybiAoeCA+IDApID8gMSA6ICgoeCA8IDApID8gLTEgOiAreClcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxuaWYgKCFTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGgpIHtcbiAgU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoID0gZnVuY3Rpb24oc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikge1xuICAgIHBvc2l0aW9uID0gcG9zaXRpb24gfHwgMFxuICAgIHJldHVybiB0aGlzLmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikgPT09IHBvc2l0aW9uXG4gIH1cbn1cbiIsIi8qIFBvbHlmaWxscyAqL1xuaW1wb3J0IFwiLi9wb2x5ZmlsbHMvTWF0aC5zaWduXCJcbmltcG9ydCBcIi4vcG9seWZpbGxzL3N0YXJ0c1dpdGhcIlxuXG5pbXBvcnQgKiBhcyBzZHhFeHBvcnRzIGZyb20gXCIuL3NyYy9zZHhcIlxuXG5leHBvcnQgaW50ZXJmYWNlIFNEWEdsb2JhbCB7XG4gIFZFUlNJT046IHN0cmluZ1xuXG4gIExvYWRlckJhcjogdHlwZW9mIHNkeEV4cG9ydHMuTG9hZGVyQmFyXG5cbiAgU2VsZWN0OiB0eXBlb2Ygc2R4RXhwb3J0cy5TZWxlY3RcbiAgSW5wdXRGaWVsZDogdHlwZW9mIHNkeEV4cG9ydHMuSW5wdXRGaWVsZFxuICBUZXh0YXJlYTogdHlwZW9mIHNkeEV4cG9ydHMuVGV4dGFyZWFcbiAgQXV0b2NvbXBsZXRlOiB0eXBlb2Ygc2R4RXhwb3J0cy5BdXRvY29tcGxldGVcblxuICBQcm9ncmVzc0xpZ2h0OiB0eXBlb2Ygc2R4RXhwb3J0cy5Qcm9ncmVzc0xpZ2h0XG4gIFByb2dyZXNzRnVsbDogdHlwZW9mIHNkeEV4cG9ydHMuUHJvZ3Jlc3NGdWxsXG5cbiAgUmFuZ2U6IHR5cGVvZiBzZHhFeHBvcnRzLlJhbmdlXG4gIE1vZGFsOiB0eXBlb2Ygc2R4RXhwb3J0cy5Nb2RhbFxuICBUb29sYmFyOiB0eXBlb2Ygc2R4RXhwb3J0cy5Ub29sYmFyXG4gIE5vdGlmaWNhdGlvbjogdHlwZW9mIHNkeEV4cG9ydHMuTm90aWZpY2F0aW9uXG5cbiAgQ29sbGFwc2U6IHR5cGVvZiBzZHhFeHBvcnRzLkNvbGxhcHNlXG4gIEFjY29yZGlvbjogdHlwZW9mIHNkeEV4cG9ydHMuQWNjb3JkaW9uXG5cbiAgTWVudUZseW91dDogdHlwZW9mIHNkeEV4cG9ydHMuTWVudUZseW91dFxuXG4gIE5hdmlnYXRpb246IHR5cGVvZiBzZHhFeHBvcnRzLk5hdmlnYXRpb25cbiAgTmF2aWdhdGlvblNpZGU6IHR5cGVvZiBzZHhFeHBvcnRzLk5hdmlnYXRpb25TaWRlXG4gIFNlYXJjaElucHV0OiB0eXBlb2Ygc2R4RXhwb3J0cy5TZWFyY2hJbnB1dFxuICBFbXB0eVN0YXRlOiB0eXBlb2Ygc2R4RXhwb3J0cy5FbXB0eVN0YXRlXG4gIENhcm91c2VsOiB0eXBlb2Ygc2R4RXhwb3J0cy5DYXJvdXNlbFxuXG4gIFRhYmxlOiB0eXBlb2Ygc2R4RXhwb3J0cy5UYWJsZVxuXG4gIFBpZUNoYXJ0OiB0eXBlb2Ygc2R4RXhwb3J0cy5QaWVDaGFydFxuICBCYXJDaGFydEhvcml6b250YWw6IHR5cGVvZiBzZHhFeHBvcnRzLkJhckNoYXJ0SG9yaXpvbnRhbFxuICBCYXJDaGFydFZlcnRpY2FsOiB0eXBlb2Ygc2R4RXhwb3J0cy5CYXJDaGFydFZlcnRpY2FsXG59XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgc2R4OiBTRFhHbG9iYWxcbiAgfVxufVxuXG5sZXQgc2R4ID0ge1xuICAuLi5zZHhFeHBvcnRzLFxuICAuLi4od2luZG93LnNkeCBhcyBhbnkpIHx8IHt9LFxuICBWRVJTSU9OOiBcIiRWRVJTSU9OJFwiXG59XG5cbndpbmRvdy5zZHggPSBzZHhcblxuc2R4RXhwb3J0cy51dGlscy5vbkRvY3VtZW50UmVhZHkoKCkgPT4ge1xuICBzZHhFeHBvcnRzLmluaXRJbnB1dEZpZWxkKClcbiAgc2R4RXhwb3J0cy5pbml0VGV4dGFyZWEoKVxuICBzZHhFeHBvcnRzLmluaXRTZWxlY3QoKVxuICBzZHhFeHBvcnRzLmluaXRMb2FkZXJCYXIoKVxuICBzZHhFeHBvcnRzLmluaXRBdXRvY29tcGxldGUoKVxuXG4gIHNkeEV4cG9ydHMuaW5pdFByb2dyZXNzTGlnaHQoKVxuICBzZHhFeHBvcnRzLmluaXRQcm9ncmVzc0Z1bGwoKVxuXG4gIHNkeEV4cG9ydHMuaW5pdFJhbmdlKClcbiAgc2R4RXhwb3J0cy5pbml0TW9kYWwoKVxuXG4gIHNkeEV4cG9ydHMuaW5pdEFjY29yZGlvbigpXG4gIHNkeEV4cG9ydHMuaW5pdENvbGxhcHNlKClcbiAgc2R4RXhwb3J0cy5pbml0TWVudUZseW91dCgpXG5cbiAgc2R4RXhwb3J0cy5pbml0TmF2aWdhdGlvbigpXG4gIHNkeEV4cG9ydHMuaW5pdE5hdmlnYXRpb25TaWRlKClcbiAgc2R4RXhwb3J0cy5pbml0U2VhcmNoSW5wdXQoKVxuICBzZHhFeHBvcnRzLmluaXRFbXB0eVN0YXRlKClcbiAgc2R4RXhwb3J0cy5pbml0Q2Fyb3VzZWwoKVxuICBzZHhFeHBvcnRzLmluaXRUYWJsZSgpXG5cbiAgc2R4RXhwb3J0cy5pbml0UGllQ2hhcnQoKVxuICBzZHhFeHBvcnRzLmluaXRCYXJDaGFydEhvcml6b250YWwoKVxuICBzZHhFeHBvcnRzLmluaXRCYXJDaGFydFZlcnRpY2FsKClcbn0pXG4iLCJpbXBvcnQgKiBhcyBEb20gZnJvbSBcIi4vRG9tRnVuY3Rpb25zXCJcblxuZGVjbGFyZSBnbG9iYWwge1xuICBsZXQgaHRtbEV2ZW50czoge1xuICAgIFtldmVudE5hbWU6IHN0cmluZ106ICgpID0+IHZvaWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBBIHdyYXBwZXIgY2xhc3MgZm9yIERPTSBFbGVtZW50cy5cbiAqL1xuY2xhc3MgRG9tRWxlbWVudDxUIGV4dGVuZHMgRWxlbWVudCA9IEVsZW1lbnQ+IHtcbiAgcHVibGljIGVsZW1lbnQ6IFRcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gLSBUaGUgZWxlbWVudCB0byB3cmFwLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gLSBUaGUgRE9NIGVsZW1lbnQgdG8gY3JlYXRlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudDogVCB8IGtleW9mIEVsZW1lbnRUYWdOYW1lTWFwKSB7XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGlzLmVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsZW1lbnQpIGFzIEVsZW1lbnQgYXMgVFxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIHNwZWNpZmllZCBDU1MgY2xhc3MgdG8gdGhlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSAtIFRoZSBjbGFzcyBuYW1lIHRvIGFkZC5cbiAgICogQHJldHVybiB7RG9tRWxlbWVudH0gUmV0dXJucyB0aGUgY3VycmVudCBpbnN0YW5jZSBmb3IgZmx1ZW50IGNoYWluaW5nIG9mIGNhbGxzLlxuICAgKi9cbiAgcHVibGljIGFkZENsYXNzKG5hbWU6IHN0cmluZykge1xuICAgIERvbS5hZGRDbGFzcyh0aGlzLmVsZW1lbnQsIG5hbWUpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgQ1NTIGNsYXNzIGZyb20gdGhlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSAtIFRoZSBjbGFzcyBuYW1lIHRvIHJlbW92ZS5cbiAgICogQHJldHVybiB7RG9tRWxlbWVudH0gUmV0dXJucyB0aGUgY3VycmVudCBpbnN0YW5jZSBmb3IgZmx1ZW50IGNoYWluaW5nIG9mIGNhbGxzLlxuICAgKi9cbiAgcHVibGljIHJlbW92ZUNsYXNzKG5hbWU6IHN0cmluZykge1xuICAgIERvbS5yZW1vdmVDbGFzcyh0aGlzLmVsZW1lbnQsIG5hbWUpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHB1YmxpYyBoYXNDbGFzcyhuYW1lOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gRG9tLmhhc0NsYXNzKHRoaXMuZWxlbWVudCwgbmFtZSlcbiAgfVxuXG4gIHB1YmxpYyB0b2dnbGVDbGFzcyhuYW1lOiBzdHJpbmcpIHtcbiAgICBEb20udG9nZ2xlQ2xhc3ModGhpcy5lbGVtZW50LCBuYW1lKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBnZXQgY2xhc3NlcygpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LmNsYXNzTGlzdFxuICB9XG5cbiAgcHVibGljIHNldElkKGlkOiBzdHJpbmcpIHtcbiAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwiaWRcIiwgaWQpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldCBpbm5lclRleHQoKSB7XG4gICAgcmV0dXJuIERvbS50ZXh0KHRoaXMuZWxlbWVudClcbiAgfVxuXG4gIGdldCBpbm5lckh0bWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5pbm5lckhUTUxcbiAgfVxuXG4gIHB1YmxpYyBzZXRIdG1sKHZhbHVlOiBzdHJpbmcpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBIVE1MIHN0cmluZ1wiKVxuICAgIH1cblxuICAgIHRoaXMuZWxlbWVudC5pbm5lckhUTUwgPSB2YWx1ZVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwdWJsaWMgZ2V0QXR0cmlidXRlKG5hbWU6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKG5hbWUpXG4gIH1cblxuICBwdWJsaWMgc2V0QXR0cmlidXRlKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAqL1xuICBwdWJsaWMgYWRkRXZlbnRMaXN0ZW5lcjxUIGV4dGVuZHMga2V5b2YgSFRNTEVsZW1lbnRFdmVudE1hcD4odHlwZTogVCwgbGlzdGVuZXI6IChlOiBIVE1MRWxlbWVudEV2ZW50TWFwW1RdKSA9PiB2b2lkKSB7XG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpXG4gIH1cblxuICAvKipcbiAgICogVW5yZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIHB1YmxpYyByZW1vdmVFdmVudExpc3RlbmVyPFQgZXh0ZW5kcyBrZXlvZiBIVE1MRWxlbWVudEV2ZW50TWFwPih0eXBlOiBULCBsaXN0ZW5lcjogKGU6IEhUTUxFbGVtZW50RXZlbnRNYXBbVF0pID0+IHZvaWQpIHtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcilcbiAgfVxuXG4gIHB1YmxpYyBhcHBlbmRDaGlsZChuZXdDaGlsZDogRG9tRWxlbWVudCkge1xuICAgIGlmICghKG5ld0NoaWxkIGluc3RhbmNlb2YgRG9tRWxlbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkgb3RoZXIgRG9tRWxlbWVudHMgY2FuIGJlIGFkZGVkIGFzIGNoaWxkcmVuXCIpXG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKG5ld0NoaWxkLmVsZW1lbnQpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHB1YmxpYyBwcmVwZW5kQ2hpbGQobmV3Q2hpbGQ6IERvbUVsZW1lbnQpIHtcbiAgICBpZiAoIShuZXdDaGlsZCBpbnN0YW5jZW9mIERvbUVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG90aGVyIERvbUVsZW1lbnRzIGNhbiBiZSBhZGRlZCBhcyBjaGlsZHJlblwiKVxuICAgIH1cblxuICAgIHRoaXMuZWxlbWVudC5pbnNlcnRCZWZvcmUobmV3Q2hpbGQuZWxlbWVudCwgdGhpcy5lbGVtZW50LmZpcnN0Q2hpbGQpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHB1YmxpYyBpbnNlcnRCZWZvcmUobmV3Q2hpbGQ6IERvbUVsZW1lbnQpIHtcbiAgICBpZiAoIShuZXdDaGlsZCBpbnN0YW5jZW9mIERvbUVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG90aGVyIERvbUVsZW1lbnRzIGNhbiBiZSBhZGRlZCBhcyBjaGlsZHJlblwiKVxuICAgIH1cbiAgICBpZiAoIXRoaXMuZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbGVtZW50IGlzIG5vdCBhdHRhY2hlZFwiKVxuICAgIH1cblxuICAgIHRoaXMuZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdDaGlsZC5lbGVtZW50LCB0aGlzLmVsZW1lbnQpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHB1YmxpYyBpbnNlcnRBZnRlcihuZXdDaGlsZDogRG9tRWxlbWVudCkge1xuICAgIGlmICghKG5ld0NoaWxkIGluc3RhbmNlb2YgRG9tRWxlbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkgb3RoZXIgRG9tRWxlbWVudHMgY2FuIGJlIGFkZGVkIGFzIGNoaWxkcmVuXCIpXG4gICAgfVxuICAgIGlmICghdGhpcy5lbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVsZW1lbnQgaXMgbm90IGF0dGFjaGVkXCIpXG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld0NoaWxkLmVsZW1lbnQsIHRoaXMuZWxlbWVudC5uZXh0U2libGluZylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHVibGljIHJlbW92ZUNoaWxkKG9sZENoaWxkOiBEb21FbGVtZW50KSB7XG4gICAgaWYgKCEob2xkQ2hpbGQgaW5zdGFuY2VvZiBEb21FbGVtZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBhIERvbUVsZW1lbnRzIGNoaWxkIGNhbiBiZSByZW1vdmVkXCIpXG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUNoaWxkKG9sZENoaWxkLmVsZW1lbnQpXG4gIH1cblxuICBwdWJsaWMgZmluZChzZWxlY3RvcnM6IHN0cmluZykge1xuICAgIGxldCBlID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3JzKVxuICAgIGlmIChlKSB7XG4gICAgICByZXR1cm4gbmV3IERvbUVsZW1lbnQoZSBhcyBFbGVtZW50KVxuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHB1YmxpYyB3cmFwV2l0aEVsZW1lbnQod3JhcHBlckVsZW1lbnQ6IERvbUVsZW1lbnQpIHtcbiAgICBpZiAoIXRoaXMuZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbGVtZW50IGlzIG5vdCBhdHRhY2hlZFwiKVxuICAgIH1cbiAgICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQod3JhcHBlckVsZW1lbnQuZWxlbWVudCwgdGhpcy5lbGVtZW50KVxuICAgIHdyYXBwZXJFbGVtZW50LmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50KVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHB1YmxpYyBkaXNwYXRjaEV2ZW50KGV2ZW50TmFtZTogc3RyaW5nKSB7XG4gICAgbGV0IGV2ZW50XG4gICAgbGV0IGVsID0gdGhpcy5lbGVtZW50XG5cbiAgICBpZiAoZG9jdW1lbnQuY3JlYXRlRXZlbnQpIHtcbiAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJIVE1MRXZlbnRzXCIpXG4gICAgICBldmVudC5pbml0RXZlbnQoZXZlbnROYW1lLCB0cnVlLCB0cnVlKVxuICAgIH0gZWxzZSBpZiAoKGRvY3VtZW50IGFzIGFueSkuY3JlYXRlRXZlbnRPYmplY3QpIHsgLy8gSUUgPCA5XG4gICAgICBldmVudCA9IChkb2N1bWVudCBhcyBhbnkpLmNyZWF0ZUV2ZW50T2JqZWN0KClcbiAgICAgIGV2ZW50LmV2ZW50VHlwZSA9IGV2ZW50TmFtZVxuICAgIH1cbiAgICBldmVudC5ldmVudE5hbWUgPSBldmVudE5hbWVcbiAgICBpZiAoZWwuZGlzcGF0Y2hFdmVudCkge1xuICAgICAgZWwuZGlzcGF0Y2hFdmVudChldmVudClcbiAgICB9IGVsc2UgaWYgKChlbCBhcyBhbnkpLmZpcmVFdmVudCAmJiBodG1sRXZlbnRzW2BvbiR7ZXZlbnROYW1lfWBdKSB7IC8vIElFIDwgOVxuICAgICAgKGVsIGFzIGFueSkuZmlyZUV2ZW50KGBvbiR7ZXZlbnQuZXZlbnRUeXBlfWAsIGV2ZW50KSAvLyBjYW4gdHJpZ2dlciBvbmx5IHJlYWwgZXZlbnQgKGUuZy4gJ2NsaWNrJylcbiAgICB9IGVsc2UgaWYgKGVsW2V2ZW50TmFtZSBhcyBrZXlvZiBFbGVtZW50XSkge1xuICAgICAgKGVsIGFzIGFueSlbZXZlbnROYW1lXSgpXG4gICAgfSBlbHNlIGlmIChlbFtgb24ke2V2ZW50TmFtZX1gIGFzIGtleW9mIEVsZW1lbnRdKSB7XG4gICAgICAoZWwgYXMgYW55KVtgb24ke2V2ZW50TmFtZX1gXSgpXG4gICAgfVxuICB9XG5cbiAgcHVibGljIGNzcyhwcm9wZXJ0eTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIERvbS5jc3ModGhpcy5lbGVtZW50LCBwcm9wZXJ0eSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBjaGlsZCBub2RlcyBvZiB0aGUgY3VycmVudCBEb21FbGVtZW50LlxuICAgKi9cbiAgcHVibGljIGVtcHR5KCkge1xuICAgIERvbS5lbXB0eSh0aGlzLmVsZW1lbnQpXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRG9tRWxlbWVudFxuIiwiXG5leHBvcnQgZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudDogRWxlbWVudCwgbmFtZTogc3RyaW5nKSB7XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHN0cmluZyBjbGFzcyBuYW1lXCIpXG4gIH1cblxuICBlbGVtZW50LmNsYXNzTGlzdC5hZGQobmFtZSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQ6IEVsZW1lbnQsIG5hbWU6IHN0cmluZykge1xuICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBzdHJpbmcgY2xhc3MgbmFtZVwiKVxuICB9XG5cbiAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKG5hbWUpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNDbGFzcyhlbGVtZW50OiBFbGVtZW50LCBuYW1lOiBzdHJpbmcpIHtcbiAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgc3RyaW5nIGNsYXNzIG5hbWVcIilcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhuYW1lKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWxlbWVudDogRWxlbWVudCwgbmFtZTogc3RyaW5nKSB7XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHN0cmluZyBjbGFzcyBuYW1lXCIpXG4gIH1cblxuICBlbGVtZW50LmNsYXNzTGlzdC50b2dnbGUobmFtZSlcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiBlbGVtZW50IGlzIGhpZGRlbiBmcm9tIHZpZXcuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IEVsZW1lbnQgVGhlIGRvbSBlbGVtZW50IHRvIGNoZWNrLlxuICogQHBhcmFtIHtib29sZWFufSBpbmNsdWRlUGFyZW50cyBJZiBzZXQgdG8gYHRydWVgIHNlYXJjaGVzIHVwIHRoZSBET00gYW5kIGNoZWNrcyBwYXJlbnQgdmlzaWJpbGl0eSBhcyB3ZWxsLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNIaWRkZW4oZWxlbWVudDogSFRNTEVsZW1lbnQsIGluY2x1ZGVQYXJlbnRzID0gZmFsc2UpOiBib29sZWFuIHtcbiAgaWYgKGluY2x1ZGVQYXJlbnRzID09PSBmYWxzZSkge1xuICAgIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudClcbiAgICByZXR1cm4gKHN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiKSB8fCBlbGVtZW50Lm9mZnNldExlZnQgPCAwXG4gIH1cblxuICBsZXQgcmVzdWx0XG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25kaXRpb25hbC1hc3NpZ25tZW50XG4gIHdoaWxlICgocmVzdWx0ID0gaXNIaWRkZW4oZWxlbWVudCwgZmFsc2UpKSA9PT0gZmFsc2UgJiYgZWxlbWVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudFxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIEdldHMgdGhlIHRleHQgb2YgYW4gZWxlbWVudCBhbiBtYWtlcyBzdXJlIHRoaXMgd29ya3Mgb24gYWxsIGJyb3dzZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGV4dChlbGVtZW50OiBFbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LnRleHRDb250ZW50IHx8IChlbGVtZW50IGFzIEhUTUxFbGVtZW50KS5pbm5lclRleHRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcmVudFdpdGhDbGFzczxFIGV4dGVuZHMgRWxlbWVudCA9IEVsZW1lbnQ+KGVsZW1lbnQ6IEUsIGNsYXNzTmFtZTogc3RyaW5nKTogRSB8IHVuZGVmaW5lZCB7XG4gIGxldCBjdXJyZW50OiBFID0gZWxlbWVudFxuXG4gIHdoaWxlICghaGFzQ2xhc3MoY3VycmVudCwgY2xhc3NOYW1lKSAmJiBjdXJyZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnRFbGVtZW50IGFzIEVsZW1lbnQgYXMgRVxuICB9XG5cbiAgaWYgKGhhc0NsYXNzKGN1cnJlbnQsIGNsYXNzTmFtZSkpIHtcbiAgICByZXR1cm4gY3VycmVudFxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gdGV4dFdpZHRoKHRleHQ6IHN0cmluZywgZm9udDogc3RyaW5nKSB7XG4gIC8vIE5PVEU6IHRoaXMgd2lkdGggbWVhc3VyaW5nIGFsZ29yaXRobSBpcyBhIGxvdCBmYXN0ZXJcbiAgLy8gYnV0IGRvZXMgdW5mb3J0dW5hdGVseSBub3Qgd29yayBvbiBJRSAxMC4uLlxuXG4gIC8vIGxldCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpXG4gIC8vIGxldCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKVxuICAvLyBjb250ZXh0LmZvbnQgPSBmb250XG4gIC8vIGxldCBtZXRyaWNzID0gY29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KVxuICAvLyByZXR1cm4gTWF0aC5yb3VuZChtZXRyaWNzLndpZHRoKVxuXG4gIGxldCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXG4gIGRpdi5pbm5lckhUTUwgPSB0ZXh0XG5cbiAgZGl2LnN0eWxlLmZvbnQgPSBmb250XG4gIGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIlxuICBkaXYuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCJcblxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdilcblxuICBjb25zdCByZXN1bHQgPSBkaXYub2Zmc2V0V2lkdGhcbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaXYpXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3NzKGVsZW1lbnQ6IEVsZW1lbnQsIHByb3BlcnR5OiBzdHJpbmcpIHtcbiAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpXG59XG5cbi8qKlxuICogR2V0cyB0aGUgc2luZ2xlIGVsZW1lbnQgcmVmZXJlbmNlZCBpbiBhbiBpdGVtcyBkYXRhLSogYXR0cmlidXRlLlxuICogQHBhcmFtIHtEb21FbGVtZW50fSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgY29udGFpbmluZyB0aGUgcmVmZXJlbmNlIGF0dHJpYnV0ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgLSBUaGUgbmFtZSBvZiB0aGUgcmVmZXJlbmNlIGF0dHJpYnV0ZS5cbiAqIEByZXR1cm5zIHtEb21FbGVtZW50fSBUaGUgcmVmZXJlbmNlZCBlbGVtZW50OyBvciBgdW5kZWZpbmVkYCBpZiB0aGUgcmVmZXJlbmNlIGlzIGludmFsaWRcbiAqIG9yIHRoZSBhdHRyaWJ1dGUgY291bGQgbm90IGJlIGZvdW5kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXR0cmlidXRlUmVmZXJlbmNlPEkgZXh0ZW5kcyBFbGVtZW50ID0gRWxlbWVudCwgTyBleHRlbmRzIEVsZW1lbnQgPSBJPihlbGVtZW50OiBJLCBhdHRyaWJ1dGU6IHN0cmluZyk6IE8gfCBudWxsIHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgYXR0clZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKVxuXG4gIGlmICghYXR0clZhbHVlIHx8IGF0dHJWYWx1ZSA9PT0gXCJcIikge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGF0dHJWYWx1ZSkgYXMgRWxlbWVudCBhcyBPXG59XG5cbi8qKlxuICogR2V0cyB0aGUgZG9jdW1lbnQgcm9vdCBlbGVtZW50IChub3JtYWxseSB0aGUgYm9keSBlbGVtZW50KVxuICogSWYgdGhlIGRvY3VtZW50IHVzZXMgYSBzZHgtY29udGFpbmVyIHdyYXBwZXIgdGhpcyBpcyByZXR1cm5lZCBpbnN0ZWFkLlxuICogQHJldHVybnMge0VsZW1lbnR9IFRoZSByb290IGRvbSBlbGVtZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um9vdEVsZW1lbnQoKSB7XG4gIGxldCBlbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5zZHgtY29udGFpbmVyXCIpXG4gIGlmICghZWxlbWVudCkge1xuICAgIGVsZW1lbnQgPSBkb2N1bWVudC5ib2R5XG4gIH1cblxuICByZXR1cm4gZWxlbWVudFxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGNoaWxkIG5vZGVzIGZyb20gdGhlIHByb3ZpZGVkIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIERvbSBlbGVtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbXB0eShlbGVtZW50OiBFbGVtZW50KSB7XG4gIHdoaWxlIChlbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICBlbGVtZW50LnJlbW92ZUNoaWxkKGVsZW1lbnQuZmlyc3RDaGlsZClcbiAgfVxufVxuIiwiLyogS2V5Ym9hcmQgaW5wdXQga2V5Y29kZSBkZWZpbml0aW9ucyAqL1xuXG5leHBvcnQgY29uc3QgS0VZX1RBQiA9IDlcbmV4cG9ydCBjb25zdCBLRVlfRU5URVIgPSAxM1xuZXhwb3J0IGNvbnN0IEtFWV9FU0NBUEUgPSAyN1xuXG4vLyBBcnJvdyBrZXlzXG5leHBvcnQgY29uc3QgS0VZX0FSUk9XX1VQID0gMzhcbmV4cG9ydCBjb25zdCBLRVlfQVJST1dfRE9XTiA9IDQwXG5leHBvcnQgY29uc3QgS0VZX0FSUk9XX0xFRlQgPSAzN1xuZXhwb3J0IGNvbnN0IEtFWV9BUlJPV19SSUdIVCA9IDM5XG5cbi8vIFBhZ2Uga2V5c1xuZXhwb3J0IGNvbnN0IEtFWV9QQUdFX1VQID0gMzNcbmV4cG9ydCBjb25zdCBLRVlfUEFHRV9ET1dOID0gMzRcblxuLy8gTnVtYmVyc1xuZXhwb3J0IGNvbnN0IEtFWV9OUl8wID0gNDhcbmV4cG9ydCBjb25zdCBLRVlfTlJfMSA9IDQ5XG5leHBvcnQgY29uc3QgS0VZX05SXzkgPSA1N1xuXG4vLyBoZWxwZXIgZnVuY3Rpb25zXG5leHBvcnQgbGV0IGNvbnRhaW5zS2V5ID0gKGtleWNvZGU6IG51bWJlciwgaW5wdXRzS2V5czogbnVtYmVyW10pID0+IHtcbiAgbGV0IGhhc0tleSA9IGZhbHNlXG4gIGlmIChpbnB1dHNLZXlzICYmIGlucHV0c0tleXMubGVuZ3RoID4gMCkge1xuICAgIFtdLmZvckVhY2guY2FsbChpbnB1dHNLZXlzLCAoaW5wdXRzS2V5OiBudW1iZXIpID0+IHtcbiAgICAgIGlmIChrZXljb2RlID09PSBpbnB1dHNLZXkpIHtcbiAgICAgICAgaGFzS2V5ID0gdHJ1ZVxuICAgICAgfVxuICAgIH0pXG4gIH1cbiAgcmV0dXJuIGhhc0tleVxufVxuXG5leHBvcnQgbGV0IGdldEtleVZhbHVlID0gKGtleWNvZGU6IG51bWJlcik6IHN0cmluZyA9PiB7XG4gIGlmIChrZXljb2RlIDwgNDggfHwga2V5Y29kZSA+IDEwNSkge1xuICAgIHJldHVybiBcIlwiXG4gIH1cbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoOTYgPD0ga2V5Y29kZSAmJiBrZXljb2RlIDw9IDEwNSA/IGtleWNvZGUgLSA0OCA6IGtleWNvZGUpLnRvTG93ZXJDYXNlKClcbn1cbiIsIi8qKlxuICogQ2FsbHMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdGhlIGRvY3VtZW50IGhhcyBiZWVuIGNvbXBsZXRlbHkgcGFyc2VkLlxuICogQHBhcmFtIHtjYWxsYmFja30gdmFsdWUgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGV4ZWN1dGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbkRvY3VtZW50UmVhZHkoY2FsbGJhY2s6IChlPzogRXZlbnQpID0+IHZvaWQpIHtcbiAgZnVuY3Rpb24gY29tcGxldGVkKCkge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCwgZmFsc2UpXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGNvbXBsZXRlZCwgZmFsc2UpXG4gICAgY2FsbGJhY2soKVxuICB9XG5cbiAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIikge1xuICAgIHNldFRpbWVvdXQoY2FsbGJhY2spXG4gIH0gZWxzZSB7XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQsIGZhbHNlKVxuXG4gICAgLy8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgY29tcGxldGVkLCBmYWxzZSlcbiAgfVxufVxuXG4vKipcbiAqIFNlYXJjaGVzIGZvciBlbGVtZW50cyB3aXRoIHRoZSBnaXZlbiBzZWxlY3RvciBhbmQgY2FsbHMgdGhlIGNhbGxiYWNrXG4gKiBmdW5jdGlvbiBpZiB0aGUgYGRhdGEtaW5pdGAgYXR0cmlidXRlIGlzIHByZXNlbnQgb24gdGhlIGVsZW1lbnQuXG4gKiBAcGFyYW0ge3NlbGVjdG9yfSB2YWx1ZSBUaGUgcXVlcnkuXG4gKiBAcGFyYW0ge2NhbGxiYWNrfSB2YWx1ZSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gaW5pdGlhbGl6ZSB0aGUgZWxlbWVudC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGluaXRTZWxlY3RvciBUaGUgaW5pdGl0YWxpemF0aW9uIGVsZW1lbnQgc2VsZWN0b3IgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZWFyY2hBbmRJbml0aWFsaXplPFxuICBLIGV4dGVuZHMga2V5b2YgSFRNTEVsZW1lbnRUYWdOYW1lTWFwXG4gID4oXG4gICAgc2VsZWN0b3I6IEssXG4gICAgY2FsbGJhY2s6IChlbDogSFRNTEVsZW1lbnRUYWdOYW1lTWFwW0tdKSA9PiB2b2lkLFxuICAgIGluaXRTZWxlY3Rvcj86IChlbDogSFRNTEVsZW1lbnRUYWdOYW1lTWFwW0tdKSA9PiBFbGVtZW50XG4gICk6IHZvaWRcbmV4cG9ydCBmdW5jdGlvbiBzZWFyY2hBbmRJbml0aWFsaXplPFxuICBFIGV4dGVuZHMgRWxlbWVudFxuICA+KFxuICAgIHNlbGVjdG9yOiBzdHJpbmcsXG4gICAgY2FsbGJhY2s6IChlbDogRSkgPT4gdm9pZCxcbiAgICBpbml0U2VsZWN0b3I/OiAoZWw6IEUpID0+IEVsZW1lbnRcbiAgKTogdm9pZFxuZXhwb3J0IGZ1bmN0aW9uIHNlYXJjaEFuZEluaXRpYWxpemUoXG4gIHNlbGVjdG9yOiBzdHJpbmcsXG4gIGNhbGxiYWNrOiAoZWw6IEVsZW1lbnQpID0+IHZvaWQsXG4gIGluaXRTZWxlY3Rvcj86IChlbDogRWxlbWVudCkgPT4gRWxlbWVudFxuKTogdm9pZCB7XG4gIGlmICghY2FsbGJhY2spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY2FsbGJhY2sgY2Fubm90IGJlIHVuZGVmaW5lZFwiKVxuICB9XG5cbiAgbGV0IGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikgYXMgTm9kZUxpc3RPZjxFbGVtZW50PlxuXG4gIGZvciAobGV0IGUgb2YgZWxlbWVudHMpIHtcblxuICAgIGxldCBpbml0RWxlbWVudDogRWxlbWVudCA9IGVcblxuICAgIGlmIChpbml0U2VsZWN0b3IpIHtcbiAgICAgIGluaXRFbGVtZW50ID0gaW5pdFNlbGVjdG9yKGUpXG4gICAgfVxuXG4gICAgaWYgKGluaXRFbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtaW5pdFwiKSA9PT0gXCJhdXRvXCIpIHtcbiAgICAgIGNhbGxiYWNrKGUpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG51bWJlciB3aG9zZSB2YWx1ZSBpcyBsaW1pdGVkIHRvIHRoZSBnaXZlbiByYW5nZS5cbiAqXG4gKiBFeGFtcGxlOiBsaW1pdCB0aGUgb3V0cHV0IG9mIHRoaXMgY29tcHV0YXRpb24gdG8gYmV0d2VlbiAwIGFuZCAyNTVcbiAqIFV0aWxzLmNsYW1wKG51bWJlciwgMCwgMjU1KVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgbnVtYmVyIHRvIGNsYW1wXG4gKiBAcGFyYW0ge051bWJlcn0gbWluIFRoZSBsb3dlciBib3VuZGFyeSBvZiB0aGUgb3V0cHV0IHJhbmdlXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4IFRoZSB1cHBlciBib3VuZGFyeSBvZiB0aGUgb3V0cHV0IHJhbmdlXG4gKiBAcmV0dXJucyBBIG51bWJlciBpbiB0aGUgcmFuZ2UgW21pbiwgbWF4XVxuICogQHR5cGUgTnVtYmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFtcCh2YWx1ZTogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW4pLCBtYXgpXG59XG5cbi8qKlxuICogQSBwb2x5ZmlsbCBmb3IgRXZlbnQucHJldmVudERlZmF1bHQoKS5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IHRvIHByZXZlbnQgdGhlIGRlZmF1bHQgYWN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXZlbnQ6IEV2ZW50KSB7XG4gIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgfSBlbHNlIHtcbiAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlXG4gIH1cbn1cblxuLyoqXG4gKiBBIHBvbHlmaWxsIGZvciBOb2RlLnJlbW92ZSgpLlxuICogQHBhcmFtIHtOb2RlfSBub2RlIC0gVGhlIG5vZGUgdG8gcmVtb3ZlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlKG5vZGU6IE5vZGUpIHtcbiAgaWYgKCFub2RlIHx8ICFub2RlLnBhcmVudE5vZGUpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKVxufVxuXG4vKipcbiAqIEEgc2ltcGxlIHBvbHlmaWxsIGZvciB0aGUgQXJyYXkuZmluZCgpIG1ldGhvZC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IC0gVGhlIGFycmF5IHRvIHNlYXJjaCBpbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGV4cHJlc3Npb24gLSBUaGUgZXhwcmVzc2lvbiB0byBldmFsdWF0ZS4gTXVzdCByZXR1cm4gdHJ1ZSBpZiB0aGUgZWxlbWVudCBtYXRjaGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZDxUID0gYW55PihcbiAgYXJyYXk6IFRbXSB8IHsgbGVuZ3RoOiBudW1iZXIsIFtpOiBudW1iZXJdOiBUIH0sXG4gIGV4cHJlc3Npb246IChpdGVtOiBUKSA9PiBib29sZWFuXG4pIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGxldCBpdGVtID0gYXJyYXlbaV1cbiAgICBpZiAoZXhwcmVzc2lvbihpdGVtKSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGl0ZW1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkXG59XG5cbi8qKlxuICogQ2hlY2tzIHRoZSB1c2VyYWdlbnQgYW5kIHJldHVybnMgdGhlIE1pY3Jvc29mdCBJbnRlcm5ldCBFeHBsb3JlciAvIEVkZ2UgdmVyc2lvbi5cbiAqIElmIGFub3RoZXIgYnJvd3NlciBpcyBkZXRlY3RlZCAwIGlzIHJldHVybmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJuZXRFeHBsb3Jlck9yRWRnZVZlcnNpb24odXNlckFnZW50OiBzdHJpbmcgPSBuYXZpZ2F0b3IudXNlckFnZW50KSB7XG4gIC8vIGhhbmRsZSBJRSBhbmQgRWRnZVxuICBjb25zdCBpZU9yRWRnZSA9IHVzZXJBZ2VudC5zZWFyY2goL01TSUUgfEVkZ2VbL10vKVxuICBpZiAoaWVPckVkZ2UgPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHVzZXJBZ2VudC5zdWJzdHJpbmcoaWVPckVkZ2UgKyA1LCB1c2VyQWdlbnQuaW5kZXhPZihcIi5cIiwgaWVPckVkZ2UpKSwgMTApXG4gIH1cbiAgLy8gaGFuZGxlIElFMTFcbiAgaWYgKHVzZXJBZ2VudC5pbmRleE9mKFwiVHJpZGVudC9cIikgPiAwKSB7XG4gICAgY29uc3QgcnYgPSB1c2VyQWdlbnQuaW5kZXhPZihcInJ2OlwiKVxuICAgIHJldHVybiBwYXJzZUludCh1c2VyQWdlbnQuc3Vic3RyaW5nKHJ2ICsgMywgdXNlckFnZW50LmluZGV4T2YoXCIuXCIsIHJ2KSksIDEwKVxuICB9XG5cbiAgcmV0dXJuIDBcbn1cblxuLyoqXG4gKiBUcmllcyB0byBtb3ZlIGEgY2hpbGQgZWxlbWVudCB0byB0aGUgdG9wIGJ5IHNjcm9sbGluZyB0aGUgcGFyZW50IGVsZW1lbnQsIGlmIGl0IGlzIG5vdCBhbHJlYWR5IGZ1bGx5IHZpc2libGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY3JvbGxJbnRvVmlldyhjaGlsZDogSFRNTEVsZW1lbnQpIHtcbiAgY29uc3QgcGFyZW50ID0gY2hpbGQucGFyZW50Tm9kZSBhcyBIVE1MRWxlbWVudFxuICBjb25zdCBwYXJlbnRSZWN0ID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gIGNvbnN0IGNoaWxkUmVjdCA9IGNoaWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gIGNvbnN0IGlzRnVsbHlWaXNpYmxlID0gY2hpbGRSZWN0LnRvcCA+PSBwYXJlbnRSZWN0LnRvcCAmJiBjaGlsZFJlY3QuYm90dG9tIDw9IHBhcmVudFJlY3QudG9wICsgcGFyZW50LmNsaWVudEhlaWdodFxuXG4gIGlmICghaXNGdWxseVZpc2libGUpIHtcbiAgICBwYXJlbnQuc2Nyb2xsVG9wID0gY2hpbGRSZWN0LnRvcCArIHBhcmVudC5zY3JvbGxUb3AgLSBwYXJlbnRSZWN0LnRvcFxuICB9XG59XG4iLCJpbXBvcnQgeyBzZWFyY2hBbmRJbml0aWFsaXplIH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCBhbmltZSwgeyBBbmltZVRpbWVsaW5lSW5zdGFuY2UgfSBmcm9tIFwiYW5pbWVqc1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgKiBhcyBEb20gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5cbmNvbnN0IFFVRVJZX1RPR0dMRSA9IFwiLmFjY29yZGlvbl9fdG9nZ2xlXCJcbmNvbnN0IFFVRVJZX09QRU5fU0VDVElPTiA9IFwiLmFjY29yZGlvbl9faXRlbS5pcy1vcGVuXCJcbmNvbnN0IFFVRVJZX0NPTExBUFNFID0gXCIuYWNjb3JkaW9uX19jb2xsYXBzZVwiXG5cbmNvbnN0IENMQVNTX0lURU0gPSBcImFjY29yZGlvbl9faXRlbVwiXG5jb25zdCBDTEFTU19PUEVOID0gXCJpcy1vcGVuXCJcbmNvbnN0IENMQVNTX0tFRVBfT1BFTiA9IFwiYWNjb3JkaW9uX19rZWVwLW9wZW5cIlxuXG5jb25zdCBSRUdFWF9ISURERU4gPSAvYWNjb3JkaW9uLS1oaWRkZW4tLiovXG5cbmNvbnN0IEFOSU1BVElPTl9PUEVOID0gMzAwXG5jb25zdCBBTklNQVRJT05fREVMQVlfT1BFTiA9IDUwXG5jb25zdCBBTklNQVRJT05fVklTSUJMRSA9IDE1MFxuXG4vKipcbiAqIFRoZSBBY2NvcmRpb24gY29tcG9uZW50XG4gKi9cbmNsYXNzIEFjY29yZGlvbiBleHRlbmRzIERvbUVsZW1lbnQge1xuICBwcml2YXRlIF9zZWN0aW9uQ2xpY2tIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfaGlkZGVuSW5kaWNhdG9yITogSFRNTElucHV0RWxlbWVudFxuICBwcml2YXRlIGFuaW1hdGlvbiE6IEFuaW1lVGltZWxpbmVJbnN0YW5jZVxuICBwcml2YXRlIGxhc3RBbmltYXRlZEVsZW1lbnQ/OiBIVE1MRWxlbWVudFxuICBwcml2YXRlIGVhc2luZyA9IHtcbiAgICAvLyBFcXVpdmFsZW50IHRvIGdzYXAncyBbIFBvd2VyMS5lYXNlSW4sIFBvd2VyNC5lYXNlT3V0IF1cbiAgICBpblF1YWRPdXRRdWludDogWyAwLjU1MCwgMC4wODUsIDAuMzIwLCAxIF1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuZCBpbml0aWFsaXplcyB0aGUgQWNjb3JkaW9uIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtEb21FbGVtZW50fSAtIFRoZSByb290IGVsZW1lbnQgb2YgdGhlIEFjY29yZGlvbiBjb21wb25lbnQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBFbGVtZW50KSB7XG4gICAgc3VwZXIoZWxlbWVudClcblxuICAgIHRoaXMuX3NlY3Rpb25DbGlja0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVTZWN0aW9uQ2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuX2luaXRpYWxpemUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBBY2NvcmRpb24gY29tcG9uZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplKCkge1xuICAgIGlmICh0aGlzLmVsZW1lbnQuY2xhc3NOYW1lLnNwbGl0KFwiIFwiKS5zb21lKChjKSA9PiBSRUdFWF9ISURERU4udGVzdChjKSkpIHtcbiAgICAgIGxldCBpbmRpY2F0b3IgPSBuZXcgRG9tRWxlbWVudDxIVE1MSW5wdXRFbGVtZW50PihcImlucHV0XCIpXG4gICAgICAgIC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwiaGlkZGVuXCIpXG4gICAgICAgIC5hZGRDbGFzcyhcImpzLWhpZGRlblwiKVxuXG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGluZGljYXRvcilcbiAgICAgIHRoaXMuX2hpZGRlbkluZGljYXRvciA9IGluZGljYXRvci5lbGVtZW50XG4gICAgfVxuXG4gICAgZm9yIChsZXQgdG9nZ2xlIG9mIHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFFVRVJZX1RPR0dMRSkpIHtcbiAgICAgIHRvZ2dsZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fc2VjdGlvbkNsaWNrSGFuZGxlcilcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZVNlY3Rpb25DbGljayhldmVudDogRXZlbnQpIHtcbiAgICBpZiAodGhpcy5faGlkZGVuSW5kaWNhdG9yKSB7XG4gICAgICBsZXQgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9oaWRkZW5JbmRpY2F0b3IpXG5cbiAgICAgIGlmIChzdHlsZS52aXNpYmlsaXR5ICE9PSBcInZpc2libGVcIikge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgbmF2U2VjdGlvbiA9IChldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnQpLnBhcmVudEVsZW1lbnQhXG5cbiAgICB3aGlsZSAoIURvbS5oYXNDbGFzcyhuYXZTZWN0aW9uLCBDTEFTU19JVEVNKSAmJiBuYXZTZWN0aW9uLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIG5hdlNlY3Rpb24gPSBuYXZTZWN0aW9uLnBhcmVudEVsZW1lbnRcbiAgICB9XG5cbiAgICBsZXQgcHJldlNlY3Rpb24gPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9PUEVOX1NFQ1RJT04pXG5cbiAgICBpZiAocHJldlNlY3Rpb24gJiYgcHJldlNlY3Rpb24gIT09IG5hdlNlY3Rpb24pIHtcbiAgICAgIGlmICghRG9tLmhhc0NsYXNzKHRoaXMuZWxlbWVudCwgQ0xBU1NfS0VFUF9PUEVOKSl7XG4gICAgICAgIHRoaXMuX3RvZ2dsZVNlY3Rpb24ocHJldlNlY3Rpb24pXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fdG9nZ2xlU2VjdGlvbihuYXZTZWN0aW9uKVxuICB9XG5cbiAgcHJvdGVjdGVkIF90b2dnbGVTZWN0aW9uKGFjY1NlY3Rpb246IEVsZW1lbnQpIHtcbiAgICBsZXQgY29sbGFwc2VFbGVtZW50ID0gYWNjU2VjdGlvbi5xdWVyeVNlbGVjdG9yKFFVRVJZX0NPTExBUFNFKSEgYXMgSFRNTEVsZW1lbnRcblxuICAgIGlmIChEb20uaGFzQ2xhc3MoYWNjU2VjdGlvbiwgQ0xBU1NfT1BFTikpIHtcbiAgICAgIERvbS5yZW1vdmVDbGFzcyhhY2NTZWN0aW9uLCBDTEFTU19PUEVOKVxuICAgICAgdGhpcy5fY2xvc2VDb2xsYXBzZVNlY3Rpb24oY29sbGFwc2VFbGVtZW50KVxuICAgIH0gZWxzZSB7XG4gICAgICBEb20uYWRkQ2xhc3MoYWNjU2VjdGlvbiwgQ0xBU1NfT1BFTilcbiAgICAgIGlmIChjb2xsYXBzZUVsZW1lbnQpIHsgLy8gdG8gaWdub3JlIHRoZSBjYXNlIHdoZW4gdGhlcmUgaXMgbm8gY29sbGFwc2libGUgZWxlbWVudCAoc2VlIHNkeCBkb2t1IG5hdmlnYXRpb24sIFwiYWxsIHRoZSBiYXNpY3NcIikgaW4gYSBsaXN0IG9mIGFjY29yZGlvblxuICAgICAgICB0aGlzLl9vcGVuQ29sbGFwc2VTZWN0aW9uKGNvbGxhcHNlRWxlbWVudClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX29wZW5Db2xsYXBzZVNlY3Rpb24oZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgdGhpcy5fc3RvcEFuaW1hdGlvbnMoZWwpXG5cbiAgICBlbC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiXG5cbiAgICB0aGlzLmFuaW1hdGlvbiA9IGFuaW1lLnRpbWVsaW5lKClcbiAgICAgIC5hZGQoe1xuICAgICAgICB0YXJnZXRzOiBlbCxcbiAgICAgICAgZHVyYXRpb246IEFOSU1BVElPTl9PUEVOLFxuICAgICAgICBoZWlnaHQ6IGVsLnNjcm9sbEhlaWdodCArIFwicHhcIixcbiAgICAgICAgZWFzaW5nOiB0aGlzLmVhc2luZy5pblF1YWRPdXRRdWludCxcbiAgICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSBcImF1dG9cIlxuICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgXCJ0cnVlXCIpXG4gICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChDTEFTU19PUEVOKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmFkZCh7XG4gICAgICAgIHRhcmdldHM6IGVsLFxuICAgICAgICBkdXJhdGlvbjogQU5JTUFUSU9OX1ZJU0lCTEUsXG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIGVhc2luZzogXCJsaW5lYXJcIixcbiAgICAgICAgb2Zmc2V0OiBBTklNQVRJT05fREVMQVlfT1BFTlxuICAgICAgfSlcbiAgfVxuXG4gIHByb3RlY3RlZCBfY2xvc2VDb2xsYXBzZVNlY3Rpb24oZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgdGhpcy5fc3RvcEFuaW1hdGlvbnMoZWwpXG5cbiAgICB0aGlzLmFuaW1hdGlvbiA9IGFuaW1lLnRpbWVsaW5lKClcbiAgICAgIC5hZGQoe1xuICAgICAgICB0YXJnZXRzOiBlbCxcbiAgICAgICAgZHVyYXRpb246IEFOSU1BVElPTl9PUEVOLFxuICAgICAgICBoZWlnaHQ6IFwiMHB4XCIsXG4gICAgICAgIGVhc2luZzogdGhpcy5lYXNpbmcuaW5RdWFkT3V0UXVpbnQsXG4gICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJkaXNwbGF5XCIpXG4gICAgICAgICAgZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJvcGFjaXR5XCIpXG4gICAgICAgICAgZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJoZWlnaHRcIilcbiAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIFwiZmFsc2VcIilcbiAgICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX09QRU4pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuYWRkKHtcbiAgICAgICAgdGFyZ2V0czogZWwsXG4gICAgICAgIGR1cmF0aW9uOiBBTklNQVRJT05fVklTSUJMRSxcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgZWFzaW5nOiBcImxpbmVhclwiLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH0pXG4gIH1cblxuICBwcm90ZWN0ZWQgX3N0b3BBbmltYXRpb25zKGVsOiBIVE1MRWxlbWVudCkge1xuICAgIGlmICh0aGlzLmxhc3RBbmltYXRlZEVsZW1lbnQgPT09IGVsKSB7XG4gICAgICBpZiAodGhpcy5hbmltYXRpb24pIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb24ucGF1c2UoKVxuICAgICAgfVxuICAgICAgYW5pbWUucmVtb3ZlKGVsKVxuICAgIH1cbiAgICB0aGlzLmxhc3RBbmltYXRlZEVsZW1lbnQgPSBlbFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGV2ZW50IGhhbmRsZXJzIGFuZCBjbGVhcnMgcmVmZXJlbmNlcy5cbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIGZvciAobGV0IHRvZ2dsZSBvZiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChRVUVSWV9UT0dHTEUpKSB7XG4gICAgICB0b2dnbGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3NlY3Rpb25DbGlja0hhbmRsZXIpXG4gICAgfVxuXG4gICAgKHRoaXMgYXMgYW55KS5fc2VjdGlvbkNsaWNrSGFuZGxlciA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5lbGVtZW50ID0gbnVsbFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBzZWFyY2hBbmRJbml0aWFsaXplKFwiLmFjY29yZGlvblwiLCAoZSkgPT4ge1xuICAgIG5ldyBBY2NvcmRpb24oZSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgQWNjb3JkaW9uXG4iLCJpbXBvcnQgeyBzZWFyY2hBbmRJbml0aWFsaXplLCBjbGFtcCwgcHJldmVudERlZmF1bHQsIHJlbW92ZSB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgKiBhcyBJbnB1dHMgZnJvbSBcIi4uL0lucHV0c1wiXG5pbXBvcnQgKiBhcyBEb20gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5cbmNvbnN0IFFVRVJZX1NMSURFUiA9IFwiLmNhcm91c2VsX19jb250YWluZXJcIlxuY29uc3QgUVVFUllfU0xJREVfQVJFQSA9IFwiLmNhcm91c2VsX19zbGlkZXJcIlxuY29uc3QgUVVFUllfV1JBUFBFUiA9IFwiLmNhcm91c2VsX19zbGlkZXItd3JhcHBlclwiXG5cbmNvbnN0IFFVRVJZX1BBR0lOQVRJT04gPSBcIi5jYXJvdXNlbF9fcGFnaW5hdGlvblwiXG5cbmNvbnN0IENMQVNTX0FDVElWRSA9IFwic2xpZGUtLWFjdGl2ZVwiXG5jb25zdCBDTEFTU19QUkVWID0gXCJzbGlkZS0tcHJldlwiXG5jb25zdCBDTEFTU19ORVhUID0gXCJzbGlkZS0tbmV4dFwiXG5cbmNvbnN0IENMQVNTX0JVTExFVCA9IFwicGFnaW5hdGlvbi1idWxsZXRcIlxuY29uc3QgQ0xBU1NfQlVMTEVUX0FDVElWRSA9IFwicGFnaW5hdGlvbi1idWxsZXQtLWFjdGl2ZVwiXG5cbmNvbnN0IFFVRVJZX0JUTl9QUkVWID0gXCIuY2Fyb3VzZWxfX2J1dHRvbi1wcmV2XCJcbmNvbnN0IFFVRVJZX0JUTl9ORVhUID0gXCIuY2Fyb3VzZWxfX2J1dHRvbi1uZXh0XCJcbmNvbnN0IFFVRVJZX0JUTl9XUkFQUEVSID0gXCIuY2Fyb3VzZWxfX2J1dHRvbi13cmFwcGVyXCJcblxuY29uc3QgQVRUUklCVVRFX0lOREVYID0gXCJqcy1pbmRleFwiXG5cbmNvbnN0IEFOSU1BVElPTl9EVVJBVElPTiA9IDM1MFxuY29uc3QgQU5JTUFUSU9OX0VBU0lORyA9IFwiZWFzZS1pbi1vdXRcIlxuXG5jb25zdCBUT1VDSF9EVVJBVElPTiA9IDMwMFxuY29uc3QgVE9VQ0hfREVMVEFfTUlOID0gMjVcblxuZXhwb3J0IGludGVyZmFjZSBTbGlkZVByb3BlcnRpZXMge1xuICByaWdodDogbnVtYmVyXG4gIGxlZnQ6IG51bWJlclxuICB2aXNpYmxlOiBib29sZWFuXG4gIGluZGV4OiBudW1iZXJcbiAgd2lkdGg6IG51bWJlclxuICBtYXJnaW5MZWZ0OiBudW1iZXJcbiAgbWFyZ2luUmlnaHQ6IG51bWJlclxufVxuXG5leHBvcnQgdHlwZSBEaXJlY3Rpb24gPSAwIHwgLTEgfCAxXG5cbi8qKlxuICogVGhlIGNhcm91c2VsIGNvbXBvbmVudCBkZWZpbml0aW9uLlxuICovXG5jbGFzcyBDYXJvdXNlbCBleHRlbmRzIERvbUVsZW1lbnQ8SFRNTEVsZW1lbnQ+IHtcbiAgcHJpdmF0ZSBfc2xpZGVyOiBIVE1MRWxlbWVudFxuICBwcml2YXRlIF93cmFwcGVyOiBIVE1MRWxlbWVudFxuICBwcml2YXRlIF9wYWdpbmF0aW9uPzogSFRNTEVsZW1lbnRcbiAgcHJpdmF0ZSBfc2xpZGVBcmVhOiBIVE1MRWxlbWVudFxuXG4gIHByaXZhdGUgX2J0bldyYXBwZXI6IEhUTUxFbGVtZW50XG4gIHByaXZhdGUgX3ByZXZDdHJsOiBIVE1MRWxlbWVudFxuICBwcml2YXRlIF9uZXh0Q3RybDogSFRNTEVsZW1lbnRcblxuICBwcml2YXRlIF9zbGlkZXM6IEhUTUxFbGVtZW50W11cblxuICBwcml2YXRlIF9pbmRleDogbnVtYmVyXG4gIHByaXZhdGUgX3NsaWRlc1Blckdyb3VwOiBudW1iZXJcblxuICBwcml2YXRlIF9zbGlkZXJXcmFwcGVyOiBTbGlkZXJXcmFwcGVyXG5cbiAgcHJpdmF0ZSBfYWRkaXRpb25hbFNsaWRlTWFyZ2luOiBudW1iZXJcblxuICBwcml2YXRlIF9yZXNpemVIYW5kbGVyOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX3ByZXZIYW5kbGVyOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX25leHRIYW5kbGVyOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX3BhZ2luYXRpb25DbGlja0hhbmRsZXI6IChldmVudDogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfa2V5ZG93bkhhbmRsZXI6IChldmVudDogRXZlbnQpID0+IHZvaWRcblxuICBwcml2YXRlIF9oYW5kbGVUb3VjaHN0YXJ0OiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2hhbmRsZVRvdWNobW92ZTogKGV2ZW50OiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9oYW5kbGVUb3VjaGVuZDogKGV2ZW50OiBFdmVudCkgPT4gdm9pZFxuXG4gIHByaXZhdGUgX2JyZWFrcG9pbnRQaG9uZSE6IEhUTUxEaXZFbGVtZW50XG4gIHByaXZhdGUgX2JyZWFrcG9pbnRUYWJsZXQhOiBIVE1MRGl2RWxlbWVudFxuICBwcml2YXRlIF9icmVha3BvaW50RGVza3RvcCE6IEhUTUxEaXZFbGVtZW50XG5cbiAgcHJpdmF0ZSBfdG91Y2hPZmZzZXQ/OiB7XG4gICAgeDogbnVtYmVyO1xuICAgIHRpbWU6IG51bWJlcjtcbiAgfVxuXG4gIHByaXZhdGUgX2RlbHRhPzoge1xuICAgIHg6IG51bWJlcjtcbiAgICBsYXN0TW92ZTogbnVtYmVyO1xuICB9XG5cbiAgcHJpdmF0ZSBfZnJhbWVXaWR0aD86IG51bWJlclxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuZCBpbml0aWFsaXplcyB0aGUgY2Fyb3VzZWwgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge0RvbUVsZW1lbnR9IGVsZW1lbnQgLSBUaGUgcm9vdCBlbGVtZW50IG9mIHRoZSBDYXJvdXNlbCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIFRoZSBpbml0aWFsIGluZGV4LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudDogSFRNTEVsZW1lbnQsIGluZGV4ID0gMCkge1xuICAgIHN1cGVyKGVsZW1lbnQpXG5cbiAgICB0aGlzLl9zbGlkZXIgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9TTElERVIpISBhcyBIVE1MRWxlbWVudFxuICAgIHRoaXMuX3dyYXBwZXIgPSB0aGlzLl9zbGlkZXIucXVlcnlTZWxlY3RvcihRVUVSWV9XUkFQUEVSKSEgYXMgSFRNTEVsZW1lbnRcbiAgICB0aGlzLl9wYWdpbmF0aW9uID0gdGhpcy5fc2xpZGVyLnF1ZXJ5U2VsZWN0b3IoUVVFUllfUEFHSU5BVElPTikgYXMgSFRNTEVsZW1lbnRcbiAgICB0aGlzLl9zbGlkZUFyZWEgPSB0aGlzLl9zbGlkZXIucXVlcnlTZWxlY3RvcihRVUVSWV9TTElERV9BUkVBKSEgYXMgSFRNTEVsZW1lbnRcblxuICAgIHRoaXMuX2J0bldyYXBwZXIgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9CVE5fV1JBUFBFUikhIGFzIEhUTUxFbGVtZW50XG4gICAgdGhpcy5fcHJldkN0cmwgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9CVE5fUFJFVikhIGFzIEhUTUxFbGVtZW50XG4gICAgdGhpcy5fbmV4dEN0cmwgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9CVE5fTkVYVCkhIGFzIEhUTUxFbGVtZW50XG5cbiAgICB0aGlzLl9zbGlkZXMgPSBbXVxuXG4gICAgdGhpcy5faW5kZXggPSBpbmRleCB8fCAwXG4gICAgdGhpcy5fc2xpZGVzUGVyR3JvdXAgPSAxXG5cbiAgICB0aGlzLl9zbGlkZXJXcmFwcGVyID0gbmV3IFNsaWRlcldyYXBwZXIodGhpcy5fd3JhcHBlciwgdGhpcy5fc2xpZGVBcmVhLCB0aGlzLmVsZW1lbnQpXG4gICAgdGhpcy5fc2xpZGVyV3JhcHBlci5pbmRleCA9IHRoaXMuX2luZGV4XG4gICAgdGhpcy5fYWRkaXRpb25hbFNsaWRlTWFyZ2luID0gMFxuXG4gICAgdGhpcy5fcmVzaXplSGFuZGxlciA9IHRoaXMuX29ucmVzaXplLmJpbmQodGhpcylcbiAgICB0aGlzLl9wcmV2SGFuZGxlciA9IHRoaXMucHJldi5iaW5kKHRoaXMpXG4gICAgdGhpcy5fbmV4dEhhbmRsZXIgPSB0aGlzLm5leHQuYmluZCh0aGlzKVxuICAgIHRoaXMuX3BhZ2luYXRpb25DbGlja0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVQYWdpbmF0aW9uQ2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuX2tleWRvd25IYW5kbGVyID0gdGhpcy5faGFuZGxlS2V5ZG93bi5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9oYW5kbGVUb3VjaHN0YXJ0ID0gdGhpcy5fb25Ub3VjaHN0YXJ0LmJpbmQodGhpcylcbiAgICB0aGlzLl9oYW5kbGVUb3VjaG1vdmUgPSB0aGlzLl9vblRvdWNobW92ZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5faGFuZGxlVG91Y2hlbmQgPSB0aGlzLl9vblRvdWNoZW5kLmJpbmQodGhpcylcblxuICAgIHRoaXMuX2luaXRpYWxpemUoKVxuICAgIHRoaXMuc2xpZGUodGhpcy5faW5kZXgsIDAsIGZhbHNlKVxuXG4gICAgdGhpcy5fdXBkYXRlQ3RybE9mZnNldHMoKVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBjYXJvdXNlbCBjb21wb25lbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX2luaXRpYWxpemUoKSB7XG4gICAgLy8gcmVzcG9uc2l2ZSBoZWxwZXJzXG4gICAgdGhpcy5fYnJlYWtwb2ludFBob25lID0gbmV3IERvbUVsZW1lbnQ8SFRNTERpdkVsZW1lbnQ+KFwiZGl2XCIpXG4gICAgICAuYWRkQ2xhc3MoXCJqcy1waG9uZVwiKVxuICAgICAgLmVsZW1lbnRcblxuICAgIHRoaXMuX2JyZWFrcG9pbnRUYWJsZXQgPSBuZXcgRG9tRWxlbWVudDxIVE1MRGl2RWxlbWVudD4oXCJkaXZcIilcbiAgICAgIC5hZGRDbGFzcyhcImpzLXRhYmxldFwiKVxuICAgICAgLmVsZW1lbnRcblxuICAgIHRoaXMuX2JyZWFrcG9pbnREZXNrdG9wID0gbmV3IERvbUVsZW1lbnQ8SFRNTERpdkVsZW1lbnQ+KFwiZGl2XCIpXG4gICAgICAuYWRkQ2xhc3MoXCJqcy1kZXNrdG9wXCIpXG4gICAgICAuZWxlbWVudFxuXG4gICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX2JyZWFrcG9pbnRQaG9uZSlcbiAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fYnJlYWtwb2ludFRhYmxldClcbiAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fYnJlYWtwb2ludERlc2t0b3ApXG5cbiAgICBpZiAodGhpcy5fcHJldkN0cmwgJiYgdGhpcy5fbmV4dEN0cmwpIHtcbiAgICAgIHRoaXMuX3ByZXZDdHJsLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9wcmV2SGFuZGxlcilcbiAgICAgIHRoaXMuX25leHRDdHJsLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9uZXh0SGFuZGxlcilcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcGFnaW5hdGlvbikge1xuICAgICAgdGhpcy5fcGFnaW5hdGlvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fcGFnaW5hdGlvbkNsaWNrSGFuZGxlcilcbiAgICB9XG5cbiAgICB0aGlzLl9zbGlkZXMgPSBBcnJheS5mcm9tKHRoaXMuX3dyYXBwZXIuY2hpbGRyZW4pIGFzIEhUTUxFbGVtZW50W11cbiAgICBpZiAodGhpcy5fc2xpZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJQcm92aWRlIGF0IGxlYXN0IG9uZSBzbGlkZSB0byB0aGUgc2xpZGVyXCIpXG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9zbGlkZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBzbGlkZSA9IHRoaXMuX3NsaWRlc1tpXVxuICAgICAgc2xpZGUuc2V0QXR0cmlidXRlKEFUVFJJQlVURV9JTkRFWCwgU3RyaW5nKGkpKVxuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZVJlc3BvbnNpdmVPcHRpb25zKClcbiAgICB0aGlzLl9zbGlkZXJXcmFwcGVyLmluaXRpYWxpemUoKVxuXG4gICAgdGhpcy5yZXNldCgpXG5cbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fa2V5ZG93bkhhbmRsZXIpXG5cbiAgICB0aGlzLl9zbGlkZUFyZWEuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLl9oYW5kbGVUb3VjaHN0YXJ0KVxuICAgIHRoaXMuX3NsaWRlQXJlYS5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLl9oYW5kbGVUb3VjaHN0YXJ0KVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5fcmVzaXplSGFuZGxlcilcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIHRoaXMuX3Jlc2l6ZUhhbmRsZXIpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2lzQnJlYWtwb2ludEFjdGl2ZShicmVha3BvaW50OiBIVE1MRGl2RWxlbWVudCkge1xuICAgIGxldCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGJyZWFrcG9pbnQpXG4gICAgcmV0dXJuIHN0eWxlLnZpc2liaWxpdHkgPT09IFwidmlzaWJsZVwiXG4gIH1cblxuICBwcm90ZWN0ZWQgX29ucmVzaXplKCkge1xuICAgIHRoaXMucmVzZXQoKVxuICAgIHRoaXMuX3VwZGF0ZUN0cmxPZmZzZXRzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlcyBzdXJlIHRoZSBpbmRleCBpcyBhbHdheXMgaW4gdGhlIHJhbmdlIG9mIGF2YWlsYWJsZSBzbGlkZVxuICAgKiBJbiBjYXNlIGl0J3MgdG8gaGlnaCBvciB0byBsb3cgaXQgaXMgd3JhcHBlZCBhcm91bmRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IHRvIGFkanVzdCBhbmQgc2FuaXRpemVcbiAgICogQHJldHVybnMge051bWJlcn0gaW5kZXggLSBUaGUgYWRqdXN0ZWQgaW5kZXhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfYWRqdXN0SW5kZXgoaW5kZXg6IG51bWJlcikge1xuICAgIGlmICh0eXBlb2YgaW5kZXggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGluZGV4ID0gMFxuICAgIH1cblxuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIGluZGV4ID0gdGhpcy5fd3JhcHJvdW5kKGluZGV4LCAwLCB0aGlzLl9zbGlkZXMubGVuZ3RoKVxuICAgIH0gZWxzZSBpZiAoaW5kZXggPj0gdGhpcy5fc2xpZGVzLmxlbmd0aCkge1xuICAgICAgaW5kZXggJT0gdGhpcy5fc2xpZGVzLmxlbmd0aFxuICAgIH1cblxuICAgIHJldHVybiBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5fc2xpZGVzUGVyR3JvdXApICogdGhpcy5fc2xpZGVzUGVyR3JvdXBcbiAgfVxuXG4gIHByb3RlY3RlZCBfd3JhcHJvdW5kKG46IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKSB7XG4gICAgaWYgKG4gPj0gbWF4KSB7XG4gICAgICByZXR1cm4gbWluXG4gICAgfVxuXG4gICAgaWYgKG4gPCBtaW4pIHtcbiAgICAgIHJldHVybiBtYXggLSAxXG4gICAgfVxuXG4gICAgcmV0dXJuIG5cbiAgfVxuXG4gIHByb3RlY3RlZCBfd3JhcHJvdW5kQ291bnQoYTogbnVtYmVyLCBiOiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlciwgZGlyZWN0aW9uOiBEaXJlY3Rpb24pIHtcbiAgICBpZiAoZGlyZWN0aW9uID09PSAwKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIGlmIChhIDwgbWluIHx8IGEgPj0gbWF4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFyZ3VtZW50ICdhJyBpcyBvdXQgb2YgcmFuZ2UsIFZhbHVlOiAke2F9IE1pbjogJHttaW59LCBNYXg6ICR7bWF4fWApXG4gICAgfVxuXG4gICAgaWYgKGIgPCBtaW4gfHwgYiA+PSBtYXgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXJndW1lbnQgJ2InIGlzIG91dCBvZiByYW5nZSwgVmFsdWU6ICR7Yn0gTWluOiAke21pbn0sIE1heDogJHttYXh9YClcbiAgICB9XG5cbiAgICBsZXQgaSA9IDBcbiAgICB3aGlsZSAoYSAhPT0gYikge1xuICAgICAgaSsrXG4gICAgICBhID0gdGhpcy5fd3JhcHJvdW5kKGEgKyBkaXJlY3Rpb24sIG1pbiwgbWF4KVxuICAgIH1cblxuICAgIHJldHVybiBpXG4gIH1cblxuICBwcm90ZWN0ZWQgX3VwZGF0ZUN0cmxPZmZzZXRzKCkge1xuICAgIGlmICghdGhpcy5fbmV4dEN0cmwgfHwgIXRoaXMuX3ByZXZDdHJsIHx8ICF0aGlzLl9idG5XcmFwcGVyKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgcHJldkN0cmxNYXJnaW4gPSAwXG4gICAgbGV0IG5leHRDdHJsTWFyZ2luID0gMFxuXG4gICAgaWYgKHRoaXMuX3NsaWRlc1Blckdyb3VwID4gMSkge1xuICAgICAgbGV0IHdyYXBwZXJSZWN0ID0gdGhpcy5fYnRuV3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXG4gICAgICBjb25zdCBwcmV2U2xpZGVDb3VudCA9IE1hdGguZmxvb3IoMC41ICogdGhpcy5fc2xpZGVzUGVyR3JvdXApXG4gICAgICBjb25zdCByaWdodEluZGV4ID0gdGhpcy5fc2xpZGVyV3JhcHBlci5pbmRleCArIHByZXZTbGlkZUNvdW50ICsgMVxuXG4gICAgICBsZXQgbGVmdEluZGV4ID0gdGhpcy5fc2xpZGVyV3JhcHBlci5pbmRleCAtIDFcbiAgICAgIGlmICh0aGlzLl9zbGlkZXNQZXJHcm91cCAlIDIgIT09IDApIHtcbiAgICAgICAgbGVmdEluZGV4IC09IHByZXZTbGlkZUNvdW50XG4gICAgICB9XG5cbiAgICAgIGlmICgobGVmdEluZGV4ID49IDAgJiYgbGVmdEluZGV4IDwgdGhpcy5fd3JhcHBlci5jaGlsZHJlbi5sZW5ndGgpICYmXG4gICAgICAgIChyaWdodEluZGV4ID49IDAgJiYgcmlnaHRJbmRleCA8IHRoaXMuX3dyYXBwZXIuY2hpbGRyZW4ubGVuZ3RoKSkge1xuICAgICAgICBsZXQgbGVmdFNsaWRlID0gdGhpcy5fc2xpZGVyV3JhcHBlci5nZXRTbGlkZVByb3BlcnRpZXMobGVmdEluZGV4KVxuICAgICAgICBsZXQgcmlnaHRTbGlkZSA9IHRoaXMuX3NsaWRlcldyYXBwZXIuZ2V0U2xpZGVQcm9wZXJ0aWVzKHJpZ2h0SW5kZXgpXG5cbiAgICAgICAgbGV0IGJ0bldpZHRoID0gdGhpcy5fcHJldkN0cmwub2Zmc2V0V2lkdGhcbiAgICAgICAgaWYgKGJ0bldpZHRoIDw9IDApIHtcbiAgICAgICAgICBidG5XaWR0aCA9IDYwXG4gICAgICAgIH1cblxuICAgICAgICBwcmV2Q3RybE1hcmdpbiA9IGxlZnRTbGlkZS5yaWdodCAtIHdyYXBwZXJSZWN0LmxlZnQgLSBidG5XaWR0aFxuICAgICAgICBuZXh0Q3RybE1hcmdpbiA9IHdyYXBwZXJSZWN0LnJpZ2h0IC0gcmlnaHRTbGlkZS5sZWZ0IC0gYnRuV2lkdGhcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgbGVmdCA9IHByZXZDdHJsTWFyZ2luICE9PSAwID8gYCR7cHJldkN0cmxNYXJnaW59cHhgIDogXCJcIlxuICAgIHRoaXMuX3ByZXZDdHJsLnN0eWxlLmxlZnQgPSBsZWZ0XG5cbiAgICBsZXQgcmlnaHQgPSBuZXh0Q3RybE1hcmdpbiAhPT0gMCA/IGAke25leHRDdHJsTWFyZ2lufXB4YCA6IFwiXCJcbiAgICB0aGlzLl9uZXh0Q3RybC5zdHlsZS5yaWdodCA9IHJpZ2h0XG4gIH1cblxuICBwcm90ZWN0ZWQgX3VwZGF0ZUFjdGl2ZVNsaWRlcyhuZXh0SW5kZXg6IG51bWJlcikge1xuICAgIGNvbnN0IHByZXZTbGlkZUNvdW50ID0gTWF0aC5mbG9vcigwLjUgKiAodGhpcy5fc2xpZGVzUGVyR3JvdXAgLSAxKSlcbiAgICBjb25zdCBldmVuR3JvdXAgPSB0aGlzLl9zbGlkZXNQZXJHcm91cCAlIDIgPT09IDBcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fd3JhcHBlci5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHNsaWRlID0gdGhpcy5fd3JhcHBlci5jaGlsZHJlbltpXVxuXG4gICAgICBpZiAoaSA9PT0gbmV4dEluZGV4IHx8IChldmVuR3JvdXAgJiYgaSA9PT0gbmV4dEluZGV4ICsgMSkpIHtcbiAgICAgICAgRG9tLmFkZENsYXNzKHNsaWRlLCBDTEFTU19BQ1RJVkUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBEb20ucmVtb3ZlQ2xhc3Moc2xpZGUsIENMQVNTX0FDVElWRSlcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPCBuZXh0SW5kZXggJiYgaSA+PSBuZXh0SW5kZXggLSBwcmV2U2xpZGVDb3VudCkge1xuICAgICAgICBEb20uYWRkQ2xhc3Moc2xpZGUsIENMQVNTX1BSRVYpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBEb20ucmVtb3ZlQ2xhc3Moc2xpZGUsIENMQVNTX1BSRVYpXG4gICAgICB9XG5cbiAgICAgIGlmIChpID4gbmV4dEluZGV4ICYmIChpIDw9IG5leHRJbmRleCArIHByZXZTbGlkZUNvdW50IHx8IChldmVuR3JvdXAgJiYgaSA8PSBuZXh0SW5kZXggKyAxICsgcHJldlNsaWRlQ291bnQpKSkge1xuICAgICAgICBEb20uYWRkQ2xhc3Moc2xpZGUsIENMQVNTX05FWFQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBEb20ucmVtb3ZlQ2xhc3Moc2xpZGUsIENMQVNTX05FWFQpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYW5kIGNyZWF0ZXMgdGhlIHBhZ2luYXRpb24gYnVsbGV0cy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfdXBkYXRlUGFnaW5hdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX3BhZ2luYXRpb24pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCB0byA9IHRoaXMuX2luZGV4XG5cbiAgICBsZXQgYnVsbGV0cyA9IHRoaXMuX3BhZ2luYXRpb24uY2hpbGRyZW5cbiAgICBsZXQgdG90YWxJdGVtcyA9IE1hdGgubWF4KHRoaXMuX3NsaWRlcy5sZW5ndGgsIGJ1bGxldHMubGVuZ3RoKVxuICAgIGxldCBzbGlkZUNvdW50ID0gTWF0aC5jZWlsKHRoaXMuX3NsaWRlcy5sZW5ndGggLyB0aGlzLl9zbGlkZXNQZXJHcm91cClcbiAgICBsZXQgYWN0aXZlU2xpZGVJbmRleCA9IE1hdGguZmxvb3IodG8gLyB0aGlzLl9zbGlkZXNQZXJHcm91cClcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWxJdGVtczsgaSsrKSB7XG4gICAgICBsZXQgYnVsbGV0XG5cbiAgICAgIGlmIChidWxsZXRzLmxlbmd0aCA+IGkpIHtcbiAgICAgICAgaWYgKGJ1bGxldHMubGVuZ3RoIDw9IHNsaWRlQ291bnQpIHtcbiAgICAgICAgICBidWxsZXQgPSBidWxsZXRzW2ldXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlKGJ1bGxldHNbaV0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaSA8IHNsaWRlQ291bnQpIHtcbiAgICAgICAgYnVsbGV0ID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfQlVMTEVUKVxuICAgICAgICAgIC5lbGVtZW50XG4gICAgICAgIHRoaXMuX3BhZ2luYXRpb24uYXBwZW5kQ2hpbGQoYnVsbGV0KVxuICAgICAgfVxuXG4gICAgICBpZiAoYnVsbGV0ICYmIGkgPCBzbGlkZUNvdW50KSB7XG4gICAgICAgIGlmIChpID09PSBhY3RpdmVTbGlkZUluZGV4KSB7XG4gICAgICAgICAgRG9tLmFkZENsYXNzKGJ1bGxldCwgQ0xBU1NfQlVMTEVUX0FDVElWRSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBEb20ucmVtb3ZlQ2xhc3MoYnVsbGV0LCBDTEFTU19CVUxMRVRfQUNUSVZFKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVQYWdpbmF0aW9uQ2xpY2soZTogTW91c2VFdmVudCkge1xuICAgIGlmICghRG9tLmhhc0NsYXNzKGUudGFyZ2V0IGFzIEVsZW1lbnQsIENMQVNTX0JVTExFVCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBpbmRleCA9IEFycmF5LmZyb20odGhpcy5fcGFnaW5hdGlvbiEuY2hpbGRyZW4pLmluZGV4T2YoZS50YXJnZXQgYXMgRWxlbWVudClcbiAgICBsZXQgc2xpZGVOdW1iZXIgPSBpbmRleCAqIHRoaXMuX3NsaWRlc1Blckdyb3VwXG5cbiAgICB0aGlzLnNsaWRlVG8oc2xpZGVOdW1iZXIpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUtleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICBsZXQga2V5Y29kZSA9IGV2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGVcblxuICAgIHN3aXRjaCAoa2V5Y29kZSkge1xuICAgICAgY2FzZSBJbnB1dHMuS0VZX0FSUk9XX0xFRlQ6XG4gICAgICAgIHRoaXMucHJldigpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIElucHV0cy5LRVlfQVJST1dfUklHSFQ6XG4gICAgICAgIHRoaXMubmV4dCgpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIElucHV0cy5LRVlfRVNDQVBFOlxuICAgICAgICB0aGlzLmVsZW1lbnQuYmx1cigpXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfb25Ub3VjaHN0YXJ0KGV2ZW50OiBUb3VjaEV2ZW50IHwgTW91c2VFdmVudCkge1xuICAgIGNvbnN0IHRvdWNoID0gKGV2ZW50IGFzIFRvdWNoRXZlbnQpLnRvdWNoZXMgPyAoZXZlbnQgYXMgVG91Y2hFdmVudCkudG91Y2hlc1swXSA6IGV2ZW50IGFzIE1vdXNlRXZlbnRcblxuICAgIHRoaXMuX3NsaWRlQXJlYS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuX2hhbmRsZVRvdWNoc3RhcnQpXG4gICAgdGhpcy5fc2xpZGVBcmVhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuX2hhbmRsZVRvdWNoc3RhcnQpXG5cbiAgICB0aGlzLl9zbGlkZXJXcmFwcGVyLmJlZ2luRHJhZygpXG4gICAgY29uc3QgeyBwYWdlWCB9ID0gdG91Y2hcblxuICAgIHRoaXMuX3RvdWNoT2Zmc2V0ID0ge1xuICAgICAgeDogcGFnZVgsXG4gICAgICB0aW1lOiBEYXRlLm5vdygpXG4gICAgfVxuXG4gICAgdGhpcy5fZGVsdGEgPSB7XG4gICAgICB4OiAwLFxuICAgICAgbGFzdE1vdmU6IHBhZ2VYXG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9oYW5kbGVUb3VjaG1vdmUpXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLl9oYW5kbGVUb3VjaG1vdmUpXG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLl9oYW5kbGVUb3VjaGVuZClcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB0aGlzLl9oYW5kbGVUb3VjaGVuZClcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5faGFuZGxlVG91Y2hlbmQpXG4gIH1cblxuICBwcm90ZWN0ZWQgX29uVG91Y2htb3ZlKGV2ZW50OiBUb3VjaEV2ZW50IHwgTW91c2VFdmVudCkge1xuICAgIGNvbnN0IHRvdWNoID0gKGV2ZW50IGFzIFRvdWNoRXZlbnQpLnRvdWNoZXMgPyAoZXZlbnQgYXMgVG91Y2hFdmVudCkudG91Y2hlc1swXSA6IGV2ZW50IGFzIE1vdXNlRXZlbnRcbiAgICBjb25zdCB7IHBhZ2VYIH0gPSB0b3VjaFxuXG4gICAgbGV0IGRlbHRhTW92ZSA9IHBhZ2VYIC0gdGhpcy5fZGVsdGEhLmxhc3RNb3ZlXG5cbiAgICB0aGlzLl9kZWx0YSA9IHtcbiAgICAgIHg6IHBhZ2VYIC0gdGhpcy5fdG91Y2hPZmZzZXQhLngsXG4gICAgICBsYXN0TW92ZTogcGFnZVhcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdG91Y2hPZmZzZXQpIHtcbiAgICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KVxuXG4gICAgICB0aGlzLl9zbGlkZXJXcmFwcGVyLm1vdmUoZGVsdGFNb3ZlKVxuICAgICAgdGhpcy5fY2xvbmVTbGlkZXNUb0ZpdFdyYXBwZXIoZmFsc2UsIGRlbHRhTW92ZSlcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX29uVG91Y2hlbmQoKSB7XG4gICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLl90b3VjaE9mZnNldCA/IERhdGUubm93KCkgLSB0aGlzLl90b3VjaE9mZnNldC50aW1lIDogdW5kZWZpbmVkXG5cbiAgICBjb25zdCBpc1ZhbGlkID0gTnVtYmVyKGR1cmF0aW9uKSA8IFRPVUNIX0RVUkFUSU9OICYmXG4gICAgICBNYXRoLmFicyh0aGlzLl9kZWx0YSEueCkgPiBUT1VDSF9ERUxUQV9NSU4gfHxcbiAgICAgIE1hdGguYWJzKHRoaXMuX2RlbHRhIS54KSA+IHRoaXMuX2ZyYW1lV2lkdGghIC8gM1xuXG4gICAgaWYgKGlzVmFsaWQpIHtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGNsYW1wKHRoaXMuX2RlbHRhIS54LCAtMSwgMSkgKiAtMSBhcyBEaXJlY3Rpb25cbiAgICAgIHRoaXMuc2xpZGUoZmFsc2UsIGRpcmVjdGlvbiwgdHJ1ZSlcblxuICAgICAgdGhpcy5fc2xpZGVyV3JhcHBlci5lbmREcmFnKClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2xpZGUgYmFjayB0byB0aGUgc3RhcnRpbmcgcG9pbnQgb2YgdGhlIGRyYWcgb3BlcmF0aW9uXG4gICAgICB0aGlzLl9zbGlkZXJXcmFwcGVyLmNhbmNlbERyYWcoKVxuICAgIH1cblxuICAgIHRoaXMuX3RvdWNoT2Zmc2V0ID0gdW5kZWZpbmVkXG5cbiAgICB0aGlzLl9zbGlkZUFyZWEuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLl9oYW5kbGVUb3VjaHN0YXJ0KVxuICAgIHRoaXMuX3NsaWRlQXJlYS5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLl9oYW5kbGVUb3VjaHN0YXJ0KVxuXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9oYW5kbGVUb3VjaG1vdmUpXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5faGFuZGxlVG91Y2hlbmQpXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgdGhpcy5faGFuZGxlVG91Y2hlbmQpXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLl9oYW5kbGVUb3VjaG1vdmUpXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX2hhbmRsZVRvdWNoZW5kKVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZWQgcGFyYW1ldGVycyBpbiByZWdhcmQgdG8gdGhlIGN1cnJlbnRseSBhY3RpdmUgcmVzcG9uc2l2ZVxuICAgKiBicmVha3BvaW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF91cGRhdGVSZXNwb25zaXZlT3B0aW9ucygpIHtcbiAgICBpZiAodGhpcy5faXNCcmVha3BvaW50QWN0aXZlKHRoaXMuX2JyZWFrcG9pbnRQaG9uZSkpIHtcbiAgICAgIHRoaXMuX3NsaWRlc1Blckdyb3VwID0gMVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9pc0JyZWFrcG9pbnRBY3RpdmUodGhpcy5fYnJlYWtwb2ludFRhYmxldCkpIHtcbiAgICAgIHRoaXMuX3NsaWRlc1Blckdyb3VwID0gMlxuICAgIH1cblxuICAgIGlmICh0aGlzLl9pc0JyZWFrcG9pbnRBY3RpdmUodGhpcy5fYnJlYWtwb2ludERlc2t0b3ApKSB7XG4gICAgICB0aGlzLl9zbGlkZXNQZXJHcm91cCA9IDNcbiAgICB9XG5cbiAgICB0aGlzLl9zbGlkZXJXcmFwcGVyLnNsaWRlc1Blckdyb3VwID0gdGhpcy5fc2xpZGVzUGVyR3JvdXBcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHJlcXVlc3RlZCBzbGlkZSBhbmQgYWRkcyBpdCB0byB0aGUgc2xpZGVyLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBUaGUgb3JpZ2luYWwgc2xpZGUgaW5kZXggb2YgdGhlIHRlbXBsYXRlIHNsaWRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkaXJlY3Rpb24gLSBUaGUgZGlyZWN0aW9uIGluIHdoaWNoIHRvIGFkZCB0aGUgc2xpZGVzLCAtMSBmb3IgbGVmdCwgMSBmb3IgcmlnaHRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfY2xvbmVTbGlkZShpbmRleDogbnVtYmVyLCBkaXJlY3Rpb246IG51bWJlcikge1xuICAgIGxldCBjbG9uZSA9IHRoaXMuX3NsaWRlc1tpbmRleF0uY2xvbmVOb2RlKHRydWUpIGFzIEhUTUxFbGVtZW50XG4gICAgRG9tLnJlbW92ZUNsYXNzKGNsb25lLCBDTEFTU19BQ1RJVkUpXG4gICAgRG9tLnJlbW92ZUNsYXNzKGNsb25lLCBDTEFTU19QUkVWKVxuICAgIERvbS5yZW1vdmVDbGFzcyhjbG9uZSwgQ0xBU1NfTkVYVClcblxuICAgIHRoaXMuX3NsaWRlcldyYXBwZXIuYWRkU2xpZGUoY2xvbmUsIGRpcmVjdGlvbilcblxuICAgIGxldCBzbGlkZU1hcmdpbiA9IHRoaXMuX2FkZGl0aW9uYWxTbGlkZU1hcmdpbiA+IDAgPyBgJHt0aGlzLl9hZGRpdGlvbmFsU2xpZGVNYXJnaW59cHhgIDogXCJcIlxuICAgIGNsb25lLnN0eWxlLm1hcmdpbkxlZnQgPSBzbGlkZU1hcmdpblxuICAgIGNsb25lLnN0eWxlLm1hcmdpblJpZ2h0ID0gc2xpZGVNYXJnaW5cblxuICAgIHJldHVybiBjbG9uZS5vZmZzZXRXaWR0aFxuICB9XG5cbiAgLyoqXG4gICAqIENsb25lcyBhbmQgYWRkcyB0aGUgcmVxdWVzdGVkIGFtbW91bnQgb2Ygc2xpZGVzLlxuICAgKiBAcGFyYW0ge051bWJlcn0gc2xpZGVDb3VudCAtIFRoZSBudW1iZXIgb2Ygc2xpZGVzIHRvIGFkZFxuICAgKiBAcGFyYW0ge051bWJlcn0gZGlyZWN0aW9uIC0gVGhlIGRpcmVjdGlvbiBpbiB3aGljaCB0byBhZGQgdGhlIHNsaWRlcywgLTEgZm9yIGxlZnQsIDEgZm9yIHJpZ2h0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX2Nsb25lU2xpZGVzQnlDb3VudChzbGlkZUNvdW50OiBudW1iZXIsIGRpcmVjdGlvbjogRGlyZWN0aW9uKSB7XG4gICAgbGV0IG9yaWdpbmFsSW5kZXggPSBkaXJlY3Rpb24gPCAwID8gMCA6IHRoaXMuX3dyYXBwZXIuY2hpbGRyZW4ubGVuZ3RoIC0gMVxuICAgIGxldCBpbmRleCA9IHBhcnNlSW50KHRoaXMuX3dyYXBwZXIuY2hpbGRyZW5bb3JpZ2luYWxJbmRleF0uZ2V0QXR0cmlidXRlKEFUVFJJQlVURV9JTkRFWCkhLCAxMClcblxuICAgIHdoaWxlIChzbGlkZUNvdW50ID4gMCkge1xuICAgICAgaW5kZXggPSB0aGlzLl93cmFwcm91bmQoaW5kZXggKyBkaXJlY3Rpb24sIDAsIHRoaXMuX3NsaWRlcy5sZW5ndGgpXG4gICAgICB0aGlzLl9jbG9uZVNsaWRlKGluZGV4LCBkaXJlY3Rpb24pXG4gICAgICBzbGlkZUNvdW50LS1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgc2Nyb2xsIGNsb3VudCBhbmQgaW5zZXJ0cyB0aGUgcmVxdWlyZWQgYW1tb3VudCBvZiBzbGlkZXNcbiAgICogaW4gdGhlIGFwcm9wcmlhdGUgZGlyZWN0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gbmV4dEluZGV4IC0gVGhlIHNsaWRlIHRvIHNjcm9sbCB0b1xuICAgKiBAcGFyYW0ge051bWJlcn0gZGlyZWN0aW9uIC0gVGhlIGRpcmVjdGlvbiBvZiB0aGUgc2Nyb2xsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX2Nsb25lU2xpZGVzQnlTY3JvbGxDb3VudChuZXh0SW5kZXg6IG51bWJlciwgZGlyZWN0aW9uOiBEaXJlY3Rpb24pIHtcbiAgICBjb25zdCBzY3JvbGxDb3VudCA9IHRoaXMuX3dyYXByb3VuZENvdW50KHRoaXMuX2luZGV4LCBuZXh0SW5kZXgsIDAsIHRoaXMuX3NsaWRlcy5sZW5ndGgsIGRpcmVjdGlvbilcblxuICAgIGNvbnN0IG91dGVyU2xpZGVQcm9wcyA9IHRoaXMuX3NsaWRlcldyYXBwZXIuZ2V0U2xpZGVQcm9wZXJ0aWVzKGRpcmVjdGlvbiA+IDAgPyB0aGlzLl93cmFwcGVyLmNoaWxkcmVuLmxlbmd0aCAtIDEgOiAwKVxuICAgIGNvbnN0IGluZGV4VG9PdXRlclNsaWRlQ291bnQgPSB0aGlzLl93cmFwcm91bmRDb3VudCh0aGlzLl9pbmRleCwgb3V0ZXJTbGlkZVByb3BzLmluZGV4LCAwLCB0aGlzLl9zbGlkZXMubGVuZ3RoLCBkaXJlY3Rpb24pXG5cbiAgICBjb25zdCBzbGlkZXNUb0luc2VydCA9IHNjcm9sbENvdW50IC0gaW5kZXhUb091dGVyU2xpZGVDb3VudFxuICAgIGlmIChzbGlkZXNUb0luc2VydCA+IDApIHtcbiAgICAgIHRoaXMuX2Nsb25lU2xpZGVzQnlDb3VudChzbGlkZXNUb0luc2VydCwgZGlyZWN0aW9uKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfY2xvbmVTbGlkZXNCeVRvRmlsbChzcGFjZVRvRmlsbDogbnVtYmVyLCBkaXJlY3Rpb246IERpcmVjdGlvbikge1xuICAgIGxldCBvcmlnaW5hbEluZGV4ID0gZGlyZWN0aW9uIDwgMCA/IDAgOiB0aGlzLl93cmFwcGVyLmNoaWxkcmVuLmxlbmd0aCAtIDFcbiAgICBsZXQgaW5kZXggPSBwYXJzZUludCh0aGlzLl93cmFwcGVyLmNoaWxkcmVuW29yaWdpbmFsSW5kZXhdLmdldEF0dHJpYnV0ZShBVFRSSUJVVEVfSU5ERVgpISwgMTApXG5cbiAgICB3aGlsZSAoc3BhY2VUb0ZpbGwgPiAwKSB7XG4gICAgICBpbmRleCA9IHRoaXMuX3dyYXByb3VuZChpbmRleCArIGRpcmVjdGlvbiwgMCwgdGhpcy5fc2xpZGVzLmxlbmd0aClcbiAgICAgIHNwYWNlVG9GaWxsIC09IHRoaXMuX2Nsb25lU2xpZGUoaW5kZXgsIGRpcmVjdGlvbilcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2Nsb25lU2xpZGVzVG9GaXRXcmFwcGVyKGNsZWFudXAgPSB0cnVlLCBzbGlkZURlbHRhID0gMCkge1xuICAgIGNvbnN0IHJlYWxJbmRleCA9IHRoaXMuX3NsaWRlcldyYXBwZXIuaW5kZXhcbiAgICBsZXQgZmlyc3Q6IFNsaWRlUHJvcGVydGllc1xuICAgIGxldCBsYXN0OiBTbGlkZVByb3BlcnRpZXNcblxuICAgIGlmIChjbGVhbnVwID09PSBmYWxzZSkge1xuICAgICAgZmlyc3QgPSB0aGlzLl9zbGlkZXJXcmFwcGVyLmdldFNsaWRlUHJvcGVydGllcygwKVxuICAgICAgbGFzdCA9IHRoaXMuX3NsaWRlcldyYXBwZXIuZ2V0U2xpZGVQcm9wZXJ0aWVzKHRoaXMuX3dyYXBwZXIuY2hpbGRyZW4ubGVuZ3RoIC0gMSlcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuX3NsaWRlcldyYXBwZXIuZ2V0UmVtb3ZhYmxlU2xpZGVzKHNsaWRlRGVsdGEpXG4gICAgICBmaXJzdCA9IHJlc3VsdC5maXJzdCFcbiAgICAgIGxhc3QgPSByZXN1bHQubGFzdCFcblxuICAgICAgLy8gUmVtb3ZlIHRoZSBzbGlkZXMgZnJvbSB2aWV3XG4gICAgICBmb3IgKGxldCBpID0gcmVzdWx0LnNsaWRlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAocmVzdWx0LnNsaWRlc1tpXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuX3NsaWRlcldyYXBwZXIucmVtb3ZlU2xpZGUoaSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBzcGFjZVRvRmlsbCA9IHRoaXMuX3NsaWRlcldyYXBwZXIuZ2V0RW1wdHlTcGFjZShmaXJzdC5sZWZ0LCBsYXN0LnJpZ2h0KVxuXG4gICAgLy8gQ2hlY2sgaWYgYWRkaXRpb25hbCBzbGlkZXMgYXJlIHJlcXVpcmVkIG9uIHRoZSBsZWZ0XG4gICAgaWYgKGZpcnN0LnZpc2libGUgPT09IHRydWUgJiYgc3BhY2VUb0ZpbGwubGVmdCA+IDApIHtcbiAgICAgIHRoaXMuX2Nsb25lU2xpZGVzQnlUb0ZpbGwoc3BhY2VUb0ZpbGwubGVmdCwgLTEpXG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgYWRkaXRpb25hbCBzbGlkZXMgYXJlIHJlcXVpcmVkIG9uIHRoZSByaWdodFxuICAgIGlmIChsYXN0LnZpc2libGUgPT09IHRydWUgJiYgc3BhY2VUb0ZpbGwucmlnaHQgPiAwKSB7XG4gICAgICB0aGlzLl9jbG9uZVNsaWRlc0J5VG9GaWxsKHNwYWNlVG9GaWxsLnJpZ2h0LCAxKVxuICAgIH1cblxuICAgIHJldHVybiByZWFsSW5kZXggLSB0aGlzLl9zbGlkZXJXcmFwcGVyLmluZGV4XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgcmVhbCAod3JhcHBlcikgaW5kZXggZm9yIHRoZSBzbGlkZSB3aXRoIHRoZSBnaXZlbiBvcmlnaW5hbCBpbmRleFxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggdG8gc2VhcmNoIGZvclxuICAgKiBAcGFyYW0ge051bWJlcn0gZGlyZWN0aW9uIC0gVGhlIGRpcmVjdGlvbiBpbiB3aGljaCB0byBzZWFyY2hcbiAgICogQHJldHVybnMge051bWJlcn0gVGhlIHdyYXBwZXIgaW5kZXhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfZ2V0UmVhbEluZGV4Rm9yKGluZGV4OiBudW1iZXIsIGRpcmVjdGlvbjogRGlyZWN0aW9uKSB7XG4gICAgbGV0IGkgPSB0aGlzLl9zbGlkZXJXcmFwcGVyLmluZGV4XG4gICAgd2hpbGUgKGkgPj0gMCAmJiBpIDwgdGhpcy5fd3JhcHBlci5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIGxldCBzbGlkZUluZGV4ID0gcGFyc2VJbnQodGhpcy5fd3JhcHBlci5jaGlsZHJlbltpXS5nZXRBdHRyaWJ1dGUoQVRUUklCVVRFX0lOREVYKSEsIDEwKVxuICAgICAgaWYgKHNsaWRlSW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpXG4gICAgICB9XG5cbiAgICAgIGkgKz0gZGlyZWN0aW9uXG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKGBDbG91ZCBub3QgZmluZCByZWFsIGluZGV4IGZvciBzbGlkZSAke2luZGV4fSBpbiBkaXJlY3Rpb24gJHtkaXJlY3Rpb259YClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBhY3RpdmUgc2xpZGUuIElmIHRoZSBzbGlkZXMgYXJlIGdyb3VwZWQgZXZlbmx5XG4gICAqIHRoZSBhY3RpdmUgc2xpZGUgaXMgYWx3YXlzIHRoZSBmaXJzdCBpbiB0aGUgZ3JvdXAuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgYWN0aXZlIHNsaWRlLlxuICAgKi9cbiAgZ2V0IGluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLl9pbmRleFxuICB9XG5cbiAgcHVibGljIHJlc2V0KCkge1xuICAgIHRoaXMuX2ZyYW1lV2lkdGggPSB0aGlzLl9zbGlkZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgIC53aWR0aCB8fCB0aGlzLl9zbGlkZXIub2Zmc2V0V2lkdGhcblxuICAgIHRoaXMuX3VwZGF0ZVJlc3BvbnNpdmVPcHRpb25zKClcblxuICAgIGlmICh0aGlzLl9uZXh0Q3RybCkge1xuICAgICAgKHRoaXMuX25leHRDdHJsIGFzIGFueSkuZGlzYWJsZWQgPSBmYWxzZVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9wcmV2Q3RybCkge1xuICAgICAgKHRoaXMuX3ByZXZDdHJsIGFzIGFueSkuZGlzYWJsZWQgPSBmYWxzZVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9zbGlkZXNQZXJHcm91cCA9PT0gMSkge1xuICAgICAgbGV0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5fc2xpZGVyLnBhcmVudEVsZW1lbnQhKVxuICAgICAgbGV0IHBhcmVudFdpZHRoID0gdGhpcy5fc2xpZGVyLnBhcmVudEVsZW1lbnQhLmNsaWVudFdpZHRoICsgKHBhcnNlRmxvYXQoc3R5bGUubWFyZ2luTGVmdCEpIHx8IDApICsgKHBhcnNlRmxvYXQoc3R5bGUubWFyZ2luUmlnaHQhKSB8fCAwKVxuXG4gICAgICBsZXQgb3V0ZXJNYXJnaW4gPSBNYXRoLmNlaWwocGFyZW50V2lkdGggLSB0aGlzLl9mcmFtZVdpZHRoKVxuICAgICAgdGhpcy5fYWRkaXRpb25hbFNsaWRlTWFyZ2luID0gTWF0aC5jZWlsKG91dGVyTWFyZ2luICogMC41KSArIDFcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYWRkaXRpb25hbFNsaWRlTWFyZ2luID0gMFxuICAgIH1cblxuICAgIGxldCBzbGlkZU1hcmdpbiA9IHRoaXMuX2FkZGl0aW9uYWxTbGlkZU1hcmdpbiA+IDAgPyBgJHt0aGlzLl9hZGRpdGlvbmFsU2xpZGVNYXJnaW59cHhgIDogXCJcIlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fd3JhcHBlci5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHNsaWRlID0gdGhpcy5fd3JhcHBlci5jaGlsZHJlbltpXSBhcyBIVE1MRWxlbWVudFxuICAgICAgc2xpZGUuc3R5bGUubWFyZ2luTGVmdCA9IHNsaWRlTWFyZ2luXG4gICAgICBzbGlkZS5zdHlsZS5tYXJnaW5SaWdodCA9IHNsaWRlTWFyZ2luXG4gICAgfVxuXG4gICAgdGhpcy5fc2xpZGVyV3JhcHBlci5vbnJlc2l6ZSgpXG4gICAgdGhpcy5fY2xvbmVTbGlkZXNUb0ZpdFdyYXBwZXIoZmFsc2UpXG4gICAgdGhpcy5fc2xpZGVyV3JhcHBlci5tb3ZlVG8odGhpcy5fc2xpZGVyV3JhcHBlci5pbmRleClcblxuICAgIHRoaXMuX3VwZGF0ZVBhZ2luYXRpb24oKVxuICAgIHRoaXMuX3VwZGF0ZUFjdGl2ZVNsaWRlcyh0aGlzLl9zbGlkZXJXcmFwcGVyLmluZGV4KVxuICB9XG5cbiAgLyoqXG4gICAqIE1vdmVzIHRoZSBzbGlkZXIgdG8gdGhlIG5leHQgaXRlbS5cbiAgICovXG4gIHB1YmxpYyBwcmV2KCkge1xuICAgIHRoaXMuc2xpZGUoZmFsc2UsIC0xKVxuICB9XG5cbiAgLyoqXG4gICAqIE1vdmVzIHRoZSBzbGlkZXIgdG8gdGhlIHByZXZpb3VzIGl0ZW0uXG4gICAqL1xuICBwdWJsaWMgbmV4dCgpIHtcbiAgICB0aGlzLnNsaWRlKGZhbHNlLCAxKVxuICB9XG5cbiAgcHVibGljIHNsaWRlKG5leHRJbmRleDogbnVtYmVyIHwgZmFsc2UsIGRpcmVjdGlvbj86IERpcmVjdGlvbiwgYW5pbWF0ZSA9IHRydWUpIHtcbiAgICBpZiAodHlwZW9mIG5leHRJbmRleCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgaWYgKGRpcmVjdGlvbiEgPiAwKSB7XG4gICAgICAgIG5leHRJbmRleCA9IHRoaXMuX2luZGV4ICsgdGhpcy5fc2xpZGVzUGVyR3JvdXBcbiAgICAgICAgZGlyZWN0aW9uID0gMVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dEluZGV4ID0gdGhpcy5faW5kZXggLSB0aGlzLl9zbGlkZXNQZXJHcm91cFxuICAgICAgICBkaXJlY3Rpb24gPSAtMVxuICAgICAgfVxuICAgIH1cblxuICAgIG5leHRJbmRleCA9IHRoaXMuX2FkanVzdEluZGV4KG5leHRJbmRleClcblxuICAgIGlmICghZGlyZWN0aW9uKSB7XG4gICAgICBkaXJlY3Rpb24gPSBjbGFtcChuZXh0SW5kZXggLSB0aGlzLl9pbmRleCwgLTEsIDEpIGFzIERpcmVjdGlvblxuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSBhcmUgZW5vdWdodCBzbGlkZXMgb24gc2NyZWVuXG4gICAgdGhpcy5fY2xvbmVTbGlkZXNUb0ZpdFdyYXBwZXIoZmFsc2UpXG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlcmUgYXJlIGVub3VnaCBzbGlkZXMgZm9yIHRoZSBzY3JvbGwgb3BlcmF0aW9uXG4gICAgdGhpcy5fY2xvbmVTbGlkZXNCeVNjcm9sbENvdW50KG5leHRJbmRleCwgZGlyZWN0aW9uKVxuXG4gICAgbGV0IHJlYWxJbmRleCA9IHRoaXMuX2dldFJlYWxJbmRleEZvcihuZXh0SW5kZXgsIGRpcmVjdGlvbilcbiAgICBsZXQgc2xpZGVEZWx0YSA9IHRoaXMuX3NsaWRlcldyYXBwZXIuZ2V0U2xpZGVEZWx0YShyZWFsSW5kZXgpXG4gICAgcmVhbEluZGV4ID0gTWF0aC5tYXgocmVhbEluZGV4IC0gdGhpcy5fY2xvbmVTbGlkZXNUb0ZpdFdyYXBwZXIodHJ1ZSwgc2xpZGVEZWx0YSksIDApXG5cbiAgICB0aGlzLl9zbGlkZXJXcmFwcGVyLm1vdmVUbyhyZWFsSW5kZXgsIHVuZGVmaW5lZCwgYW5pbWF0ZSlcblxuICAgIC8vIFVwZGF0ZSB0aGUgYWN0aXZlIGluZGV4XG4gICAgdGhpcy5faW5kZXggPSBuZXh0SW5kZXhcblxuICAgIC8vIE1hcmsgc2xpZGVzIGFzIGFjdGl2ZVxuICAgIHRoaXMuX3VwZGF0ZVBhZ2luYXRpb24oKVxuICAgIHRoaXMuX3VwZGF0ZUFjdGl2ZVNsaWRlcyhyZWFsSW5kZXgpXG5cbiAgICAvLyBjb25zb2xlLmxvZyhgUGVyZm9ybWVkIHNsaWRlIHRvICR7dGhpcy5faW5kZXh9LCByZWFsSW5kZXg6ICR7dGhpcy5fc2xpZGVyV3JhcHBlci5pbmRleH1gKVxuICB9XG5cbiAgLyoqXG4gICAqIE1vdmVzIHRoZSBzbGlkZXIgdG8gdGhlIHNlbGVjdGVkIHNsaWRlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIHNsaWRlIHRvIHNsaWRlIHRvLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFuaW1hdGUgLSBgVHJ1ZWAgaWYgdGhlIHNsaWRlIHNob3VsZCBiZSBhbmltYXRlZDsgb3RoZXJ3aXNlIGBmYWxzZWAuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICovXG4gIHB1YmxpYyBzbGlkZVRvKGluZGV4OiBudW1iZXIsIGFuaW1hdGUgPSB0cnVlKSB7XG4gICAgdGhpcy5zbGlkZShpbmRleCwgdW5kZWZpbmVkLCBhbmltYXRlKVxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBjb21wb25lbnRzIGFuZCBmcmVlcyBhbGwgcmVmZXJlbmNlcy5cbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMuX3Jlc2l6ZUhhbmRsZXIpXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvcmllbnRhdGlvbmNoYW5nZVwiLCB0aGlzLl9yZXNpemVIYW5kbGVyKVxuXG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2tleWRvd25IYW5kbGVyKVxuICAgIHRoaXMuX3NsaWRlQXJlYS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuX2hhbmRsZVRvdWNoc3RhcnQpXG4gICAgdGhpcy5fc2xpZGVBcmVhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuX2hhbmRsZVRvdWNoc3RhcnQpXG5cbiAgICB0aGlzLl9icmVha3BvaW50UGhvbmUucmVtb3ZlKClcbiAgICB0aGlzLl9icmVha3BvaW50VGFibGV0LnJlbW92ZSgpXG4gICAgdGhpcy5fYnJlYWtwb2ludERlc2t0b3AucmVtb3ZlKClcblxuICAgIGlmICh0aGlzLl9wcmV2Q3RybCAmJiB0aGlzLl9uZXh0Q3RybCkge1xuICAgICAgdGhpcy5fcHJldkN0cmwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3ByZXZIYW5kbGVyKVxuICAgICAgdGhpcy5fbmV4dEN0cmwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX25leHRIYW5kbGVyKVxuICAgIH1cblxuICAgICh0aGlzIGFzIGFueSkuX3ByZXZDdHJsID0gdW5kZWZpbmVkO1xuICAgICh0aGlzIGFzIGFueSkuX25leHRDdHJsID0gdW5kZWZpbmVkXG5cbiAgICBpZiAodGhpcy5fcGFnaW5hdGlvbikge1xuICAgICAgdGhpcy5fcGFnaW5hdGlvbi5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fcGFnaW5hdGlvbkNsaWNrSGFuZGxlcik7XG4gICAgICAodGhpcyBhcyBhbnkpLl9wYWdpbmF0aW9uID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgdGhpcy5fc2xpZGVyV3JhcHBlci5kZXN0cm95KCk7XG4gICAgKHRoaXMgYXMgYW55KS5fc2xpZGVyV3JhcHBlciA9IHVuZGVmaW5lZFxuICB9XG59XG5cbmNvbnN0IFRSQU5TRk9STSA9IFwidHJhbnNmb3JtXCJcbmNvbnN0IERVUkFUSU9OID0gXCJ0cmFuc2l0aW9uRHVyYXRpb25cIlxuY29uc3QgVElNSU5HID0gXCJ0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb25cIlxuXG5jbGFzcyBTbGlkZXJXcmFwcGVyIHtcbiAgcHJpdmF0ZSBfd3JhcHBlckVsZW1lbnQ6IEhUTUxFbGVtZW50XG4gIHByaXZhdGUgX3NsaWRlQXJlYUVsZW1lbnQ6IEhUTUxFbGVtZW50XG4gIHByaXZhdGUgX2Nhcm91c2VsRWxlbWVudDogSFRNTEVsZW1lbnRcblxuICBwcml2YXRlIF9wb3NpdGlvbjogbnVtYmVyXG4gIHByaXZhdGUgX2luZGV4OiBudW1iZXJcblxuICBwcml2YXRlIF9pc2RyYWdnaW5nOiBib29sZWFuXG4gIHByaXZhdGUgX2RyYWdTdGFydFBvc2l0aW9uPzogbnVtYmVyXG5cbiAgcHJpdmF0ZSBfYXJlYU9mZnNldD86IG51bWJlclxuXG4gIHByaXZhdGUgX3NsaWRlc1Blckdyb3VwITogbnVtYmVyXG5cbiAgcHJpdmF0ZSBfY29udGFpbmVyTWluITogbnVtYmVyXG4gIHByaXZhdGUgX2NvbnRhaW5lck1heCE6IG51bWJlclxuXG4gIGNvbnN0cnVjdG9yKHdyYXBwZXJFbGVtZW50OiBIVE1MRWxlbWVudCwgc2xpZGVBcmVhRWxlbWVudDogSFRNTEVsZW1lbnQsIGNhcm91c2VsRWxlbWVudDogSFRNTEVsZW1lbnQpIHtcbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudCA9IHdyYXBwZXJFbGVtZW50XG4gICAgdGhpcy5fc2xpZGVBcmVhRWxlbWVudCA9IHNsaWRlQXJlYUVsZW1lbnRcbiAgICB0aGlzLl9jYXJvdXNlbEVsZW1lbnQgPSBjYXJvdXNlbEVsZW1lbnRcblxuICAgIHRoaXMuX3Bvc2l0aW9uID0gMFxuICAgIHRoaXMuX2luZGV4ID0gMFxuICAgIHRoaXMuX2lzZHJhZ2dpbmcgPSBmYWxzZVxuICB9XG5cbiAgcHJvdGVjdGVkIF9nZXRTbGlkZShpbmRleDogbnVtYmVyKSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl93cmFwcGVyRWxlbWVudC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXJndW1lbnQgJ2luZGV4JyBpcyBvdXQgb2YgcmFuZ2UsIFZhbHVlOiAke2luZGV4fSBNaW46IDAsIE1heDogJHt0aGlzLl93cmFwcGVyRWxlbWVudC5jaGlsZHJlbi5sZW5ndGggLSAxfWApXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3dyYXBwZXJFbGVtZW50LmNoaWxkcmVuW2luZGV4XSBhcyBIVE1MRWxlbWVudFxuICB9XG5cbiAgcHJvdGVjdGVkIF9zZXRUcmFuc2Zvcm0odGFyZ2V0UG9zaXRpb246IG51bWJlciwgYW5pbWF0ZWQgPSBmYWxzZSwgZHVyYXRpb24gPSBBTklNQVRJT05fRFVSQVRJT04sIGVhc2UgPSBBTklNQVRJT05fRUFTSU5HKSB7XG4gICAgaWYgKGFuaW1hdGVkID09PSBmYWxzZSkge1xuICAgICAgZHVyYXRpb24gPSAwXG4gICAgfVxuXG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLl93cmFwcGVyRWxlbWVudC5zdHlsZVxuICAgIGlmIChzdHlsZSkge1xuICAgICAgc3R5bGVbRFVSQVRJT05dID0gYCR7ZHVyYXRpb259bXNgXG4gICAgICBzdHlsZVtUSU1JTkddID0gZWFzZVxuXG4gICAgICAvLyBObyBzdWIgcGl4ZWwgdHJhbnNpdGlvbnMuXG4gICAgICB0YXJnZXRQb3NpdGlvbiA9IE1hdGguZmxvb3IodGFyZ2V0UG9zaXRpb24pXG5cbiAgICAgIHN0eWxlW1RSQU5TRk9STV0gPSBgdHJhbnNsYXRlKCR7dGFyZ2V0UG9zaXRpb259cHgsIDApYFxuICAgICAgdGhpcy5fcG9zaXRpb24gPSB0YXJnZXRQb3NpdGlvblxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfZ2V0V3JhcHBlclNsaWRlUG9zaXRpb24oaW5kZXg6IG51bWJlcikge1xuICAgIGNvbnN0IHdyYXBwZXJDZW50ZXIgPSAoMC41ICogdGhpcy5fd3JhcHBlckVsZW1lbnQub2Zmc2V0V2lkdGgpXG4gICAgY29uc3Qgc2xpZGUgPSB0aGlzLl9nZXRTbGlkZShpbmRleClcblxuICAgIGxldCByZXN1bHQgPSAwXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgc2xpZGUgKGNlbnRlcmVkKVxuICAgIGlmICh0aGlzLl9zbGlkZXNQZXJHcm91cCAlIDIgPT09IDApIHtcbiAgICAgIGxldCBzbGlkZVN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoc2xpZGUpXG4gICAgICBsZXQgc2xpZGVNYXJnaW4gPSBzbGlkZVN0eWxlID8gcGFyc2VJbnQoc2xpZGVTdHlsZS5tYXJnaW5SaWdodCEsIDEwKSA6IDBcbiAgICAgIC8vIENlbnRlcmVkIHRvIHRoZSBzcGFjZSBiZXR3ZWVuIHRoZSB0d28gY2VudGVyIHNsaWRlcyBvZiB0aGUgZ3JvdXBcbiAgICAgIHJlc3VsdCA9IC1zbGlkZS5vZmZzZXRMZWZ0IC0gKHNsaWRlLmNsaWVudFdpZHRoKSArIHdyYXBwZXJDZW50ZXIgLSBzbGlkZU1hcmdpblxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSAtc2xpZGUub2Zmc2V0TGVmdCAtICgwLjUgKiBzbGlkZS5jbGllbnRXaWR0aCkgKyB3cmFwcGVyQ2VudGVyXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgZ2V0IHBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9wb3NpdGlvblxuICB9XG5cbiAgZ2V0IGluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLl9pbmRleFxuICB9XG5cbiAgc2V0IGluZGV4KGluZGV4OiBudW1iZXIpIHtcbiAgICB0aGlzLl9pbmRleCA9IGluZGV4XG4gIH1cblxuICBzZXQgc2xpZGVzUGVyR3JvdXAodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMuX3NsaWRlc1Blckdyb3VwID0gdmFsdWVcbiAgfVxuXG4gIHB1YmxpYyBpbml0aWFsaXplKCkge1xuICAgIHRoaXMub25yZXNpemUoKVxuICB9XG5cbiAgcHVibGljIG9ucmVzaXplKCkge1xuICAgIC8vIHVwZGF0ZSB0aGUgYXJlYSBvZmZzZXQgZm9yIHNsaWRlIHBvc2l0aW9uIGNhbGN1bGF0aW9uXG4gICAgdGhpcy5fYXJlYU9mZnNldCA9IHRoaXMuX3NsaWRlQXJlYUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdFxuXG4gICAgLy8gR2V0IHRoZSBjb250YWluZXIgZGltZW5zaW9uc1xuICAgIGNvbnN0IGNvbnRhaW5lclJlY3QgPSB0aGlzLl9jYXJvdXNlbEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICB0aGlzLl9jb250YWluZXJNaW4gPSBjb250YWluZXJSZWN0LmxlZnRcbiAgICB0aGlzLl9jb250YWluZXJNYXggPSBjb250YWluZXJSZWN0LnJpZ2h0XG4gIH1cblxuICBwdWJsaWMgYmVnaW5EcmFnKCkge1xuICAgIHRoaXMuX2lzZHJhZ2dpbmcgPSB0cnVlXG4gICAgdGhpcy5fZHJhZ1N0YXJ0UG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvblxuICB9XG5cbiAgcHVibGljIGNhbmNlbERyYWcoKSB7XG4gICAgdGhpcy5faXNkcmFnZ2luZyA9IGZhbHNlXG4gICAgdGhpcy5fc2V0VHJhbnNmb3JtKHRoaXMuX2RyYWdTdGFydFBvc2l0aW9uISwgdHJ1ZSwgQU5JTUFUSU9OX0RVUkFUSU9OLCBBTklNQVRJT05fRUFTSU5HKVxuXG4gICAgdGhpcy5fZHJhZ1N0YXJ0UG9zaXRpb24gPSB1bmRlZmluZWRcbiAgfVxuXG4gIHB1YmxpYyBlbmREcmFnKCkge1xuICAgIHRoaXMuX2lzZHJhZ2dpbmcgPSBmYWxzZVxuICAgIHRoaXMuX2RyYWdTdGFydFBvc2l0aW9uID0gdW5kZWZpbmVkXG4gIH1cblxuICBwdWJsaWMgbW92ZShkZWx0YTogbnVtYmVyLCBhbmltYXRlZCA9IGZhbHNlLCBkdXJhdGlvbiA9IEFOSU1BVElPTl9EVVJBVElPTiwgZWFzZSA9IEFOSU1BVElPTl9FQVNJTkcpIHtcbiAgICBkZWx0YSA9IE1hdGgudHJ1bmMoZGVsdGEpXG4gICAgaWYgKE1hdGguYWJzKGRlbHRhKSA8PSAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgdGFyZ2V0UG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvbiArPSBkZWx0YVxuICAgIHRoaXMuX3NldFRyYW5zZm9ybSh0YXJnZXRQb3NpdGlvbiwgYW5pbWF0ZWQsIGR1cmF0aW9uLCBlYXNlKVxuICB9XG5cbiAgcHVibGljIG1vdmVUbyhpbmRleDogbnVtYmVyLCBkZWx0YT86IG51bWJlciwgYW5pbWF0ZWQgPSBmYWxzZSkge1xuICAgIGxldCBuZXdQb3NpdGlvbiA9IDBcbiAgICBpZiAoIWRlbHRhKSB7XG4gICAgICBuZXdQb3NpdGlvbiA9IHRoaXMuX2dldFdyYXBwZXJTbGlkZVBvc2l0aW9uKGluZGV4KVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdQb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uICs9IGRlbHRhXG4gICAgfVxuXG4gICAgdGhpcy5faW5kZXggPSBpbmRleFxuICAgIHRoaXMuX3NldFRyYW5zZm9ybShuZXdQb3NpdGlvbiwgYW5pbWF0ZWQpXG4gIH1cblxuICBwdWJsaWMgYWRkU2xpZGUoc2xpZGU6IEhUTUxFbGVtZW50LCBwb3NpdGlvbjogbnVtYmVyKSB7XG4gICAgaWYgKCFzbGlkZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFkZCBhbiB1bmRlZmluZWQgc2xpZGVcIilcbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gIT09IC0xICYmIHBvc2l0aW9uICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFyZ3VtZW50IG91dCBvZiByYW5nZSwgJ3Bvc2l0aW9uJyBtdXN0IGJlIGVpdGhlciAxIG9yIC0xLiBWYWx1ZSAke3Bvc2l0aW9ufWApXG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uID4gMCkge1xuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuYXBwZW5kQ2hpbGQoc2xpZGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50Lmluc2VydEJlZm9yZShzbGlkZSwgdGhpcy5fd3JhcHBlckVsZW1lbnQuY2hpbGRyZW5bMF0pXG4gICAgICB0aGlzLl9pbmRleCsrXG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgbGV0IHdpZHRoID0gc2xpZGUub2Zmc2V0V2lkdGhcblxuICAgICAgbGV0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoc2xpZGUpXG4gICAgICBsZXQgbWFyZ2luTGVmdCA9IHN0eWxlID8gcGFyc2VJbnQoc3R5bGUubWFyZ2luTGVmdCEsIDEwKSA6IDBcbiAgICAgIGxldCBtYXJnaW5SaWdodCA9IHN0eWxlID8gcGFyc2VJbnQoc3R5bGUubWFyZ2luUmlnaHQhLCAxMCkgOiAwXG5cbiAgICAgIHRoaXMubW92ZSgtKHdpZHRoICsgbWFyZ2luTGVmdCArIG1hcmdpblJpZ2h0KSlcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVtb3ZlU2xpZGUoaW5kZXg6IG51bWJlcikge1xuICAgIGNvbnN0IHNsaWRlID0gdGhpcy5fZ2V0U2xpZGUoaW5kZXgpXG4gICAgbGV0IHdpZHRoID0gc2xpZGUub2Zmc2V0V2lkdGhcblxuICAgIGlmIChpbmRleCA8PSB0aGlzLl9pbmRleCkge1xuICAgICAgd2lkdGggKj0gLTFcbiAgICAgIHRoaXMuX2luZGV4LS1cbiAgICB9XG5cbiAgICByZW1vdmUoc2xpZGUpXG5cbiAgICBpZiAod2lkdGggPCAwKSB7XG4gICAgICB0aGlzLm1vdmUoLXdpZHRoKVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXRTbGlkZURlbHRhKGluZGV4OiBudW1iZXIpIHtcbiAgICBsZXQgY3VycmVudFBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb25cbiAgICBpZiAodGhpcy5faXNkcmFnZ2luZyA9PT0gdHJ1ZSkge1xuICAgICAgY3VycmVudFBvc2l0aW9uID0gdGhpcy5fZHJhZ1N0YXJ0UG9zaXRpb24hIC0gdGhpcy5fcG9zaXRpb25cbiAgICB9XG5cbiAgICBjb25zdCBuZXdQb3NpdGlvbiA9IHRoaXMuX2dldFdyYXBwZXJTbGlkZVBvc2l0aW9uKGluZGV4KVxuICAgIHJldHVybiBuZXdQb3NpdGlvbiAtIGN1cnJlbnRQb3NpdGlvblxuICB9XG5cbiAgcHVibGljIGdldFNsaWRlUHJvcGVydGllcyhpbmRleDogbnVtYmVyLCBkZWx0YSA9IDApOiBTbGlkZVByb3BlcnRpZXMge1xuICAgIGxldCBjdXJyZW50T2Zmc2V0ID0gdGhpcy5fYXJlYU9mZnNldCEgKyB0aGlzLl9wb3NpdGlvbiArIGRlbHRhXG4gICAgbGV0IGN1cnJlbnRMZWZ0ID0gY3VycmVudE9mZnNldFxuICAgIGxldCBjdXJyZW50UmlnaHQgPSBjdXJyZW50T2Zmc2V0XG4gICAgbGV0IFsgY3VycmVudE1hcmdpbkxlZnQsIGN1cnJlbnRNYXJnaW5SaWdodCBdID0gWyAwLCAwIF1cblxuICAgIGxldCBzbGlkZSA9IHRoaXMuX2dldFNsaWRlKGluZGV4KVxuICAgIGxldCBzbGlkZUluZGV4ID0gcGFyc2VJbnQoc2xpZGUuZ2V0QXR0cmlidXRlKEFUVFJJQlVURV9JTkRFWCkhLCAxMClcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGluZGV4OyBpKyspIHtcbiAgICAgIHNsaWRlID0gdGhpcy5fZ2V0U2xpZGUoaSlcbiAgICAgIGxldCBzbGlkZVN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoc2xpZGUpXG5cbiAgICAgIGN1cnJlbnRNYXJnaW5MZWZ0ID0gcGFyc2VJbnQoc2xpZGVTdHlsZS5tYXJnaW5MZWZ0ISwgMTApXG4gICAgICBjdXJyZW50TWFyZ2luUmlnaHQgPSBwYXJzZUludChzbGlkZVN0eWxlLm1hcmdpblJpZ2h0ISwgMTApXG5cbiAgICAgIGN1cnJlbnRPZmZzZXQgKz0gY3VycmVudE1hcmdpbkxlZnRcbiAgICAgIGN1cnJlbnRMZWZ0ID0gY3VycmVudE9mZnNldFxuICAgICAgY3VycmVudFJpZ2h0ID0gY3VycmVudExlZnQgKyBzbGlkZS5vZmZzZXRXaWR0aFxuXG4gICAgICBpZiAoaSA8IGluZGV4KSB7XG4gICAgICAgIGN1cnJlbnRPZmZzZXQgPSBjdXJyZW50UmlnaHQgKyBjdXJyZW50TWFyZ2luUmlnaHRcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgdmlzaWJsZSA9IGZhbHNlXG4gICAgaWYgKChjdXJyZW50TGVmdCA+IHRoaXMuX2NvbnRhaW5lck1pbiAmJiBjdXJyZW50TGVmdCA8IHRoaXMuX2NvbnRhaW5lck1heCkgfHxcbiAgICAgIChjdXJyZW50UmlnaHQgPiB0aGlzLl9jb250YWluZXJNaW4gJiYgY3VycmVudFJpZ2h0IDwgdGhpcy5fY29udGFpbmVyTWF4KSkge1xuICAgICAgdmlzaWJsZSA9IHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmlzaWJsZSxcbiAgICAgIGluZGV4OiBzbGlkZUluZGV4LFxuICAgICAgbGVmdDogY3VycmVudExlZnQsXG4gICAgICByaWdodDogY3VycmVudFJpZ2h0LFxuICAgICAgd2lkdGg6IGN1cnJlbnRSaWdodCAtIGN1cnJlbnRMZWZ0LFxuICAgICAgbWFyZ2luTGVmdDogY3VycmVudE1hcmdpbkxlZnQsXG4gICAgICBtYXJnaW5SaWdodDogY3VycmVudE1hcmdpblJpZ2h0XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldFJlbW92YWJsZVNsaWRlcyhkZWx0YTogbnVtYmVyKSB7XG4gICAgbGV0IHNsaWRlcyA9IFtdXG4gICAgbGV0IGZpcnN0OiBTbGlkZVByb3BlcnRpZXMgfCB1bmRlZmluZWRcbiAgICBsZXQgbGFzdDogU2xpZGVQcm9wZXJ0aWVzIHwgdW5kZWZpbmVkXG5cbiAgICBsZXQgaW5kZXggPSB0aGlzLl93cmFwcGVyRWxlbWVudC5jaGlsZHJlbi5sZW5ndGhcbiAgICB3aGlsZSAoaW5kZXggPiAwKSB7XG4gICAgICBpbmRleC0tXG5cbiAgICAgIGxldCBwcm9wc05vdyA9IHRoaXMuZ2V0U2xpZGVQcm9wZXJ0aWVzKGluZGV4KVxuICAgICAgbGV0IHByb3BzTmV3ID0gdGhpcy5nZXRTbGlkZVByb3BlcnRpZXMoaW5kZXgsIGRlbHRhKVxuXG4gICAgICBpZiAoaW5kZXggPT09IHRoaXMuX3dyYXBwZXJFbGVtZW50LmNoaWxkcmVuLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgbGFzdCA9IHByb3BzTmV3XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICBmaXJzdCA9IHByb3BzTmV3XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wc05vdy52aXNpYmxlID09PSBmYWxzZSAmJiBwcm9wc05ldy52aXNpYmxlID09PSBmYWxzZSAmJlxuICAgICAgICBpbmRleCAhPT0gdGhpcy5faW5kZXggJiYgdGhpcy5faXNkcmFnZ2luZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgc2xpZGVzLnB1c2godHJ1ZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsaWRlcy5wdXNoKGZhbHNlKVxuICAgICAgfVxuICAgIH1cblxuICAgIHNsaWRlcy5yZXZlcnNlKClcblxuICAgIGxldCBmaXJzdFRvS2VlcCA9IHNsaWRlcy5pbmRleE9mKGZhbHNlKVxuICAgIGxldCBsYXN0VG9LZWVwID0gc2xpZGVzLmxhc3RJbmRleE9mKGZhbHNlKVxuXG4gICAgZm9yIChsZXQgaSA9IGZpcnN0VG9LZWVwOyBpIDwgbGFzdFRvS2VlcDsgaSsrKSB7XG4gICAgICBzbGlkZXNbaV0gPSBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzbGlkZXMsXG4gICAgICBmaXJzdDogZmlyc3QgYXMgU2xpZGVQcm9wZXJ0aWVzLFxuICAgICAgbGFzdDogbGFzdCBhcyBTbGlkZVByb3BlcnRpZXNcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0RW1wdHlTcGFjZShsZWZ0OiBudW1iZXIsIHJpZ2h0OiBudW1iZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogTWF0aC5tYXgoTWF0aC5jZWlsKGxlZnQgLSB0aGlzLl9jb250YWluZXJNaW4pLCAwKSxcbiAgICAgIHJpZ2h0OiBNYXRoLm1heChNYXRoLmNlaWwodGhpcy5fY29udGFpbmVyTWF4IC0gcmlnaHQpLCAwKVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgICh0aGlzIGFzIGFueSkuX3dyYXBwZXJFbGVtZW50ID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9zbGlkZUFyZWFFbGVtZW50ID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9jYXJvdXNlbEVsZW1lbnQgPSBudWxsXG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGRlc3Ryb3koKSBpbnN0ZWFkLlxuICAgKiBAdG9kbyByZW1vdmUgaW4gdmVyc2lvbiAyLjAuMFxuICAgKi9cbiAgcHVibGljIGRlc3RvcnkoKSB7XG4gICAgdGhpcy5kZXN0cm95KClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZShcIi5jYXJvdXNlbFwiLCAoZSkgPT4ge1xuICAgIG5ldyBDYXJvdXNlbChlIGFzIEhUTUxFbGVtZW50KVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYXJvdXNlbFxuIiwiaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSwgcmVtb3ZlIH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCB7IGdldEF0dHJpYnV0ZVJlZmVyZW5jZSB9IGZyb20gXCIuLi9Eb21GdW5jdGlvbnNcIlxuaW1wb3J0IHsgdHJ5R2V0RGF0YSwgY3JlYXRlTGVnZW5kSXRlbSwgaXNDb2xvciwgcmVtb3ZlQWxsQ2hpbGRyZW4sIENoYXJ0RGF0YSwgQ2hhcnRBeGlzIH0gZnJvbSBcIi4vQ2hhcnRGdW5jdGlvbnNcIlxuXG5pbXBvcnQgYW5pbWUgZnJvbSBcImFuaW1lanNcIlxuXG5jb25zdCBRVUVSWV9ERVRBSUxfUklHSFQgPSBcIi5kZXRhaWwtcmlnaHRcIlxuY29uc3QgUVVFUllfREVUQUlMX0JPVFRPTSA9IFwiLmRldGFpbC1ib3R0b21cIlxuY29uc3QgUVVFUllfUFJPR1JFU1MgPSBcIi5iYXItY2hhcnRfX3Byb2dyZXNzXCJcblxuY29uc3QgQ0xBU1NfVU5MSU1JVEVEID0gXCJiYXItY2hhcnQtaG9yaXpvbnRhbC0tdW5saW1pdGVkXCJcbmNvbnN0IENMQVNTX0xJTUlURUQgPSBcImJhci1jaGFydC1ob3Jpem9udGFsLS1saW1pdGVkXCJcblxuY29uc3QgQ0xBU1NfREVUQUlMX1ZBTFVFID0gXCJ2YWx1ZVwiXG5jb25zdCBDTEFTU19ERVRBSUxfVU5JVCA9IFwidW5pdFwiXG5cbmNvbnN0IENMQVNTX0lORElDQVRPUiA9IFwiaW5kaWNhdG9yXCJcbmNvbnN0IENMQVNTX0lORElDQVRPUl9XUkFQUEVSID0gXCJpbmRpY2F0b3Itd3JhcHBlclwiXG5cbmNvbnN0IENMQVNTX1RPT0xUSVAgPSBcInRvb2x0aXBcIlxuY29uc3QgQ0xBU1NfVE9PTFRJUF9NVUxUSUxJTkUgPSBcInRvb2x0aXAtLW11bHRpbGluZVwiXG5cbmNvbnN0IEFOSU1BVElPTl9EVVJBVElPTiA9IDUwMFxuXG4vKipcbiAqIEJhciBDaGFydCBIb3Jpem9udGFsIENvbXBvbmVudC5cbiAqL1xuY2xhc3MgQmFyQ2hhcnRIb3Jpem9udGFsIGV4dGVuZHMgRG9tRWxlbWVudDxIVE1MRWxlbWVudD4ge1xuICBwcml2YXRlIF9kYXRhITogQ2hhcnREYXRhXG5cbiAgcHJpdmF0ZSBfbGVnZW5kSXRlbXM6IEhUTUxFbGVtZW50W11cbiAgcHJpdmF0ZSBfcHJvZ2Vzc1dyYXBwZXIhOiBIVE1MRWxlbWVudFxuXG4gIHByaXZhdGUgX3VuaXQhOiBzdHJpbmdcbiAgcHJpdmF0ZSBfbWF4VmFsdWUhOiBudW1iZXJcbiAgcHJpdmF0ZSBfcHJlY2lzaW9uITogbnVtYmVyXG5cbiAgcHJpdmF0ZSBfaXNVbmxpbWl0ZWQhOiBib29sZWFuXG4gIHByaXZhdGUgX2lzTGltaXRlZCE6IGJvb2xlYW5cblxuICBwcml2YXRlIF9kZXRhaWxSaWdodCE6IEhUTUxFbGVtZW50XG4gIHByaXZhdGUgX2xlZ2VuZCE6IEhUTUxFbGVtZW50XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGluaXRpYWxpemVzIHRoZSBiYXIgY2hhcnQgaG9yaXpvbnRhbCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7RG9tRWxlbWVudH0gLSByb290IGVsZW1lbnQgb2YgdGhlIGNoYXJ0LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudDogSFRNTEVsZW1lbnQsIGRhdGE/OiBDaGFydERhdGEpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSBkYXRhXG4gICAgfVxuXG4gICAgdGhpcy5fbGVnZW5kSXRlbXMgPSBbXVxuXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2luaXRpYWxpemUoKSB7XG4gICAgdGhpcy5fdW5pdCA9IHRoaXMuZ2V0QXR0cmlidXRlKFwiZGF0YS11bml0XCIpIHx8IFwiXCJcbiAgICB0aGlzLl9tYXhWYWx1ZSA9IHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1heFwiKSEpXG4gICAgdGhpcy5fcHJlY2lzaW9uID0gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXByZWNpc2lvblwiKSEsIDEwKSB8fCAwXG5cbiAgICB0aGlzLl9pc1VubGltaXRlZCA9IHRoaXMuaGFzQ2xhc3MoQ0xBU1NfVU5MSU1JVEVEKVxuICAgIHRoaXMuX2lzTGltaXRlZCA9IHRoaXMuaGFzQ2xhc3MoQ0xBU1NfTElNSVRFRClcblxuICAgIHRoaXMuX3Byb2dlc3NXcmFwcGVyID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfUFJPR1JFU1MpISBhcyBIVE1MRWxlbWVudFxuXG4gICAgaWYgKHRoaXMuX2lzTGltaXRlZCA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5fZGV0YWlsUmlnaHQgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9ERVRBSUxfQk9UVE9NKSEgYXMgSFRNTEVsZW1lbnRcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZGV0YWlsUmlnaHQgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9ERVRBSUxfUklHSFQpISBhcyBIVE1MRWxlbWVudFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9pc1VubGltaXRlZCA9PT0gZmFsc2UgJiYgdGhpcy5faXNMaW1pdGVkID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5fbGVnZW5kID0gZ2V0QXR0cmlidXRlUmVmZXJlbmNlKHRoaXMuZWxlbWVudCwgXCJkYXRhLWxlZ2VuZFwiKSFcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2RhdGEpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSB0cnlHZXREYXRhKHRoaXMuZWxlbWVudClcbiAgICB9XG5cbiAgICB0aGlzLl9yZW5kZXIoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9yZW5kZXIoKSB7XG4gICAgbGV0IGRhdGFPbmUgPSB0aGlzLl9kYXRhWzBdXG4gICAgbGV0IGRhdGFUd28gPSB0aGlzLl9kYXRhWzFdXG5cbiAgICBsZXQgdG9vbHRpcCA9IHRoaXMuX2lzTGltaXRlZCA9PT0gZmFsc2UgPyB0aGlzLl9nZXRUb29sdGlwQ29udGVudCh0aGlzLl9kYXRhKSA6IHVuZGVmaW5lZFxuXG4gICAgbGV0IGFuaW1hdGVkVmFsdWVFbGVtZW50OiBFbGVtZW50IHwgdW5kZWZpbmVkXG5cbiAgICAvLyBDbGVhbnVwXG4gICAgcmVtb3ZlQWxsQ2hpbGRyZW4odGhpcy5fZGV0YWlsUmlnaHQpXG4gICAgcmVtb3ZlQWxsQ2hpbGRyZW4odGhpcy5fcHJvZ2Vzc1dyYXBwZXIpXG5cbiAgICAvLyBDbGVhciBvbmx5IG93biBsZWdlbmQgaXRlbXNcbiAgICBmb3IgKGxldCBpdGVtIG9mIHRoaXMuX2xlZ2VuZEl0ZW1zKSB7XG4gICAgICByZW1vdmUoaXRlbSlcbiAgICB9XG4gICAgdGhpcy5fbGVnZW5kSXRlbXMgPSBbXVxuXG4gICAgaWYgKGRhdGFPbmUpIHtcbiAgICAgIGlmICh0aGlzLl9pc1VubGltaXRlZCA9PT0gZmFsc2UgfHwgKHRoaXMuX2lzVW5saW1pdGVkID09PSB0cnVlICYmICFkYXRhVHdvKSkge1xuXG4gICAgICAgIGxldCB2YWxFbGVtZW50ID0gYW5pbWF0ZWRWYWx1ZUVsZW1lbnQgPSB0aGlzLl9jcmVhdGVWYWx1ZUVsZW1lbnQoZGF0YU9uZSlcbiAgICAgICAgdGhpcy5fZGV0YWlsUmlnaHQuYXBwZW5kQ2hpbGQodmFsRWxlbWVudClcblxuICAgICAgICBpZiAodGhpcy5faXNMaW1pdGVkID09PSBmYWxzZSkge1xuICAgICAgICAgIGNvbnN0IHNlcGFyYXRvckVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgICAgICAgLmFkZENsYXNzKENMQVNTX0RFVEFJTF9VTklUKVxuICAgICAgICAgICAgLmVsZW1lbnQgYXMgSFRNTEVsZW1lbnRcbiAgICAgICAgICBzZXBhcmF0b3JFbGVtZW50LmlubmVyVGV4dCA9IGAgJHt0aGlzLl91bml0fWBcblxuICAgICAgICAgIHRoaXMuX2RldGFpbFJpZ2h0LmFwcGVuZENoaWxkKHNlcGFyYXRvckVsZW1lbnQpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQWRkIHRoZSBpbmRpY2F0b3JcbiAgICAgIGxldCBpbmRpY2F0b3IgPSB0aGlzLl9hZGRJbmRpY2F0b3IoZGF0YU9uZSwgdG9vbHRpcClcbiAgICAgIHRoaXMuX2FuaW1hdGVJbmRpY2F0b3IoaW5kaWNhdG9yLCAwKVxuXG4gICAgICAvLyBBbmltYXRlIHRoZSB2YWx1ZSBpZiByZXF1aXJlZFxuICAgICAgaWYgKGFuaW1hdGVkVmFsdWVFbGVtZW50ICYmIHRoaXMuX2lzTGltaXRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9hbmltYXRlVmFsdWVFbGVtZW50KGFuaW1hdGVkVmFsdWVFbGVtZW50IGFzIEhUTUxFbGVtZW50LCBkYXRhT25lLnZhbHVlKVxuICAgICAgfVxuXG4gICAgICAvLyBBZGQgdGhlIGxlZ2VuZFxuICAgICAgaWYgKHRoaXMuX2xlZ2VuZCkge1xuICAgICAgICBjb25zdCBsZWdlbmRJdGVtID0gY3JlYXRlTGVnZW5kSXRlbShkYXRhT25lKVxuICAgICAgICB0aGlzLl9sZWdlbmQuYXBwZW5kQ2hpbGQobGVnZW5kSXRlbSlcbiAgICAgICAgdGhpcy5fbGVnZW5kSXRlbXMucHVzaChsZWdlbmRJdGVtKVxuXG4gICAgICAgIHRoaXMuX2FuaW1hdGVMZWdlbmQobGVnZW5kSXRlbSwgMClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGF0YVR3bykge1xuICAgICAgbGV0IHZhbEVsZW1lbnQgPSB0aGlzLl9jcmVhdGVWYWx1ZUVsZW1lbnQoZGF0YVR3bylcblxuICAgICAgbGV0IHVuaXRFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgLmFkZENsYXNzKENMQVNTX0RFVEFJTF9VTklUKVxuICAgICAgICAuZWxlbWVudCBhcyBIVE1MRWxlbWVudFxuICAgICAgdW5pdEVsZW1lbnQuaW5uZXJUZXh0ID0gYCAke3RoaXMuX3VuaXR9YFxuXG4gICAgICB0aGlzLl9kZXRhaWxSaWdodC5hcHBlbmRDaGlsZCh2YWxFbGVtZW50KVxuICAgICAgdGhpcy5fZGV0YWlsUmlnaHQuYXBwZW5kQ2hpbGQodW5pdEVsZW1lbnQpXG5cbiAgICAgIC8vIEFkZCB0aGUgaW5kaWNhdG9yXG4gICAgICBsZXQgaW5kaWNhdG9yID0gdGhpcy5fYWRkSW5kaWNhdG9yKGRhdGFUd28sIHRvb2x0aXApXG4gICAgICB0aGlzLl9hbmltYXRlSW5kaWNhdG9yKGluZGljYXRvciwgQU5JTUFUSU9OX0RVUkFUSU9OKVxuXG4gICAgICAvLyBBZGQgdGhlIGxlZ2VuZFxuICAgICAgaWYgKHRoaXMuX2xlZ2VuZCkge1xuICAgICAgICBjb25zdCBsZWdlbmRJdGVtID0gY3JlYXRlTGVnZW5kSXRlbShkYXRhVHdvKVxuICAgICAgICB0aGlzLl9sZWdlbmQuYXBwZW5kQ2hpbGQobGVnZW5kSXRlbSlcbiAgICAgICAgdGhpcy5fbGVnZW5kSXRlbXMucHVzaChsZWdlbmRJdGVtKVxuXG4gICAgICAgIHRoaXMuX2FuaW1hdGVMZWdlbmQobGVnZW5kSXRlbSwgQU5JTUFUSU9OX0RVUkFUSU9OKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9pc0xpbWl0ZWQgPT09IHRydWUpIHtcbiAgICAgIGxldCB2YWxFbGVtZW50ID0gdGhpcy5fY3JlYXRlVmFsdWVFbGVtZW50KHsgdmFsdWU6IHRoaXMuX21heFZhbHVlIH0pXG5cbiAgICAgIGxldCB1bml0RWxlbWVudCA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19ERVRBSUxfVU5JVClcbiAgICAgICAgLmVsZW1lbnQgYXMgSFRNTEVsZW1lbnRcbiAgICAgIHVuaXRFbGVtZW50LmlubmVyVGV4dCA9IGAgJHt0aGlzLl91bml0fWBcblxuICAgICAgdGhpcy5fZGV0YWlsUmlnaHQuYXBwZW5kQ2hpbGQodmFsRWxlbWVudClcbiAgICAgIHRoaXMuX2RldGFpbFJpZ2h0LmFwcGVuZENoaWxkKHVuaXRFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2FuaW1hdGVWYWx1ZUVsZW1lbnQoYW5pbWF0ZWRWYWx1ZUVsZW1lbnQ6IEhUTUxFbGVtZW50LCB0b1ZhbHVlOiBudW1iZXIpIHtcbiAgICBsZXQgY291bnRlciA9IHsgdmFyOiAwIH1cbiAgICBhbmltZSh7XG4gICAgICB0YXJnZXRzOiBjb3VudGVyLFxuICAgICAgdmFyOiB0b1ZhbHVlLFxuICAgICAgZHVyYXRpb246IEFOSU1BVElPTl9EVVJBVElPTixcbiAgICAgIGVhc2luZzogXCJlYXNlT3V0UXVpbnRcIixcbiAgICAgIHJvdW5kOiAxLFxuICAgICAgdXBkYXRlOiAoKSA9PiB7XG4gICAgICAgIGFuaW1hdGVkVmFsdWVFbGVtZW50IS5pbm5lclRleHQgPSBgJHtjb3VudGVyLnZhcn1gXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHByaXZhdGUgX2FuaW1hdGVJbmRpY2F0b3IoaW5kaWNhdG9yV3JhcHBlcjogSFRNTEVsZW1lbnQsIGFuaW1hdGlvbk9mZnNldDogbnVtYmVyKSB7XG4gICAgY29uc3QgaW5kaWNhdG9yID0gaW5kaWNhdG9yV3JhcHBlci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiaW5kaWNhdG9yXCIpWzBdIGFzIEhUTUxFbGVtZW50XG4gICAgY29uc3QgaW5kaWNhdG9yV2lkdGggPSBpbmRpY2F0b3Iuc2Nyb2xsV2lkdGhcbiAgICBpbmRpY2F0b3Iuc3R5bGUud2lkdGggPSBcIjBweFwiXG5cbiAgICBhbmltZSh7XG4gICAgICB0YXJnZXRzOiBpbmRpY2F0b3IsXG4gICAgICBkdXJhdGlvbjogQU5JTUFUSU9OX0RVUkFUSU9OLFxuICAgICAgd2lkdGg6IGluZGljYXRvcldpZHRoICsgXCJweFwiLFxuICAgICAgZWFzaW5nOiBcImVhc2VJbk91dFF1aW50XCIsXG4gICAgICBkZWxheTogYW5pbWF0aW9uT2Zmc2V0LFxuICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgaW5kaWNhdG9yLnN0eWxlLndpZHRoID0gbnVsbFxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBwcml2YXRlIF9hbmltYXRlTGVnZW5kKGxlZ2VuZEl0ZW06IEhUTUxFbGVtZW50LCBhbmltYXRpb25PZmZzZXQ6IG51bWJlcikge1xuICAgIGxlZ2VuZEl0ZW0uc3R5bGUub3BhY2l0eSA9IFwiMFwiXG4gICAgYW5pbWUoe1xuICAgICAgdGFyZ2V0czogbGVnZW5kSXRlbSxcbiAgICAgIGR1cmF0aW9uOiBBTklNQVRJT05fRFVSQVRJT04sXG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgZWFzaW5nOiBcImVhc2VJbk91dFF1aW50XCIsXG4gICAgICBkZWxheTogYW5pbWF0aW9uT2Zmc2V0LFxuICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgbGVnZW5kSXRlbS5zdHlsZS5vcGFjaXR5ID0gbnVsbFxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBwcm90ZWN0ZWQgX2NyZWF0ZVZhbHVlRWxlbWVudChkYXRhOiB7IHZhbHVlOiBudW1iZXIgfCBzdHJpbmcgfSkge1xuICAgIGxldCB1bmxpbWl0ZWRQcmVmaXggPSBcIlwiXG5cbiAgICBpZiAodGhpcy5faXNVbmxpbWl0ZWQgPT09IHRydWUpIHtcbiAgICAgIHVubGltaXRlZFByZWZpeCA9IFwiK1wiXG4gICAgfVxuXG4gICAgbGV0IHZhbHVlOiBzdHJpbmcgfCBudW1iZXIgPSBwYXJzZUZsb2F0KChkYXRhLnZhbHVlIGFzIHN0cmluZykpXG5cbiAgICBpZiAodmFsdWUgPD0gMCkge1xuICAgICAgaWYgKHRoaXMuX3ByZWNpc2lvbiA9PT0gMCkge1xuICAgICAgICB2YWx1ZSA9IFwiMFwiXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IFwiLlwiXG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9wcmVjaXNpb247IGkrKykge1xuICAgICAgICAgIHZhbHVlICs9IFwiMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSB2YWx1ZS50b0ZpeGVkKHRoaXMuX3ByZWNpc2lvbilcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZUVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKENMQVNTX0RFVEFJTF9WQUxVRSlcbiAgICAgIC5lbGVtZW50IGFzIEhUTUxFbGVtZW50XG4gICAgdmFsdWVFbGVtZW50LmlubmVyVGV4dCA9IGAke3VubGltaXRlZFByZWZpeH0ke3ZhbHVlfWBcbiAgICByZXR1cm4gdmFsdWVFbGVtZW50XG4gIH1cblxuICBwcm90ZWN0ZWQgX2FkZEluZGljYXRvcihkYXRhOiBDaGFydEF4aXMsIHRvb2x0aXA/OiBzdHJpbmcpIHtcbiAgICBsZXQgd2lkdGggPSAoKDEwMC4wIC8gdGhpcy5fbWF4VmFsdWUpICogZGF0YS52YWx1ZSlcblxuICAgIGxldCBpbmRpY2F0b3IgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKENMQVNTX0lORElDQVRPUilcblxuICAgIGlmIChpc0NvbG9yKGRhdGEuY29sb3IpID09PSB0cnVlKSB7XG4gICAgICBpbmRpY2F0b3Iuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgYGJhY2tncm91bmQtY29sb3I6ICR7ZGF0YS5jb2xvcn07YClcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kaWNhdG9yLmFkZENsYXNzKGRhdGEuY29sb3IpXG4gICAgfVxuXG4gICAgbGV0IGluZGljYXRvcldyYXBwZXIgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKENMQVNTX0lORElDQVRPUl9XUkFQUEVSKVxuICAgICAgLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIGB3aWR0aDogJHt3aWR0aH0lYClcbiAgICAgIC5hcHBlbmRDaGlsZChpbmRpY2F0b3IpXG4gICAgICAuc2V0QXR0cmlidXRlKFwib25jbGlja1wiLCBcInZvaWQoMClcIilcblxuICAgIGlmICh0b29sdGlwICYmIHRvb2x0aXAgIT09IFwiXCIpIHtcbiAgICAgIGluZGljYXRvcldyYXBwZXJcbiAgICAgICAgLmFkZENsYXNzKENMQVNTX1RPT0xUSVApXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19UT09MVElQX01VTFRJTElORSlcbiAgICAgICAgLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdG9vbHRpcClcbiAgICB9XG5cbiAgICB0aGlzLl9wcm9nZXNzV3JhcHBlci5hcHBlbmRDaGlsZChpbmRpY2F0b3JXcmFwcGVyLmVsZW1lbnQpXG4gICAgcmV0dXJuIGluZGljYXRvcldyYXBwZXIuZWxlbWVudCBhcyBIVE1MRWxlbWVudFxuICB9XG5cbiAgcHJvdGVjdGVkIF9nZXRUb29sdGlwQ29udGVudChkYXRhTGlzdDogQ2hhcnREYXRhKSB7XG4gICAgbGV0IHRvb2x0aXAgPSBcIlwiXG4gICAgZm9yIChsZXQgZGF0YSBvZiBkYXRhTGlzdCkge1xuICAgICAgdG9vbHRpcCArPSBgJHtkYXRhLnRpdGxlfTogJHtkYXRhLnZhbHVlfSAke3RoaXMuX3VuaXR9XFxuYFxuICAgIH1cblxuICAgIHJldHVybiB0b29sdGlwLnRyaW0oKVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGJhciBjaGFydCB3aXRoIHRoZSBzcGVjaWZpZWQgZGF0YSBkZWZpbml0aW9ucy5cbiAgICogQHBhcmFtIHtBcnJheX0gLSBiYXIgY2hhcnQgZGF0YSBkZWZpbml0aW9ucy5cbiAgICovXG4gIHB1YmxpYyB1cGRhdGUoZGF0YTogQ2hhcnREYXRhKSB7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSBkYXRhXG4gICAgfVxuXG4gICAgdGhpcy5fcmVuZGVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBldmVudCBoYW5kbGVycyBhbmQgY2xlYXJzIHJlZmVyZW5jZXMuXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICAodGhpcyBhcyBhbnkpLl9kYXRhID0gdW5kZWZpbmVkXG5cbiAgICByZW1vdmVBbGxDaGlsZHJlbih0aGlzLl9kZXRhaWxSaWdodClcbiAgICByZW1vdmVBbGxDaGlsZHJlbih0aGlzLl9wcm9nZXNzV3JhcHBlcik7XG5cbiAgICAodGhpcyBhcyBhbnkpLl9kZXRhaWxSaWdodCA9IHVuZGVmaW5lZDtcbiAgICAodGhpcyBhcyBhbnkpLl9wcm9nZXNzV3JhcHBlciA9IHVuZGVmaW5lZFxuXG4gICAgZm9yIChsZXQgaXRlbSBvZiB0aGlzLl9sZWdlbmRJdGVtcykge1xuICAgICAgcmVtb3ZlKGl0ZW0pXG4gICAgfVxuXG4gICAgKHRoaXMgYXMgYW55KS5fbGVnZW5kSXRlbXMgPSB1bmRlZmluZWQ7XG4gICAgKHRoaXMgYXMgYW55KS5fbGVnZW5kID0gdW5kZWZpbmVkXG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGRlc3Ryb3koKSBpbnN0ZWFkLlxuICAgKiBAdG9kbyByZW1vdmUgaW4gdmVyc2lvbiAyLjAuMFxuICAgKi9cbiAgcHVibGljIGRlc3RvcnkoKSB7XG4gICAgdGhpcy5kZXN0cm95KClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZTxIVE1MRWxlbWVudD4oXCIuYmFyLWNoYXJ0LWhvcml6b250YWxcIiwgKGUpID0+IHtcbiAgICBuZXcgQmFyQ2hhcnRIb3Jpem9udGFsKGUpXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhckNoYXJ0SG9yaXpvbnRhbFxuIiwiaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgeyB0ZXh0IH0gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5pbXBvcnQgeyBjcmVhdGVMZWdlbmRJdGVtLCBpc0NvbG9yLCByZW1vdmVBbGxDaGlsZHJlbiwgQ2hhcnRMYWJlbCB9IGZyb20gXCIuL0NoYXJ0RnVuY3Rpb25zXCJcblxuaW1wb3J0IGFuaW1lIGZyb20gXCJhbmltZWpzXCJcblxuY29uc3QgUVVFUllfREFUQV9DQVRFR09SSUVTID0gXCIuanMtZGF0YS1saXN0IC5qcy1jYXRlZ29yeVwiXG5jb25zdCBRVUVSWV9EQVRBX0lURU1TID0gXCIuanMtZGF0YS1saXN0IC5qcy1kYXRhXCJcbmNvbnN0IFFVRVJZX0NIQVJUID0gXCIuanMtY2hhcnRcIlxuY29uc3QgUVVFUllfTEVHRU5EID0gXCIuYmFyLWNoYXJ0X19sZWdlbmRcIlxuXG5jb25zdCBDTEFTU19JTkRJQ0FUT1IgPSBcImluZGljYXRvclwiXG5jb25zdCBDTEFTU19MQUJFTF9YID0gXCJheGlzLXgtbGFiZWxcIlxuY29uc3QgQ0xBU1NfSU5ESUNBVE9SX1dSQVBQRVIgPSBcImluZGljYXRvci13cmFwcGVyXCJcbmNvbnN0IENMQVNTX0lORElDQVRPUl9JTk5FUl9XUkFQUEVSID0gXCJpbmRpY2F0b3Itd3JhcHBlci1pbm5lclwiXG5jb25zdCBDTEFTU19JTkRJQ0FUT1JfRU1QVFkgPSBcImVtcHR5XCJcblxuY29uc3QgQ0xBU1NfVE9PTFRJUCA9IFwidG9vbHRpcFwiXG5jb25zdCBDTEFTU19UT09MVElQX0xFRlQgPSBcInRvb2x0aXAtLWxlZnRcIlxuY29uc3QgQ0xBU1NfVE9PTFRJUF9SSUdIVCA9IFwidG9vbHRpcC0tcmlnaHRcIlxuY29uc3QgQ0xBU1NfVE9PTFRJUF9NVUxUSUxJTkUgPSBcInRvb2x0aXAtLW11bHRpbGluZVwiXG5cbmNvbnN0IEFOSU1BVElPTl9EVVJBVElPTiA9IDUwMFxuXG5leHBvcnQgaW50ZXJmYWNlIENhdGVnb3J5IGV4dGVuZHMgQ2hhcnRMYWJlbCB7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0YUVudHJ5IHtcbiAgdGl0bGU6IHN0cmluZ1xuICBjbGFzczogc3RyaW5nXG4gIHZhbHVlczogbnVtYmVyW11cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaGFydERhdGEge1xuICBjYXRlZ29yaWVzOiBDYXRlZ29yeVtdXG4gIGl0ZW1zOiBEYXRhRW50cnlbXVxufVxuXG4vKipcbiAqIEJhciBDaGFydCBIb3Jpem9udGFsIENvbXBvbmVudC5cbiAqL1xuY2xhc3MgQmFyQ2hhcnRWZXJ0aWNhbCBleHRlbmRzIERvbUVsZW1lbnQ8SFRNTEVsZW1lbnQ+IHtcbiAgcHJpdmF0ZSBfZGF0YSE6IENoYXJ0RGF0YVxuXG4gIHByaXZhdGUgX3VuaXQhOiBzdHJpbmdcbiAgcHJpdmF0ZSBfbWF4VmFsdWUhOiBudW1iZXJcblxuICBwcml2YXRlIF9jaGFydCE6IEhUTUxFbGVtZW50XG4gIHByaXZhdGUgX2xlZ2VuZCE6IEhUTUxFbGVtZW50XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGluaXRpYWxpemVzIHRoZSBiYXIgY2hhcnQgaG9yaXpvbnRhbCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSBlbGVtZW50IC0gcm9vdCBlbGVtZW50IG9mIHRoZSBjaGFydC5cbiAgICogQHBhcmFtIGRhdGEgLSBkYXRhIGZvciB0aGUgY2hhcnQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBIVE1MRWxlbWVudCwgZGF0YT86IENoYXJ0RGF0YSkge1xuICAgIHN1cGVyKGVsZW1lbnQpXG5cbiAgICBpZiAoZGF0YSkge1xuICAgICAgdGhpcy5fZGF0YSA9IGRhdGFcbiAgICB9XG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLl91bml0ID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXVuaXRcIikgfHwgXCJcIlxuXG4gICAgdGhpcy5fbWF4VmFsdWUgPSBwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKFwiZGF0YS1tYXhcIikhKSB8fCAxMDBcblxuICAgIHRoaXMuX2NoYXJ0ID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfQ0hBUlQpISBhcyBIVE1MRWxlbWVudFxuICAgIHRoaXMuX2xlZ2VuZCA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX0xFR0VORCkhIGFzIEhUTUxFbGVtZW50XG5cbiAgICBpZiAoIXRoaXMuX2RhdGEpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSB0aGlzLl90cnlHZXREYXRhKHRoaXMuZWxlbWVudClcbiAgICB9XG5cbiAgICB0aGlzLl9yZW5kZXIoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF90cnlHZXREYXRhKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogQ2hhcnREYXRhIHtcbiAgICBjb25zdCBkYXRhOiBDaGFydERhdGEgPSB7XG4gICAgICBjYXRlZ29yaWVzOiBbXSxcbiAgICAgIGl0ZW1zOiBbXVxuICAgIH1cblxuICAgIGNvbnN0IGNhdGVnb3JpZXMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoUVVFUllfREFUQV9DQVRFR09SSUVTKVxuICAgIGNvbnN0IGl0ZW1zID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFFVRVJZX0RBVEFfSVRFTVMpXG5cbiAgICBmb3IgKGNvbnN0IGNhdGVnb3J5IG9mIGNhdGVnb3JpZXMpIHtcbiAgICAgIGRhdGEuY2F0ZWdvcmllcy5wdXNoKFxuICAgICAgICB7XG4gICAgICAgICAgdGl0bGU6IHRleHQoY2F0ZWdvcnkpLFxuICAgICAgICAgIGNvbG9yOiBjYXRlZ29yeS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbG9yXCIpIVxuICAgICAgICB9XG4gICAgICApXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICBjb25zdCBkYXRhRW50eTogRGF0YUVudHJ5ID0ge1xuICAgICAgICB0aXRsZTogdGV4dChpdGVtKSxcbiAgICAgICAgY2xhc3M6IGl0ZW0uZ2V0QXR0cmlidXRlKFwiZGF0YS1jbGFzc1wiKSEsXG4gICAgICAgIHZhbHVlczogW11cbiAgICAgIH1cblxuICAgICAgY29uc3QgdmFscyA9IGl0ZW0uZ2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiKVxuICAgICAgaWYgKHZhbHMpIHtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdmFscy5zcGxpdChcIixcIikpIHtcbiAgICAgICAgICBkYXRhRW50eS52YWx1ZXMucHVzaChwYXJzZUZsb2F0KHZhbCkpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZGF0YS5pdGVtcy5wdXNoKGRhdGFFbnR5KVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhXG4gIH1cblxuICBwcm90ZWN0ZWQgX2dldFRvb2x0aXBDb250ZW50KGVudHJ5OiBEYXRhRW50cnksIGNhdGVnb3JpZXM6IENhdGVnb3J5W10pIHtcbiAgICBsZXQgdG9vbHRpcCA9IFwiXCJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVudHJ5LnZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdG9vbHRpcCArPSBgJHtjYXRlZ29yaWVzW2ldLnRpdGxlfTogJHtlbnRyeS52YWx1ZXNbaV19ICR7dGhpcy5fdW5pdH1cXG5gXG4gICAgfVxuXG4gICAgcmV0dXJuIHRvb2x0aXAudHJpbSgpXG4gIH1cblxuICBwcm90ZWN0ZWQgX3JlbmRlcigpIHtcbiAgICBpZiAodGhpcy5fbGVnZW5kKSB7XG4gICAgICByZW1vdmVBbGxDaGlsZHJlbih0aGlzLl9sZWdlbmQpXG5cbiAgICAgIGZvciAoY29uc3QgY2F0ZWdvcnkgb2YgdGhpcy5fZGF0YS5jYXRlZ29yaWVzKSB7XG4gICAgICAgIGNvbnN0IGxlZ2VuZEl0ZW0gPSBjcmVhdGVMZWdlbmRJdGVtKGNhdGVnb3J5KVxuICAgICAgICB0aGlzLl9sZWdlbmQuYXBwZW5kQ2hpbGQobGVnZW5kSXRlbSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZW1vdmVBbGxDaGlsZHJlbih0aGlzLl9jaGFydClcblxuICAgIGNvbnN0IGFuaW1hdGlvblN0YWdlczogRWxlbWVudFtdW10gPSBbXVxuXG4gICAgbGV0IGxlZnRTaWRlSXRlbXMgPSBNYXRoLmZsb29yKHRoaXMuX2RhdGEuaXRlbXMubGVuZ3RoIC8gMilcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5fZGF0YS5pdGVtcykge1xuICAgICAgbGV0IGVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChcImxpXCIpXG5cbiAgICAgIGlmIChpdGVtLmNsYXNzKSB7XG4gICAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoaXRlbS5jbGFzcylcbiAgICAgIH1cblxuICAgICAgY29uc3QgbGlzdEVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChcInVsXCIpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19JTkRJQ0FUT1JfV1JBUFBFUilcblxuICAgICAgY29uc3Qgd3JhcHBlciA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19JTkRJQ0FUT1JfSU5ORVJfV1JBUFBFUilcbiAgICAgIGxpc3RFbGVtZW50LmFwcGVuZENoaWxkKHdyYXBwZXIpXG5cbiAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQobGlzdEVsZW1lbnQpXG5cbiAgICAgIGNvbnN0IHRvb2x0aXAgPSB0aGlzLl9nZXRUb29sdGlwQ29udGVudChpdGVtLCB0aGlzLl9kYXRhLmNhdGVnb3JpZXMpXG4gICAgICBpZiAodG9vbHRpcCkge1xuICAgICAgICB3cmFwcGVyXG4gICAgICAgICAgLmFkZENsYXNzKENMQVNTX1RPT0xUSVApXG4gICAgICAgICAgLmFkZENsYXNzKGxlZnRTaWRlSXRlbXMgPD0gMCA/IENMQVNTX1RPT0xUSVBfTEVGVCA6IENMQVNTX1RPT0xUSVBfUklHSFQpXG4gICAgICAgICAgLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdG9vbHRpcClcblxuICAgICAgICBpZiAoaXRlbS52YWx1ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHdyYXBwZXIuYWRkQ2xhc3MoQ0xBU1NfVE9PTFRJUF9NVUxUSUxJTkUpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtLnZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBoZWlnaHQgPSAodGhpcy5fY2hhcnQub2Zmc2V0SGVpZ2h0IC8gdGhpcy5fbWF4VmFsdWUpICogaXRlbS52YWx1ZXNbaV1cblxuICAgICAgICBjb25zdCBpbmRpY2F0b3IgPSBuZXcgRG9tRWxlbWVudChcImxpXCIpXG4gICAgICAgICAgLmFkZENsYXNzKENMQVNTX0lORElDQVRPUilcbiAgICAgICAgICAuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgYGhlaWdodDogJHtoZWlnaHR9cHg7YClcblxuICAgICAgICBpZiAoaGVpZ2h0ID4gMCkge1xuICAgICAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5fZGF0YS5jYXRlZ29yaWVzW2ldLmNvbG9yXG4gICAgICAgICAgaWYgKGlzQ29sb3IoY29sb3IpKSB7XG4gICAgICAgICAgICBpbmRpY2F0b3Iuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgYGJhY2tncm91bmQtY29sb3I6ICR7Y29sb3J9O2ApXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGljYXRvci5hZGRDbGFzcyhjb2xvcilcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYW5pbWF0aW9uU3RhZ2VzLmxlbmd0aCA8PSBpKSB7XG4gICAgICAgICAgICBhbmltYXRpb25TdGFnZXMucHVzaChbXSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhbmltYXRpb25TdGFnZXNbaV0ucHVzaChpbmRpY2F0b3IuZWxlbWVudClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmRpY2F0b3IuYWRkQ2xhc3MoQ0xBU1NfSU5ESUNBVE9SX0VNUFRZKVxuICAgICAgICB9XG5cbiAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChpbmRpY2F0b3IpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRpdGxlRG9tRWxlbWVudCA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19MQUJFTF9YKVxuICAgICAgY29uc3QgdGl0bGVFbGVtZW50ID0gdGl0bGVEb21FbGVtZW50LmVsZW1lbnQgYXMgSFRNTEVsZW1lbnRcbiAgICAgIHRpdGxlRWxlbWVudC5pbm5lclRleHQgPSBpdGVtLnRpdGxlXG4gICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHRpdGxlRG9tRWxlbWVudClcblxuICAgICAgdGhpcy5fY2hhcnQuYXBwZW5kQ2hpbGQoZWxlbWVudC5lbGVtZW50KVxuICAgICAgbGVmdFNpZGVJdGVtcyAtPSAxXG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbmltYXRpb25TdGFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IEFOSU1BVElPTl9EVVJBVElPTiAqIGlcbiAgICAgIHRoaXMuX2FuaW1hdGVCYXJzKGFuaW1hdGlvblN0YWdlc1tpXSBhcyBIVE1MRWxlbWVudFtdLCBvZmZzZXQpXG5cbiAgICAgIGlmICh0aGlzLl9sZWdlbmQpIHtcbiAgICAgICAgdGhpcy5fYW5pbWF0ZUxlZ2VuZCh0aGlzLl9sZWdlbmQuY2hpbGRyZW5baV0gYXMgSFRNTEVsZW1lbnQsIG9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9hbmltYXRlQmFycyhiYXJzOiBIVE1MRWxlbWVudFtdLCBhbmltYXRpb25PZmZzZXQ6IG51bWJlcikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYmFyID0gYmFyc1tpXVxuICAgICAgY29uc3QgYmFySGVpZ2h0ID0gYmFyLnN0eWxlLmhlaWdodFxuICAgICAgYmFyLnN0eWxlLmhlaWdodCA9IFwiMFwiXG4gICAgICBhbmltZSh7XG4gICAgICAgIHRhcmdldHM6IGJhcnNbaV0sXG4gICAgICAgIGhlaWdodDogYmFySGVpZ2h0LFxuICAgICAgICBlYXNpbmc6IFwiZWFzZUluT3V0UXVpbnRcIixcbiAgICAgICAgZHVyYXRpb246IEFOSU1BVElPTl9EVVJBVElPTixcbiAgICAgICAgZGVsYXk6IGFuaW1hdGlvbk9mZnNldFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9hbmltYXRlTGVnZW5kKGxlZ2VuZDogSFRNTEVsZW1lbnQsIGFuaW1hdGlvbk9mZnNldDogbnVtYmVyKSB7XG4gICAgbGVnZW5kLnN0eWxlLm9wYWNpdHkgPSBcIjBcIlxuICAgIGFuaW1lKHtcbiAgICAgIHRhcmdldHM6IGxlZ2VuZCxcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICBlYXNpbmc6IFwiZWFzZUluT3V0UXVpbnRcIixcbiAgICAgIGR1cmF0aW9uOiBBTklNQVRJT05fRFVSQVRJT04sXG4gICAgICBkZWxheTogYW5pbWF0aW9uT2Zmc2V0XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBiYXIgY2hhcnQgd2l0aCB0aGUgc3BlY2lmaWVkIGRhdGEgZGVmaW5pdGlvbnMuXG4gICAqIEBwYXJhbSB7QXJyYXl9IC0gYmFyIGNoYXJ0IGRhdGEgZGVmaW5pdGlvbnMuXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlKGRhdGE6IENoYXJ0RGF0YSkge1xuICAgIGlmIChkYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhID0gZGF0YVxuICAgIH1cblxuICAgIHRoaXMuX3JlbmRlcigpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgZXZlbnQgaGFuZGxlcnMgYW5kIGNsZWFycyByZWZlcmVuY2VzLlxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgKHRoaXMgYXMgYW55KS5fZGF0YSA9IHVuZGVmaW5lZFxuXG4gICAgaWYgKHRoaXMuX2xlZ2VuZCkge1xuICAgICAgcmVtb3ZlQWxsQ2hpbGRyZW4odGhpcy5fbGVnZW5kKTtcbiAgICAgICh0aGlzIGFzIGFueSkuX2xlZ2VuZCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgZGVzdHJveSgpIGluc3RlYWQuXG4gICAqIEB0b2RvIHJlbW92ZSBpbiB2ZXJzaW9uIDIuMC4wXG4gICAqL1xuICBwdWJsaWMgZGVzdG9yeSgpIHtcbiAgICB0aGlzLmRlc3Ryb3koKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBzZWFyY2hBbmRJbml0aWFsaXplPEhUTUxFbGVtZW50PihcIi5iYXItY2hhcnQtdmVydGljYWxcIiwgKGUpID0+IHtcbiAgICBuZXcgQmFyQ2hhcnRWZXJ0aWNhbChlKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXJDaGFydFZlcnRpY2FsXG4iLCJpbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgeyB0ZXh0IH0gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhcnRMYWJlbCB7XG4gIHRpdGxlOiBzdHJpbmdcbiAgY29sb3I6IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENoYXJ0QXhpcyBleHRlbmRzIENoYXJ0TGFiZWwge1xuICB2YWx1ZTogbnVtYmVyXG59XG5cbmV4cG9ydCB0eXBlIENoYXJ0RGF0YSA9IENoYXJ0QXhpc1tdXG5cbmNvbnN0IFFVRVJZX0RBVEEgPSBcIi5qcy1kYXRhXCJcblxuZXhwb3J0IGZ1bmN0aW9uIHRyeUdldERhdGEoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBDaGFydERhdGEge1xuICBsZXQgZGF0YSA9IFtdXG4gIGxldCBlbGVtZW50cyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChRVUVSWV9EQVRBKVxuXG4gIGZvciAobGV0IGVudHJ5IG9mIGVsZW1lbnRzKSB7XG4gICAgbGV0IHZhbHVlID0gcGFyc2VGbG9hdChlbnRyeS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpISlcbiAgICBsZXQgY29sb3IgPSBlbnRyeS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbG9yXCIpIVxuICAgIGxldCB0aXRsZSA9IHRleHQoZW50cnkpXG5cbiAgICBsZXQgaXRlbSA9IHtcbiAgICAgIHRpdGxlLFxuICAgICAgdmFsdWUsXG4gICAgICBjb2xvclxuICAgIH1cblxuICAgIGRhdGEucHVzaChpdGVtKVxuICB9XG5cbiAgcmV0dXJuIGRhdGFcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUFsbENoaWxkcmVuKG5vZGU6IE5vZGUpIHtcbiAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMZWdlbmRJdGVtKGRhdGE6IENoYXJ0TGFiZWwpIHtcbiAgY29uc3QgYnVsbGV0ID0gbmV3IERvbUVsZW1lbnQ8SFRNTFNwYW5FbGVtZW50PihcInNwYW5cIilcbiAgICAuYWRkQ2xhc3MoXCJidWxsZXRcIilcblxuICBpZiAoaXNDb2xvcihkYXRhLmNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgIGJ1bGxldC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBgYmFja2dyb3VuZC1jb2xvcjogJHtkYXRhLmNvbG9yfTtgKVxuICB9IGVsc2Uge1xuICAgIGJ1bGxldC5hZGRDbGFzcyhkYXRhLmNvbG9yKVxuICB9XG5cbiAgY29uc3QgY2FwdGlvbiA9IG5ldyBEb21FbGVtZW50PEhUTUxTcGFuRWxlbWVudD4oXCJzcGFuXCIpXG4gICAgLnNldEh0bWwoZGF0YS50aXRsZSlcblxuICByZXR1cm4gbmV3IERvbUVsZW1lbnQ8SFRNTExJRWxlbWVudD4oXCJsaVwiKVxuICAgIC5hcHBlbmRDaGlsZChidWxsZXQpXG4gICAgLmFwcGVuZENoaWxkKGNhcHRpb24pXG4gICAgLmVsZW1lbnRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ29sb3Ioc3RyOiBzdHJpbmcpIHtcbiAgY29uc3QgcGF0dGVybiA9IC9eIy9pXG4gIHJldHVybiBwYXR0ZXJuLnRlc3Qoc3RyKVxufVxuIiwiaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgeyByZW1vdmVBbGxDaGlsZHJlbiwgdHJ5R2V0RGF0YSwgaXNDb2xvciwgQ2hhcnREYXRhIH0gZnJvbSBcIi4vQ2hhcnRGdW5jdGlvbnNcIlxuaW1wb3J0IGFuaW1lIGZyb20gXCJhbmltZWpzXCJcblxuY29uc3QgUVVFUllfQ0hBUlQgPSBcIi5qcy1jaGFydFwiXG5jb25zdCBRVUVSWV9MRUdFTkQgPSBcIi5qcy1sZWdlbmRcIlxuXG5jb25zdCBEQVNIX1NFUEFSQVRPUl9XSURUSCA9IDNcbmNvbnN0IEFOSU1BVElPTl9EVVJBVElPTiA9IDE1MDBcbmNvbnN0IEFOSU1BVElPTl9EVVJBVElPTl9MRUdFTkQgPSA1MDBcblxuY29uc3QgUVVFUllfTUVUQV9USVRMRSA9IFwiLm1ldGEgLnRpdGxlXCJcbmNvbnN0IFFVRVJZX01FVEFfU1VCVElUTEUgPSBcIi5tZXRhIC5zdWJ0aXRsZVwiXG5cbi8qKlxuICogUGllIENoYXJ0IENvbXBvbmVudC5cbiAqL1xuY2xhc3MgUGllQ2hhcnQgZXh0ZW5kcyBEb21FbGVtZW50PEhUTUxFbGVtZW50PiB7XG4gIHByaXZhdGUgX2RhdGEhOiBDaGFydERhdGFcblxuICBwcml2YXRlIF9jaGFydCE6IEhUTUxFbGVtZW50XG4gIHByaXZhdGUgX2xlZ2VuZCE6IEhUTUxFbGVtZW50XG4gIHByaXZhdGUgX3RpdGxlITogSFRNTEVsZW1lbnRcbiAgcHJpdmF0ZSBfc3VidGl0bGUhOiBIVE1MRWxlbWVudFxuXG4gIHByaXZhdGUgX3VuaXQhOiBzdHJpbmdcbiAgcHJpdmF0ZSBfYWx3YXlzU2hvd0xlZ2VuZCE6IGJvb2xlYW5cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgaW5pdGlhbGl6ZXMgdGhlIFBpZSBDaGFydCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7RG9tRWxlbWVudH0gLSByb290IGVsZW1lbnQgb2YgdGhlIGNoYXJ0LlxuICAgKiBAcGFyYW0ge0FycmF5fSAtIHBpZSBjaGFydCBkYXRhIGRlZmluaXRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudDogSFRNTEVsZW1lbnQsIGRhdGE/OiBDaGFydERhdGEpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuICAgIGlmIChkYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhID0gZGF0YVxuICAgIH1cblxuICAgIHRoaXMuX2luaXRpYWxpemUoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplKCkge1xuICAgIHRoaXMuX2NoYXJ0ID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfQ0hBUlQpISBhcyBIVE1MRWxlbWVudFxuICAgIHRoaXMuX2xlZ2VuZCA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX0xFR0VORCkhIGFzIEhUTUxFbGVtZW50XG4gICAgdGhpcy5fdGl0bGUgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9NRVRBX1RJVExFKSEgYXMgSFRNTEVsZW1lbnRcbiAgICB0aGlzLl9zdWJ0aXRsZSA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX01FVEFfU1VCVElUTEUpISBhcyBIVE1MRWxlbWVudFxuXG4gICAgdGhpcy5fdW5pdCA9IHRoaXMuZ2V0QXR0cmlidXRlKFwiZGF0YS11bml0XCIpIHx8IFwiXCJcbiAgICB0aGlzLl9hbHdheXNTaG93TGVnZW5kID0gdGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZShcImRhdGEtYWx3YXlzLXNob3ctbGVnZW5kXCIpXG5cbiAgICBpZiAoIXRoaXMuX2RhdGEpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSB0cnlHZXREYXRhKHRoaXMuZWxlbWVudClcbiAgICB9XG5cbiAgICB0aGlzLl9yZW5kZXIoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9yZW5kZXIoKSB7XG4gICAgY29uc3QgdG90YWwgPSB0aGlzLl9kYXRhLnJlZHVjZSgoYSwgYikgPT4gYSArIGIudmFsdWUsIDApXG4gICAgY29uc3QgciA9IDE2XG4gICAgY29uc3QgZGFzaFRvdGFsID0gKDIgKiByICogTWF0aC5QSSlcblxuICAgIGxldCBjdXJyZW50Um90YXRlID0gOVxuXG4gICAgLy8gQ2xlYW51cFxuICAgIHJlbW92ZUFsbENoaWxkcmVuKHRoaXMuX2NoYXJ0KVxuXG4gICAgaWYgKHRoaXMuX2xlZ2VuZCkge1xuICAgICAgcmVtb3ZlQWxsQ2hpbGRyZW4odGhpcy5fbGVnZW5kKVxuICAgIH1cblxuICAgIGxldCBwZXJjZW50YWdlQWRqdXN0VG90YWwgPSAwXG4gICAgbGV0IHBlcmNlbnRhZ2VBZGp1c3QgPSAwXG4gICAgY29uc3Qgc2VwYXJhdG9yUGVyY2VudGFnZSA9IERBU0hfU0VQQVJBVE9SX1dJRFRIIC8gMTAwXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5fZGF0YVtpXVxuXG4gICAgICBjb25zdCBwZXJjZW50YWdlID0gZW50cnkudmFsdWUgLyB0b3RhbFxuICAgICAgaWYgKHBlcmNlbnRhZ2UgPCBzZXBhcmF0b3JQZXJjZW50YWdlKSB7XG4gICAgICAgIHBlcmNlbnRhZ2VBZGp1c3RUb3RhbCArPSAoc2VwYXJhdG9yUGVyY2VudGFnZSAtIHBlcmNlbnRhZ2UpXG4gICAgICAgIHBlcmNlbnRhZ2VBZGp1c3QrK1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwZXJjZW50YWdlQWRqdXN0ID4gMCkge1xuICAgICAgcGVyY2VudGFnZUFkanVzdCA9IHBlcmNlbnRhZ2VBZGp1c3RUb3RhbCAvICh0aGlzLl9kYXRhLmxlbmd0aCAtIHBlcmNlbnRhZ2VBZGp1c3QpXG4gICAgfVxuXG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IGFuaW1lLnRpbWVsaW5lKClcblxuICAgIGxldCBhbmltYXRpb25PZmZzZXQgPSAwXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbnRyeSA9IHRoaXMuX2RhdGFbaV1cblxuICAgICAgY29uc3QgZGlzcGxheVBlcmNlbnRhZ2UgPSBlbnRyeS52YWx1ZSAvIHRvdGFsXG4gICAgICBjb25zdCBwZXJjZW50YWdlID0gTWF0aC5tYXgoc2VwYXJhdG9yUGVyY2VudGFnZSwgZGlzcGxheVBlcmNlbnRhZ2UgLSBwZXJjZW50YWdlQWRqdXN0KVxuXG4gICAgICBsZXQgZGFzaFdpZHRoID0gKHBlcmNlbnRhZ2UgKiBkYXNoVG90YWwpIC0gREFTSF9TRVBBUkFUT1JfV0lEVEhcblxuICAgICAgbGV0IHN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwic3ZnXCIpXG4gICAgICBzdmcuc2V0QXR0cmlidXRlKFwidmlld0JveFwiLCBcIjAgMCAzNCAzNFwiKVxuICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJpbWdcIilcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsbGVkYnlcIiwgXCJ0aXRsZSBkZXNjXCIpXG5cbiAgICAgIGxldCB0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwidGl0bGVcIilcbiAgICAgIHRpdGxlLnNldEF0dHJpYnV0ZShcImlkXCIsIFwidGl0bGVcIilcbiAgICAgIHRpdGxlLmlubmVySFRNTCA9IGBQaWUgY2hhcnQgc2VnbWVudCAke01hdGguZmxvb3IoZGlzcGxheVBlcmNlbnRhZ2UgKiAxMDApfSVgXG5cbiAgICAgIGxldCBkZXNjcmlwdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiZGVzY1wiKVxuICAgICAgZGVzY3JpcHRpb24uc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJkZXNjXCIpXG4gICAgICBkZXNjcmlwdGlvbi5pbm5lckhUTUwgPSBgJHtlbnRyeS50aXRsZX06ICR7ZW50cnkudmFsdWV9YFxuXG4gICAgICBsZXQgY2lyY2xlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJjaXJjbGVcIilcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJjeFwiLCBcIjE3XCIpXG4gICAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwiY3lcIiwgXCIxN1wiKVxuICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInJcIiwgU3RyaW5nKHIpKVxuXG4gICAgICBpZiAoaXNDb2xvcihlbnRyeS5jb2xvcikgPT09IHRydWUpIHtcbiAgICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBgJHtlbnRyeS5jb2xvcn1gKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGVudHJ5LmNvbG9yKVxuICAgICAgfVxuXG4gICAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiKVxuICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIGB0cmFuc2Zvcm06IHJvdGF0ZSgke2N1cnJlbnRSb3RhdGV9ZGVnKTtgKVxuXG4gICAgICBzdmcuYXBwZW5kQ2hpbGQodGl0bGUpXG4gICAgICBzdmcuYXBwZW5kQ2hpbGQoZGVzY3JpcHRpb24pXG4gICAgICBzdmcuYXBwZW5kQ2hpbGQoY2lyY2xlKVxuICAgICAgdGhpcy5fY2hhcnQuYXBwZW5kQ2hpbGQoc3ZnKVxuXG4gICAgICBsZXQgYW5pbWF0aW9uRHVyYXRpb24gPSBBTklNQVRJT05fRFVSQVRJT04gKiBwZXJjZW50YWdlXG4gICAgICBjaXJjbGUuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiXG5cbiAgICAgIGxldCBjb3VudGVyID0geyB2YXI6IDAuNSB9XG4gICAgICBhbmltYXRpb25zLmFkZCh7XG4gICAgICAgIHRhcmdldHM6IGNvdW50ZXIsXG4gICAgICAgIHZhcjogZGFzaFdpZHRoLFxuICAgICAgICBiZWdpbjogKCkgPT4ge1xuICAgICAgICAgIGNpcmNsZS5zdHlsZS5kaXNwbGF5ID0gXCJcIlxuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6ICgpID0+IHtcbiAgICAgICAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLWRhc2hhcnJheVwiLCBgJHtjb3VudGVyLnZhcn0gJHtkYXNoVG90YWx9YClcbiAgICAgICAgfSxcbiAgICAgICAgZHVyYXRpb246IGFuaW1hdGlvbkR1cmF0aW9uLFxuICAgICAgICBlYXNpbmc6IFwiZWFzZUluUXVpbnRcIlxuICAgICAgfSlcblxuICAgICAgLy8gTGVnZW5kXG4gICAgICBpZiAodGhpcy5fbGVnZW5kICYmICh0aGlzLl9kYXRhLmxlbmd0aCA+IDEpIHx8IHRoaXMuX2Fsd2F5c1Nob3dMZWdlbmQpIHtcbiAgICAgICAgbGV0IGJ1bGxldCA9IG5ldyBEb21FbGVtZW50KFwic3BhblwiKVxuICAgICAgICAgIC5hZGRDbGFzcyhcImJ1bGxldFwiKVxuXG4gICAgICAgIGlmIChpc0NvbG9yKGVudHJ5LmNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGJ1bGxldC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBgYmFja2dyb3VuZC1jb2xvcjogJHtlbnRyeS5jb2xvcn1gKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1bGxldC5hZGRDbGFzcyhlbnRyeS5jb2xvcilcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNhcHRpb24gPSBuZXcgRG9tRWxlbWVudChcInNwYW5cIilcbiAgICAgICAgY29uc3QgY2FwdGlvbkVsZW1lbnQgPSBjYXB0aW9uLmVsZW1lbnQgYXMgSFRNTEVsZW1lbnRcbiAgICAgICAgY2FwdGlvbkVsZW1lbnQuaW5uZXJUZXh0ID0gZW50cnkudGl0bGVcblxuICAgICAgICBsZXQgbGVnZW5kSXRlbSA9IG5ldyBEb21FbGVtZW50KFwibGlcIilcbiAgICAgICAgICAuYXBwZW5kQ2hpbGQoYnVsbGV0KVxuICAgICAgICAgIC5hcHBlbmRDaGlsZChjYXB0aW9uKVxuXG4gICAgICAgIHRoaXMuX2xlZ2VuZC5hcHBlbmRDaGlsZChsZWdlbmRJdGVtLmVsZW1lbnQpXG5cbiAgICAgICAgdGhpcy5fYW5pbWF0ZUxlZ2VuZChsZWdlbmRJdGVtLmVsZW1lbnQgYXMgSFRNTEVsZW1lbnQsIGFuaW1hdGlvbk9mZnNldClcbiAgICAgIH1cbiAgICAgIGFuaW1hdGlvbk9mZnNldCArPSBhbmltYXRpb25EdXJhdGlvblxuXG4gICAgICBjdXJyZW50Um90YXRlICs9ICgzNjAgKiBwZXJjZW50YWdlKVxuXG4gICAgICBpZiAoaSA9PT0gdGhpcy5fZGF0YS5sZW5ndGggLSAxKSB7XG4gICAgICAgIHRoaXMuX3RpdGxlLmlubmVySFRNTCA9IGAke2VudHJ5LnZhbHVlfSAke3RoaXMuX3VuaXR9YFxuICAgICAgICB0aGlzLl9zdWJ0aXRsZS5pbm5lckhUTUwgPSBlbnRyeS50aXRsZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2FuaW1hdGVMZWdlbmQobGVnZW5kSXRlbTogSFRNTEVsZW1lbnQsIGFuaW1hdGlvbk9mZnNldDogbnVtYmVyKSB7XG4gICAgbGVnZW5kSXRlbS5zdHlsZS5vcGFjaXR5ID0gXCIwXCJcbiAgICBhbmltZSh7XG4gICAgICB0YXJnZXRzOiBsZWdlbmRJdGVtLFxuICAgICAgZHVyYXRpb246IEFOSU1BVElPTl9EVVJBVElPTl9MRUdFTkQsXG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgZWFzaW5nOiBcImVhc2VJbk91dFF1aW50XCIsXG4gICAgICBkZWxheTogYW5pbWF0aW9uT2Zmc2V0LFxuICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgbGVnZW5kSXRlbS5zdHlsZS5vcGFjaXR5ID0gbnVsbFxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcGllIGNoYXJ0IHdpdGggdGhlIHNwZWNpZmllZCBkYXRhIGRlZmluaXRpb25zLlxuICAgKiBAcGFyYW0ge0FycmF5fSAtIHBpZSBjaGFydCBkYXRhIGRlZmluaXRpb25zLlxuICAgKi9cbiAgcHVibGljIHVwZGF0ZShkYXRhOiBDaGFydERhdGEpIHtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgdGhpcy5fZGF0YSA9IGRhdGFcbiAgICB9XG5cbiAgICB0aGlzLl9yZW5kZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGV2ZW50IGhhbmRsZXJzIGFuZCBjbGVhcnMgcmVmZXJlbmNlcy5cbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgICh0aGlzIGFzIGFueSkuX2RhdGEgPSB1bmRlZmluZWQ7XG4gICAgKHRoaXMgYXMgYW55KS5fdGl0bGUgPSB1bmRlZmluZWQ7XG4gICAgKHRoaXMgYXMgYW55KS5fc3VidGl0bGUgPSB1bmRlZmluZWQ7XG4gICAgKHRoaXMgYXMgYW55KS5fdW5pdCA9IHVuZGVmaW5lZFxuXG4gICAgcmVtb3ZlQWxsQ2hpbGRyZW4odGhpcy5fY2hhcnQpO1xuICAgICh0aGlzIGFzIGFueSkuX2NoYXJ0ID0gdW5kZWZpbmVkXG5cbiAgICBpZiAodGhpcy5fbGVnZW5kKSB7XG4gICAgICByZW1vdmVBbGxDaGlsZHJlbih0aGlzLl9sZWdlbmQpO1xuICAgICAgKHRoaXMgYXMgYW55KS5fbGVnZW5kID0gdW5kZWZpbmVkXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBkZXN0cm95KCkgaW5zdGVhZC5cbiAgICogQHRvZG8gcmVtb3ZlIGluIHZlcnNpb24gMi4wLjBcbiAgICovXG4gIHB1YmxpYyBkZXN0b3J5KCkge1xuICAgIHRoaXMuZGVzdHJveSgpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHNlYXJjaEFuZEluaXRpYWxpemU8SFRNTEVsZW1lbnQ+KFwiLnBpZS1jaGFydFwiLCAoZSkgPT4ge1xuICAgIG5ldyBQaWVDaGFydChlKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBQaWVDaGFydFxuIiwiaW1wb3J0IHsgcHJldmVudERlZmF1bHQgfSBmcm9tIFwiLi4vVXRpbHNcIlxuaW1wb3J0IGFuaW1lIGZyb20gXCJhbmltZWpzXCJcbmltcG9ydCBEb21FbGVtZW50IGZyb20gXCIuLi9Eb21FbGVtZW50XCJcbmltcG9ydCB7IGFkZENsYXNzLCBoYXNDbGFzcywgcmVtb3ZlQ2xhc3MsIGlzSGlkZGVuIH0gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5cbmNvbnN0IENMQVNTX09QRU4gPSBcImlzLW9wZW5cIlxuXG5jb25zdCBBTklNQVRJT05fT1BFTiA9IDMwMFxuXG4vKipcbiAqIFRoZSBDb2xsYXBzZSBjb21wb25lbnQuXG4gKi9cbmNsYXNzIENvbGxhcHNlIGV4dGVuZHMgRG9tRWxlbWVudCB7XG4gIHByaXZhdGUgX2hpZGRlbkluZGljYXRvciE6IEhUTUxFbGVtZW50XG4gIHByaXZhdGUgX2NvbGxhcHNpYmxlRWxlbWVudHMhOiBOb2RlTGlzdE9mPEhUTUxFbGVtZW50PlxuICBwcml2YXRlIGVhc2luZyA9IHtcbiAgICAvLyBFcXVpdmFsZW50IHRvIGdzYXAncyBbIFBvd2VyMS5lYXNlSW4sIFBvd2VyNC5lYXNlT3V0IF1cbiAgICBpblF1YWRPdXRRdWludDogWyAwLjU1MCwgMC4wODUsIDAuMzIwLCAxIF1cbiAgfVxuICBwcml2YXRlIF9jbGlja0hhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuZCBpbml0aWFsaXplcyB0aGUgQ29sbGFwc2UgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge0RvbUVsZW1lbnR9IC0gVGhlIHJvb3QgZWxlbWVudCBvZiB0aGUgQ29sbGFwc2UgY29tcG9uZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudDogSFRNTEVsZW1lbnQpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgdGhpcy5fY2xpY2tIYW5kbGVyID0gdGhpcy5faGFuZGxlQ2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuX2luaXRpYWxpemUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBDb2xsYXBzZSBjb21wb25lbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX2luaXRpYWxpemUoKSB7XG4gICAgbGV0IGRhdGFUYXJnZXQgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS10YXJnZXRcIilcbiAgICBpZiAoZGF0YVRhcmdldCA9PT0gbnVsbCB8fCBkYXRhVGFyZ2V0ID09PSBcIlwiKSB7XG5cbiAgICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGUgKi9cbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJBIGNvbGxhcHNpYmxlIGVsZW1lbnQgcmVxdWlyZXMgYSAnZGF0YS10YXJnZXQnIHRoYXQgc3BlY2lmaWVzIHRoZSBlbGVtZW50IHRvIGNvbGxhcHNlXCIpXG4gICAgICBjb25zb2xlLmluZm8odGhpcy5lbGVtZW50KVxuICAgICAgLyogdHNsaW50OmVuYWJsZTpuby1jb25zb2xlICovXG5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBoaWRkZW5UYXJnZXQgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1oaWRkZW5cIilcbiAgICBpZiAoaGlkZGVuVGFyZ2V0ICE9PSBudWxsICYmIGhpZGRlblRhcmdldCAhPT0gXCJcIikge1xuICAgICAgdGhpcy5faGlkZGVuSW5kaWNhdG9yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihoaWRkZW5UYXJnZXQpISBhcyBIVE1MRWxlbWVudFxuICAgIH1cblxuICAgIHRoaXMuX2NvbGxhcHNpYmxlRWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGRhdGFUYXJnZXQpXG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jbGlja0hhbmRsZXIpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUNsaWNrKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgcHJldmVudERlZmF1bHQoZXZlbnQpXG4gICAgdGhpcy50b2dnbGUoKVxuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIGNvbGxhcHNlaWJsZS5cbiAgICovXG4gIHB1YmxpYyB0b2dnbGUoKSB7XG4gICAgaWYgKHRoaXMuX2hpZGRlbkluZGljYXRvciAmJiBpc0hpZGRlbih0aGlzLl9oaWRkZW5JbmRpY2F0b3IsIGZhbHNlKSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGhhc0NsYXNzKHRoaXMuZWxlbWVudCwgQ0xBU1NfT1BFTikgPT09IGZhbHNlKSB7XG4gICAgICBhZGRDbGFzcyh0aGlzLmVsZW1lbnQsIENMQVNTX09QRU4pXG5cbiAgICAgIGZvciAobGV0IHMgb2YgdGhpcy5fY29sbGFwc2libGVFbGVtZW50cykge1xuICAgICAgICB0aGlzLl9vcGVuQ29sbGFwc2UocylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5lbGVtZW50LCBDTEFTU19PUEVOKVxuXG4gICAgICBmb3IgKGxldCBzIG9mIHRoaXMuX2NvbGxhcHNpYmxlRWxlbWVudHMpIHtcbiAgICAgICAgdGhpcy5fY2xvc2VDb2xsYXBzZShzKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfb3BlbkNvbGxhcHNlKGVsOiBIVE1MRWxlbWVudCkge1xuICAgIGFuaW1lLnJlbW92ZShlbClcblxuICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCJcblxuICAgIGFuaW1lKHtcbiAgICAgIHRhcmdldHM6IGVsLFxuICAgICAgZHVyYXRpb246IEFOSU1BVElPTl9PUEVOLFxuICAgICAgaGVpZ2h0OiBlbC5zY3JvbGxIZWlnaHQgKyBcInB4XCIsXG4gICAgICBlYXNpbmc6IHRoaXMuZWFzaW5nLmluUXVhZE91dFF1aW50LFxuICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgY29uc3QgZG9tRWwgPSBuZXcgRG9tRWxlbWVudChlbClcbiAgICAgICAgZG9tRWwuYWRkQ2xhc3MoQ0xBU1NfT1BFTilcbiAgICAgICAgZG9tRWwuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJcIilcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gc2V0IGFyaWEgZXhwYW5kZWRcbiAgICBlbC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIFwidHJ1ZVwiKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9jbG9zZUNvbGxhcHNlKGVsOiBIVE1MRWxlbWVudCkge1xuICAgIGFuaW1lLnJlbW92ZShlbClcblxuICAgIGFuaW1lKHtcbiAgICAgIHRhcmdldHM6IGVsLFxuICAgICAgZHVyYXRpb246IEFOSU1BVElPTl9PUEVOLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgZWFzaW5nOiB0aGlzLmVhc2luZy5pblF1YWRPdXRRdWludCxcbiAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRvbUVsID0gbmV3IERvbUVsZW1lbnQoZWwpXG4gICAgICAgIGRvbUVsLnJlbW92ZUNsYXNzKENMQVNTX09QRU4pXG4gICAgICAgIGRvbUVsLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiXCIpXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIHNldCBhcmlhIGV4cGFuZGVkXG4gICAgZWwuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcImZhbHNlXCIpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgZXZlbnQgaGFuZGxlcnMgYW5kIGNsZWFycyByZWZlcmVuY2VzLlxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgKHRoaXMgYXMgYW55KS5fY29sbGFwc2libGVFbGVtZW50cyA9IG51bGxcblxuICAgIGlmICgodGhpcyBhcyBhbnkpLl9jbGlja0hhbmRsZXIpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fY2xpY2tIYW5kbGVyKVxuICAgIH1cblxuICAgICh0aGlzIGFzIGFueSkuZWxlbWVudCA9IG51bGxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgbGV0IGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLXRvZ2dsZT0nY29sbGFwc2UnXVwiKVxuICBmb3IgKGxldCBlIG9mIGVsZW1lbnRzKSB7XG4gICAgaWYgKGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1pbml0XCIpID09PSBcImF1dG9cIikge1xuICAgICAgbmV3IENvbGxhcHNlKGUgYXMgSFRNTEVsZW1lbnQpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbGxhcHNlXG4iLCJpbXBvcnQgeyBzZWFyY2hBbmRJbml0aWFsaXplIH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCBEb21FbGVtZW50IGZyb20gXCIuLi9Eb21FbGVtZW50XCJcbmltcG9ydCB7IHBhcmVudFdpdGhDbGFzcywgZ2V0Um9vdEVsZW1lbnQgfSBmcm9tIFwiLi4vRG9tRnVuY3Rpb25zXCJcblxuY29uc3QgQ0xBU1NfQk9SREVSID0gXCJlbXB0eS1zdGF0ZV9fYm9yZGVyXCJcbmNvbnN0IENMQVNTX0JPUkRFUl9NT0RBTCA9IFwiZW1wdHktc3RhdGVfX2JvcmRlci0tbW9kYWxcIlxuY29uc3QgQ0xBU1NfQUNUSVZFID0gXCJpcy1hY3RpdmVcIlxuY29uc3QgQ0xBU1NfSEFTRklMRVMgPSBcImhhcy1maWxlc1wiXG5jb25zdCBDTEFTU19NT0RBTCA9IFwiZW1wdHktc3RhdGUtLW1vZGFsXCJcbmNvbnN0IENMQVNTX01PREFMX0NPTlRFTlQgPSBcIm1vZGFsX19jb250ZW50XCJcblxuY29uc3QgUVVFUllfTU9EQUxfQk9EWSA9IFwiLm1vZGFsX19ib2R5XCJcbmNvbnN0IFFVRVJZX0ZJTEUgPSBcImlucHV0W3R5cGU9J2ZpbGUnXVwiXG5cbi8qKlxuICogRW1wdHkgc3RhdGUgcGF0dGVyblxuICovXG5jbGFzcyBFbXB0eVN0YXRlIGV4dGVuZHMgRG9tRWxlbWVudCB7XG4gIHByaXZhdGUgX2JvcmRlciE6IERvbUVsZW1lbnQ8SFRNTERpdkVsZW1lbnQ+XG5cbiAgcHJpdmF0ZSBfZmlsZUlucHV0OiBIVE1MSW5wdXRFbGVtZW50XG4gIHByaXZhdGUgX2J1dHRvbjogSFRNTExhYmVsRWxlbWVudFxuXG4gIHByaXZhdGUgX2RyYWdBcmVhITogRWxlbWVudFxuXG4gIHByaXZhdGUgX2ZpbGVDaGFuZ2VkSGFuZGxlcjogKGV2ZW50OiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9wcmV2ZW50RXZlbnRzSGFuZGxlcjogKGV2ZW50OiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9kcmFnRW50ZXJIYW5kbGVyOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2RyYWdMZWF2ZUhhbmRsZXI6IChldmVudDogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfZHJvcEhhbmRsZXI6IChldmVudDogRXZlbnQpID0+IHZvaWRcblxuICBwcml2YXRlIF9pc0RyYWdnaW5nOiBib29sZWFuXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGluaXRpYWxpemVzIHRoZSBFbXB0eS1TdGF0ZSBwYXR0ZXJuIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtEb21FbGVtZW50fSAtIHJvb3QgZWxlbWVudCBvZiB0aGUgZW1wdHktc3RhdGUgcGF0dGVybi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEVsZW1lbnQpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgdGhpcy5fZmlsZUlucHV0ID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfRklMRSkhIGFzIEhUTUxJbnB1dEVsZW1lbnRcbiAgICB0aGlzLl9idXR0b24gPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihcImxhYmVsXCIpIVxuXG4gICAgdGhpcy5fZmlsZUNoYW5nZWRIYW5kbGVyID0gdGhpcy5faGFuZGxlRmlsZUNoYW5nZWQuYmluZCh0aGlzKVxuICAgIHRoaXMuX3ByZXZlbnRFdmVudHNIYW5kbGVyID0gdGhpcy5fcHJldmVudERyYWdFdmVudHMuYmluZCh0aGlzKVxuICAgIHRoaXMuX2RyYWdFbnRlckhhbmRsZXIgPSB0aGlzLl9oYW5kbGVEcmFnRW50ZXIuYmluZCh0aGlzKVxuICAgIHRoaXMuX2RyYWdMZWF2ZUhhbmRsZXIgPSB0aGlzLl9oYW5kbGVEcmFnTGVhdmUuYmluZCh0aGlzKVxuICAgIHRoaXMuX2Ryb3BIYW5kbGVyID0gdGhpcy5faGFuZGxlRHJvcC5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2VcblxuICAgIHRoaXMuX2luaXRpYWxpemUoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplKCkge1xuICAgIGlmICh0aGlzLmhhc0NsYXNzKENMQVNTX01PREFMKSkge1xuICAgICAgLy8gaGFuZGxlIG1vZGFsIGRpYWxvZ3NcbiAgICAgIHRoaXMuX2RyYWdBcmVhID0gcGFyZW50V2l0aENsYXNzKHRoaXMuZWxlbWVudCwgQ0xBU1NfTU9EQUxfQ09OVEVOVCkhXG4gICAgICBsZXQgYm9yZGVyQXJlYSA9IHRoaXMuX2RyYWdBcmVhLnF1ZXJ5U2VsZWN0b3IoUVVFUllfTU9EQUxfQk9EWSkhXG4gICAgICBib3JkZXJBcmVhLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwicG9pbnRlci1ldmVudHM6IG5vbmU7XCIpXG5cbiAgICAgIHRoaXMuX2JvcmRlciA9IG5ldyBEb21FbGVtZW50PEhUTUxEaXZFbGVtZW50PihcImRpdlwiKVxuICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfQk9SREVSKVxuICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfQk9SREVSX01PREFMKVxuXG4gICAgICBib3JkZXJBcmVhLmFwcGVuZENoaWxkKHRoaXMuX2JvcmRlci5lbGVtZW50KVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vcm1hbCBtb2RhbCBkaWFsb2dcbiAgICAgIHRoaXMuX2RyYWdBcmVhID0gdGhpcy5lbGVtZW50XG4gICAgICBsZXQgYm9yZGVyQXJlYSA9IGdldFJvb3RFbGVtZW50KClcblxuICAgICAgdGhpcy5fYm9yZGVyID0gbmV3IERvbUVsZW1lbnQ8SFRNTERpdkVsZW1lbnQ+KFwiZGl2XCIpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19CT1JERVIpXG5cbiAgICAgIGlmICghYm9yZGVyQXJlYS5xdWVyeVNlbGVjdG9yKGAuJHtDTEFTU19CT1JERVJ9YCkpIHtcbiAgICAgICAgYm9yZGVyQXJlYS5hcHBlbmRDaGlsZCh0aGlzLl9ib3JkZXIuZWxlbWVudClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBmb3JtID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJmb3JtXCIpIVxuXG4gICAgZm9yIChsZXQgZXZlbnQgb2YgWyBcImRyYWdcIiwgXCJkcmFnc3RhcnRcIiwgXCJkcmFnZW5kXCIsIFwiZHJhZ292ZXJcIiwgXCJkcmFnZW50ZXJcIiwgXCJkcmFnbGVhdmVcIiwgXCJkcm9wXCIgXSkge1xuICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIHRoaXMuX3ByZXZlbnRFdmVudHNIYW5kbGVyKVxuICAgICAgZm9ybS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLl9wcmV2ZW50RXZlbnRzSGFuZGxlcilcbiAgICAgIHRoaXMuX2RyYWdBcmVhLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIHRoaXMuX3ByZXZlbnRFdmVudHNIYW5kbGVyKVxuICAgIH1cblxuICAgIHRoaXMuX2RyYWdBcmVhLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnb3ZlclwiLCB0aGlzLl9kcmFnRW50ZXJIYW5kbGVyKVxuICAgIHRoaXMuX2RyYWdBcmVhLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnZW50ZXJcIiwgdGhpcy5fZHJhZ0VudGVySGFuZGxlcilcblxuICAgIHRoaXMuX2RyYWdBcmVhLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnbGVhdmVcIiwgdGhpcy5fZHJhZ0xlYXZlSGFuZGxlcilcbiAgICB0aGlzLl9kcmFnQXJlYS5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ2VuZFwiLCB0aGlzLl9kcmFnTGVhdmVIYW5kbGVyKVxuICAgIHRoaXMuX2RyYWdBcmVhLmFkZEV2ZW50TGlzdGVuZXIoXCJkcm9wXCIsIHRoaXMuX2RyYWdMZWF2ZUhhbmRsZXIpXG5cbiAgICB0aGlzLl9kcmFnQXJlYS5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLCB0aGlzLl9kcm9wSGFuZGxlcilcbiAgICB0aGlzLl9maWxlSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCB0aGlzLl9maWxlQ2hhbmdlZEhhbmRsZXIpXG4gIH1cblxuICBwcm90ZWN0ZWQgX3ByZXZlbnREcmFnRXZlbnRzKGU6IEV2ZW50KSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZURyYWdFbnRlcigpIHtcbiAgICBpZiAodGhpcy5faXNEcmFnZ2luZyA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5faXNEcmFnZ2luZyA9IHRydWVcbiAgICB0aGlzLl9idXR0b24uc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJwb2ludGVyLWV2ZW50czogbm9uZTtcIilcblxuICAgIHRoaXMuYWRkQ2xhc3MoQ0xBU1NfQUNUSVZFKVxuICAgIHRoaXMuX2JvcmRlci5hZGRDbGFzcyhDTEFTU19BQ1RJVkUpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZURyYWdMZWF2ZSgpIHtcbiAgICBpZiAodGhpcy5faXNEcmFnZ2luZyA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZVxuICAgIHRoaXMuX2J1dHRvbi5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcIlwiKVxuXG4gICAgdGhpcy5yZW1vdmVDbGFzcyhDTEFTU19BQ1RJVkUpXG4gICAgdGhpcy5fYm9yZGVyLnJlbW92ZUNsYXNzKENMQVNTX0FDVElWRSlcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlRHJvcChlOiBEcmFnRXZlbnQpIHtcbiAgICAodGhpcy5fZmlsZUlucHV0IGFzIGFueSkuZmlsZXMgPSBlLmRhdGFUcmFuc2Zlci5maWxlc1xuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVGaWxlQ2hhbmdlZCgpIHtcbiAgICBsZXQgZmlsZXMgPSB0aGlzLl9maWxlSW5wdXQuZmlsZXNcblxuICAgIGlmIChmaWxlcyAmJiBmaWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKENMQVNTX0hBU0ZJTEVTKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKENMQVNTX0hBU0ZJTEVTKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZmlsZXMuXG4gICAqL1xuICBnZXQgZmlsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGVJbnB1dC5maWxlc1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBzZWFyY2hBbmRJbml0aWFsaXplKFwiLmVtcHR5LXN0YXRlXCIsIChlKSA9PiB7XG4gICAgbmV3IEVtcHR5U3RhdGUoZSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgRW1wdHlTdGF0ZVxuIiwiaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSwgcHJldmVudERlZmF1bHQgfSBmcm9tIFwiLi4vVXRpbHNcIlxuaW1wb3J0IHsgZW1wdHksIGFkZENsYXNzLCByZW1vdmVDbGFzcywgaGFzQ2xhc3MgfSBmcm9tIFwiLi4vRG9tRnVuY3Rpb25zXCJcbmltcG9ydCBEb21FbGVtZW50IGZyb20gXCIuLi9Eb21FbGVtZW50XCJcbmltcG9ydCAqIGFzIElucHV0cyBmcm9tIFwiLi4vSW5wdXRzXCJcblxuY29uc3QgUVVFUllfRFJPUERPV04gPSBcIi5qcy1hdXRvY29tcGxldGVcIlxuY29uc3QgQ0xBU1NfUkVTVUxUID0gXCJhdXRvY29tcGxldGVfX3Jlc3VsdFwiXG5jb25zdCBDTEFTU19PUEVOID0gXCJpcy1vcGVuXCJcbmNvbnN0IENMQVNTX0hPVkVSID0gXCJqcy1ob3ZlclwiXG5jb25zdCBBVFRSSUJVVEVfVkFMVUUgPSBcImRhdGEtdmFsdWVcIlxuXG5jb25zdCBUSU1FT1VUX0JMVVIgPSA0MDBcblxuZXhwb3J0IGludGVyZmFjZSBTb3VyY2Uge1xuICAoXG4gICAgdGVybTogc3RyaW5nLFxuICAgIGNhbGxiYWNrOiAobWF0Y2hlczogc3RyaW5nW10sIHRlcm11c2VkOiBzdHJpbmcpID0+IHZvaWRcbiAgKTogdm9pZFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEF1dG9jb21wbGV0ZUNvbmZpZyB7XG4gIG1pbkNoYXJzOiBudW1iZXJcbiAgc291cmNlOiBTb3VyY2Vcbn1cblxuLyoqXG4gKiBBdXRvY29tcGxldGUgY29tcG9uZW50XG4gKiBAZmlyZXMgQXV0b2NvbXBsZXRlI2NoYW5nZVxuICovXG5jbGFzcyBBdXRvY29tcGxldGUgZXh0ZW5kcyBEb21FbGVtZW50PEhUTUxFbGVtZW50PiB7XG4gIHByaXZhdGUgX3NvdXJjZSE6IFNvdXJjZVxuICBwcml2YXRlIF9taW5DaGFycyE6IG51bWJlclxuXG4gIHByaXZhdGUgX2lucHV0OiBIVE1MSW5wdXRFbGVtZW50XG4gIHByaXZhdGUgX3N1Z2dlc3Rpb25MaXN0ITogSFRNTFVMaXN0RWxlbWVudFxuICBwcml2YXRlIF9kcm9wZG93bjogSFRNTEVsZW1lbnRcblxuICBwcml2YXRlIF9jbGlja0hhbmRsZXI6IChldmVudDogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfd2luZG93Q2xpY2tIYW5kbGVyOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2tleVVwSGFuZGxlcjogKGV2ZW50OiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9rZXlEb3duSGFuZGxlcjogKGV2ZW50OiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9ibHVySGFuZGxlcjogKGV2ZW50OiBFdmVudCkgPT4gdm9pZFxuXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBjb25maWd1cmF0aW9uPzogQXV0b2NvbXBsZXRlQ29uZmlnKSB7XG4gICAgc3VwZXIoZWxlbWVudClcblxuICAgIHRoaXMuX2lucHV0ID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJpbnB1dFwiKSFcbiAgICB0aGlzLl9kcm9wZG93biA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX0RST1BET1dOKSEgYXMgSFRNTEVsZW1lbnRcblxuICAgIC8vIFNldHVwIGV2ZW50IGNvbnRleHRcbiAgICB0aGlzLl9jbGlja0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVDbGljay5iaW5kKHRoaXMpXG4gICAgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyID0gdGhpcy5faGFuZGxlV2luZG93Q2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuX2tleVVwSGFuZGxlciA9IHRoaXMuX2hhbmRsZUtleVVwLmJpbmQodGhpcylcbiAgICB0aGlzLl9rZXlEb3duSGFuZGxlciA9IHRoaXMuX2hhbmRsZUtleURvd24uYmluZCh0aGlzKVxuICAgIHRoaXMuX2JsdXJIYW5kbGVyID0gdGhpcy5faGFuZGxlQmx1ci5iaW5kKHRoaXMpXG5cbiAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgdGhpcy5fbWluQ2hhcnMgPSBjb25maWd1cmF0aW9uLm1pbkNoYXJzXG4gICAgICB0aGlzLl9zb3VyY2UgPSBjb25maWd1cmF0aW9uLnNvdXJjZVxuICAgIH1cblxuICAgIGlmICghdGhpcy5fbWluQ2hhcnMgfHwgdGhpcy5fbWluQ2hhcnMgPCAwKSB7XG4gICAgICB0aGlzLl9taW5DaGFycyA9IDJcbiAgICB9XG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgQXV0b2NvbXBsZXRlIGNvbXBvbmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLl9jbGVhclN1Z2dlc3Rpb25zKClcblxuICAgIGlmICh0aGlzLl9pbnB1dC5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSkge1xuICAgICAgdGhpcy5kaXNhYmxlKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbmFibGUoKVxuICAgIH1cblxuICAgIC8vIERpc2FibGUgYnJvd3NlciBhdXRvZmlsbFxuICAgIHRoaXMuX2lucHV0LnNldEF0dHJpYnV0ZShcImF1dG9jb21wbGV0ZVwiLCBcIm9mZlwiKVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBBdXRvY29tcGxldGUgY29tcG9uZW50IGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqIEBjYWxsYmFjayBBdXRvY29tcGxldGV+U3VnZ2VzdFxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gdGVybSAtIFRoZSBjdXJyZW50IHNlYXJjaCB0ZXJtLlxuICAgKiBAcHJvcGVydHkge1N0cmluZ1tdfSBtYXRjaGVzIC0gVGhlIGxpc3Qgb2YgbWF0Y2hpbmcgc3RyaW5ncy5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSBBdXRvY29tcGxldGUgY29tcG9uZW50IGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqIEBjYWxsYmFjayBBdXRvY29tcGxldGV+U291cmNlXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB0ZXJtIC0gVGhlIGN1cnJlbnQgc2VhcmNoIHRlcm0uXG4gICAqIEBwcm9wZXJ0eSB7QXV0b2NvbXBsZXRlflN1Z2dlc3R9IHN1Z2dlc3QgLSBUaGUgYXV0b2NvbXBsZXRlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHJlcG9ydCB0aGUgcmVzdWx0cy5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSBBdXRvY29tcGxldGUgY29tcG9uZW50IGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IEF1dG9jb21wbGV0ZX5Db25maWdcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IG1pbkNoYXJzIC0gVGhlIG1pbmltYWwgcmVxdWlyZWQgY2hhcmFjdGVycyB0byBzdGFydCBxdWVyeWluZyBmb3IgYXV0b2NvbXBsZXRlIG1hdGNoZXMuXG4gICAqIEBwcm9wZXJ0eSB7QXV0b2NvbXBsZXRlflNvdXJjZX0gc291cmNlIC0gVGhlIGF1dG9jb21wbGV0ZSBzb3VyY2UgZnVuY3Rpb24uXG4gICAqL1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBhdXRvY29tcGxldGUgY29tcG9uZW50IGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBjdXJyZW50IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7QXV0b2NvbXBsZXRlfkNvbmZpZ30gY29uZmlndXJhdGlvbiBUaGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICovXG4gIHB1YmxpYyBjb25maWd1cmUoY29uZmlndXJhdGlvbj86IEF1dG9jb21wbGV0ZUNvbmZpZykge1xuICAgIGlmICghY29uZmlndXJhdGlvbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZ3VyYXRpb24ubWluQ2hhcnMpIHtcbiAgICAgIHRoaXMuX21pbkNoYXJzID0gTWF0aC5taW4oY29uZmlndXJhdGlvbi5taW5DaGFycywgMSlcbiAgICB9XG5cbiAgICBpZiAoY29uZmlndXJhdGlvbi5zb3VyY2UpIHtcbiAgICAgIHRoaXMuX3NvdXJjZSA9IGNvbmZpZ3VyYXRpb24uc291cmNlXG4gICAgfVxuXG4gICAgdGhpcy5fY2xlYXJTdWdnZXN0aW9ucygpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc2VsZWN0IGNvbnRyb2wgdG8gdGhlIGVuYWJsZWQgc3RhdGUuXG4gICAqL1xuICBwdWJsaWMgZW5hYmxlKCkge1xuICAgIGlmICghdGhpcy5faW5wdXQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2lucHV0LnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpXG5cbiAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgdGhpcy5fa2V5VXBIYW5kbGVyKVxuICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2tleURvd25IYW5kbGVyKVxuICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuX2JsdXJIYW5kbGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNlbGVjdCBjb250cm9sIHRvIHRoZSBkaXNhYmxlZCBzdGF0ZS5cbiAgICovXG4gIHB1YmxpYyBkaXNhYmxlKCkge1xuICAgIGlmICghdGhpcy5faW5wdXQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2lucHV0LnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwidHJ1ZVwiKVxuXG4gICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIHRoaXMuX2tleVVwSGFuZGxlcilcbiAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9rZXlEb3duSGFuZGxlcilcbiAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLl9ibHVySGFuZGxlcilcblxuICAgIHRoaXMuY2xvc2UoKVxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBjb21wb25lbnQgYW5kIGZyZWVzIGFsbCByZWZlcmVuY2VzLlxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kaXNhYmxlKCk7XG5cbiAgICAodGhpcyBhcyBhbnkpLl9rZXlVcEhhbmRsZXIgPSB1bmRlZmluZWQ7XG4gICAgKHRoaXMgYXMgYW55KS5fa2V5RG93bkhhbmRsZXIgPSB1bmRlZmluZWQ7XG4gICAgKHRoaXMgYXMgYW55KS5fd2luZG93Q2xpY2tIYW5kbGVyID0gdW5kZWZpbmVkO1xuICAgICh0aGlzIGFzIGFueSkuX2JsdXJIYW5kbGVyID0gdW5kZWZpbmVkO1xuXG4gICAgKHRoaXMgYXMgYW55KS5faW5wdXQgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIHN1Z2dlc3Rpb25zIGRyb3Bkb3duLlxuICAgKi9cbiAgcHVibGljIG9wZW4oKSB7XG4gICAgdGhpcy5fZHJvcGRvd24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2NsaWNrSGFuZGxlcilcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcblxuICAgIHRoaXMuYWRkQ2xhc3MoQ0xBU1NfT1BFTilcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVucyB0aGUgc3VnZ2VzdGlvbnMgZHJvcGRvd24uXG4gICAqL1xuICBwdWJsaWMgY2xvc2UoKSB7XG4gICAgdGhpcy5fZHJvcGRvd24ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2NsaWNrSGFuZGxlcilcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcblxuICAgIHRoaXMucmVtb3ZlQ2xhc3MoQ0xBU1NfT1BFTilcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiB0aGUgaW5wdXQgZmllbGQuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSB2YWx1ZSBvZiB0aGUgaW5wdXQgZmllbGQuXG4gICAqL1xuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lucHV0LnZhbHVlXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUNsaWNrKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLl9pc0Ryb3Bkb3duVGFyZ2V0KGV2ZW50LnRhcmdldCBhcyBOb2RlKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IGN1cnJlbnQgPSBldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnRcbiAgICB3aGlsZSAoY3VycmVudC5ub2RlTmFtZSAhPT0gXCJMSVwiICYmIGN1cnJlbnQucGFyZW50Tm9kZSkge1xuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZSBhcyBIVE1MRWxlbWVudFxuICAgIH1cblxuICAgIGlmIChjdXJyZW50Lm5vZGVOYW1lID09PSBcIkxJXCIpIHtcbiAgICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KVxuICAgICAgdGhpcy5fc2VsZWN0SXRlbShjdXJyZW50KVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlQmx1cigpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgIH0sIFRJTUVPVVRfQkxVUilcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlS2V5VXAoZXZ0OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgbGV0IGtleWNvZGUgPSBldnQud2hpY2ggfHwgZXZ0LmtleUNvZGVcblxuICAgIGlmIChJbnB1dHMuY29udGFpbnNLZXkoa2V5Y29kZSwgWyBJbnB1dHMuS0VZX0FSUk9XX1VQLCBJbnB1dHMuS0VZX0FSUk9XX0RPV04sIElucHV0cy5LRVlfRU5URVIsIElucHV0cy5LRVlfVEFCIF0pKSB7XG4gICAgICAvLyBEbyBub3QgaGFuZGxlIHRoZXNlIGV2ZW50cyBvbiBrZXl1cFxuICAgICAgcHJldmVudERlZmF1bHQoZXZ0KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gZXZ0LmN1cnJlbnRUYXJnZXQgYXMgSFRNTElucHV0RWxlbWVudFxuXG4gICAgaWYgKGV2dC5jdXJyZW50VGFyZ2V0ICYmIHRhcmdldC52YWx1ZSAmJiB0YXJnZXQudmFsdWUubGVuZ3RoID49IHRoaXMuX21pbkNoYXJzKSB7XG4gICAgICB0aGlzLl9nZXRTdWdnZXN0aW9uKHRhcmdldC52YWx1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jbG9zZSgpXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVLZXlEb3duKGV2dDogS2V5Ym9hcmRFdmVudCkge1xuICAgIGxldCBrZXljb2RlID0gZXZ0LndoaWNoIHx8IGV2dC5rZXlDb2RlXG4gICAgY29uc3QgaXNPcGVuID0gaGFzQ2xhc3ModGhpcy5lbGVtZW50LCBDTEFTU19PUEVOKVxuXG4gICAgaWYgKGtleWNvZGUgPT09IElucHV0cy5LRVlfRVNDQVBFICYmIGlzT3BlbiA9PT0gdHJ1ZSkge1xuICAgICAgLy8gaGFuZGxlIEVzY2FwZSBrZXkgKEVTQylcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgcHJldmVudERlZmF1bHQoZXZ0KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGlzT3BlbiA9PT0gdHJ1ZSAmJiBJbnB1dHMuY29udGFpbnNLZXkoa2V5Y29kZSwgWyBJbnB1dHMuS0VZX0VOVEVSLCBJbnB1dHMuS0VZX1RBQiBdKSkge1xuICAgICAgbGV0IGZvY3VzZWRFbGVtZW50ID0gdGhpcy5fc3VnZ2VzdGlvbkxpc3QucXVlcnlTZWxlY3RvcihgLiR7Q0xBU1NfSE9WRVJ9YClcblxuICAgICAgcHJldmVudERlZmF1bHQoZXZ0KVxuICAgICAgdGhpcy5fc2VsZWN0SXRlbShmb2N1c2VkRWxlbWVudClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChpc09wZW4gPT09IHRydWUgJiYgSW5wdXRzLmNvbnRhaW5zS2V5KGtleWNvZGUsIFsgSW5wdXRzLktFWV9BUlJPV19VUCwgSW5wdXRzLktFWV9BUlJPV19ET1dOIF0pKSB7XG4gICAgICAvLyBVcCBhbmQgZG93biBhcnJvd3NcblxuICAgICAgbGV0IGZvY3VzZWRFbGVtZW50ID0gdGhpcy5fc3VnZ2VzdGlvbkxpc3QucXVlcnlTZWxlY3RvcihgLiR7Q0xBU1NfSE9WRVJ9YCkhXG4gICAgICBpZiAoZm9jdXNlZEVsZW1lbnQpIHtcbiAgICAgICAgcmVtb3ZlQ2xhc3MoZm9jdXNlZEVsZW1lbnQsIENMQVNTX0hPVkVSKVxuXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fc3VnZ2VzdGlvbkxpc3QuY2hpbGROb2RlcykgYXMgRWxlbWVudFtdXG5cbiAgICAgICAgY29uc3QgdG90YWxOb2RlcyA9IGNoaWxkcmVuLmxlbmd0aCAtIDFcbiAgICAgICAgY29uc3QgZGlyZWN0aW9uID0ga2V5Y29kZSA9PT0gSW5wdXRzLktFWV9BUlJPV19VUCA/IC0xIDogMVxuXG4gICAgICAgIGxldCBpbmRleCA9IGNoaWxkcmVuLmluZGV4T2YoZm9jdXNlZEVsZW1lbnQpXG5cbiAgICAgICAgaW5kZXggPSBNYXRoLm1heChNYXRoLm1pbihpbmRleCArIGRpcmVjdGlvbiwgdG90YWxOb2RlcyksIDApXG4gICAgICAgIGZvY3VzZWRFbGVtZW50ID0gdGhpcy5fc3VnZ2VzdGlvbkxpc3QuY2hpbGROb2Rlc1tpbmRleF0gYXMgRWxlbWVudFxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb2N1c2VkRWxlbWVudCA9IHRoaXMuX3N1Z2dlc3Rpb25MaXN0LnF1ZXJ5U2VsZWN0b3IoXCJsaVwiKSBhcyBFbGVtZW50XG4gICAgICB9XG5cbiAgICAgIGFkZENsYXNzKGZvY3VzZWRFbGVtZW50LCBDTEFTU19IT1ZFUilcbiAgICAgIHByZXZlbnREZWZhdWx0KGV2dClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlV2luZG93Q2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICBpZiAodGhpcy5faXNEcm9wZG93blRhcmdldChldmVudC50YXJnZXQgYXMgTm9kZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuY2xvc2UoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9zZWxlY3RJdGVtKGl0ZW0/OiBFbGVtZW50IHwgbnVsbCkge1xuICAgIGlmICghaXRlbSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgdGV4dCA9IGl0ZW0uZ2V0QXR0cmlidXRlKEFUVFJJQlVURV9WQUxVRSlcbiAgICBpZiAodGV4dCkge1xuICAgICAgdGhpcy5faW5wdXQudmFsdWUgPSB0ZXh0XG5cbiAgICAgIC8vIERpc3BhdGNoIHRoZSBjaGFuZ2VkIGV2ZW50XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJjaGFuZ2VcIilcbiAgICB9XG5cbiAgICB0aGlzLmNsb3NlKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfaXNEcm9wZG93blRhcmdldCh0YXJnZXQ6IE5vZGUpIHtcbiAgICBsZXQgY3VycmVudCA9IHRhcmdldFxuICAgIHdoaWxlIChjdXJyZW50ICE9PSB0aGlzLl9kcm9wZG93biAmJiBjdXJyZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGVcbiAgICB9XG5cbiAgICByZXR1cm4gY3VycmVudCA9PT0gdGhpcy5fZHJvcGRvd25cbiAgfVxuXG4gIHByb3RlY3RlZCBfY2xlYXJTdWdnZXN0aW9ucygpIHtcbiAgICAvLyBDbGVhciB0aGUgZHJvcGRvd24gaXRlbVxuICAgIGVtcHR5KHRoaXMuX2Ryb3Bkb3duKVxuXG4gICAgdGhpcy5fc3VnZ2VzdGlvbkxpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidWxcIilcbiAgICB0aGlzLl9kcm9wZG93bi5hcHBlbmRDaGlsZCh0aGlzLl9zdWdnZXN0aW9uTGlzdClcbiAgfVxuXG4gIHByb3RlY3RlZCBfYWRkU3VnZ2VzdGlvbih0ZXh0OiBzdHJpbmcsIHRlcm06IHN0cmluZykge1xuICAgIGNvbnN0IHNhbml0aXplZFRlcm0gPSB0ZXJtLnJlcGxhY2UoL1stXFxcXF4kKis/LigpfFtcXF17fV0vZywgXCJcXFxcJCZcIilcbiAgICBjb25zdCBodG1sID0gdGV4dC5yZXBsYWNlKG5ldyBSZWdFeHAoYCgke3Nhbml0aXplZFRlcm19KWAsIFwiZ2lcIiksIFwiPHN0cm9uZz4kMTwvc3Ryb25nPlwiKVxuXG4gICAgY29uc3QgdGV4dEVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChcInNwYW5cIilcbiAgICAgIC5zZXRIdG1sKGh0bWwpXG5cbiAgICBjb25zdCBpbm5lckVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKENMQVNTX1JFU1VMVClcbiAgICAgIC5hcHBlbmRDaGlsZCh0ZXh0RWxlbWVudClcblxuICAgIGNvbnN0IGxpRWxlbWVudCA9IG5ldyBEb21FbGVtZW50KFwibGlcIilcbiAgICAgIC5zZXRBdHRyaWJ1dGUoQVRUUklCVVRFX1ZBTFVFLCB0ZXh0KVxuICAgICAgLmFwcGVuZENoaWxkKGlubmVyRWxlbWVudClcblxuICAgIHRoaXMuX3N1Z2dlc3Rpb25MaXN0LmFwcGVuZENoaWxkKGxpRWxlbWVudC5lbGVtZW50KVxuICB9XG5cbiAgcHJvdGVjdGVkIF9nZXRTdWdnZXN0aW9uKHRlcm06IHN0cmluZykge1xuICAgIGlmICghdGhpcy5fc291cmNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc291cmNlIGZ1bmN0aW9uIGlzIHVuZGVmaW5lZCwgY2Fubm90IGxvYWQgc3VnZ2VzdGlvbnNcIilcbiAgICB9XG5cbiAgICB0aGlzLl9zb3VyY2UodGVybSwgKG1hdGNoZXMsIHRlcm11c2VkKSA9PiB7XG4gICAgICB0aGlzLl9vbk1hdGNoZXNSZWNlaXZlZChtYXRjaGVzLCB0ZXJtdXNlZClcbiAgICB9KVxuICB9XG5cbiAgcHJvdGVjdGVkIF9vbk1hdGNoZXNSZWNlaXZlZChtYXRjaGVzOiBzdHJpbmdbXSwgdGVybTogc3RyaW5nKSB7XG4gICAgdGhpcy5fY2xlYXJTdWdnZXN0aW9ucygpXG5cbiAgICBpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDbGVhciB0aGUgZHJvcGRvd24gaXRlbVxuICAgICAgZW1wdHkodGhpcy5fc3VnZ2VzdGlvbkxpc3QpXG5cbiAgICAgIGZvciAobGV0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICAgICAgdGhpcy5fYWRkU3VnZ2VzdGlvbihtYXRjaCwgdGVybSlcbiAgICAgIH1cblxuICAgICAgdGhpcy5vcGVuKClcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGFuZ2UgZXZlbnRcbiAqXG4gKiBAZXZlbnQgQXV0b2NvbXBsZXRlI2NoYW5nZVxuICogQHR5cGUge29iamVjdH1cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZTxIVE1MRWxlbWVudD4oXCIuaW5wdXQtZmllbGQtLWF1dG9jb21wbGV0ZVwiLCAoZSkgPT4ge1xuICAgIG5ldyBBdXRvY29tcGxldGUoZSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgQXV0b2NvbXBsZXRlXG4iLCJpbXBvcnQgeyBzZWFyY2hBbmRJbml0aWFsaXplLCByZW1vdmUgfSBmcm9tIFwiLi4vVXRpbHNcIlxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuaW1wb3J0IGZsYXRwaWNrciBmcm9tIFwiZmxhdHBpY2tyXCJcblxuaW1wb3J0IHsgSXRhbGlhbiB9IGZyb20gXCJmbGF0cGlja3IvZGlzdC9sMTBuL2l0LmpzXCJcbmltcG9ydCB7IEZyZW5jaCB9IGZyb20gXCJmbGF0cGlja3IvZGlzdC9sMTBuL2ZyLmpzXCJcbmltcG9ydCB7IEdlcm1hbiB9IGZyb20gXCJmbGF0cGlja3IvZGlzdC9sMTBuL2RlLmpzXCJcblxuZmxhdHBpY2tyLmxvY2FsaXplKEl0YWxpYW4pXG5mbGF0cGlja3IubG9jYWxpemUoRnJlbmNoKVxuZmxhdHBpY2tyLmxvY2FsaXplKEdlcm1hbilcblxuY29uc3QgREVGQVVMVFNfRkxBVFBJQ0tSID0ge1xuICB3cmFwOiB0cnVlLCAvLyBlbmFibGUgY2FsZW5kYXIgdG9nZ2xlIGljb25cbiAgYWxsb3dJbnB1dDogdHJ1ZSwgLy8gZG9uJ3Qgc2V0IGlucHV0IHRvIHJlYWRvbmx5XG4gIGxvY2FsZTogXCJkZVwiLCAvLyBHZXJtYW4gaXMgZGVmYXVsdFxuICBkYXRlRm9ybWF0OiBcImQubS5ZXCIsIC8vIDE1LjAxLjIwMTdcbiAgdGltZV8yNGhyOiB0cnVlXG59XG5cbmNvbnN0IENMQVNTX0hBU19WQUxVRSA9IFwiaXMtZml4ZWRcIlxuY29uc3QgQ0xBU1NfTUVTU0FHRSA9IFwiLm1lc3NhZ2VcIlxuXG4vKipcbiAqIElucHV0IGZpZWxkIGNvbXBvbmVudFxuICovXG5jbGFzcyBJbnB1dEZpZWxkIGV4dGVuZHMgRG9tRWxlbWVudDxIVE1MSW5wdXRFbGVtZW50PiB7XG4gIHByaXZhdGUgX2NoYW5nZWRIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfYW5pbWF0aW9uU3RhcnRIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfZmxhdHBpY2tySW5zdGFuY2U6IGFueVxuICBwcml2YXRlIF9kYXRlUGlja2VyT3B0aW9uczogYW55XG5cbiAgY29uc3RydWN0b3IoZWxlbWVudDogSFRNTElucHV0RWxlbWVudCwgZGF0ZVBpY2tlck9wdGlvbnM/OiBhbnkpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgdGhpcy5fY2hhbmdlZEhhbmRsZXIgPSB0aGlzLm9uVmFsdWVDaGFuZ2VkLmJpbmQodGhpcylcbiAgICB0aGlzLl9hbmltYXRpb25TdGFydEhhbmRsZXIgPSB0aGlzLl9vbkFuaW1hdGlvblN0YXJ0LmJpbmQodGhpcylcbiAgICB0aGlzLl9kYXRlUGlja2VyT3B0aW9ucyA9IGRhdGVQaWNrZXJPcHRpb25zXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGlucHV0IGZpZWxkIGNvbXBvbmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHRoaXMuX2NoYW5nZWRIYW5kbGVyKVxuXG4gICAgaWYgKHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpID09PSBcInBhc3N3b3JkXCIpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uc3RhcnRcIiwgdGhpcy5fYW5pbWF0aW9uU3RhcnRIYW5kbGVyKVxuICAgIH1cblxuICAgIHRoaXMuX2luaXRpYWxpemVEYXRlUGlja2VyKClcbiAgICB0aGlzLm9uVmFsdWVDaGFuZ2VkKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZURhdGVQaWNrZXIoKSB7XG4gICAgY29uc3QgcGlja2VyID0gdGhpcy5lbGVtZW50LnBhcmVudEVsZW1lbnRcbiAgICBpZiAoIXBpY2tlciB8fCAhcGlja2VyLmNsYXNzTGlzdC5jb250YWlucyhcImZsYXRwaWNrclwiKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICghdGhpcy5fZGF0ZVBpY2tlck9wdGlvbnMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX2RhdGVQaWNrZXJPcHRpb25zID0gSlNPTi5wYXJzZShwaWNrZXIuZGF0YXNldC5vcHRpb25zIHx8IFwie31cIilcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5fZGF0ZVBpY2tlck9wdGlvbnMgPSB7fVxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLndhcm4oXCJfaW5pdGlhbGl6ZURhdGVQaWNrZXIgSlNPTi5wYXJzZSBmYWlsZWRcIiwgcGlja2VyLmRhdGFzZXQub3B0aW9ucywgZSlcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZmxhdHBpY2tySW5zdGFuY2UgPSBmbGF0cGlja3IocGlja2VyLCBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUU19GTEFUUElDS1IsIHRoaXMuX2RhdGVQaWNrZXJPcHRpb25zKSlcbiAgfVxuXG4gIHByb3RlY3RlZCBfZGVzdHJveURhdGVQaWNrZXIoKSB7XG4gICAgaWYgKHRoaXMuX2ZsYXRwaWNrckluc3RhbmNlKSB7XG4gICAgICB0aGlzLl9mbGF0cGlja3JJbnN0YW5jZS5kZXN0cm95KClcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX29uQW5pbWF0aW9uU3RhcnQoZTogQW5pbWF0aW9uRXZlbnQpIHtcbiAgICBpZiAoZS5hbmltYXRpb25OYW1lID09PSBcIm9uQXV0b0ZpbGxTdGFydFwiKSB7XG4gICAgICB0aGlzLm9uVmFsdWVDaGFuZ2VkKHRydWUpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE5vdGlmaWVzIHRoZSBpbnB1dCBmaWVsZCBjb21wb25lbnQgdGhhdCBpdCdzIHZhbHVlIGhhcyBiZWVuIGNoYW5nZWQuXG4gICAqL1xuICBwdWJsaWMgb25WYWx1ZUNoYW5nZWQoZm9yY2UgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmVsZW1lbnQudmFsdWUgJiYgdGhpcy5lbGVtZW50LnZhbHVlICE9PSBcIlwiIHx8IGZvcmNlID09PSB0cnVlKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKENMQVNTX0hBU19WQUxVRSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVDbGFzcyhDTEFTU19IQVNfVkFMVUUpXG4gICAgICB0aGlzLmVsZW1lbnQudmFsdWUgPSBcIlwiXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBjb21wb25lbnQgYW5kIGZyZWVzIGFsbCByZWZlcmVuY2VzLlxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLl9jaGFuZ2VkSGFuZGxlcilcblxuICAgIGlmICh0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSA9PT0gXCJwYXNzd29yZFwiKSB7XG4gICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbnN0YXJ0XCIsIHRoaXMuX2FuaW1hdGlvblN0YXJ0SGFuZGxlcilcbiAgICB9XG5cbiAgICAodGhpcyBhcyBhbnkpLl9jaGFuZ2VkSGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICAodGhpcyBhcyBhbnkpLl9hbmltYXRpb25TdGFydEhhbmRsZXIgPSB1bmRlZmluZWRcblxuICAgIHRoaXMuX2Rlc3Ryb3lEYXRlUGlja2VyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwbGF5cyB0aGUgc3BlY2lmaWVkIGVycm9yIHRleHQgdW5kZXJuZWF0aCB0aGUgaW5wdXQgZmllbGQuXG4gICAqIEBwYXJhbSB7dGV4dH0gdGV4dCBUaGUgZXJyb3IgdGV4dC9odG1sIHRvIGRpc3BsYXk7IG9yIHVuZGVmaW5lZCB0byBoaWRlIHRoZSBtZXNzYWdlLlxuICAgKi9cbiAgcHVibGljIHNob3dFcnJvcih0ZXh0OiBzdHJpbmcpIHtcbiAgICBsZXQgbWVzc2FnZVxuICAgIGlmICh0aGlzLmVsZW1lbnQucGFyZW50RWxlbWVudCkge1xuICAgICAgbGV0IG1zZyA9IHRoaXMuZWxlbWVudC5wYXJlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoQ0xBU1NfTUVTU0FHRSlcblxuICAgICAgaWYgKG1zZykge1xuICAgICAgICBtZXNzYWdlID0gbmV3IERvbUVsZW1lbnQobXNnKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGV4dCB8fCB0ZXh0ID09PSBcIlwiKSB7XG4gICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICByZW1vdmUobWVzc2FnZS5lbGVtZW50KVxuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKFwiaW52YWxpZFwiKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5hZGRDbGFzcyhcImludmFsaWRcIilcblxuICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgbWVzc2FnZSA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAgIC5hZGRDbGFzcyhcIm1lc3NhZ2VcIilcblxuICAgICAgdGhpcy5lbGVtZW50LnBhcmVudEVsZW1lbnQhLmFwcGVuZENoaWxkKG1lc3NhZ2UuZWxlbWVudClcbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZS5lbXB0eSgpXG4gICAgfVxuXG4gICAgY29uc3QgaWNvbiA9IG5ldyBEb21FbGVtZW50KFwiaVwiKVxuICAgICAgLmFkZENsYXNzKFwiaWNvblwiKVxuICAgICAgLmFkZENsYXNzKFwiaWNvbi0wMjYtZXhjbGFtYXRpb24tbWFyay1jaXJjbGVcIilcbiAgICAgIC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIilcblxuICAgIGNvbnN0IG1zZyA9IG5ldyBEb21FbGVtZW50KFwic3BhblwiKVxuICAgICAgLnNldEh0bWwodGV4dClcblxuICAgIG1lc3NhZ2UuYXBwZW5kQ2hpbGQoaWNvbilcbiAgICBtZXNzYWdlLmFwcGVuZENoaWxkKG1zZylcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZTxIVE1MSW5wdXRFbGVtZW50PihcIi5pbnB1dC1maWVsZCBpbnB1dFwiLCAoZSkgPT4ge1xuICAgIG5ldyBJbnB1dEZpZWxkKGUpXG4gIH0sIChlKSA9PiBlLnBhcmVudEVsZW1lbnQhKVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbnB1dEZpZWxkXG4iLCJpbXBvcnQgYW5pbWUgZnJvbSBcImFuaW1lanNcIlxuXG5pbXBvcnQgeyBzZWFyY2hBbmRJbml0aWFsaXplLCBjbGFtcCwgcHJldmVudERlZmF1bHQgfSBmcm9tIFwiLi4vVXRpbHNcIlxuaW1wb3J0ICogYXMgSW5wdXRzIGZyb20gXCIuLi9JbnB1dHNcIlxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuXG5jb25zdCBNQVJHSU5fVElDSyA9IDMyXG5jb25zdCBDTEFTU19IVE1MNSA9IFwiaHRtbDVcIlxuY29uc3QgUkFOR0VfTElHSFQgPSBcInJhbmdlLS1saWdodFwiXG5cbmNvbnN0IENMQVNTX0NPTlRBSU5FUiA9IFwicmFuZ2UtY29udGFpbmVyXCJcbmNvbnN0IENMQVNTX1NMSURFUiA9IFwicmFuZ2Utc2xpZGVyXCJcbmNvbnN0IENMQVNTX0FDVElWRSA9IFwicmFuZ2UtLWFjdGl2ZVwiXG5cbmNvbnN0IENMQVNTX1RSQUNLID0gXCJyYW5nZS10cmFja1wiXG5jb25zdCBDTEFTU19UUkFDS19QUk9HUkVTUyA9IFwicmFuZ2UtdHJhY2tfX3Byb2dyZXNzXCJcblxuY29uc3QgQ0xBU1NfVElDSyA9IFwicmFuZ2UtdGlja1wiXG5jb25zdCBDTEFTU19USUNLX0xBQkVMID0gXCJyYW5nZS10aWNrX19sYWJlbFwiXG5jb25zdCBDTEFTU19USUNLX0FDVElWRSA9IFwicmFuZ2UtdGljay0tYWN0aXZlXCJcblxuY29uc3QgQ0xBU1NfVEhVTUIgPSBcInJhbmdlLXRodW1iXCJcbmNvbnN0IENMQVNTX1RIVU1CX1ZBTFVFID0gXCJyYW5nZS10aHVtYl9fdmFsdWVcIlxuY29uc3QgQ0xBU1NfRElTQUJMRUQgPSBcInJhbmdlLS1kaXNhYmxlZFwiXG5cbmNvbnN0IENMQVNTX0RSQUdHSU5HID0gXCJyYW5nZS0tZHJhZ2dpbmdcIlxuXG5leHBvcnQgaW50ZXJmYWNlIEZvcm1hdHRlciB7XG4gICh2YWx1ZTogbnVtYmVyLCBzaG9ydDogYm9vbGVhbik6IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbiB7XG4gIHZhbHVlOiBudW1iZXJcbiAgbGFiZWw6IHN0cmluZyB8IG51bWJlclxufVxuXG4vKipcbiAqIFRoZSByYW5nZSBzbGlkZXIgY29tcG9uZW50IGRlZmluaXRpb24uXG4gKi9cbmNsYXNzIFJhbmdlIGV4dGVuZHMgRG9tRWxlbWVudDxIVE1MSW5wdXRFbGVtZW50PiB7XG4gIHByaXZhdGUgX2Rvd25IYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfbW92ZUhhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9lbmRIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfa2V5ZG93bkhhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9mb2N1c0hhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9ibHVySGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX3Jlc2l6ZUhhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuXG4gIHByaXZhdGUgX3dyYXBwZXJFbGVtZW50ITogRG9tRWxlbWVudDxIVE1MRWxlbWVudD5cbiAgcHJpdmF0ZSBfcmFuZ2VDb250YWluZXIhOiBEb21FbGVtZW50PEhUTUxEaXZFbGVtZW50PlxuICBwcml2YXRlIF9yYW5nZVRyYWNrITogRG9tRWxlbWVudDxIVE1MRGl2RWxlbWVudD5cbiAgcHJpdmF0ZSBfcmFuZ2VQcm9ncmVzcyE6IERvbUVsZW1lbnQ8SFRNTERpdkVsZW1lbnQ+XG4gIHByaXZhdGUgX3RpY2tzV3JhcHBlciE6IERvbUVsZW1lbnQ8SFRNTERpdkVsZW1lbnQ+XG4gIHByaXZhdGUgX3JhbmdlVGh1bWIhOiBEb21FbGVtZW50PEhUTUxEaXZFbGVtZW50PlxuICBwcml2YXRlIF90aHVtYlZhbHVlITogRG9tRWxlbWVudDxIVE1MRGl2RWxlbWVudD5cbiAgcHJpdmF0ZSBfb3V0cHV0TGFiZWw/OiBEb21FbGVtZW50PEVsZW1lbnQ+XG5cbiAgcHJpdmF0ZSBfbWluVmFsdWUhOiBudW1iZXJcbiAgcHJpdmF0ZSBfbWF4VmFsdWUhOiBudW1iZXJcbiAgcHJpdmF0ZSBfdHJhY2tWYWx1ZVRvdGFsITogbnVtYmVyXG5cbiAgcHJpdmF0ZSBfZ3JhYlBvc2l0aW9uITogbnVtYmVyXG4gIHByaXZhdGUgX3RyYWNrV2lkdGghOiBudW1iZXJcbiAgcHJpdmF0ZSBfdHJhY2tQb3NpdGlvbk1pbiE6IG51bWJlclxuICBwcml2YXRlIF90cmFja1Bvc2l0aW9uTWF4ITogbnVtYmVyXG4gIHByaXZhdGUgX3RyYWNrTGVmdFBvc2l0aW9uITogbnVtYmVyXG4gIHByaXZhdGUgX2l0ZW1XaWR0aCE6IG51bWJlclxuXG4gIHByaXZhdGUgX2Zvcm1hdHRlciE6IEZvcm1hdHRlclxuXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEhUTUxJbnB1dEVsZW1lbnQpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgLy8gU2V0dXAgZXZlbnQgY29udGV4dFxuICAgIHRoaXMuX2Rvd25IYW5kbGVyID0gdGhpcy5faGFuZGxlRG93bi5iaW5kKHRoaXMpXG4gICAgdGhpcy5fbW92ZUhhbmRsZXIgPSB0aGlzLl9oYW5kbGVNb3ZlLmJpbmQodGhpcylcbiAgICB0aGlzLl9lbmRIYW5kbGVyID0gdGhpcy5faGFuZGxlRW5kLmJpbmQodGhpcylcbiAgICB0aGlzLl9rZXlkb3duSGFuZGxlciA9IHRoaXMuX2hhbmRsZUtleWRvd24uYmluZCh0aGlzKVxuXG4gICAgdGhpcy5fZm9jdXNIYW5kbGVyID0gdGhpcy5faGFuZGxlRm9jdXMuYmluZCh0aGlzKVxuICAgIHRoaXMuX2JsdXJIYW5kbGVyID0gdGhpcy5faGFuZGxlQmx1ci5iaW5kKHRoaXMpXG4gICAgdGhpcy5fcmVzaXplSGFuZGxlciA9IHRoaXMubGF5b3V0LmJpbmQodGhpcylcblxuICAgIHRoaXMuX2luaXRpYWxpemUoKVxuXG4gICAgaWYgKHRoaXMuZWxlbWVudC5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5kaXNhYmxlKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbmFibGUoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgcmFuZ2Ugc2xpZGVyIGNvbXBvbmVudC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaW5zcGVjdHMgdGhlIHNlbGVjdCBkZWZpbml0aW9uIGFuZCBpdHMgb3B0aW9ucyBhbmRcbiAgICogZ2VuZXJhdGVzIG5ldyBzdHlsYWJsZSBET00gZWxlbWVudHMgYXJvdW5kIHRoZSBvcmlnaW5hbCByYW5nZSBpbnB1dC1lbGVtZW50XG4gICAqIGRlZmluaXRpb25zLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplKCkge1xuXG4gICAgaWYgKHRoaXMuaGFzQ2xhc3MoQ0xBU1NfSFRNTDUpKSB7XG4gICAgICAvLyBUaGlzIGVsZW1lbnQgdXNlcyBIVE1MNSBzdHlsaW5nLCBkbyBub3QgdG91Y2ggaXQuLi5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQodGhpcy5lbGVtZW50LnBhcmVudEVsZW1lbnQhKVxuXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIgPSBuZXcgRG9tRWxlbWVudDxIVE1MRGl2RWxlbWVudD4oXCJkaXZcIilcbiAgICAgIC5hZGRDbGFzcyhDTEFTU19DT05UQUlORVIpXG5cbiAgICB0aGlzLl9yYW5nZVRyYWNrID0gbmV3IERvbUVsZW1lbnQ8SFRNTERpdkVsZW1lbnQ+KFwiZGl2XCIpXG4gICAgICAuYWRkQ2xhc3MoQ0xBU1NfVFJBQ0spXG5cbiAgICAvLyBjaGVjayBpZiByYW5nZS0tbGlnaHQgc2xpZGVyIHRoZW4gYWRkIHByb2dyZXNzXG4gICAgaWYgKHRoaXMuX3dyYXBwZXJFbGVtZW50Lmhhc0NsYXNzKFJBTkdFX0xJR0hUKSkge1xuICAgICAgdGhpcy5fcmFuZ2VQcm9ncmVzcyA9IG5ldyBEb21FbGVtZW50PEhUTUxEaXZFbGVtZW50PihcImRpdlwiKVxuICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfVFJBQ0tfUFJPR1JFU1MpXG5cbiAgICAgIHRoaXMuX3JhbmdlVHJhY2suYXBwZW5kQ2hpbGQodGhpcy5fcmFuZ2VQcm9ncmVzcylcbiAgICB9XG5cbiAgICB0aGlzLl9yYW5nZVRodW1iID0gbmV3IERvbUVsZW1lbnQ8SFRNTERpdkVsZW1lbnQ+KFwiZGl2XCIpXG4gICAgICAuYWRkQ2xhc3MoQ0xBU1NfVEhVTUIpXG5cbiAgICB0aGlzLl90aWNrc1dyYXBwZXIgPSBuZXcgRG9tRWxlbWVudDxIVE1MRGl2RWxlbWVudD4oXCJkaXZcIilcbiAgICAgIC5hZGRDbGFzcyhDTEFTU19TTElERVIpXG5cbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9yYW5nZVRyYWNrKVxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX3RpY2tzV3JhcHBlcilcbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9yYW5nZVRodW1iKVxuXG4gICAgLy8gYWRkIGNvbnRhaW5lciB0byB3cmFwcGVyXG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fcmFuZ2VDb250YWluZXIpXG5cbiAgICAvLyBnZXQgbWluICYgbWF4IGRlZmluaXRpb25zXG4gICAgdGhpcy5fbWluVmFsdWUgPSBwYXJzZUZsb2F0KHRoaXMuZWxlbWVudC5taW4pIHx8IDBcbiAgICB0aGlzLl9tYXhWYWx1ZSA9IHBhcnNlRmxvYXQodGhpcy5lbGVtZW50Lm1heCkgfHwgMVxuXG4gICAgLy8gZ2V0IHRoZSBsYWJlbC9vdXRwdXQgZm9ybWF0IHN0cmluZ1xuICAgIHRoaXMuX2Zvcm1hdHRlciA9ICh3aW5kb3cgYXMgYW55KVt0aGlzLmdldEF0dHJpYnV0ZShcImZvcm1hdHRlclwiKSFdXG5cbiAgICAvLyBnZXQgdGhlIG91dHB1dCBsYWJlbCBhbmQgbW92ZSBpdCBiZWxvdyB0aGUgY29udGFpbmVyXG4gICAgaWYgKHRoaXMuZWxlbWVudC5pZCkge1xuICAgICAgdGhpcy5fb3V0cHV0TGFiZWwgPSB0aGlzLl93cmFwcGVyRWxlbWVudC5maW5kKGBvdXRwdXRbZm9yPScke3RoaXMuZWxlbWVudC5pZH0nXWApXG4gICAgICBpZiAodGhpcy5fb3V0cHV0TGFiZWwpIHtcbiAgICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fb3V0cHV0TGFiZWwpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmVsZW1lbnQuc3RlcCkge1xuICAgICAgLy8gZml4IGlzc3VlcyB3aXRoIGZsb2F0IHNsaWRlcnMgaWYgdGhlIHN0ZXAgaXMgdW5kZWZpbmVkXG4gICAgICB0aGlzLmVsZW1lbnQuc3RlcCA9IFwiYW55XCJcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fZ2V0T3B0aW9uc0xpc3QoKVxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy5fYWRkVGlja3Mob3B0aW9ucylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmFuZ2VDb250YWluZXIuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuJHtDTEFTU19USUNLX0xBQkVMfWApLmxlbmd0aCA8PSAxKSB7XG4gICAgICB0aGlzLl90aHVtYlZhbHVlID0gbmV3IERvbUVsZW1lbnQ8SFRNTERpdkVsZW1lbnQ+KFwiZGl2XCIpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19USFVNQl9WQUxVRSlcblxuICAgICAgdGhpcy5fcmFuZ2VUaHVtYi5hcHBlbmRDaGlsZCh0aGlzLl90aHVtYlZhbHVlKVxuICAgIH1cblxuICAgIHRoaXMuX3RyYWNrVmFsdWVUb3RhbCA9IHRoaXMuX21heFZhbHVlIC0gdGhpcy5fbWluVmFsdWVcbiAgICB0aGlzLmxheW91dCgpXG5cbiAgICB0aGlzLl91cGRhdGVUaWNrU3RhdGUoKVxuXG4gICAgLy8gQXBwbHkgdGhlIHRhYiBpbmRleFxuICAgIGNvbnN0IHRhYkluZGV4ID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInRhYmluZGV4XCIpXG4gICAgaWYgKHRhYkluZGV4KSB7XG4gICAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCB0YWJJbmRleClcbiAgICB9XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLl9yZXNpemVIYW5kbGVyKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgdGhpcy5fcmVzaXplSGFuZGxlcilcbiAgfVxuXG4gIHByb3RlY3RlZCBfZ2V0T3B0aW9uc0xpc3QoKSB7XG4gICAgbGV0IG9wdGlvbnM6IE9wdGlvbltdID0gW11cblxuICAgIGxldCBsaXN0SWQgPSB0aGlzLmdldEF0dHJpYnV0ZShcImxpc3RcIilcbiAgICBpZiAobGlzdElkKSB7XG4gICAgICBsZXQgZGF0YUxpc3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAjJHtsaXN0SWR9YClcbiAgICAgIGlmIChkYXRhTGlzdCkge1xuICAgICAgICBmb3IgKGxldCBlbnRyeSBvZiBkYXRhTGlzdC5xdWVyeVNlbGVjdG9yQWxsKFwib3B0aW9uXCIpKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gcGFyc2VGbG9hdChlbnRyeS5pbm5lclRleHQpXG4gICAgICAgICAgbGV0IGxhYmVsID0gZW50cnkuZ2V0QXR0cmlidXRlKFwibGFiZWxcIikgfHwgcGFyc2VGbG9hdCh2YWx1ZS50b0ZpeGVkKDIpKVxuXG4gICAgICAgICAgb3B0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgbGFiZWxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU29ydCB0aGUgbGlzdCB0byBlbmFibGUgc25hcHBpbmdcbiAgICBvcHRpb25zID0gb3B0aW9ucy5zb3J0KChhLCBiKSA9PiBhLnZhbHVlIC0gYi52YWx1ZSlcblxuICAgIGlmIChvcHRpb25zLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRoaXMuX21pblZhbHVlID0gTnVtYmVyLk1BWF9WQUxVRVxuICAgICAgdGhpcy5fbWF4VmFsdWUgPSBOdW1iZXIuTUlOX1ZBTFVFXG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9taW5WYWx1ZSA9IE1hdGgubWluKHRoaXMuX21pblZhbHVlLCBvcHRpb25zW2ldLnZhbHVlKVxuICAgICAgICB0aGlzLl9tYXhWYWx1ZSA9IE1hdGgubWF4KHRoaXMuX21heFZhbHVlLCBvcHRpb25zW2ldLnZhbHVlKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvcHRpb25zXG4gIH1cblxuICBwcm90ZWN0ZWQgX2FkZFRpY2tzKGRhdGFJdGVtczogT3B0aW9uW10pIHtcbiAgICBmb3IgKGxldCBlbnRyeSBvZiBkYXRhSXRlbXMpIHtcbiAgICAgIGxldCB0aWNrRWxlbWVudCA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAgIC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIsIFN0cmluZyhlbnRyeS52YWx1ZSkpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19USUNLKVxuXG4gICAgICBsZXQgdGlja0xhYmVsID0gbmV3IERvbUVsZW1lbnQoXCJzcGFuXCIpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19USUNLX0xBQkVMKVxuICAgICAgICAuc2V0SHRtbChTdHJpbmcoZW50cnkubGFiZWwpKVxuXG4gICAgICB0aWNrRWxlbWVudC5hcHBlbmRDaGlsZCh0aWNrTGFiZWwpXG4gICAgICB0aGlzLl90aWNrc1dyYXBwZXIuYXBwZW5kQ2hpbGQodGlja0VsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9pc0V2ZW50T25MYWJlbChldmVudDogRXZlbnQpIHtcbiAgICByZXR1cm4gKGV2ZW50LnRhcmdldCBhcyBFbGVtZW50KS5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfVElDS19MQUJFTClcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlRG93bihldmVudDogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQpIHtcbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5hZGRDbGFzcyhDTEFTU19EUkFHR0lORylcblxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5fZW5kSGFuZGxlcilcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX21vdmVIYW5kbGVyKVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMuX2VuZEhhbmRsZXIpXG5cbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5fbW92ZUhhbmRsZXIpXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX2VuZEhhbmRsZXIpXG5cbiAgICAvLyBJZ25vcmUgY2xpY2tzIGRpcmVjdGx5IG9uIHRoZSB0aHVtYlxuICAgIGlmIChldmVudC50YXJnZXQgIT09IHRoaXMuX3JhbmdlVGh1bWIuZWxlbWVudCAmJiAhdGhpcy5faXNFdmVudE9uTGFiZWwoZXZlbnQpKSB7XG4gICAgICBsZXQgcG9zID0gdGhpcy5fZ2V0UmVsYXRpdmVQb3NpdGlvbihldmVudClcbiAgICAgIHRoaXMuX3NldFBvc2l0aW9uKHBvcywgdHJ1ZSwgZmFsc2UsIGZhbHNlKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlTW92ZShldmVudDogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQpIHtcbiAgICBwcmV2ZW50RGVmYXVsdChldmVudClcbiAgICB0aGlzLl91bmZvY3VzKClcblxuICAgIGlmICghdGhpcy5faXNFdmVudE9uTGFiZWwoZXZlbnQpKSB7XG4gICAgICBsZXQgcG9zID0gdGhpcy5fZ2V0UmVsYXRpdmVQb3NpdGlvbihldmVudClcbiAgICAgIHRoaXMuX3NldFBvc2l0aW9uKHBvcywgdHJ1ZSwgZmFsc2UsIGZhbHNlKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlRW5kKGV2ZW50OiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCkge1xuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LnJlbW92ZUNsYXNzKENMQVNTX0RSQUdHSU5HKVxuXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLl9lbmRIYW5kbGVyKVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMuX2VuZEhhbmRsZXIpXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9tb3ZlSGFuZGxlcilcblxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLl9tb3ZlSGFuZGxlcilcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fZW5kSGFuZGxlcilcblxuICAgIGxldCBwb3MgPSB0aGlzLl9nZXRSZWxhdGl2ZVBvc2l0aW9uKGV2ZW50KVxuICAgIHRoaXMuX3NldFBvc2l0aW9uKHBvcywgdHJ1ZSwgdHJ1ZSwgdHJ1ZSlcbiAgICB0aGlzLl9oYW5kbGVCbHVyKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlS2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgIGxldCBrZXljb2RlID0gZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZVxuXG4gICAgaWYgKGtleWNvZGUgPT09IElucHV0cy5LRVlfRVNDQVBFKSB7XG4gICAgICAvLyBoYW5kbGUgRXNjYXBlIGtleSAoRVNDKVxuICAgICAgdGhpcy5fcmFuZ2VDb250YWluZXIuZWxlbWVudC5ibHVyKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGlzVXAgPSBrZXljb2RlID09PSBJbnB1dHMuS0VZX0FSUk9XX1VQIHx8IGtleWNvZGUgPT09IElucHV0cy5LRVlfQVJST1dfUklHSFRcbiAgICAgIHx8IGtleWNvZGUgPT09IElucHV0cy5LRVlfUEFHRV9VUFxuXG4gICAgY29uc3QgaXNEb3duID0ga2V5Y29kZSA9PT0gSW5wdXRzLktFWV9BUlJPV19ET1dOIHx8IGtleWNvZGUgPT09IElucHV0cy5LRVlfQVJST1dfTEVGVFxuICAgICAgfHwga2V5Y29kZSA9PT0gSW5wdXRzLktFWV9QQUdFX0RPV05cblxuICAgIGlmIChpc1VwIHx8IGlzRG93bikge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuXG4gICAgICBsZXQgZGlyZWN0aW9uID0gaXNEb3duID8gLTEgOiAxXG5cbiAgICAgIC8vIG1ha2UgYSBsYXJnZXIgc3RlcCBpZiBpdHMgdGhlIHZlcnRpY2FsIGFycm93IG9yIHBhZ2Uga2V5c1xuICAgICAgaWYgKGtleWNvZGUgPT09IElucHV0cy5LRVlfQVJST1dfVVAgfHwga2V5Y29kZSA9PT0gSW5wdXRzLktFWV9BUlJPV19ET1dOIHx8XG4gICAgICAgIGtleWNvZGUgPT09IElucHV0cy5LRVlfUEFHRV9VUCB8fCBrZXljb2RlID09PSBJbnB1dHMuS0VZX1BBR0VfRE9XTikge1xuICAgICAgICBkaXJlY3Rpb24gKj0gMTBcbiAgICAgIH1cblxuICAgICAgbGV0IHZhbCA9IHRoaXMudmFsdWVcbiAgICAgIGlmICh0aGlzLl90aWNrc1dyYXBwZXIuZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFsID0gdGhpcy5fZ2V0TmV4dFZhbHVlKHZhbCwgZGlyZWN0aW9uKVxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBsZXQgc3RlcDogc3RyaW5nIHwgbnVtYmVyID0gdGhpcy5lbGVtZW50LnN0ZXBcbiAgICAgICAgaWYgKCFzdGVwIHx8IHN0ZXAgPT09IFwiYW55XCIpIHtcbiAgICAgICAgICBzdGVwID0gXCIwLjFcIlxuICAgICAgICB9XG4gICAgICAgIGxldCBuZXdWYWwgPSB2YWwgKyAocGFyc2VGbG9hdChzdGVwKSAqIGRpcmVjdGlvbilcbiAgICAgICAgdmFsID0gbmV3VmFsXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NldFZhbHVlKHZhbCwgdHJ1ZSwgdHJ1ZSlcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlRm9jdXMoKSB7XG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuYWRkQ2xhc3MoQ0xBU1NfQUNUSVZFKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVCbHVyKCkge1xuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLnJlbW92ZUNsYXNzKENMQVNTX0FDVElWRSlcbiAgfVxuXG4gIHByb3RlY3RlZCBfdW5mb2N1cygpIHtcbiAgICBpZiAoKGRvY3VtZW50IGFzIGFueSkuc2VsZWN0aW9uKSB7XG4gICAgICAoZG9jdW1lbnQgYXMgYW55KS5zZWxlY3Rpb24uZW1wdHkoKVxuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkucmVtb3ZlQWxsUmFuZ2VzKClcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2dldFJlbGF0aXZlUG9zaXRpb24oZXZlbnQ6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50KSB7XG4gICAgbGV0IHBhZ2VYXG4gICAgaWYgKFwicGFnZVhcIiBpbiBldmVudCkge1xuICAgICAgcGFnZVggPSBldmVudC5wYWdlWFxuICAgIH0gZWxzZSB7XG4gICAgICBwYWdlWCA9IChldmVudC50b3VjaGVzWzBdIHx8IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdKS5wYWdlWFxuICAgIH1cblxuICAgIHJldHVybiBwYWdlWCAtIHRoaXMuX3RyYWNrTGVmdFBvc2l0aW9uICsgdGhpcy5fZ3JhYlBvc2l0aW9uXG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIGFuZCB1cGRhdGVzIHRoZSBwb3NpdGlvbiBhbmQgc2V0cyB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZSBvbiB0aGUgc2xpZGVyLlxuICAgKiBAcGFyYW0ge3Bvc2l0aW9ufSB0aGUgbmV3IHBvc2l0aW9uIHRvIHNldC5cbiAgICogQHBhcmFtIHt1cGRhdGVWYWx1ZX0gdHJ1ZSBpZiB0aGUgdmFsdWUgc2hvdWxkIGJlIHVwZGF0ZWQgYXMgd2VsbDsgb3RoZXJ3aXNlIGZhbHNlLlxuICAgKiBAcGFyYW0ge3NuYXB9IHRydWUgaWYgc25hcHBpbmcgc2hvdWxkIGJlIHVzZWQ7IG90aGVyd2lzZSBmYWxzZS5cbiAgICogQHBhcmFtIHthbmltYXRlfSB0cnVlIGlmIHRoZSBVSSB1cGRhdGUgc2hvdWxkIGJlIGFuaW1hdGVkOyBvdGhlcndpc2UgZmFsc2UuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX3NldFBvc2l0aW9uKFxuICAgIHBvc2l0aW9uOiBudW1iZXIsXG4gICAgdXBkYXRlVmFsdWUgPSB0cnVlLFxuICAgIHNuYXAgPSBmYWxzZSxcbiAgICBhbmltYXRlID0gdHJ1ZVxuICApIHtcbiAgICBpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbiA9PT0gbnVsbCB8fCBOdW1iZXIuaXNOYU4ocG9zaXRpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb3NpdGlvbiBpcyBub3QgYSBudW1iZXJcIilcbiAgICB9XG5cbiAgICAvLyBDbGFtcCB0byBtaW4gYW5kIG1heCByYW5nZVxuICAgIGxldCBuZXdQb3MgPSBjbGFtcChwb3NpdGlvbiwgdGhpcy5fdHJhY2tQb3NpdGlvbk1pbiwgdGhpcy5fdHJhY2tQb3NpdGlvbk1heClcbiAgICBpZiAodXBkYXRlVmFsdWUpIHtcbiAgICAgIGxldCB2YWx1ZSA9ICh0aGlzLl90cmFja1ZhbHVlVG90YWwgLyB0aGlzLl90cmFja1dpZHRoKSAqIG5ld1BvcyArIHRoaXMuX21pblZhbHVlXG5cbiAgICAgIGlmICh0aGlzLl90aWNrc1dyYXBwZXIuZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA+IDEgJiYgc25hcCkge1xuICAgICAgICBsZXQgc25hcFBvcyA9IHRoaXMuX2dldFNuYXBQb3NpdGlvbihuZXdQb3MpXG4gICAgICAgIG5ld1BvcyA9IHNuYXBQb3MucG9zaXRpb25cbiAgICAgICAgdmFsdWUgPSBzbmFwUG9zLnZhbHVlXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZWxlbWVudC5zdGVwICYmIHRoaXMuZWxlbWVudC5zdGVwICE9PSBcImFueVwiKSB7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSBwYXJzZUZsb2F0KHRoaXMuZWxlbWVudC5zdGVwKVxuICAgICAgICB2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUgLyBzdGVwKSAqIHN0ZXBcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2V0VmFsdWUodmFsdWUsIGZhbHNlLCBmYWxzZSlcbiAgICB9XG5cbiAgICBpZiAoYW5pbWF0ZSAmJiB1cGRhdGVWYWx1ZSkge1xuICAgICAgdGhpcy5fdXBkYXRlVGlja1N0YXRlKClcbiAgICB9XG5cbiAgICBpZiAoYW5pbWF0ZSkge1xuICAgICAgYW5pbWUoe1xuICAgICAgICB0YXJnZXRzOiB0aGlzLl9yYW5nZVRodW1iLmVsZW1lbnQsXG4gICAgICAgIGR1cmF0aW9uOiAyMDAsXG4gICAgICAgIGxlZnQ6IG5ld1BvcyxcbiAgICAgICAgZWFzaW5nOiBcImVhc2VJbk91dFF1aW50XCJcbiAgICAgIH0pXG5cbiAgICAgIGlmICh0aGlzLl9yYW5nZVByb2dyZXNzKSB7XG4gICAgICAgIGFuaW1lKHtcbiAgICAgICAgICB0YXJnZXRzOiB0aGlzLl9yYW5nZVByb2dyZXNzLmVsZW1lbnQsXG4gICAgICAgICAgZHVyYXRpb246IDIwMCxcbiAgICAgICAgICB3aWR0aDogbmV3UG9zLFxuICAgICAgICAgIGVhc2luZzogXCJlYXNlSW5PdXRRdWludFwiXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JhbmdlVGh1bWIuZWxlbWVudC5zdHlsZS5sZWZ0ID0gbmV3UG9zICsgXCJweFwiXG5cbiAgICAgIGlmICh0aGlzLl9yYW5nZVByb2dyZXNzKSB7XG4gICAgICAgIHRoaXMuX3JhbmdlUHJvZ3Jlc3MuZWxlbWVudC5zdHlsZS53aWR0aCA9IG5ld1BvcyArIFwicHhcIlxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzbmFwIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIHZhbHVlLlxuICAgKiBAcGFyYW0ge3ZhbHVlfSB0aGUgdGFyZ2V0IHZhbHVlLlxuICAgKiBAcmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgc25hcCBwb3NpdGlvbiBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX2dldFNuYXBWYWx1ZSh2YWx1ZTogbnVtYmVyKSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLl90aWNrc1dyYXBwZXIuZWxlbWVudC5jaGlsZHJlblxuICAgIGxldCBjdXJyZW50UG9zaXRpb24gPSAwXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgIGxldCBjdXJyZW50RWxlbWVudCA9IG5ldyBEb21FbGVtZW50KHRpY2tzW2ldKVxuICAgICAgbGV0IGN1cnJlbnRWYWx1ZSA9IHBhcnNlRmxvYXQoY3VycmVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiKSEpXG4gICAgICBsZXQgY3VycmVudFdpZHRoID0gY3VycmVudEVsZW1lbnQuZWxlbWVudC5jbGllbnRXaWR0aFxuXG4gICAgICBsZXQgbmV4dEVsZW1lbnRcbiAgICAgIGxldCBuZXh0VmFsdWUgPSBOdW1iZXIuTUFYX1ZBTFVFXG5cbiAgICAgIGlmIChpIDwgdGlja3MubGVuZ3RoIC0gMSkge1xuICAgICAgICBuZXh0RWxlbWVudCA9IG5ldyBEb21FbGVtZW50KHRpY2tzW2kgKyAxXSlcbiAgICAgICAgbmV4dFZhbHVlID0gcGFyc2VGbG9hdChuZXh0RWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpISlcbiAgICAgIH1cblxuICAgICAgLy8gbGVmdCBtb3N0IGVsZW1lbnRcbiAgICAgIGlmIChpID09PSAwICYmIHZhbHVlIDw9IGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBjdXJyZW50VmFsdWUsXG4gICAgICAgICAgcG9zaXRpb246IE1BUkdJTl9USUNLIC0gdGhpcy5fZ3JhYlBvc2l0aW9uXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcmlnaHQgbW9zdCBlbGVtZW50XG4gICAgICBpZiAoIW5leHRFbGVtZW50ICYmIHZhbHVlID49IGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBjdXJyZW50VmFsdWUsXG4gICAgICAgICAgcG9zaXRpb246IGN1cnJlbnRQb3NpdGlvbiArIChjdXJyZW50V2lkdGggLSBNQVJHSU5fVElDSykgLSB0aGlzLl9ncmFiUG9zaXRpb24gLSAxXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlID49IGN1cnJlbnRWYWx1ZSAmJiB2YWx1ZSA8IG5leHRWYWx1ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBjdXJyZW50VmFsdWUsXG4gICAgICAgICAgcG9zaXRpb246IGN1cnJlbnRQb3NpdGlvbiArICgwLjUgKiBjdXJyZW50V2lkdGgpIC0gdGhpcy5fZ3JhYlBvc2l0aW9uXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3VycmVudFBvc2l0aW9uICs9IGN1cnJlbnRXaWR0aFxuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBkZXRlcm1pbmUgc25hcCB2YWx1ZVwiKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNuYXAgcG9zaXRpb24gY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAqIEBwYXJhbSB7cG9zaXRpb259IHRoZSB0YXJnZXQgcG9zaXRpb24uXG4gICAqIEByZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBzbmFwIHBvc2l0aW9uIGFuZCB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfZ2V0U25hcFBvc2l0aW9uKHBvc2l0aW9uPzogbnVtYmVyIHwgbnVsbCkge1xuICAgIGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9uID09PSBudWxsIHx8IE51bWJlci5pc05hTihwb3NpdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInBvc2l0aW9uIGlzIG5vdCBhIG51bWJlclwiKVxuICAgIH1cblxuICAgIGNvbnN0IHRpY2tzID0gdGhpcy5fdGlja3NXcmFwcGVyLmVsZW1lbnQuY2hpbGRyZW5cbiAgICBsZXQgY3VycmVudFBvc2l0aW9uID0gMFxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuXG4gICAgICBsZXQgY3VycmVudEVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudCh0aWNrc1tpXSlcbiAgICAgIGxldCBjdXJyZW50VmFsdWUgPSBwYXJzZUZsb2F0KGN1cnJlbnRFbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIikhKVxuICAgICAgbGV0IGN1cnJlbnRXaWR0aCA9IGN1cnJlbnRFbGVtZW50LmVsZW1lbnQuY2xpZW50V2lkdGhcblxuICAgICAgbGV0IG5leHRFbGVtZW50XG5cbiAgICAgIGlmIChpIDwgdGlja3MubGVuZ3RoIC0gMSkge1xuICAgICAgICBuZXh0RWxlbWVudCA9IG5ldyBEb21FbGVtZW50KHRpY2tzW2kgKyAxXSlcbiAgICAgIH1cblxuICAgICAgLy8gbGVmdCBtb3N0IGVsZW1lbnRcbiAgICAgIGlmIChpID09PSAwICYmIHBvc2l0aW9uIDw9IGN1cnJlbnRQb3NpdGlvbiArIGN1cnJlbnRXaWR0aCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBjdXJyZW50VmFsdWUsXG4gICAgICAgICAgcG9zaXRpb246IE1BUkdJTl9USUNLIC0gdGhpcy5fZ3JhYlBvc2l0aW9uXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcmlnaHQgbW9zdCBlbGVtZW50XG4gICAgICBpZiAoIW5leHRFbGVtZW50ICYmIHBvc2l0aW9uID49IGN1cnJlbnRQb3NpdGlvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBjdXJyZW50VmFsdWUsXG4gICAgICAgICAgcG9zaXRpb246IGN1cnJlbnRQb3NpdGlvbiArIChjdXJyZW50V2lkdGggLSBNQVJHSU5fVElDSykgLSB0aGlzLl9ncmFiUG9zaXRpb24gLSAxXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHBvc2l0aW9uID49IGN1cnJlbnRQb3NpdGlvbiAmJiBwb3NpdGlvbiA8IChjdXJyZW50UG9zaXRpb24gKyBjdXJyZW50V2lkdGgpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IGN1cnJlbnRWYWx1ZSxcbiAgICAgICAgICBwb3NpdGlvbjogY3VycmVudFBvc2l0aW9uICsgKDAuNSAqIGN1cnJlbnRXaWR0aCkgLSB0aGlzLl9ncmFiUG9zaXRpb25cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjdXJyZW50UG9zaXRpb24gKz0gY3VycmVudFdpZHRoXG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGRldGVybWluZSBzbmFwIHBvc2l0aW9uXCIpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbmV4dCB2YWx1ZSBpbiB0aGUgZ2l2ZW4gZGlyZWN0aW9uIHdpdGggcmVnYXJkcyB0byBzbmFwcGluZy5cbiAgICogQHBhcmFtIHt2YWx1ZX0gVGhlIGN1cnJlbnQgdmFsdWUuXG4gICAqIEBwYXJhbSB7ZGlyZWN0aW9ufSBUaGUgZGlyZWN0aW9uIChwb3NpdGl2ZSBvciBuZWdhdGl2ZSBpbnRlZ2VyKS5cbiAgICogQHJldHVybnMgVGhlIG5leHQgdmFsdWUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX2dldE5leHRWYWx1ZSh2YWx1ZTogbnVtYmVyLCBkaXJlY3Rpb246IG51bWJlcikge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy5fdGlja3NXcmFwcGVyLmVsZW1lbnQuY2hpbGRyZW5cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGlja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQodGlja3NbaV0pXG4gICAgICBsZXQgY3VycmVudFZhbCA9IHBhcnNlRmxvYXQoY3VycmVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiKSEpXG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gY3VycmVudFZhbCkge1xuICAgICAgICBsZXQgaW5kZXggPSBjbGFtcChpICsgZGlyZWN0aW9uLCAwLCB0aWNrcy5sZW5ndGggLSAxKVxuICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodGlja3NbaW5kZXhdLmdldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIikhKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgcHJvdGVjdGVkIF91cGRhdGVUaWNrU3RhdGUoKSB7XG4gICAgaWYgKHRoaXMuX3RpY2tzV3JhcHBlci5lbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgbGV0IGFjdGl2ZVRpY2sgPSB0aGlzLl90aWNrc1dyYXBwZXIuZmluZChgLiR7Q0xBU1NfVElDS19BQ1RJVkV9YClcbiAgICAgIGlmIChhY3RpdmVUaWNrKSB7XG4gICAgICAgIGFjdGl2ZVRpY2sucmVtb3ZlQ2xhc3MoQ0xBU1NfVElDS19BQ1RJVkUpXG4gICAgICB9XG4gICAgICBsZXQgbmV3QWN0aXZlVGljayA9IHRoaXMuX3RpY2tzV3JhcHBlci5maW5kKGAuJHtDTEFTU19USUNLfVtkYXRhLXZhbHVlPScke3RoaXMudmFsdWV9J11gKVxuICAgICAgaWYgKG5ld0FjdGl2ZVRpY2spIHtcbiAgICAgICAgbmV3QWN0aXZlVGljay5hZGRDbGFzcyhDTEFTU19USUNLX0FDVElWRSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2FkanVzdFRpY2tMYWJlbFBvc2l0aW9uKFxuICAgIHRpY2tJdGVtOiBFbGVtZW50LFxuICAgIGxlZnQ6IGJvb2xlYW5cbiAgKSB7XG4gICAgY29uc3QgbGFiZWwgPSBuZXcgRG9tRWxlbWVudCh0aWNrSXRlbS5xdWVyeVNlbGVjdG9yKGAuJHtDTEFTU19USUNLX0xBQkVMfWApISlcblxuICAgIGxldCBkdW1teUVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChcInNwYW5cIilcbiAgICAgIC5hZGRDbGFzcyhDTEFTU19USUNLX0xBQkVMKVxuICAgICAgLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwidmlzaWJpbGl0eTogaGlkZGVuOyBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XCIpXG4gICAgICAuc2V0SHRtbChsYWJlbC5pbm5lclRleHQpXG5cbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5hcHBlbmRDaGlsZChkdW1teUVsZW1lbnQpXG5cbiAgICBsZXQgd2lkdGggPSBkdW1teUVsZW1lbnQuZWxlbWVudC5jbGllbnRXaWR0aCAvIDJcbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5yZW1vdmVDaGlsZChkdW1teUVsZW1lbnQpXG5cbiAgICBjb25zdCBmbG9hdFBvc2l0aW9uID0gbGVmdCA/IFwibGVmdFwiIDogXCJyaWdodFwiXG5cbiAgICBpZiAod2lkdGggPCBNQVJHSU5fVElDSykge1xuICAgICAgLy8gY2VudGVyIHNtYWxsIGl0ZW1zIG9uIHRoZSB0aWNrXG4gICAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBgJHtmbG9hdFBvc2l0aW9ufTogJHtNQVJHSU5fVElDSyAtIE1hdGguZmxvb3Iod2lkdGgpfXB4OyB0ZXh0LWFsaWduOiAke2Zsb2F0UG9zaXRpb259O2ApXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9mb3JtYXRPdXRwdXQodmFsdWU6IG51bWJlciwgc2hvcnQ6IGJvb2xlYW4pIHtcbiAgICBpZiAodGhpcy5fZm9ybWF0dGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZm9ybWF0dGVyKHZhbHVlLCBzaG9ydClcbiAgICB9XG5cbiAgICBjb25zdCBzdHIgPSBwYXJzZUZsb2F0KHZhbHVlLnRvRml4ZWQoMikpXG4gICAgcmV0dXJuIHN0ci50b1N0cmluZygpXG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIGFuZCB1cGRhdGVzIHRoZSByYW5nZSB2YWx1ZS5cbiAgICogQHBhcmFtIHt2YWx1ZX0gdGhlIG5ldyB2YWx1ZSB0byBzZXQuXG4gICAqIEBwYXJhbSB7dXBkYXRlfSB0cnVlIGlmIHRoZSBVSSBzaG91bGQgYmUgdXBkYXRlZDsgb3RoZXJ3aXNlIGZhbHNlLlxuICAgKiBAcGFyYW0ge2FuaW1hdGV9IHRydWUgaWYgdGhlIFVJIHVwZGF0ZSBzaG91bGQgYmUgYW5pbWF0ZWQ7IG90aGVyd2lzZSBmYWxzZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfc2V0VmFsdWUoXG4gICAgdmFsdWU6IG51bWJlcixcbiAgICB1cGRhdGUgPSB0cnVlLFxuICAgIGFuaW1hdGUgPSBmYWxzZVxuICApIHtcbiAgICBsZXQgdmFsID0gY2xhbXAodmFsdWUsIHRoaXMuX21pblZhbHVlLCB0aGlzLl9tYXhWYWx1ZSlcbiAgICBsZXQgcG9zaXRpb25cblxuICAgIGlmICh0aGlzLl90aWNrc1dyYXBwZXIuZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0IHNuYXBWYWx1ZSA9IHRoaXMuX2dldFNuYXBWYWx1ZSh2YWwpXG4gICAgICBwb3NpdGlvbiA9IHNuYXBWYWx1ZS5wb3NpdGlvblxuICAgICAgdmFsID0gc25hcFZhbHVlLnZhbHVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHBvc2l0aW9uID0gKHRoaXMuX3RyYWNrV2lkdGggLyB0aGlzLl90cmFja1ZhbHVlVG90YWwpICogKHZhbHVlIC0gdGhpcy5fbWluVmFsdWUpXG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50LnZhbHVlID0gU3RyaW5nKHZhbClcblxuICAgIGlmICh0aGlzLl90aHVtYlZhbHVlKSB7XG4gICAgICB0aGlzLl90aHVtYlZhbHVlLnNldEh0bWwodGhpcy5fZm9ybWF0T3V0cHV0KHZhbCwgdHJ1ZSkpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX291dHB1dExhYmVsKSB7XG4gICAgICB0aGlzLl9vdXRwdXRMYWJlbC5zZXRIdG1sKHRoaXMuX2Zvcm1hdE91dHB1dCh2YWwsIGZhbHNlKSlcbiAgICB9XG5cbiAgICBpZiAodXBkYXRlKSB7XG4gICAgICB0aGlzLl9zZXRQb3NpdGlvbihwb3NpdGlvbiwgZmFsc2UsIGZhbHNlLCBhbmltYXRlKVxuICAgICAgdGhpcy5fdXBkYXRlVGlja1N0YXRlKClcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJpbnB1dFwiKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSByYW5nZSBzbGlkZXIuXG4gICAqL1xuICBzZXQgdmFsdWUodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMuX3NldFZhbHVlKHZhbHVlLCB0cnVlLCB0cnVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAqL1xuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy5lbGVtZW50LnZhbHVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNlIHRoZSBjb21wb25lbnQgdG8gcmUtbGF5b3V0IGl0c2VsZi5cbiAgICovXG4gIHB1YmxpYyBsYXlvdXQoKSB7XG4gICAgdGhpcy5fZ3JhYlBvc2l0aW9uID0gTWF0aC5yb3VuZCh0aGlzLl9yYW5nZVRodW1iLmVsZW1lbnQub2Zmc2V0V2lkdGggLyAyKVxuICAgIGNvbnN0IHRpY2tJdGVtcyA9IHRoaXMuX3JhbmdlQ29udGFpbmVyLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChgLiR7Q0xBU1NfVElDS31gKVxuICAgIGNvbnN0IHRpY2tzT2Zmc2V0ID0gdGlja0l0ZW1zICYmIHRpY2tJdGVtcy5sZW5ndGggPiAwID8gKDIgKiBNQVJHSU5fVElDSykgOiBNQVJHSU5fVElDS1xuXG4gICAgdGhpcy5fdHJhY2tXaWR0aCA9IHRoaXMuX3JhbmdlVHJhY2suZWxlbWVudC5vZmZzZXRXaWR0aCAtIHRpY2tzT2Zmc2V0XG5cbiAgICB0aGlzLl90cmFja1Bvc2l0aW9uTWluID0gMFxuICAgIHRoaXMuX3RyYWNrUG9zaXRpb25NYXggPSB0aGlzLl9yYW5nZVRyYWNrLmVsZW1lbnQuY2xpZW50V2lkdGggLSB0aGlzLl9yYW5nZVRodW1iLmVsZW1lbnQub2Zmc2V0V2lkdGggKyAxXG4gICAgdGhpcy5fdHJhY2tMZWZ0UG9zaXRpb24gPSB0aGlzLl9yYW5nZVRyYWNrLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCArIE1BUkdJTl9USUNLXG5cbiAgICBsZXQgaXRlbUNvdW50ID0gdGlja0l0ZW1zLmxlbmd0aCAtIDFcblxuICAgIHRoaXMuX2l0ZW1XaWR0aCA9IHRoaXMuX3RyYWNrV2lkdGggLyBpdGVtQ291bnRcbiAgICBjb25zdCBvdXRlckl0ZW1zV2lkdGggPSAodGhpcy5faXRlbVdpZHRoICogMC41KSArIE1BUkdJTl9USUNLXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBpdGVtQ291bnQ7IGkrKykge1xuICAgICAgbGV0IHdpZHRoID0gdGhpcy5faXRlbVdpZHRoXG5cbiAgICAgIGlmIChpID09PSAwIHx8IGkgPT09IGl0ZW1Db3VudCkge1xuICAgICAgICB3aWR0aCA9IG91dGVySXRlbXNXaWR0aFxuICAgICAgfVxuXG4gICAgICBsZXQgaXRlbSA9IG5ldyBEb21FbGVtZW50KHRpY2tJdGVtc1tpXSlcbiAgICAgIGl0ZW0uc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgYHdpZHRoOiAke01hdGguZmxvb3Iod2lkdGgpfXB4O2ApXG4gICAgfVxuXG4gICAgLy8gYWRqdXN0IGZpcnN0IGFuZCBsYXN0IGxhYmVsIHBvc2l0aW9uc1xuICAgIGlmICh0aWNrSXRlbXMubGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy5fYWRqdXN0VGlja0xhYmVsUG9zaXRpb24odGlja0l0ZW1zWzBdLCB0cnVlKVxuICAgICAgdGhpcy5fYWRqdXN0VGlja0xhYmVsUG9zaXRpb24odGlja0l0ZW1zW3RpY2tJdGVtcy5sZW5ndGggLSAxXSwgZmFsc2UpXG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIHRoZSB2YWx1ZVxuICAgIHRoaXMuX3NldFZhbHVlKHBhcnNlRmxvYXQodGhpcy5lbGVtZW50LnZhbHVlKSwgdHJ1ZSwgZmFsc2UpXG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIGNvbXBvbmVudHMgYW5kIGZyZWVzIGFsbCByZWZlcmVuY2VzLlxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5fcmVzaXplSGFuZGxlcilcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIHRoaXMuX3Jlc2l6ZUhhbmRsZXIpO1xuXG4gICAgKHRoaXMgYXMgYW55KS5fZG93bkhhbmRsZXIgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX21vdmVIYW5kbGVyID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9lbmRIYW5kbGVyID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9mb2N1c0hhbmRsZXIgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX2JsdXJIYW5kbGVyID0gbnVsbDtcblxuICAgICh0aGlzIGFzIGFueSkuZWxlbWVudCA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fcmFuZ2VDb250YWluZXIgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX3dyYXBwZXJFbGVtZW50ID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBkZXN0cm95KCkgaW5zdGVhZC5cbiAgICogQHRvZG8gcmVtb3ZlIGluIHZlcnNpb24gMi4wLjBcbiAgICovXG4gIHB1YmxpYyBkZXN0b3koKSB7XG4gICAgdGhpcy5kZXN0cm95KClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjb21wb25lbnQgdG8gdGhlIGVuYWJsZWQgc3RhdGUuXG4gICAqL1xuICBwdWJsaWMgZW5hYmxlKCkge1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKVxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LnJlbW92ZUNsYXNzKENMQVNTX0RJU0FCTEVEKVxuXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuX2Rvd25IYW5kbGVyKVxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5fZG93bkhhbmRsZXIpXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9rZXlkb3duSGFuZGxlcilcbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLl9mb2N1c0hhbmRsZXIpXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLl9ibHVySGFuZGxlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjb21wb25lbnQgdG8gdGhlIGRpc2FibGVkIHN0YXRlLlxuICAgKi9cbiAgcHVibGljIGRpc2FibGUoKSB7XG4gICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpXG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuYWRkQ2xhc3MoQ0xBU1NfRElTQUJMRUQpXG5cbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5fZG93bkhhbmRsZXIpXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLl9lbmRIYW5kbGVyKVxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9tb3ZlSGFuZGxlcilcblxuICAgIHRoaXMuX3JhbmdlQ29udGFpbmVyLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5fZG93bkhhbmRsZXIpXG5cbiAgICB0aGlzLl9yYW5nZUNvbnRhaW5lci5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLl9mb2N1c0hhbmRsZXIpXG4gICAgdGhpcy5fcmFuZ2VDb250YWluZXIuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLl9ibHVySGFuZGxlcilcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZTxIVE1MSW5wdXRFbGVtZW50PihcImlucHV0W3R5cGU9J3JhbmdlJ11cIiwgKGUpID0+IHtcbiAgICBuZXcgUmFuZ2UoZSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgUmFuZ2VcbiIsImltcG9ydCB7IHNlYXJjaEFuZEluaXRpYWxpemUsIHByZXZlbnREZWZhdWx0LCBmaW5kLCByZW1vdmUsIGludGVybmV0RXhwbG9yZXJPckVkZ2VWZXJzaW9uLCBzY3JvbGxJbnRvVmlldyB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgKiBhcyBJbnB1dHMgZnJvbSBcIi4uL0lucHV0c1wiXG5pbXBvcnQgKiBhcyBEb20gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5cbmNvbnN0IENMQVNTX1BMQUNFSE9MREVSID0gXCJzZWxlY3RfX3BsYWNlaG9sZGVyXCJcbmNvbnN0IENMQVNTX1RIVU1CID0gXCJzZWxlY3RfX3RodW1iXCJcbmNvbnN0IENMQVNTX0JVVFRPTiA9IFwic2VsZWN0X19idXR0b25cIlxuY29uc3QgQ0xBU1NfRFJPUERPV04gPSBcInNlbGVjdF9fZHJvcGRvd25cIlxuXG5jb25zdCBDTEFTU19PUEVOID0gXCJzZWxlY3QtLW9wZW5cIlxuY29uc3QgQ0xBU1NfQ0xPU0VEID0gXCJzZWxlY3QtLWNsb3NlZFwiXG5jb25zdCBDTEFTU19ESVNBQkxFRCA9IFwic2VsZWN0LS1kaXNhYmxlZFwiXG5jb25zdCBDTEFTU19GSUxURVJBQkxFID0gXCJzZWxlY3QtLWZpbHRlcmFibGVcIlxuXG5jb25zdCBDTEFTU19JVEVNID0gXCJkcm9wZG93bi1pdGVtXCJcbmNvbnN0IENMQVNTX0lURU1fU0VMRUNURUQgPSBcImRyb3Bkb3duLWl0ZW0tLXNlbGVjdGVkXCJcbmNvbnN0IENMQVNTX0lURU1fRk9DVVNFRCA9IFwiZHJvcGRvd24taXRlbS0tZm9jdXNlZFwiXG5jb25zdCBDTEFTU19JVEVNX0RJU0FCTEVEID0gXCJkcm9wZG93bi1pdGVtLS1kaXNhYmxlZFwiXG5cbmNvbnN0IENMQVNTX0dST1VQX0lURU0gPSBcImRyb3Bkb3duLWdyb3VwXCJcbmNvbnN0IENMQVNTX0dST1VQX0hFQURFUiA9IFwiZHJvcGRvd24tZ3JvdXBfX2l0ZW1cIlxuXG5jb25zdCBRVUVSWV9NRVNTQUdFID0gXCIubWVzc2FnZVwiXG5cbmNvbnN0IFRJTUVPVVRfQ0xPU0UgPSAxNTBcbmNvbnN0IFRJTUVPVVRfQkxVUiA9IDQwMFxuXG4vKipcbiAqIFRoZSBzZWxlY3QgY29tcG9uZW50IEFQSS5cbiAqL1xuY2xhc3MgU2VsZWN0IGV4dGVuZHMgRG9tRWxlbWVudDxIVE1MU2VsZWN0RWxlbWVudD4ge1xuICBwcml2YXRlIF9vcGVuQnlGb2N1czogYm9vbGVhblxuICBwcml2YXRlIF9tdWx0aXNlbGVjdGlvbjogYm9vbGVhblxuICBwcml2YXRlIF9jbGlja0hhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9oYW5kbGVEcm9wZG93bkNsaWNrOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfa2V5ZG93bkhhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9mb2N1c0hhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9ibHVySGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX3dpbmRvd0NsaWNrSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2ZpbHRlcktleWRvd25IYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfZmlsdGVyS2V5dXBIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfZmlsdGVyRm9jdXNIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcblxuICBwcml2YXRlIF93cmFwcGVyRWxlbWVudCE6IERvbUVsZW1lbnRcbiAgcHJpdmF0ZSBfZHJvcGRvd25FbGVtZW50ITogRG9tRWxlbWVudDxIVE1MRWxlbWVudD5cblxuICBwcml2YXRlIF9zZWxlY3RCdXR0b25FbGVtZW50ITogRG9tRWxlbWVudFxuICBwcml2YXRlIF90aHVtYkVsZW1lbnQhOiBEb21FbGVtZW50XG5cbiAgcHJpdmF0ZSBfcGxhY2Vob2xkZXJPcHRpb24/OiBIVE1MT3B0aW9uRWxlbWVudFxuICBwcml2YXRlIF9wbGFjZWhvbGRlckVsZW1lbnQhOiBEb21FbGVtZW50XG4gIHByaXZhdGUgX3BsYWNlaG9sZGVyVGV4dCE6IHN0cmluZ1xuXG4gIHByaXZhdGUgX2xhc3RIYW5kbGVkRXZlbnQ/OiBFdmVudFxuICBwcml2YXRlIF9sYXN0U2VsZWN0ZWRPcHRpb24/OiBIVE1MT3B0aW9uRWxlbWVudFxuXG4gIC8vIE1pbmltdW0gZmlsdGVyIGxlbmd0aFxuICBwcml2YXRlIF9taW5GaWx0ZXJMZW5ndGggPSAyXG5cbiAgLy8gVGhlIGtleXdvcmQgdGhlIFNlbGVjdCBpcyBjdXJyZW50bHkgZmlsdGVyZWQgYnlcbiAgcHJpdmF0ZSBfYWN0aXZlRmlsdGVyPzogc3RyaW5nXG5cbiAgLy8gVGhlIG9wdGlvbnMgdGhlIFNlbGVjdCB3YXMgaW5pdGlhbGx5IGNyZWF0ZWQgdXBvblxuICAvLyBUaGVzZSB3aWxsIGJlIHVzZWQgYXMgYSBiYXNpcyBmb3IgZmlsdGVyaW5nXG4gIHByaXZhdGUgX2luaXRpYWxPcHRpb25zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5lbGVtZW50LmNoaWxkcmVuKVxuXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEhUTUxTZWxlY3RFbGVtZW50KSB7XG4gICAgc3VwZXIoZWxlbWVudClcblxuICAgIHRoaXMuX29wZW5CeUZvY3VzID0gZmFsc2VcblxuICAgIC8vIENoZWNrIGZvciBtdWx0aS1zZWxlY3Rpb25cbiAgICB0aGlzLl9tdWx0aXNlbGVjdGlvbiA9IHRoaXMuZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKSA9PT0gdHJ1ZVxuXG4gICAgLy8gU2V0dXAgZXZlbnQgY29udGV4dFxuICAgIHRoaXMuX2NsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZUNsaWNrLmJpbmQodGhpcylcbiAgICB0aGlzLl9oYW5kbGVEcm9wZG93bkNsaWNrID0gdGhpcy5faGFuZGxlQ2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuX2tleWRvd25IYW5kbGVyID0gdGhpcy5faGFuZGxlS2V5ZG93bi5iaW5kKHRoaXMpXG4gICAgdGhpcy5fZm9jdXNIYW5kbGVyID0gdGhpcy5faGFuZGxlRm9jdXMuYmluZCh0aGlzKVxuICAgIHRoaXMuX2JsdXJIYW5kbGVyID0gdGhpcy5faGFuZGxlQmx1ci5iaW5kKHRoaXMpXG4gICAgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyID0gdGhpcy5faGFuZGxlV2luZG93Q2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuX2ZpbHRlcktleWRvd25IYW5kbGVyID0gdGhpcy5faGFuZGxlRmlsdGVyS2V5ZG93bi5iaW5kKHRoaXMpXG4gICAgdGhpcy5fZmlsdGVyS2V5dXBIYW5kbGVyID0gdGhpcy5faGFuZGxlRmlsdGVyS2V5dXAuYmluZCh0aGlzKVxuICAgIHRoaXMuX2ZpbHRlckZvY3VzSGFuZGxlciA9IHRoaXMuX2hhbmRsZUZpbHRlckZvY3VzLmJpbmQodGhpcylcblxuICAgIHRoaXMuX2luaXRpYWxpemUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBzZWxlY3QgY29tcG9uZW50LlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpbnNwZWN0cyB0aGUgc2VsZWN0IGRlZmluaXRpb24gYW5kIGl0cyBvcHRpb25zIGFuZFxuICAgKiBnZW5lcmF0ZXMgbmV3IHN0eWxhYmxlIERPTSBlbGVtZW50cyBhcm91bmQgdGhlIG9yaWdpbmFsIHNlbGVjdC1lbGVtZW50XG4gICAqIGRlZmluaXRpb25zLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplKCkge1xuICAgIGNvbnN0IHNlbGVjdGVkT3B0aW9uID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJvcHRpb25bc2VsZWN0ZWRdXCIpIGFzIEhUTUxPcHRpb25FbGVtZW50XG4gICAgY29uc3QgZmlyc3RPcHRpb24gPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihcIm9wdGlvblwiKSBhcyBIVE1MT3B0aW9uRWxlbWVudFxuXG4gICAgLy8gUGVyIGRlZmF1bHQsIHNldCB0aGUgbGFzdCBzZWxlY3RlZCBvcHRpb24gdG8gZWl0aGVyIHRoZSBvcHRpb24gd2l0aCBhIFwic2VsZWN0ZWRcIiBhdHRyaWJ1dGUsXG4gICAgLy8gb3IsIGlmIG5vdCBmb3VuZCwgdG8gdGhlIGZpcnN0IGF2YWlsYWJsZSBvcHRpb25cbiAgICB0aGlzLl9sYXN0U2VsZWN0ZWRPcHRpb24gPSBzZWxlY3RlZE9wdGlvbiB8fCBmaXJzdE9wdGlvblxuXG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudCh0aGlzLmVsZW1lbnQucGFyZW50RWxlbWVudCEpXG4gICAgICAuYWRkQ2xhc3MoQ0xBU1NfQ0xPU0VEKVxuXG4gICAgZm9yIChsZXQgY2xzIG9mIHRoaXMuY2xhc3Nlcykge1xuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuYWRkQ2xhc3MoY2xzKVxuICAgIH1cblxuICAgIHRoaXMuX2Ryb3Bkb3duRWxlbWVudCA9IG5ldyBEb21FbGVtZW50PEhUTUxFbGVtZW50PihcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKENMQVNTX0RST1BET1dOKVxuXG4gICAgaWYgKGludGVybmV0RXhwbG9yZXJPckVkZ2VWZXJzaW9uKCkgPiAwICYmIGludGVybmV0RXhwbG9yZXJPckVkZ2VWZXJzaW9uKCkgPCAxMikge1xuICAgICAgLy8gVGhpcyBpcyBhIHdvcmthcm91bmQgZm9yIElFIGJyb3dzZXJzIDExIGFuZCBlYXJsaWVyIHdoZXJlIGZvY3VzaW5nXG4gICAgICAvLyBhIHNjcm9sbGFibGUgZHJvcGRvd24gbGlzdCB3aWxsIGNsb3NlIHRoZSBkcm9wZG93biBwcmVtYXR1cmVseS5cbiAgICAgIHRoaXMuX2Ryb3Bkb3duRWxlbWVudC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiBldmVudC5wcmV2ZW50RGVmYXVsdCgpKVxuICAgIH1cblxuICAgIHRoaXMuX3NldHVwVGFyZ2V0KClcbiAgICB0aGlzLl9zZXR1cFBsYWNlaG9sZGVyKClcblxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX2Ryb3Bkb3duRWxlbWVudClcblxuICAgIHRoaXMuX2NyZWF0ZU9wdGlvbnModGhpcy5lbGVtZW50KVxuXG4gICAgdGhpcy5fdXBkYXRlU2l6ZSgpXG4gICAgdGhpcy5fdXBkYXRlTWVzc2FnZSgpXG5cbiAgICBpZiAodGhpcy5lbGVtZW50LmRpc2FibGVkKSB7XG4gICAgICB0aGlzLmRpc2FibGUoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVuYWJsZSgpXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9zZXR1cFRhcmdldCgpIHtcbiAgICAvLyBtb3ZlIHRoZSBpZCBmcm9tIHRoZSBzZWxlY3QgZWxlbWVudCB0byB0aGUgd3JhcHBlclxuICAgIGNvbnN0IGlkID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcImlkXCIpXG4gICAgaWYgKGlkKSB7XG4gICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiaWRcIilcbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LnNldEF0dHJpYnV0ZShcImlkXCIsIGlkKVxuICAgIH1cblxuICAgIC8vIEFwcGx5IHRoZSB0YWIgaW5kZXhcbiAgICBjb25zdCB0YWJJbmRleCA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKVxuICAgIGlmICh0YWJJbmRleCkge1xuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuc2V0QXR0cmlidXRlKFwidGFiSW5kZXhcIiwgdGFiSW5kZXgpXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9zZXR1cFBsYWNlaG9sZGVyKCkge1xuICAgIGlmICghdGhpcy5fc2VsZWN0QnV0dG9uRWxlbWVudCkge1xuICAgICAgdGhpcy5fc2VsZWN0QnV0dG9uRWxlbWVudCA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19CVVRUT04pXG5cbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX3NlbGVjdEJ1dHRvbkVsZW1lbnQpXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl90aHVtYkVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3RodW1iRWxlbWVudCA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19USFVNQilcblxuICAgICAgbGV0IHRodW1iSWNvbiA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAgIC5hZGRDbGFzcyhcInRodW1iLWljb25cIilcblxuICAgICAgbGV0IGxvYWRlciA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAgIC5hZGRDbGFzcyhcImxvYWRlci1zcGlubmVyXCIpXG4gICAgICAgIC5hZGRDbGFzcyhcImxvYWRlci1zcGlubmVyLS1zbWFsbFwiKVxuXG4gICAgICB0aGlzLl90aHVtYkVsZW1lbnQuYXBwZW5kQ2hpbGQobG9hZGVyKVxuICAgICAgdGhpcy5fdGh1bWJFbGVtZW50LmFwcGVuZENoaWxkKHRodW1iSWNvbilcbiAgICAgIHRoaXMuX3NlbGVjdEJ1dHRvbkVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fdGh1bWJFbGVtZW50KVxuICAgIH1cblxuICAgIGxldCBwbGFjZWhvbGRlclRleHQgPSBcIlwiXG5cbiAgICB0aGlzLl9wbGFjZWhvbGRlck9wdGlvbiA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwib3B0aW9uW3NlbGVjdGVkXVtkaXNhYmxlZF1cIikgYXMgSFRNTE9wdGlvbkVsZW1lbnQgfHwgdW5kZWZpbmVkXG5cbiAgICBpZiAodGhpcy5fcGxhY2Vob2xkZXJPcHRpb24pIHtcbiAgICAgIHBsYWNlaG9sZGVyVGV4dCA9IERvbS50ZXh0KHRoaXMuX3BsYWNlaG9sZGVyT3B0aW9uKVxuXG4gICAgICBpZiAodGhpcy5fbXVsdGlzZWxlY3Rpb24gPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXJPcHRpb24uc2VsZWN0ZWQgPSBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBzZWxlY3RlZE9wdGlvbiA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwib3B0aW9uW3NlbGVjdGVkXTpub3QoW2Rpc2FibGVkXSlcIilcblxuICAgIGlmIChzZWxlY3RlZE9wdGlvbikge1xuICAgICAgcGxhY2Vob2xkZXJUZXh0ID0gRG9tLnRleHQoc2VsZWN0ZWRPcHRpb24pXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9wbGFjZWhvbGRlckVsZW1lbnQpIHtcbiAgICAgIC8vIFdoZW4gdGhlIFNlbGVjdCBpcyBmaWx0ZXJhYmxlLCBjcmVhdGUgYW4gXCJpbnB1dFwiIGFzIHRoZSBwbGFjZWhvbGRlciBlbGVtZW50LCBvdGhlcndpc2UgYSBcInNwYW5cIlxuICAgICAgaWYgKHRoaXMuX2lzRmlsdGVyYWJsZSgpKSB7XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyRWxlbWVudCA9IG5ldyBEb21FbGVtZW50KFwiaW5wdXRcIilcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXJFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCAoZSkgPT4gdGhpcy5faGFuZGxlRmlsdGVyS2V5dXAoZSkpXG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAoZSkgPT4gdGhpcy5faGFuZGxlRmlsdGVyS2V5ZG93bihlKSlcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXJFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCAoZSkgPT4gdGhpcy5faGFuZGxlRmlsdGVyRm9jdXMoZSkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wbGFjZWhvbGRlckVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChcInNwYW5cIilcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcGxhY2Vob2xkZXJFbGVtZW50LmFkZENsYXNzKENMQVNTX1BMQUNFSE9MREVSKVxuICAgICAgdGhpcy5fc2VsZWN0QnV0dG9uRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9wbGFjZWhvbGRlckVsZW1lbnQpXG4gICAgfVxuXG4gICAgdGhpcy5fc2V0UGxhY2Vob2xkZXIocGxhY2Vob2xkZXJUZXh0KVxuICAgIHRoaXMuX3BsYWNlaG9sZGVyVGV4dCA9IHBsYWNlaG9sZGVyVGV4dFxuXG4gICAgaWYgKHNlbGVjdGVkT3B0aW9uICYmIHNlbGVjdGVkT3B0aW9uICE9PSB0aGlzLl9wbGFjZWhvbGRlck9wdGlvbikge1xuICAgICAgdGhpcy5fdXBkYXRlUGxhY2Vob2xkZXIodHJ1ZSlcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX3VwZGF0ZU1lc3NhZ2UoKSB7XG4gICAgY29uc3QgbWVzc2FnZU5vZGUgPSB0aGlzLl93cmFwcGVyRWxlbWVudC5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfTUVTU0FHRSlcbiAgICBpZiAobWVzc2FnZU5vZGUgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmFwcGVuZENoaWxkKG5ldyBEb21FbGVtZW50KG1lc3NhZ2VOb2RlKSlcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9pc09wdEdyb3VwKGVsZW1lbnQ6IEVsZW1lbnQpOiBlbGVtZW50IGlzIEhUTUxPcHRHcm91cEVsZW1lbnQge1xuICAgIHJldHVybiBlbGVtZW50LnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gXCJPUFRHUk9VUFwiXG4gIH1cblxuICBwcml2YXRlIF9pc09wdGlvbihlbGVtZW50OiBFbGVtZW50KTogZWxlbWVudCBpcyBIVE1MT3B0aW9uRWxlbWVudCB7XG4gICAgcmV0dXJuIGVsZW1lbnQudGFnTmFtZS50b1VwcGVyQ2FzZSgpID09PSBcIk9QVElPTlwiXG4gIH1cblxuICBwcm90ZWN0ZWQgX2NyZWF0ZU9wdGlvbnMoZWxlbWVudDogSFRNTFNlbGVjdEVsZW1lbnQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBjaGlsZCA9IGVsZW1lbnQuY2hpbGRyZW5baV1cblxuICAgICAgaWYgKHRoaXMuX2lzT3B0R3JvdXAoY2hpbGQpKSB7XG4gICAgICAgIHRoaXMuX2FwcGVuZEdyb3VwKGNoaWxkIGFzIEhUTUxPcHRHcm91cEVsZW1lbnQpXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9pc09wdGlvbihjaGlsZCkpIHtcbiAgICAgICAgbGV0IG9wdGlvbiA9IHRoaXMuX2NyZWF0ZU9wdGlvbihjaGlsZCBhcyBIVE1MT3B0aW9uRWxlbWVudClcblxuICAgICAgICBpZiAob3B0aW9uKSB7XG4gICAgICAgICAgdGhpcy5fZHJvcGRvd25FbGVtZW50LmFwcGVuZENoaWxkKG9wdGlvbilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfY3JlYXRlT3B0aW9uKG9wdGlvbjogSFRNTE9wdGlvbkVsZW1lbnQpIHtcbiAgICBsZXQgaHRtbCA9IG9wdGlvbi5pbm5lckhUTUxcblxuICAgIGlmICh0aGlzLl9hY3RpdmVGaWx0ZXIpIHtcbiAgICAgIGNvbnN0IHNhbml0aXplZEFjdGl2ZUZpbHRlciA9IHRoaXMuX2FjdGl2ZUZpbHRlci5yZXBsYWNlKC9bLVxcXFxeJCorPy4oKXxbXFxde31dL2csIFwiXFxcXCQmXCIpXG4gICAgICBodG1sID0gaHRtbC5yZXBsYWNlKG5ldyBSZWdFeHAoYCgke3Nhbml0aXplZEFjdGl2ZUZpbHRlcn0pYCwgXCJnaVwiKSwgXCI8c3Ryb25nPiQxPC9zdHJvbmc+XCIpXG4gICAgfVxuXG4gICAgbGV0IG9wdCA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAuYWRkQ2xhc3MoQ0xBU1NfSVRFTSlcbiAgICAgIC5zZXRIdG1sKGh0bWwpXG5cbiAgICBpZiAob3B0aW9uLnNlbGVjdGVkKSB7XG4gICAgICBvcHQuYWRkQ2xhc3MoQ0xBU1NfSVRFTV9TRUxFQ1RFRClcbiAgICB9XG5cbiAgICBpZiAob3B0aW9uLmRpc2FibGVkKSB7XG4gICAgICBvcHQuYWRkQ2xhc3MoQ0xBU1NfSVRFTV9ESVNBQkxFRClcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2lzUGxhY2Vob2xkZXIob3B0aW9uKSkge1xuICAgICAgb3B0LnNldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIiwgb3B0aW9uLnZhbHVlKVxuICAgICAgcmV0dXJuIG9wdFxuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHByb3RlY3RlZCBfYXBwZW5kR3JvdXAob3B0Z3JvdXA6IEhUTUxPcHRHcm91cEVsZW1lbnQpIHtcbiAgICBsZXQgbGFiZWwgPSBvcHRncm91cC5nZXRBdHRyaWJ1dGUoXCJsYWJlbFwiKSFcblxuICAgIGxldCBncm91cCA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAuYWRkQ2xhc3MoQ0xBU1NfR1JPVVBfSVRFTSlcblxuICAgIGxldCBncm91cEhlYWRlciA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAuYWRkQ2xhc3MoQ0xBU1NfR1JPVVBfSEVBREVSKVxuICAgICAgLnNldEh0bWwobGFiZWwpXG5cbiAgICBncm91cC5hcHBlbmRDaGlsZChncm91cEhlYWRlcilcblxuICAgIGxldCBvcHRpb25zID0gb3B0Z3JvdXAucXVlcnlTZWxlY3RvckFsbChcIm9wdGlvblwiKVxuICAgIGZvciAobGV0IGVudHJ5IG9mIG9wdGlvbnMpIHtcbiAgICAgIGxldCBvcHRpb24gPSB0aGlzLl9jcmVhdGVPcHRpb24oZW50cnkpXG4gICAgICBpZiAob3B0aW9uKSB7XG4gICAgICAgIGdyb3VwLmFwcGVuZENoaWxkKG9wdGlvbilcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9kcm9wZG93bkVsZW1lbnQuYXBwZW5kQ2hpbGQoZ3JvdXApXG4gICAgcmV0dXJuIGdyb3VwXG4gIH1cblxuICBwcm90ZWN0ZWQgX3VwZGF0ZVNpemUoKSB7XG4gICAgLy8gTm90ZTogTWlycm9yaW5nIHRoZSBET00gYW5kIG1lYXN1cmluZyB0aGUgaXRlbXMgdXNpbmcgdGhlaXIgY2xpZW50V2lkdGggd2FzIHZlcnlcbiAgICAvLyB1bnJlbGlhYmxlLCB0aGVyZWZvcmUgbWVhc3VyaW5nIHdhcyBzd2l0Y2hlZCB0byB0aGUgbmV3IEhUTUw1IG1lYXN1cmVUZXh0IG1ldGhvZFxuICAgIC8vIG1hcmdpbnMgYW5kIHBhZGRpbmdzIGFycm91bmQgdGhlIHRleHQgYXJlIGNvcGllZCBmcm9tIHRoZSBvcmlnaW5hbCBwbGFjZWhvbGRlciBpdGVtc1xuICAgIC8vIGRpbWVuc2lvblxuICAgIGNvbnN0IHBsYWNlaG9sZGVyU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9wbGFjZWhvbGRlckVsZW1lbnQuZWxlbWVudClcblxuICAgIGxldCBwYWRkaW5nUmlnaHQgPSBwYXJzZUZsb2F0KHBsYWNlaG9sZGVyU3R5bGUucGFkZGluZ1JpZ2h0ISlcbiAgICBsZXQgcGFkZGluZ0xlZnQgPSBwYXJzZUZsb2F0KHBsYWNlaG9sZGVyU3R5bGUucGFkZGluZ0xlZnQhKVxuXG4gICAgbGV0IGZvbnQgPSB0aGlzLl9wbGFjZWhvbGRlckVsZW1lbnQuY3NzKFwiZm9udFwiKVxuICAgIGxldCB0ZXh0V2lkdGggPSBEb20udGV4dFdpZHRoKHRoaXMuX3BsYWNlaG9sZGVyVGV4dCwgZm9udClcbiAgICBsZXQgbWF4V2lkdGggPSBwYWRkaW5nTGVmdCArIHBhZGRpbmdSaWdodCArIHRleHRXaWR0aFxuXG4gICAgbGV0IG9wdGlvbnMgPSB0aGlzLl93cmFwcGVyRWxlbWVudC5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke0NMQVNTX0lURU19YClcbiAgICBmb3IgKGxldCBlbnRyeSBvZiBvcHRpb25zKSB7XG4gICAgICBsZXQgd2lkdGggPSBEb20udGV4dFdpZHRoKERvbS50ZXh0KGVudHJ5KSwgZm9udCkgKyBwYWRkaW5nTGVmdCArIHBhZGRpbmdSaWdodFxuXG4gICAgICBpZiAod2lkdGggPiBtYXhXaWR0aCkge1xuICAgICAgICBtYXhXaWR0aCA9IHdpZHRoXG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICBwcm90ZWN0ZWQgX2lzQnV0dG9uVGFyZ2V0KHRhcmdldDogRXZlbnRUYXJnZXQpIHtcbiAgICByZXR1cm4gKHRhcmdldCA9PT0gdGhpcy5fd3JhcHBlckVsZW1lbnQuZWxlbWVudCB8fFxuICAgICAgdGFyZ2V0ID09PSB0aGlzLl9wbGFjZWhvbGRlckVsZW1lbnQuZWxlbWVudCB8fFxuICAgICAgdGFyZ2V0ID09PSB0aGlzLl9zZWxlY3RCdXR0b25FbGVtZW50LmVsZW1lbnQgfHxcbiAgICAgIHRhcmdldCA9PT0gdGhpcy5fdGh1bWJFbGVtZW50LmVsZW1lbnQpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2lzRHJvcGRvd25UYXJnZXQodGFyZ2V0OiBFdmVudFRhcmdldCkge1xuICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0IGFzIEhUTUxFbGVtZW50XG4gICAgd2hpbGUgKGN1cnJlbnQgIT09IHRoaXMuX2Ryb3Bkb3duRWxlbWVudC5lbGVtZW50ICYmIGN1cnJlbnQucGFyZW50RWxlbWVudCkge1xuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50RWxlbWVudFxuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50ID09PSB0aGlzLl9kcm9wZG93bkVsZW1lbnQuZWxlbWVudFxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIFVJIGlmIHRoZSBzZWxlY3Rpb24gaGFzIGNoYW5nZWQgYW5kIG1ha2VzIHN1cmUgdGhlXG4gICAqIHNlbGVjdCBjb250cm9sIGFuZCB0aGUgZ2VuZXJhdGVkIG1hcmt1cCBhcmUgc3luY2hyb25pemVkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9zZWxlY3RlZEl0ZW1DaGFuZ2VkKFxuICAgIG5ld0l0ZW06IEVsZW1lbnQsXG4gICAgYXV0b0Nsb3NlID0gdHJ1ZSxcbiAgICBtdWx0aXNlbGVjdCA9IGZhbHNlXG4gICkge1xuICAgIGNvbnN0IG9sZEl0ZW1zID0gdGhpcy5fZHJvcGRvd25FbGVtZW50LmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChgLiR7Q0xBU1NfSVRFTV9TRUxFQ1RFRH1gKVxuXG4gICAgaWYgKCFuZXdJdGVtKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuY2xvc2UoKSwgVElNRU9VVF9DTE9TRSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChEb20uaGFzQ2xhc3MobmV3SXRlbSwgQ0xBU1NfSVRFTV9ESVNBQkxFRCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICgob2xkSXRlbXMubGVuZ3RoID09PSAwKSAmJiAhbmV3SXRlbSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBzZWxlY3QgdW5kZWZpbmVkIGVsZW1lbnRzXCIpXG4gICAgfVxuXG4gICAgbGV0IG9sZEl0ZW0gPSBvbGRJdGVtc1swXVxuXG4gICAgaWYgKG11bHRpc2VsZWN0ID09PSB0cnVlKSB7XG4gICAgICBvbGRJdGVtID0gZmluZChvbGRJdGVtcywgKHgpID0+IHguZ2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiKSA9PT0gbmV3SXRlbS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXZhbHVlXCIpKSFcbiAgICB9XG5cbiAgICBsZXQgaXNEZXNlbGVjdCA9IGZhbHNlXG5cbiAgICBpZiAobmV3SXRlbSAmJiBvbGRJdGVtICYmIG9sZEl0ZW0gPT09IG5ld0l0ZW0pIHtcbiAgICAgIC8vIENsaWNrIG9uIGEgcHJldmlvdXNseSBzZWxlY3RlZCBlbGVtZW50IC0+IGRlc2VsZWN0XG4gICAgICBpc0Rlc2VsZWN0ID0gdHJ1ZVxuXG4gICAgICBpZiAoIXRoaXMuX3BsYWNlaG9sZGVyT3B0aW9uICYmICFtdWx0aXNlbGVjdCkge1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBwbGFjZWhvbGRlciBvcHRpb24sIG5vbiBtdWx0aXNlbGVjdCBvcHRpb25zIGNhbm5vdCBiZSBkZXNlbGVjdGVkXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBkZWxldGUgdGhpcy5fbGFzdFNlbGVjdGVkT3B0aW9uXG4gICAgfVxuXG4gICAgaWYgKG9sZEl0ZW0pIHtcbiAgICAgIC8vIFJlbW92ZSBzZWxlY3Rpb24gb24gdGhlIGVsZW1lbnRcbiAgICAgIGxldCBvbGRWYWx1ZSA9IG9sZEl0ZW0uZ2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiKVxuICAgICAgbGV0IG9wdEVsZW1lbnQgPSBmaW5kKHRoaXMuZWxlbWVudC5vcHRpb25zLCAoeCkgPT4gIXguZGlzYWJsZWQgJiYgeC52YWx1ZSA9PT0gb2xkVmFsdWUpXG5cbiAgICAgIGlmICghb3B0RWxlbWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBvcHRpb24gd2l0aCB2YWx1ZSAke29sZFZhbHVlfSBkb2VzIG5vdCBleGlzdGApXG4gICAgICB9XG5cbiAgICAgIC8vIFVuc2V0IFNlbGVjdCB2YWx1ZVxuICAgICAgb3B0RWxlbWVudC5zZWxlY3RlZCA9IGZhbHNlXG4gICAgICBEb20ucmVtb3ZlQ2xhc3Mob2xkSXRlbSwgQ0xBU1NfSVRFTV9TRUxFQ1RFRClcbiAgICB9XG5cbiAgICBpZiAoIWlzRGVzZWxlY3QpIHsgLy8gU2VsZWN0IGFuIG9wdGlvblxuICAgICAgLy8gU2VsZWN0IGEgbmV3IGl0ZW1cbiAgICAgIGxldCBuZXdWYWx1ZSA9IG5ld0l0ZW0uZ2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiKVxuICAgICAgbGV0IG9wdEVsZW1lbnQgPSBmaW5kKHRoaXMuZWxlbWVudC5vcHRpb25zLCAoeCkgPT4gIXguZGlzYWJsZWQgJiYgeC52YWx1ZSA9PT0gbmV3VmFsdWUpXG5cbiAgICAgIGlmICghb3B0RWxlbWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBvcHRpb24gd2l0aCB2YWx1ZSAke25ld1ZhbHVlfSBkb2VzIG5vdCBleGlzdGApXG4gICAgICB9XG5cbiAgICAgIC8vIFNldCBTZWxlY3QgdmFsdWVcbiAgICAgIG9wdEVsZW1lbnQuc2VsZWN0ZWQgPSB0cnVlXG4gICAgICBEb20uYWRkQ2xhc3MobmV3SXRlbSwgQ0xBU1NfSVRFTV9TRUxFQ1RFRClcblxuICAgICAgLy8gUHJlc2VydmUgc2VsZWN0aW9uXG4gICAgICB0aGlzLl9sYXN0U2VsZWN0ZWRPcHRpb24gPSBvcHRFbGVtZW50XG5cbiAgICB9IGVsc2UgeyAvLyBEZXNlbGVjdCBhbiBvcHRpb25cbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgZmFsbGluZyBiYWNrIHRvIHRoZSBwbGFjZWhvbGRlciAoaWYgYW55KVxuICAgICAgaWYgKHRoaXMuX3BsYWNlaG9sZGVyT3B0aW9uKSB7XG4gICAgICAgIHRoaXMuX2xhc3RTZWxlY3RlZE9wdGlvbiA9IHRoaXMuX3BsYWNlaG9sZGVyT3B0aW9uXG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGhhc1NlbGVjdGVkSXRlbXMgPSB0cnVlXG5cbiAgICBpZiAodGhpcy5fbXVsdGlzZWxlY3Rpb24gPT09IGZhbHNlICYmIGlzRGVzZWxlY3QpIHtcbiAgICAgIC8vIEhhbmRsZSBubyBzZWxlY3Rpb24gZm9yIG5vbi1tdWx0aXNlbGVjdCBzdGF0ZXNcbiAgICAgIHRoaXMuX3BsYWNlaG9sZGVyT3B0aW9uIS5zZWxlY3RlZCA9IHRydWVcbiAgICAgIGhhc1NlbGVjdGVkSXRlbXMgPSBmYWxzZVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9tdWx0aXNlbGVjdGlvbiA9PT0gdHJ1ZSAmJiB0aGlzLl9nZXRTZWxlY3RlZE9wdGlvbnMoKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGhhc1NlbGVjdGVkSXRlbXMgPSBmYWxzZVxuICAgIH1cblxuICAgIC8vIFJlc2V0IHRoZSBmaWx0ZXIgaWYgZmlsdGVyYWJsZVxuICAgIGlmICh0aGlzLl9hY3RpdmVGaWx0ZXIpIHtcbiAgICAgIHRoaXMuX2NsZWFyRmlsdGVyKClcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVQbGFjZWhvbGRlcihoYXNTZWxlY3RlZEl0ZW1zKVxuXG4gICAgLy8gRGlzcGF0Y2ggdGhlIGNoYW5nZWQgZXZlbnRcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJjaGFuZ2VcIilcblxuICAgIGlmIChhdXRvQ2xvc2UgJiYgIW11bHRpc2VsZWN0KSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICB9LCBUSU1FT1VUX0NMT1NFKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfdXBkYXRlUGxhY2Vob2xkZXIoaGFzU2VsZWN0ZWRJdGVtczogYm9vbGVhbikge1xuICAgIGxldCB0ZXh0ID0gdGhpcy5fcGxhY2Vob2xkZXJPcHRpb24gPyBEb20udGV4dCh0aGlzLl9wbGFjZWhvbGRlck9wdGlvbikgOiBcIiBcIlxuXG4gICAgaWYgKGhhc1NlbGVjdGVkSXRlbXMgPT09IHRydWUpIHtcbiAgICAgIGxldCBzZWxlY3RlZEl0ZW1zID0gdGhpcy5fZ2V0U2VsZWN0ZWRPcHRpb25zKClcblxuICAgICAgaWYgKHNlbGVjdGVkSXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICB0ZXh0ID0gXCJcIlxuICAgICAgICBmb3IgKGxldCBpdGVtIG9mIHNlbGVjdGVkSXRlbXMpIHtcbiAgICAgICAgICB0ZXh0ICs9IGAke0RvbS50ZXh0KGl0ZW0pfSwgYFxuICAgICAgICB9XG4gICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCB0ZXh0Lmxlbmd0aCAtIDIpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fc2V0UGxhY2Vob2xkZXIodGV4dClcbiAgfVxuXG4gIHByb3RlY3RlZCBfZ2V0U2VsZWN0ZWRPcHRpb25zKCkge1xuICAgIGxldCBzZWxlY3RlZE9wdGlvbnM6IEhUTUxPcHRpb25FbGVtZW50W10gPSBbXVxuICAgIGlmICh0aGlzLmVsZW1lbnQub3B0aW9ucykge1xuICAgICAgW10uZm9yRWFjaC5jYWxsKHRoaXMuZWxlbWVudC5vcHRpb25zLCAoKG9wdGlvbjogSFRNTE9wdGlvbkVsZW1lbnQpID0+IHtcbiAgICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAmJiAhb3B0aW9uLmRpc2FibGVkKSB7XG4gICAgICAgICAgc2VsZWN0ZWRPcHRpb25zLnB1c2gob3B0aW9uKVxuICAgICAgICB9XG4gICAgICB9KSlcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkT3B0aW9uc1xuICB9XG5cbiAgLyoqXG4gICAqIENsb25lIGFsbCBvZiB0aGUgaW5pdGlhbGx5IHNldCBvcHRpb25zIChhbmQgb3B0Z3JvdXBzKSBhbmQgcmV0dXJucyB0aGVtIGluIGEgbmV3IGFycmF5LlxuICAgKiBUaGlzIHNlcnZlcyBhcyB0aGUgYmFzaXMgZm9yIGZpbHRlcmluZy4gSWYgYSBmaWx0ZXIgaXMgcHJlc2VudCwgaXQgd2lsbCBiZSByZXNwZWN0ZWQuXG4gICAqL1xuICBwcml2YXRlIGdldEluaXRpYWxPcHRpb25zKCk6IEVsZW1lbnRbXSB7XG4gICAgY29uc3QgZmlsdGVyID0gdGhpcy5fYWN0aXZlRmlsdGVyIHx8IFwiXCJcbiAgICBjb25zdCBmaWx0ZXJlZDogRWxlbWVudFtdID0gW11cbiAgICBjb25zdCBpbml0aWFsT3B0aW9ucyA9IHRoaXMuX2luaXRpYWxPcHRpb25zXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluaXRpYWxPcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZDogRWxlbWVudCA9IGluaXRpYWxPcHRpb25zW2ldIGFzIEVsZW1lbnRcblxuICAgICAgaWYgKHRoaXMuX2lzT3B0R3JvdXAoY2hpbGQpKSB7IC8vIGhhbmRsZSA8b3B0Z3JvdXA+XG4gICAgICAgIGNvbnN0IG9wdEdyb3VwQ2xvbmU6IEVsZW1lbnQgPSBjaGlsZC5jbG9uZU5vZGUoZmFsc2UpIGFzIEVsZW1lbnRcbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2VcblxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoaWxkLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY29uc3Qgb3B0aW9uQ2xvbmU6IEVsZW1lbnQgPSBjaGlsZC5jaGlsZHJlbltqXS5jbG9uZU5vZGUodHJ1ZSkgYXMgRWxlbWVudFxuXG4gICAgICAgICAgLy8gQXBwZW5kIG9uIG1hdGNoXG4gICAgICAgICAgaWYgKHRoaXMuX2NvbnRhaW5zV29yZChvcHRpb25DbG9uZS5pbm5lckhUTUwsIGZpbHRlcikpIHtcbiAgICAgICAgICAgIG9wdEdyb3VwQ2xvbmUuYXBwZW5kQ2hpbGQob3B0aW9uQ2xvbmUpXG4gICAgICAgICAgICBmb3VuZCA9IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQdXNoIGlmIGFueSBtYXRjaGVzIGZvdW5kXG4gICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgIGZpbHRlcmVkLnB1c2gob3B0R3JvdXBDbG9uZSlcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2lzT3B0aW9uKGNoaWxkKSkgeyAvLyBoYW5kbGUgPG9wdGlvbj5cbiAgICAgICAgY29uc3Qgb3B0aW9uQ2xvbmU6IEVsZW1lbnQgPSBjaGlsZC5jbG9uZU5vZGUodHJ1ZSkgYXMgRWxlbWVudFxuXG4gICAgICAgIC8vIFB1c2ggb24gbWF0Y2hcbiAgICAgICAgaWYgKHRoaXMuX2NvbnRhaW5zV29yZChvcHRpb25DbG9uZS5pbm5lckhUTUwsIGZpbHRlcikpIHtcbiAgICAgICAgICBmaWx0ZXJlZC5wdXNoKG9wdGlvbkNsb25lKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbHRlcmVkXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGEgdGV4dCBjb250YWlucyBhIGdpdmVuIGtleXdvcmQsIGUuZy4gaW4gXCJjYVwiIGluIFwiQ2FyXCJcbiAgICovXG4gIHByaXZhdGUgX2NvbnRhaW5zV29yZCh0ZXh0OiBzdHJpbmcsIGtleXdvcmQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0ZXh0LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihrZXl3b3JkLnRvTG93ZXJDYXNlKCkpID4gLTFcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlRm9jdXMoKSB7XG4gICAgdGhpcy5vcGVuKClcbiAgICB0aGlzLl9vcGVuQnlGb2N1cyA9IHRydWVcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fb3BlbkJ5Rm9jdXMgPSBmYWxzZVxuICAgIH0sIFRJTUVPVVRfQkxVUilcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlQmx1cigpIHtcbiAgICB0aGlzLmNsb3NlKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlQ2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICBsZXQgaGFuZGxlZCA9IGZhbHNlXG5cbiAgICBpZiAodGhpcy5fbGFzdEhhbmRsZWRFdmVudCA9PT0gZXZlbnQpIHtcbiAgICAgIHRoaXMuX2xhc3RIYW5kbGVkRXZlbnQgPSB1bmRlZmluZWRcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzLl9pc0J1dHRvblRhcmdldChldmVudC50YXJnZXQhKSAmJiB0aGlzLl9vcGVuQnlGb2N1cyA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIGhhbmRsZSBoZWFkZXIgaXRlbSBjbGlja3MgYW5kIHRvZ2dsZSBkcm9wZG93blxuICAgICAgdGhpcy50b2dnbGUoKVxuICAgICAgaGFuZGxlZCA9IHRydWVcbiAgICB9XG5cbiAgICBsZXQgbmV3SXRlbSA9IGV2ZW50LnRhcmdldCBhcyBFbGVtZW50XG5cbiAgICBpZiAoIWhhbmRsZWQgJiYgRG9tLmhhc0NsYXNzKG5ld0l0ZW0sIENMQVNTX0lURU0pKSB7XG4gICAgICAvLyBoYW5kbGUgY2xpY2tzIG9uIGRyb3Bkb3duIGl0ZW1zXG4gICAgICB0aGlzLl9zZWxlY3RlZEl0ZW1DaGFuZ2VkKG5ld0l0ZW0sIHRydWUsIHRoaXMuX211bHRpc2VsZWN0aW9uKVxuICAgICAgaGFuZGxlZCA9IHRydWVcbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlZCkge1xuICAgICAgdGhpcy5fbGFzdEhhbmRsZWRFdmVudCA9IGV2ZW50XG4gICAgICBwcmV2ZW50RGVmYXVsdChldmVudClcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZVdpbmRvd0NsaWNrKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgaWYgKHRoaXMuX2lzRHJvcGRvd25UYXJnZXQoZXZlbnQudGFyZ2V0ISkgfHwgdGhpcy5faXNCdXR0b25UYXJnZXQoZXZlbnQudGFyZ2V0ISkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuY2xvc2UoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9mb2N1c09wdGlvblN0YXJ0aW5nV2l0aChrZXljb2RlOiBudW1iZXIsIHN0YXJ0SW5kZXg6IG51bWJlciwgb3B0aW9uczogTm9kZUxpc3RPZjxIVE1MRWxlbWVudD4pIHtcbiAgICBmb3IgKGxldCBpbmRleCA9IHN0YXJ0SW5kZXg7IGluZGV4IDwgb3B0aW9ucy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGxldCBpdGVtID0gbmV3IERvbUVsZW1lbnQob3B0aW9uc1tpbmRleF0pXG4gICAgICBsZXQgdmFsdWUgPSBpdGVtLmlubmVyVGV4dC50b0xvd2VyQ2FzZSgpXG5cbiAgICAgIGlmIChpbmRleCA+IG9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGluZGV4ID0gMFxuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUuc3RhcnRzV2l0aChJbnB1dHMuZ2V0S2V5VmFsdWUoa2V5Y29kZSkpKSB7XG4gICAgICAgIGxldCBuZXdPcHRpb24gPSBuZXcgRG9tRWxlbWVudChvcHRpb25zW2luZGV4XSlcblxuICAgICAgICBpZiAoIW5ld09wdGlvbi5oYXNDbGFzcyhDTEFTU19JVEVNX0RJU0FCTEVEKSkge1xuICAgICAgICAgIHNjcm9sbEludG9WaWV3KG9wdGlvbnNbaW5kZXhdKVxuICAgICAgICAgIG5ld09wdGlvbi5hZGRDbGFzcyhDTEFTU19JVEVNX0ZPQ1VTRUQpXG4gICAgICAgICAgcmV0dXJuIG5ld09wdGlvblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlS2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgIGxldCBldnQgPSBldmVudCB8fCB3aW5kb3cuZXZlbnRcbiAgICBsZXQga2V5Y29kZSA9IGV2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGVcblxuICAgIGlmIChrZXljb2RlID09PSBJbnB1dHMuS0VZX0VTQ0FQRSkge1xuICAgICAgLy8gaGFuZGxlIEVzY2FwZSBrZXkgKEVTQylcbiAgICAgIGlmICh0aGlzLmlzT3BlbigpKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgfVxuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChrZXljb2RlID09PSBJbnB1dHMuS0VZX0FSUk9XX1VQIHx8IGtleWNvZGUgPT09IElucHV0cy5LRVlfQVJST1dfRE9XTikge1xuICAgICAgLy8gVXAgYW5kIGRvd24gYXJyb3dzXG5cbiAgICAgIGxldCBvcHRpb25zID0gdGhpcy5fd3JhcHBlckVsZW1lbnQuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuJHtDTEFTU19JVEVNfWApIGFzIE5vZGVMaXN0T2Y8SFRNTEVsZW1lbnQ+XG4gICAgICBpZiAob3B0aW9ucy5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgbGV0IG5ld0luZGV4ID0gMFxuICAgICAgICBsZXQgb2xkT3B0aW9uXG5cbiAgICAgICAgbGV0IGZvY3VzZWRFbGVtZW50ID0gdGhpcy5fd3JhcHBlckVsZW1lbnQuZmluZChgLiR7Q0xBU1NfSVRFTV9GT0NVU0VEfWApXG4gICAgICAgIGxldCBzZWFyY2hGb3IgPSBmb2N1c2VkRWxlbWVudCA/IENMQVNTX0lURU1fRk9DVVNFRCA6IENMQVNTX0lURU1fU0VMRUNURURcblxuICAgICAgICBsZXQgbmV3RWxlbWVudFxuXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBvcHRpb25zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIGxldCBkaXJlY3Rpb24gPSBrZXljb2RlID09PSBJbnB1dHMuS0VZX0FSUk9XX0RPV04gPyAxIDogLTFcblxuICAgICAgICAgIGxldCBpdGVtID0gbmV3IERvbUVsZW1lbnQob3B0aW9uc1tpbmRleF0pXG5cbiAgICAgICAgICAvLyBzZWFyY2ggZm9yIHNlbGVjdGVkIG9yIGZvY3VzZWRFbGVtZW50IGVsZW1lbnRzXG4gICAgICAgICAgaWYgKGl0ZW0uaGFzQ2xhc3Moc2VhcmNoRm9yKSkge1xuICAgICAgICAgICAgb2xkT3B0aW9uID0gaXRlbVxuICAgICAgICAgICAgbmV3SW5kZXggPSBpbmRleFxuXG4gICAgICAgICAgICAvLyBnZXQgdGhlIG5leHQgbm90IGRpc2FibGVkIGVsZW1lbnQgaW4gdGhlIGFwcHJvcHJpYXRlIGRpcmVjdGlvblxuICAgICAgICAgICAgZm9yIChsZXQgY291bnQgPSAwOyBjb3VudCA8IG9wdGlvbnMubGVuZ3RoOyBjb3VudCsrKSB7XG4gICAgICAgICAgICAgIG5ld0luZGV4ICs9IGRpcmVjdGlvblxuICAgICAgICAgICAgICBuZXdJbmRleCAlPSBvcHRpb25zLmxlbmd0aFxuXG4gICAgICAgICAgICAgIGlmIChuZXdJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICBuZXdJbmRleCA9IG9wdGlvbnMubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbmV3RWxlbWVudCA9IG5ldyBEb21FbGVtZW50KG9wdGlvbnNbbmV3SW5kZXhdKVxuICAgICAgICAgICAgICBpZiAoIW5ld0VsZW1lbnQuaGFzQ2xhc3MoQ0xBU1NfSVRFTV9ESVNBQkxFRCkpIHtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHRoZSBuZXcgZWxlbWVudCBmb2N1c2VkXG4gICAgICAgIHNjcm9sbEludG9WaWV3KG9wdGlvbnNbbmV3SW5kZXhdKVxuICAgICAgICBsZXQgbmV3T3B0aW9uID0gbmV3IERvbUVsZW1lbnQob3B0aW9uc1tuZXdJbmRleF0pXG4gICAgICAgIG5ld09wdGlvbi5hZGRDbGFzcyhDTEFTU19JVEVNX0ZPQ1VTRUQpXG5cbiAgICAgICAgaWYgKG9sZE9wdGlvbikge1xuICAgICAgICAgIG9sZE9wdGlvbi5yZW1vdmVDbGFzcyhDTEFTU19JVEVNX0ZPQ1VTRUQpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChJbnB1dHMuZ2V0S2V5VmFsdWUoa2V5Y29kZSkgJiYgIXRoaXMuX2lzRmlsdGVyYWJsZSgpKSB7XG4gICAgICAvLyBLZXlib2FyZCBrZXlzXG5cbiAgICAgIGxldCBvcHRpb25zID0gdGhpcy5fd3JhcHBlckVsZW1lbnQuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuJHtDTEFTU19JVEVNfWApIGFzIE5vZGVMaXN0T2Y8SFRNTEVsZW1lbnQ+XG4gICAgICBpZiAob3B0aW9ucy5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgbGV0IG9sZEZvY3VzSW5kZXggPSAwXG4gICAgICAgIGxldCBoYXNGb2N1c2VkT3B0aW9uID0gZmFsc2VcblxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgb3B0aW9ucy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBsZXQgaXRlbSA9IG5ldyBEb21FbGVtZW50KG9wdGlvbnNbaW5kZXhdKVxuXG4gICAgICAgICAgaWYgKGl0ZW0uaGFzQ2xhc3MoQ0xBU1NfSVRFTV9GT0NVU0VEKSkge1xuICAgICAgICAgICAgaXRlbS5yZW1vdmVDbGFzcyhDTEFTU19JVEVNX0ZPQ1VTRUQpXG5cbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGl0ZW0uaW5uZXJUZXh0LnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKElucHV0cy5nZXRLZXlWYWx1ZShrZXljb2RlKSkpIHtcbiAgICAgICAgICAgICAgaGFzRm9jdXNlZE9wdGlvbiA9IHRydWVcbiAgICAgICAgICAgICAgb2xkRm9jdXNJbmRleCA9IGluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5ld09wdGlvbiA9IHRoaXMuX2ZvY3VzT3B0aW9uU3RhcnRpbmdXaXRoKGtleWNvZGUsIGhhc0ZvY3VzZWRPcHRpb24gPyBvbGRGb2N1c0luZGV4ICsgMSA6IDAsIG9wdGlvbnMpXG4gICAgICAgIGlmIChuZXdPcHRpb24gPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgdGhpcy5fZm9jdXNPcHRpb25TdGFydGluZ1dpdGgoa2V5Y29kZSwgMCwgb3B0aW9ucylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBldnQucHJldmVudERlZmF1bHQoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGtleWNvZGUgPT09IElucHV0cy5LRVlfRU5URVIgfHwga2V5Y29kZSA9PT0gSW5wdXRzLktFWV9UQUIpIHtcbiAgICAgIC8vIEhhbmRsZSBlbnRlciBhbmQgdGFiIGtleSBieSBzZWxlY3RpbmcgdGhlIGN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnRcbiAgICAgIGxldCBuZXdJdGVtID0gdGhpcy5fZHJvcGRvd25FbGVtZW50LmVsZW1lbnQucXVlcnlTZWxlY3RvcihgLiR7Q0xBU1NfSVRFTV9GT0NVU0VEfWApIVxuICAgICAgdGhpcy5fc2VsZWN0ZWRJdGVtQ2hhbmdlZChuZXdJdGVtLCB0cnVlLCB0aGlzLl9tdWx0aXNlbGVjdGlvbilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIGEga2V5IGluIHRoZSBmaWx0ZXIgZmllbGRcbiAgICovXG4gIHByaXZhdGUgX2hhbmRsZUZpbHRlcktleWRvd24oZTogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuICAgIGNvbnN0IGtleWNvZGUgPSBlLndoaWNoIHx8IGUua2V5Q29kZVxuXG4gICAgLy8gSWYgdGhlIHVzZXIgaGl0cyB0aGUgZW50ZXIga2V5IHdoaWxlIGZpbHRlcmluZyBhbmQgdGhlcmUncyBhIHNpbmdsZSBtYXRjaCwgc2VsZWN0IGl0XG4gICAgaWYgKGtleWNvZGUgPT09IElucHV0cy5LRVlfRU5URVIpIHtcbiAgICAgIGNvbnN0IGRyb3Bkb3duRWxlbWVudHMgPSB0aGlzLl9kcm9wZG93bkVsZW1lbnQuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuJHtDTEFTU19JVEVNfWApXG5cbiAgICAgIGlmIChkcm9wZG93bkVsZW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0aGlzLl9zZWxlY3RlZEl0ZW1DaGFuZ2VkKGRyb3Bkb3duRWxlbWVudHNbMF0sIHRydWUsIHRoaXMuX211bHRpc2VsZWN0aW9uKVxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gdGhlIHVzZXIgcmVsZWFzZXMgYSBrZXkgaW4gdGhlIGZpbHRlciBmaWVsZFxuICAgKi9cbiAgcHJpdmF0ZSBfaGFuZGxlRmlsdGVyS2V5dXAoZTogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnRcblxuICAgIC8vIEZpbHRlciBoYXMgY2hhbmdlZFxuICAgIGlmICh0YXJnZXQudmFsdWUgIT09IHRoaXMuX2FjdGl2ZUZpbHRlciAmJiB0YXJnZXQudmFsdWUgIT09IHRoaXMuX3BsYWNlaG9sZGVyVGV4dCAmJiB0YXJnZXQudmFsdWUgIT09IHRoaXMuX2xhc3RTZWxlY3RlZE9wdGlvbiEuaW5uZXJIVE1MKSB7XG4gICAgICB0aGlzLl9zZXRGaWx0ZXIodGFyZ2V0LnZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHRoZSB1c2VyIGZvY3Vzc2VzIHRoZSBmaWx0ZXIgaW5wdXQgZmllbGRcbiAgICovXG4gIHByaXZhdGUgX2hhbmRsZUZpbHRlckZvY3VzKGU6IEZvY3VzRXZlbnQpOiB2b2lkIHtcbiAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRhcmdldC5zZWxlY3QoKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRmlsdGVycyB0aGUgU2VsZWN0IGJ5IGEgZ2l2ZW4gZmlsdGVyIGtleXdvcmRcbiAgICogQHBhcmFtIGZpbHRlciBLZXl3b3JkIHRvIGZpbHRlciBieVxuICAgKi9cbiAgcHJpdmF0ZSBfc2V0RmlsdGVyKGZpbHRlcjogc3RyaW5nID0gXCJcIik6IHZvaWQge1xuICAgIHRoaXMuX2FjdGl2ZUZpbHRlciA9IChmaWx0ZXIubGVuZ3RoID49IHRoaXMuX21pbkZpbHRlckxlbmd0aCkgPyBmaWx0ZXIgOiBcIlwiXG4gICAgdGhpcy5zZXRPcHRpb25zKHRoaXMuZ2V0SW5pdGlhbE9wdGlvbnMoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIGZpbHRlclxuICAgKi9cbiAgcHJpdmF0ZSBfY2xlYXJGaWx0ZXIoKTogdm9pZCB7XG4gICAgZGVsZXRlIHRoaXMuX2FjdGl2ZUZpbHRlclxuICAgIHRoaXMuc2V0T3B0aW9ucyh0aGlzLmdldEluaXRpYWxPcHRpb25zKCkpXG4gIH1cblxuICAvKipcbiAgICogU2V0IG5ldyBjb250ZW50IGFuZCByZWxvYWQgdGhlIFNlbGVjdFxuICAgKiBAcGFyYW0gZWxlbWVudHMgQXJyYXkgb2YgbmV3IG9wdGlvbiAob3Igb3B0Z3JvdXApIGVsZW1lbnRzIHRvIGRpc3BsYXlcbiAgICovXG4gIHByaXZhdGUgc2V0T3B0aW9ucyhvcHRpb25zOiBFbGVtZW50W10pOiB2b2lkIHtcbiAgICB0aGlzLl9lbXB0eU5vZGUodGhpcy5lbGVtZW50KVxuXG4gICAgb3B0aW9ucy5mb3JFYWNoKChvcHRpb24pID0+IHtcbiAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZChvcHRpb24pXG4gICAgfSlcblxuICAgIC8vIFByZXNlcnZlIHNlbGVjdGVkIHZhbHVlIGlmIHRoZSBzZWxlY3RlZFxuICAgIHRoaXMuZWxlbWVudC52YWx1ZSA9IHRoaXMuX2xhc3RTZWxlY3RlZE9wdGlvbiEudmFsdWVcblxuICAgIHRoaXMucmVsb2FkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgY2hpbGRyZW4gb2YgYSBnaXZlbiBub2RlXG4gICAqIEBwYXJhbSBub2RlIE5vZGVcbiAgICovXG4gIHByaXZhdGUgX2VtcHR5Tm9kZShub2RlOiBOb2RlKTogdm9pZCB7XG4gICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBhbiBvcHRpb24gaXMgYSBwbGFjZWhvbGRlciBvcHRpb25cbiAgICovXG4gIHByaXZhdGUgX2lzUGxhY2Vob2xkZXIob3B0aW9uOiBIVE1MT3B0aW9uRWxlbWVudCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBvcHRpb24uaGFzQXR0cmlidXRlKFwiZGlzYWJsZWRcIikgJiYgb3B0aW9uLmhhc0F0dHJpYnV0ZShcInNlbGVjdGVkXCIpXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHBsYWNlaG9sZGVyIHZhbHVlXG4gICAqIEBwYXJhbSB0ZXh0IENvbnRlbnQgb2YgdGhlIHBsYWNlaG9sZGVyXG4gICAqL1xuICBwcm90ZWN0ZWQgX3NldFBsYWNlaG9sZGVyKHRleHQ6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9wbGFjZWhvbGRlckVsZW1lbnQgJiYgdGV4dCkge1xuICAgICAgaWYgKHRoaXMuX2lzRmlsdGVyYWJsZSgpKSB7XG4gICAgICAgICh0aGlzLl9wbGFjZWhvbGRlckVsZW1lbnQgYXMgRG9tRWxlbWVudDxIVE1MSW5wdXRFbGVtZW50PikuZWxlbWVudC52YWx1ZSA9IHRleHRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyRWxlbWVudC5zZXRIdG1sKHRleHQpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZhbHVlIG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgb3B0aW9uLlxuICAgKiBJZiBtdWx0aXBsZSBzZWxlY3Rpb24gaXMgZW5hYmxlZCB0aGlzIHByb3BlcnR5IHJldHVybnMgYW4gYXJyYXkgb2YgdmFsdWVzLlxuICAgKi9cbiAgZ2V0IHZhbHVlKCkge1xuICAgIGlmICh0aGlzLl9tdWx0aXNlbGVjdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFNlbGVjdGVkT3B0aW9ucygpLm1hcCgoeCkgPT4geC52YWx1ZSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5lbGVtZW50LnZhbHVlID09PSBcIlwiKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmVsZW1lbnQudmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzZWxlY3QgY29tcG9uZW50IGRlcGVuZGluZyBvbiB0aGVcbiAgICogJ3ZhbHVlJyBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSB7dmFsdWV9IElmIHRydWUgZGlzYWJsZXMgdGhlIGNvbnRyb2w7IGZhbHNlIGVuYWJsZXMgaXQuXG4gICAqL1xuICBzZXQgZGlzYWJsZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuZGlzYWJsZSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW5hYmxlKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVsb2FkcyB0aGUgZHJvcGRvd24ncyBvcHRpb24gZGF0YSBkZWZpbml0aW9ucyBmcm9tIHRoZSBET00gYW5kIHVwZGF0ZXNcbiAgICogdGhlIGdlbmVyYXRlZCBkcm9wZG93biBkaXNwbGF5IGl0ZW1zLlxuICAgKi9cbiAgcHVibGljIHJlbG9hZCgpIHtcbiAgICAvLyBSZW1vdmUgYWxsIGV4aXN0aW5nIGNoaWxkIGVsZW1lbnRzXG4gICAgdGhpcy5fZW1wdHlOb2RlKHRoaXMuX2Ryb3Bkb3duRWxlbWVudC5lbGVtZW50KVxuXG4gICAgaWYgKHRoaXMuX2FjdGl2ZUZpbHRlciA9PT0gdW5kZWZpbmVkKSB7IC8vIElmIHRoZSB1c2VyIGlzIGZpbHRlcmluZywgbGV0IHRoZSBwbGFjZWhvbGRlciBcImlucHV0XCIgYWxpdmVcbiAgICAgIHRoaXMuX3NldHVwUGxhY2Vob2xkZXIoKVxuICAgIH1cblxuICAgIHRoaXMuX2NyZWF0ZU9wdGlvbnModGhpcy5lbGVtZW50KVxuXG4gICAgdGhpcy5fdXBkYXRlU2l6ZSgpXG4gICAgdGhpcy5fdXBkYXRlTWVzc2FnZSgpXG5cbiAgICBpZiAoIXRoaXMuX2lzRmlsdGVyYWJsZSgpKSB7XG4gICAgICB0aGlzLl91cGRhdGVQbGFjZWhvbGRlcighIXRoaXMudmFsdWUpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNlbGVjdCBjb250cm9sIHRvIHRoZSBlbmFibGVkIHN0YXRlLlxuICAgKi9cbiAgcHVibGljIGVuYWJsZSgpIHtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiZGlzYWJsZWRcIilcbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5yZW1vdmVDbGFzcyhDTEFTU19ESVNBQkxFRClcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuXG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fY2xpY2tIYW5kbGVyKVxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fa2V5ZG93bkhhbmRsZXIpXG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5fZm9jdXNIYW5kbGVyKVxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5fYmx1ckhhbmRsZXIpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc2VsZWN0IGNvbnRyb2wgdG8gdGhlIGRpc2FibGVkIHN0YXRlLlxuICAgKi9cbiAgcHVibGljIGRpc2FibGUoKSB7XG4gICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpXG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuYWRkQ2xhc3MoQ0xBU1NfRElTQUJMRUQpXG5cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcblxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2NsaWNrSGFuZGxlcilcbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2tleWRvd25IYW5kbGVyKVxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuX2ZvY3VzSGFuZGxlcilcbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuX2JsdXJIYW5kbGVyKVxuXG4gICAgdGhpcy5jbG9zZSgpXG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgb3Blbi9jbG9zZWQgc3RhdGUgb2YgdGhlIHNlbGVjdCBkcm9wZG93bi5cbiAgICovXG4gIHB1YmxpYyB0b2dnbGUoKSB7XG4gICAgaWYgKHRoaXMuaXNPcGVuKCkpIHtcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wZW4oKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGlmIHRoZSBzZWxlY3QgZHJvcGRvd24gaXMgb3BlbiBvciBjbG9zZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgb3Blbjsgb3RoZXJ3aXNlIGZhbHNlLlxuICAgKi9cbiAgcHVibGljIGlzT3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlckVsZW1lbnQuaGFzQ2xhc3MoQ0xBU1NfT1BFTilcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVucyB0aGUgc2VsZWN0IGRyb3Bkb3duLlxuICAgKi9cbiAgcHVibGljIG9wZW4oKSB7XG4gICAgaWYgKCF0aGlzLmlzT3BlbigpKSB7XG4gICAgICB0aGlzLl9vcGVuQnlGb2N1cyA9IGZhbHNlXG5cbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LnJlbW92ZUNsYXNzKENMQVNTX0NMT1NFRClcbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmFkZENsYXNzKENMQVNTX09QRU4pXG5cbiAgICAgIHRoaXMuX2Ryb3Bkb3duRWxlbWVudC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9oYW5kbGVEcm9wZG93bkNsaWNrKVxuICAgICAgdGhpcy5fZHJvcGRvd25FbGVtZW50LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRhcFwiLCB0aGlzLl9oYW5kbGVEcm9wZG93bkNsaWNrKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIHNlbGVjdCBkcm9wZG93bi5cbiAgICovXG4gIHB1YmxpYyBjbG9zZSgpIHtcbiAgICBpZiAodGhpcy5pc09wZW4oKSkge1xuICAgICAgdGhpcy5fb3BlbkJ5Rm9jdXMgPSBmYWxzZVxuXG4gICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5yZW1vdmVDbGFzcyhDTEFTU19PUEVOKVxuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuYWRkQ2xhc3MoQ0xBU1NfQ0xPU0VEKVxuXG4gICAgICAvLyBJZiB0aGUgU2VsZWN0IGlzIGZpbHRlcmFibGUgYW5kIHRoZXJlZm9yZSBoYXMgYW4gaW5wdXQgZmllbGQsXG4gICAgICAvLyByZXNldCB0aGUgdmFsdWUgb2YgaXQgdG8gdGhlIGNob3NlbiBvcHRpb25cbiAgICAgIGlmICh0aGlzLl9pc0ZpbHRlcmFibGUoKSkge1xuICAgICAgICAvLyBVbmZvY3VzIGlucHV0IGZpZWxkXG4gICAgICAgICh0aGlzLl9wbGFjZWhvbGRlckVsZW1lbnQuZWxlbWVudCBhcyBIVE1MSW5wdXRFbGVtZW50KS5ibHVyKClcblxuICAgICAgICBpZiAoIXRoaXMuX2FjdGl2ZUZpbHRlciB8fCB0aGlzLl9hY3RpdmVGaWx0ZXIgPT09IHRoaXMuX2xhc3RTZWxlY3RlZE9wdGlvbiEuaW5uZXJIVE1MKSB7XG4gICAgICAgICAgdGhpcy5fc2V0UGxhY2Vob2xkZXIodGhpcy5fbGFzdFNlbGVjdGVkT3B0aW9uIS5pbm5lckhUTUwpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fZHJvcGRvd25FbGVtZW50LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2hhbmRsZURyb3Bkb3duQ2xpY2spXG4gICAgICB0aGlzLl9kcm9wZG93bkVsZW1lbnQuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidGFwXCIsIHRoaXMuX2hhbmRsZURyb3Bkb3duQ2xpY2spXG5cbiAgICAgIGxldCBmb2N1c2VkSXRlbSA9IHRoaXMuX3dyYXBwZXJFbGVtZW50LmZpbmQoYC4ke0NMQVNTX0lURU1fRk9DVVNFRH1gKVxuXG4gICAgICBpZiAoZm9jdXNlZEl0ZW0pIHtcbiAgICAgICAgZm9jdXNlZEl0ZW0ucmVtb3ZlQ2xhc3MoQ0xBU1NfSVRFTV9GT0NVU0VEKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgZWxlbWVudCBoYXMgdGhlIGZpbHRlciBtb2RpZmllciBjbGFzc1xuICAgKi9cbiAgcHJpdmF0ZSBfaXNGaWx0ZXJhYmxlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl93cmFwcGVyRWxlbWVudC5oYXNDbGFzcyhDTEFTU19GSUxURVJBQkxFKVxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBjb21wb25lbnQgYW5kIGNsZWFycyBhbGwgcmVmZXJlbmNlcy5cbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuXG4gICAgaWYgKHRoaXMuX2Ryb3Bkb3duRWxlbWVudCkge1xuICAgICAgdGhpcy5fZHJvcGRvd25FbGVtZW50LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2hhbmRsZURyb3Bkb3duQ2xpY2spXG4gICAgICB0aGlzLl9kcm9wZG93bkVsZW1lbnQuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidGFwXCIsIHRoaXMuX2hhbmRsZURyb3Bkb3duQ2xpY2spXG5cbiAgICAgIHJlbW92ZSh0aGlzLl9kcm9wZG93bkVsZW1lbnQuZWxlbWVudCk7XG4gICAgICAodGhpcyBhcyBhbnkpLl9kcm9wZG93bkVsZW1lbnQgPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcGxhY2Vob2xkZXJFbGVtZW50KSB7XG4gICAgICB0aGlzLl9wbGFjZWhvbGRlckVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fZmlsdGVyS2V5ZG93bkhhbmRsZXIpXG4gICAgICB0aGlzLl9wbGFjZWhvbGRlckVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIHRoaXMuX2ZpbHRlcktleXVwSGFuZGxlcilcbiAgICAgIHRoaXMuX3BsYWNlaG9sZGVyRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5fZmlsdGVyRm9jdXNIYW5kbGVyKVxuICAgIH1cblxuICAgIGlmICh0aGlzLl93cmFwcGVyRWxlbWVudCkge1xuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fY2xpY2tIYW5kbGVyKVxuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9rZXlkb3duSGFuZGxlcilcbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuX2ZvY3VzSGFuZGxlcilcbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5fYmx1ckhhbmRsZXIpO1xuXG4gICAgICAodGhpcyBhcyBhbnkpLl93cmFwcGVyRWxlbWVudCA9IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9zZWxlY3RCdXR0b25FbGVtZW50KSB7XG4gICAgICByZW1vdmUodGhpcy5fc2VsZWN0QnV0dG9uRWxlbWVudC5lbGVtZW50KTtcbiAgICAgICh0aGlzIGFzIGFueSkuX3NlbGVjdEJ1dHRvbkVsZW1lbnQgPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICB0aGlzLnJlbW92ZUNsYXNzKENMQVNTX0NMT1NFRClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZTxIVE1MU2VsZWN0RWxlbWVudD4oXCJzZWxlY3RcIiwgKGUpID0+IHtcbiAgICBuZXcgU2VsZWN0KGUpXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IFNlbGVjdFxuIiwiaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgKiBhcyBEb20gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5cbmNvbnN0IFFVRVJZX1RFWFRBUkVBID0gXCJ0ZXh0YXJlYVwiXG5jb25zdCBDTEFTU19IQVNfVkFMVUUgPSBcImlzLWZpeGVkXCJcblxuLyoqXG4gKiBUZXh0YXJlYSBjb21wb25lbnRcbiAqL1xuY2xhc3MgVGV4dGFyZWEgZXh0ZW5kcyBEb21FbGVtZW50IHtcbiAgcHJpdmF0ZSBfYXJlYTogSFRNTFRleHRBcmVhRWxlbWVudFxuXG4gIHByaXZhdGUgX2ZvY3VzQ2hhbmdlZEhhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF92YWx1ZUNoYW5nZWRIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfcmVzaXplSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG5cbiAgcHJpdmF0ZSBfbWluUm93cyE6IG51bWJlclxuICBwcml2YXRlIF9tYXhSb3dzITogbnVtYmVyXG4gIHByaXZhdGUgX2xpbmVIZWlnaHQhOiBudW1iZXJcblxuICBwcml2YXRlIF91cGRhdGVCYXNlSGVpZ2h0ITogYm9vbGVhblxuXG4gIHByaXZhdGUgX2Jhc2VIZWlnaHQhOiBudW1iZXJcbiAgcHJpdmF0ZSBfYmFzZVNjcm9sbEhlaWdodCE6IG51bWJlclxuXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEVsZW1lbnQpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgdGhpcy5fYXJlYSA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX1RFWFRBUkVBKSFcblxuICAgIHRoaXMuX2ZvY3VzQ2hhbmdlZEhhbmRsZXIgPSB0aGlzLl9mb2N1c0NoYW5nZWQuYmluZCh0aGlzKVxuICAgIHRoaXMuX3ZhbHVlQ2hhbmdlZEhhbmRsZXIgPSB0aGlzLl9vblZhbHVlQ2hhbmdlZC5iaW5kKHRoaXMpXG4gICAgdGhpcy5fcmVzaXplSGFuZGxlciA9IHRoaXMuX3VwZGF0ZUhlaWdodC5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgdGV4dGFyZWEgY29tcG9uZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplKCkge1xuICAgIHRoaXMuX21pblJvd3MgPSBwYXJzZUludCh0aGlzLl9hcmVhLmdldEF0dHJpYnV0ZShcImRhdGEtbWluLXJvd3NcIikgfHwgXCIzXCIsIDEwKVxuICAgIHRoaXMuX21heFJvd3MgPSBwYXJzZUludCh0aGlzLl9hcmVhLmdldEF0dHJpYnV0ZShcImRhdGEtbWF4LXJvd3NcIikhLCAxMCkgfHwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcblxuICAgIC8vIE1ha2Ugc3VyZSBtaW4gYW4gbWF4IGFyZSBwcm9wZXJ0eSBzcGVjaWZpZWRcbiAgICB0aGlzLl9taW5Sb3dzID0gTWF0aC5taW4odGhpcy5fbWluUm93cywgdGhpcy5fbWF4Um93cylcbiAgICB0aGlzLl9tYXhSb3dzID0gTWF0aC5tYXgodGhpcy5fbWluUm93cywgdGhpcy5fbWF4Um93cylcblxuICAgIHRoaXMuX2xpbmVIZWlnaHQgPSBwYXJzZUludChEb20uY3NzKHRoaXMuX2FyZWEsIFwibGluZS1oZWlnaHRcIiksIDEwKVxuXG4gICAgdGhpcy5fdXBkYXRlQmFzZUhlaWdodCA9IERvbS5pc0hpZGRlbih0aGlzLl9hcmVhLCB0cnVlKVxuICAgIHRoaXMuX2NhbGN1bGF0ZUJhc2VIZWlnaHQoKVxuXG4gICAgLy8gYWRkIGV2ZW50IGxpc3RlbmVyc1xuICAgIHRoaXMuX2FyZWEuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuX2ZvY3VzQ2hhbmdlZEhhbmRsZXIpXG4gICAgdGhpcy5fYXJlYS5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLl9mb2N1c0NoYW5nZWRIYW5kbGVyKVxuICAgIHRoaXMuX2FyZWEuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHRoaXMuX3ZhbHVlQ2hhbmdlZEhhbmRsZXIpXG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLl9yZXNpemVIYW5kbGVyKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgdGhpcy5fcmVzaXplSGFuZGxlcilcblxuICAgIHRoaXMuX29uVmFsdWVDaGFuZ2VkKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfY2FsY3VsYXRlQmFzZUhlaWdodCgpIHtcbiAgICAvLyB0ZW1wb3JhcnkgY2xlYXIgdGhlIGNvbnRlbnQgdG8gdGFrZSBtZWFzdXJlbWVudHNcbiAgICBsZXQgdmFsdWUgPSB0aGlzLl9hcmVhLnZhbHVlXG4gICAgdGhpcy5fYXJlYS52YWx1ZSA9IFwiXCJcblxuICAgIHRoaXMuX2Jhc2VIZWlnaHQgPSB0aGlzLl9hcmVhLm9mZnNldEhlaWdodCAtIHRoaXMuX2xpbmVIZWlnaHRcbiAgICB0aGlzLl9iYXNlU2Nyb2xsSGVpZ2h0ID0gdGhpcy5fYXJlYS5zY3JvbGxIZWlnaHQgLSB0aGlzLl9saW5lSGVpZ2h0XG5cbiAgICAvLyByZXN0b3JlIGluaXRpYWwgY29udGVudFxuICAgIHRoaXMuX2FyZWEudmFsdWUgPSB2YWx1ZVxuICB9XG5cbiAgcHJvdGVjdGVkIF9mb2N1c0NoYW5nZWQoKSB7XG4gICAgdGhpcy5fdXBkYXRlSGVpZ2h0KClcbiAgfVxuXG4gIHByb3RlY3RlZCBfdXBkYXRlSGVpZ2h0KCkge1xuICAgIGxldCBoYXNGb2N1cyA9IHRoaXMuX2FyZWEgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRcbiAgICBsZXQgbWF4Um93cywgcm93cyA9IDBcblxuICAgIGlmICh0aGlzLl91cGRhdGVCYXNlSGVpZ2h0ID09PSB0cnVlICYmIERvbS5pc0hpZGRlbih0aGlzLl9hcmVhLCB0cnVlKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuX2NhbGN1bGF0ZUJhc2VIZWlnaHQoKVxuICAgICAgdGhpcy5fdXBkYXRlQmFzZUhlaWdodCA9IGZhbHNlXG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBhcHJvcHJpYXRlIHNpemUgZm9yIHRoZSBjb250cm9sXG4gICAgaWYgKCF0aGlzLl9oYXNWYWx1ZSgpKSB7XG4gICAgICAvLyBIYW5kbGUgZW1wdHkgc3RhdGVzXG4gICAgICByb3dzID0gaGFzRm9jdXMgPT09IHRydWUgPyB0aGlzLl9taW5Sb3dzIDogMVxuICAgICAgbWF4Um93cyA9IHJvd3NcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVzZXQgdGhlIGhlaWdodCBmb3IgY2FsY3VsYXRpb24gb2YgdGhlIHJvdyBjb3VudFxuICAgICAgdGhpcy5fYXJlYS5zdHlsZS5oZWlnaHQgPSBcImF1dG9cIlxuXG4gICAgICAvLyBHZXQgdGhlIG5ldyBoZWlnaHRcbiAgICAgIHJvd3MgPSBNYXRoLmNlaWwoKHRoaXMuX2FyZWEuc2Nyb2xsSGVpZ2h0IC0gdGhpcy5fYmFzZVNjcm9sbEhlaWdodCkgLyB0aGlzLl9saW5lSGVpZ2h0KSArIDFcbiAgICAgIG1heFJvd3MgPSBNYXRoLm1heChNYXRoLm1pbih0aGlzLl9tYXhSb3dzLCByb3dzKSwgdGhpcy5fbWluUm93cylcbiAgICB9XG5cbiAgICBpZiAocm93cyA+IHRoaXMuX21heFJvd3MpIHtcbiAgICAgIHRoaXMuX2FyZWEuc3R5bGUub3ZlcmZsb3cgPSBcImF1dG9cIlxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hcmVhLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIlxuICAgIH1cblxuICAgIGNvbnN0IGhlaWdodCA9ICgobWF4Um93cyAtIDEpICogdGhpcy5fbGluZUhlaWdodCkgKyB0aGlzLl9iYXNlSGVpZ2h0XG4gICAgdGhpcy5fYXJlYS5zdHlsZS5oZWlnaHQgPSBgJHtoZWlnaHR9cHhgXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhc1ZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9hcmVhLnZhbHVlICYmIHRoaXMuX2FyZWEudmFsdWUubGVuZ3RoID4gMFxuICB9XG5cbiAgcHJvdGVjdGVkIF9vblZhbHVlQ2hhbmdlZCgpIHtcbiAgICBpZiAodGhpcy5faGFzVmFsdWUoKSkge1xuICAgICAgRG9tLmFkZENsYXNzKHRoaXMuX2FyZWEsIENMQVNTX0hBU19WQUxVRSlcbiAgICB9IGVsc2Uge1xuICAgICAgRG9tLnJlbW92ZUNsYXNzKHRoaXMuX2FyZWEsIENMQVNTX0hBU19WQUxVRSlcbiAgICAgIHRoaXMuX2FyZWEudmFsdWUgPSBcIlwiXG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlSGVpZ2h0KClcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgY29tcG9uZW50IGFuZCBjbGVhcnMgYWxsIHJlZmVyZW5jZXMuXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLl9yZXNpemVIYW5kbGVyKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgdGhpcy5fcmVzaXplSGFuZGxlcilcblxuICAgIHRoaXMuX2FyZWEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuX2ZvY3VzQ2hhbmdlZEhhbmRsZXIpXG4gICAgdGhpcy5fYXJlYS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLl9mb2N1c0NoYW5nZWRIYW5kbGVyKVxuICAgIHRoaXMuX2FyZWEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHRoaXMuX3ZhbHVlQ2hhbmdlZEhhbmRsZXIpO1xuXG4gICAgKHRoaXMgYXMgYW55KS5fZm9jdXNDaGFuZ2VkSGFuZGxlciA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fdmFsdWVDaGFuZ2VkSGFuZGVyID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9hcmVhID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9taW5Sb3dzID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9tYXhSb3dzID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9saW5lSGVpZ2h0ID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9iYXNlSGVpZ2h0ID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9iYXNlU2Nyb2xsSGVpZ2h0ID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLmVsZW1lbnQgPSBudWxsXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHNlYXJjaEFuZEluaXRpYWxpemUoXCIuaW5wdXQtbXVsdGlsaW5lLCAuaW5wdXQtZmllbGQtLW11bHRpbGluZVwiLCAoZSkgPT4ge1xuICAgIG5ldyBUZXh0YXJlYShlKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBUZXh0YXJlYVxuIiwiaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSB9IGZyb20gXCIuLi9VdGlsc1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5cbi8qKlxuICogTG9hZGVyIGJhciBjb21wb25lbnRcbiAqL1xuY2xhc3MgTG9hZGVyQmFyIGV4dGVuZHMgRG9tRWxlbWVudCB7XG4gIHByaXZhdGUgcHJvZ3Jlc3NFbGVtZW50ITogRG9tRWxlbWVudFxuICBwcml2YXRlIGZpbGVOYW1lRWxlbWVudCE6IERvbUVsZW1lbnRcbiAgcHJpdmF0ZSBwcm9ncmVzc0xhYmVsRWxlbWVudCE6IERvbUVsZW1lbnRcbiAgcHJpdmF0ZSB0b3RhbFByb2dyZXNzRWxlbWVudCE6IERvbUVsZW1lbnRcblxuICBwcml2YXRlIHZhbHVlITogbnVtYmVyXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGluaXRpYWxpemVzIHRoZSBMb2FkZXJCYXIgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IC0gVGhlIHJvb3QgZWxlbWVudCBvZiB0aGUgTG9hZGVyQmFyIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEVsZW1lbnQpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuICAgIHRoaXMuX2luaXRpYWxpemUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBsb2FkZXIgYmFyIGNvbXBvbmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLnByb2dyZXNzRWxlbWVudCA9IHRoaXMuZmluZChcIi5pbmRpY2F0b3JcIikgfHwgdGhpc1xuICAgIHRoaXMuZmlsZU5hbWVFbGVtZW50ID0gdGhpcy5maW5kKFwiLmRldGFpbCA+IC5uYW1lXCIpIVxuICAgIHRoaXMucHJvZ3Jlc3NMYWJlbEVsZW1lbnQgPSB0aGlzLmZpbmQoXCIucHJvZ3Jlc3NcIikhXG4gICAgdGhpcy50b3RhbFByb2dyZXNzRWxlbWVudCA9IHRoaXMuZmluZChcIi5wcm9ncmVzcyA+IC5maWxlLXNpemVcIikhXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBwcm9ncmVzcyB2YWx1ZSBpbiB0aGUgcmFuZ2Ugb2YgMC4uMS5cbiAgICovXG4gIGdldCBwcm9ncmVzcygpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGN1cnJlbnQgcHJvZ3Jlc3MuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAtIFRoZSBwcm9ncmVzcyBpbiB0aGUgcmFuZ2Ugb2YgMC4uMS5cbiAgICovXG4gIHNldCBwcm9ncmVzcyh2YWwpIHtcbiAgICAvLyB2YWwgPSBjbGFtcCh2YWwsIDAsIDEpXG5cbiAgICBsZXQgcGVyY2VudGFnZSA9ICh2YWwgKiAxMDApLnRvRml4ZWQoMClcblxuICAgIHRoaXMudmFsdWUgPSB2YWw7XG4gICAgKHRoaXMuZWxlbWVudCBhcyBIVE1MSW5wdXRFbGVtZW50KS52YWx1ZSA9IFN0cmluZyh2YWwpXG5cbiAgICB0aGlzLnByb2dyZXNzRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBgd2lkdGg6ICR7dmFsICogMTAwfSVgKVxuXG4gICAgaWYgKHRoaXMucHJvZ3Jlc3NMYWJlbEVsZW1lbnQpIHtcbiAgICAgIHRoaXMucHJvZ3Jlc3NMYWJlbEVsZW1lbnQuZWxlbWVudC50ZXh0Q29udGVudCA9IGAke3BlcmNlbnRhZ2V9JWBcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgZmlsZW5hbWUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIGZpbGVuYW1lLlxuICAgKi9cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIGlmICghdGhpcy5maWxlTmFtZUVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maWxlTmFtZUVsZW1lbnQuZWxlbWVudC5pbm5lckhUTUxcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBmaWxlbmFtZS5cbiAgICovXG4gIHNldCBmaWxlbmFtZSh2YWw6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICAgIGlmICghdGhpcy5maWxlTmFtZUVsZW1lbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgdGhlIGZpbGVuYW1lLCBtaXNzaW5nIGRldGFpbCBlbGVtZW50XCIpXG4gICAgfVxuXG4gICAgdGhpcy5maWxlTmFtZUVsZW1lbnQuc2V0SHRtbCh2YWwgfHwgXCJcIilcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBmaWxlIHNpemUgbGFiZWwuXG4gICAqL1xuICBzZXQgZmlsZVNpemUodmFsOiBzdHJpbmcpIHtcbiAgICBpZiAoIXRoaXMudG90YWxQcm9ncmVzc0VsZW1lbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgdGhlIGZpbGVTaXplLCBtaXNzaW5nIGRldGFpbCBlbGVtZW50XCIpXG4gICAgfVxuXG4gICAgdGhpcy50b3RhbFByb2dyZXNzRWxlbWVudC5zZXRIdG1sKHZhbClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZShcIi5sb2FkZXItYmFyXCIsIChlKSA9PiB7XG4gICAgbmV3IExvYWRlckJhcihlKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBMb2FkZXJCYXJcbiIsImltcG9ydCBhbmltZSBmcm9tIFwiYW5pbWVqc1wiXG5pbXBvcnQgUG9wcGVyIGZyb20gXCJwb3BwZXIuanNcIlxuXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5pbXBvcnQgeyBhZGRDbGFzcywgaGFzQ2xhc3MsIHJlbW92ZUNsYXNzLCBpc0hpZGRlbiwgcGFyZW50V2l0aENsYXNzIH0gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5cbmNvbnN0IENMQVNTX09QRU4gPSBcImlzLW9wZW5cIlxuY29uc3QgQ0xBU1NfTUVOVSA9IFwianMtZmx5b3V0XCJcbmNvbnN0IENMQVNTX1RBQlMgPSBcInRhYnNcIlxuXG5jb25zdCBBTklNQVRJT05fT1BFTiA9IDMwMFxuY29uc3QgRUFTRV9JTlFVQURfT1VUX1FVSU5UID0gWyAwLjU1MCwgMC4wODUsIDAuMzIwLCAxIF1cblxuLyoqXG4gKiBBIGNvbXBvbmVudCBmb3IgdGhlIGZseW91dCBtZW51LlxuICovXG5jbGFzcyBNZW51Rmx5b3V0IGV4dGVuZHMgRG9tRWxlbWVudCB7XG4gIHByaXZhdGUgX2NsaWNrSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX3dpbmRvd0NsaWNrSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG5cbiAgcHJpdmF0ZSBfYW5pbWF0aW9uRHVyYXRpb24gPSBBTklNQVRJT05fT1BFTlxuXG4gIHByaXZhdGUgX2R5bmFtaWNQbGFjZW1lbnQgPSBmYWxzZVxuXG4gIHByaXZhdGUgX2hpZGRlbkluZGljYXRvcj86IEhUTUxFbGVtZW50XG4gIHByaXZhdGUgX2ZseW91dEVsZW1lbnQhOiBIVE1MRWxlbWVudFxuXG4gIHByaXZhdGUgX3BvcHBlckluc3RhbmNlPzogUG9wcGVyXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGluaXRpYWxpemVzIHRoZSBmbHlvdXQgY29tcG9uZW50LlxuICAgKiBAcGFyYW0gZWxlbWVudCAtIFRoZSByb290IGVsZW1lbnQgb2YgdGhlIGZseW91dCBtZW51IGNvbXBvbmVudC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEVsZW1lbnQpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgdGhpcy5fY2xpY2tIYW5kbGVyID0gdGhpcy5faGFuZGxlQ2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZVdpbmRvd0NsaWNrLmJpbmQodGhpcylcblxuICAgIHRoaXMuX2luaXRpYWxpemUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBmbHlvdXQgY29tcG9uZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplKCkge1xuICAgIGxldCBkYXRhVGFyZ2V0ID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdGFyZ2V0XCIpXG4gICAgaWYgKGRhdGFUYXJnZXQgPT09IG51bGwgfHwgZGF0YVRhcmdldCA9PT0gXCJcIikge1xuXG4gICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlICovXG4gICAgICBjb25zb2xlLmVycm9yKFwiQSBmbHlvdXQgbWVudSBlbGVtZW50IHJlcXVpcmVzIGEgJ2RhdGEtdGFyZ2V0JyB0aGF0IHNwZWNpZmllcyB0aGUgZWxlbWVudCB0byBjb2xsYXBzZVwiKVxuICAgICAgY29uc29sZS5pbmZvKHRoaXMuZWxlbWVudClcbiAgICAgIC8qIHRzbGludDplbmFibGU6bm8tY29uc29sZSAqL1xuXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdXNlRHluYW1pY1BsYWNlbWVudCgpKSB7XG4gICAgICB0aGlzLl9keW5hbWljUGxhY2VtZW50ID0gdHJ1ZVxuICAgIH1cblxuICAgIGxldCBoaWRkZW5UYXJnZXQgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1oaWRkZW5cIilcbiAgICBpZiAoaGlkZGVuVGFyZ2V0ICE9PSBudWxsICYmIGhpZGRlblRhcmdldCAhPT0gXCJcIikge1xuICAgICAgdGhpcy5faGlkZGVuSW5kaWNhdG9yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihoaWRkZW5UYXJnZXQpIGFzIEhUTUxFbGVtZW50IHx8IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIHRoaXMuX2luaXRGbHlvdXRFbGVtZW50KGRhdGFUYXJnZXQpXG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jbGlja0hhbmRsZXIpXG4gIH1cblxuICBwcml2YXRlIF9pbml0Rmx5b3V0RWxlbWVudChkYXRhVGFyZ2V0OiBzdHJpbmcpIHtcbiAgICB0aGlzLl9mbHlvdXRFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihkYXRhVGFyZ2V0KSEgYXMgSFRNTEVsZW1lbnRcbiAgICB0aGlzLl9mbHlvdXRFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSBcIjBcIlxuICAgIHRoaXMuX2ZseW91dEVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGVZKC0yMHB4KVwiXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUNsaWNrKCkge1xuICAgIHRoaXMudG9nZ2xlKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlV2luZG93Q2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICBsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50XG5cbiAgICBpZiAocGFyZW50V2l0aENsYXNzKHRhcmdldCwgQ0xBU1NfTUVOVSkgPT09IHRoaXMuX2ZseW91dEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHdoaWxlICh0YXJnZXQgIT09IHRoaXMuZWxlbWVudCAmJiB0YXJnZXQucGFyZW50RWxlbWVudCkge1xuICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudEVsZW1lbnRcbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0ICE9PSB0aGlzLmVsZW1lbnQpIHtcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHByb3RlY3RlZCBfdXNlRHluYW1pY1BsYWNlbWVudCgpIHtcbiAgICByZXR1cm4gcGFyZW50V2l0aENsYXNzKHRoaXMuZWxlbWVudCwgQ0xBU1NfVEFCUylcbiAgfVxuXG4gIHByb3RlY3RlZCBfb3Blbk1lbnUoZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgYW5pbWUucmVtb3ZlKGVsKVxuXG4gICAgaWYgKHRoaXMuX2R5bmFtaWNQbGFjZW1lbnQgPT09IHRydWUpIHtcbiAgICAgIGNvbnN0IHBvcHBlck9wdGlvbnM6IFBvcHBlci5Qb3BwZXJPcHRpb25zID0ge1xuICAgICAgICBwbGFjZW1lbnQ6IFwiYm90dG9tXCIsXG4gICAgICAgIG1vZGlmaWVyczoge1xuICAgICAgICAgIGZsaXA6IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBldmVudHNFbmFibGVkOiBmYWxzZVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9wb3BwZXJJbnN0YW5jZSA9IG5ldyBQb3BwZXIodGhpcy5lbGVtZW50LCB0aGlzLl9mbHlvdXRFbGVtZW50LCBwb3BwZXJPcHRpb25zKVxuICAgIH1cblxuICAgIGFuaW1lKHtcbiAgICAgIHRhcmdldHM6IGVsLFxuICAgICAgZHVyYXRpb246IHRoaXMuX2FuaW1hdGlvbkR1cmF0aW9uLFxuICAgICAgZWFzaW5nOiBFQVNFX0lOUVVBRF9PVVRfUVVJTlQsXG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgdHJhbnNsYXRlWTogXCIwcHhcIixcbiAgICAgIGJlZ2luOiAoKSA9PiB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCJcbiAgICAgIH0sXG4gICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICBhZGRDbGFzcyhlbCwgQ0xBU1NfT1BFTilcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gc2V0IGFyaWEgZXhwYW5kZWRcbiAgICBlbC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIFwidHJ1ZVwiKVxuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFwib3BlbmVkXCIpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2Nsb3NlTWVudShlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBhbmltZS5yZW1vdmUoZWwpXG5cbiAgICBpZiAodGhpcy5fcG9wcGVySW5zdGFuY2UpIHtcbiAgICAgIHRoaXMuX3BvcHBlckluc3RhbmNlLmRlc3Ryb3koKVxuICAgICAgdGhpcy5fcG9wcGVySW5zdGFuY2UgPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBhbmltZSh7XG4gICAgICB0YXJnZXRzOiBlbCxcbiAgICAgIGR1cmF0aW9uOiB0aGlzLl9hbmltYXRpb25EdXJhdGlvbixcbiAgICAgIGVhc2luZzogRUFTRV9JTlFVQURfT1VUX1FVSU5ULFxuICAgICAgb3BhY2l0eTogMCxcbiAgICAgIHRyYW5zbGF0ZVk6IFwiLTIwcHhcIixcbiAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIlxuICAgICAgICByZW1vdmVDbGFzcyhlbCwgQ0xBU1NfT1BFTilcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gc2V0IGFyaWEgZXhwYW5kZWRcbiAgICBlbC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIFwiZmFsc2VcIilcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcImNsb3NlZFwiKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIG9wZW5pbmcgYW5pbWF0aW9uIGR1cmF0aW9uLlxuICAgKiBAcGFyYW0ge2R1cmF0aW9uSW5TZWNvbmRzfSAtIFRoZSBhbmltYXRpb24gZHVyYXRpb24gaW4gc2Vjb25kcy5cbiAgICovXG4gIHNldCBhbmltYXRpb25EdXJhdGlvbihkdXJhdGlvbkluU2Vjb25kczogbnVtYmVyKSB7XG4gICAgdGhpcy5fYW5pbWF0aW9uRHVyYXRpb24gPSBkdXJhdGlvbkluU2Vjb25kc1xuICB9XG5cbiAgLyoqXG4gICAqIE9wZW5zIHRoZSBmbHlvdXQgbWVudS5cbiAgICogQGZpcmVzIE1vZGFsI29wZW5lZFxuICAgKi9cbiAgcHVibGljIG9wZW4oKSB7XG4gICAgaWYgKHRoaXMuX2hpZGRlbkluZGljYXRvciAmJiBpc0hpZGRlbih0aGlzLl9oaWRkZW5JbmRpY2F0b3IsIGZhbHNlKSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGhhc0NsYXNzKHRoaXMuZWxlbWVudCwgQ0xBU1NfT1BFTikgPT09IHRydWUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGFkZENsYXNzKHRoaXMuZWxlbWVudCwgQ0xBU1NfT1BFTilcbiAgICB0aGlzLl9vcGVuTWVudSh0aGlzLl9mbHlvdXRFbGVtZW50KVxuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuICAgIH0sIDUwKVxuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgZmx5b3V0IG1lbnUuXG4gICAqIEBmaXJlcyBNb2RhbCNjbG9zZWRcbiAgICovXG4gIHB1YmxpYyBjbG9zZSgpIHtcbiAgICBpZiAodGhpcy5faGlkZGVuSW5kaWNhdG9yICYmIGlzSGlkZGVuKHRoaXMuX2hpZGRlbkluZGljYXRvciwgZmFsc2UpID09PSB0cnVlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoaGFzQ2xhc3ModGhpcy5lbGVtZW50LCBDTEFTU19PUEVOKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHJlbW92ZUNsYXNzKHRoaXMuZWxlbWVudCwgQ0xBU1NfT1BFTilcblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuXG4gICAgdGhpcy5fY2xvc2VNZW51KHRoaXMuX2ZseW91dEVsZW1lbnQpXG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgZmx5b3V0IG1lbnUuXG4gICAqIEBmaXJlcyBNb2RhbCNvcGVuZWRcbiAgICogQGZpcmVzIE1vZGFsI2Nsb3NlZFxuICAgKi9cbiAgcHVibGljIHRvZ2dsZSgpIHtcbiAgICBpZiAoaGFzQ2xhc3ModGhpcy5lbGVtZW50LCBDTEFTU19PUEVOKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMub3BlbigpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBldmVudCBoYW5kbGVycyBhbmQgY2xlYXJzIHJlZmVyZW5jZXMuXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICAodGhpcyBhcyBhbnkpLl9mbHlvdXRFbGVtZW50ID0gbnVsbFxuXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIpXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIpXG5cbiAgICBpZiAodGhpcy5fY2xpY2tIYW5kbGVyKSB7XG4gICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2NsaWNrSGFuZGxlcilcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcG9wcGVySW5zdGFuY2UpIHtcbiAgICAgIHRoaXMuX3BvcHBlckluc3RhbmNlLmRlc3Ryb3koKVxuICAgICAgdGhpcy5fcG9wcGVySW5zdGFuY2UgPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICAodGhpcyBhcyBhbnkpLl9jbGlja0hhbmRsZXIgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX3dpbmRvd0NsaWNrSGFuZGxlciA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5lbGVtZW50ID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gdGhlIGZseW91dCBtZW51IGlzIG9wZW5lZCBieSB0aGUgYW5jaG9yIGxpbmsgb3IgdXNpbmcgdGhlXG4gICAqIHtAbGluayBNZW51Rmx5b3V0I29wZW59IG1ldGhvZC5cbiAgICogQGV2ZW50IE1lbnVGbHlvdXQjb3BlbmVkXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqL1xuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHRoZSBmbHlvdXQgbWVudSBpcyBjbG9zZWQgYnkgdGhlIHVzZXIgb3IgdXNpbmcgdGhlXG4gICAqIHtAbGluayBNZW51Rmx5b3V0I2Nsb3NlfSBtZXRob2QuXG4gICAqIEBldmVudCBNZW51Rmx5b3V0I2Nsb3NlZFxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKi9cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIGxldCBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS10b2dnbGU9J2ZseW91dCddXCIpXG4gIGZvciAobGV0IGUgb2YgZWxlbWVudHMpIHtcbiAgICBpZiAoZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWluaXRcIikgPT09IFwiYXV0b1wiKSB7XG4gICAgICBuZXcgTWVudUZseW91dChlKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNZW51Rmx5b3V0XG4iLCJpbXBvcnQgeyBkaXNhYmxlQm9keVNjcm9sbCwgZW5hYmxlQm9keVNjcm9sbCB9IGZyb20gXCJib2R5LXNjcm9sbC1sb2NrXCJcbmltcG9ydCB7IHNlYXJjaEFuZEluaXRpYWxpemUsIHByZXZlbnREZWZhdWx0IH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCAqIGFzIElucHV0cyBmcm9tIFwiLi4vSW5wdXRzXCJcbmltcG9ydCBEb21FbGVtZW50IGZyb20gXCIuLi9Eb21FbGVtZW50XCJcbmltcG9ydCB7IGdldFJvb3RFbGVtZW50IH0gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5cbmNvbnN0IENMQVNTX0JBQ0tEUk9QID0gXCJiYWNrZHJvcFwiXG5jb25zdCBDTEFTU19CQUNLRFJPUF9PUEVOID0gXCJiYWNrZHJvcC0tb3BlblwiXG5cbmNvbnN0IENMQVNTX09QRU4gPSBcIm1vZGFsLS1vcGVuXCJcbmNvbnN0IENMQVNTX1RSSUdHRVIgPSBcIm1vZGFsLXRyaWdnZXJcIlxuXG5jb25zdCBDTEFTU19CT0RZID0gXCJtb2RhbF9fYm9keVwiXG5cbmNvbnN0IENMQVNTX0JVVFRPTlNfT0tBWSA9IFwiLm1vZGFsLWNsb3NlXCJcbmNvbnN0IENMQVNTX0JVVFRPTlNfQ0xPU0UgPSBcIi5tb2RhbC1jYW5jZWxcIlxuXG4vKipcbiAqIEEgY29tcG9uZW50IHRvIG9wZW4gYW5kIGNsb3NlIG1vZGFsIGRpYWxvZ3MuIEl0IGFsc28gaGFuZGxlcyBjYW5jZWxsYXRpb24gYW5kIG1ha2VzXG4gKiBzdXJlIHRoYXQgdGhlIG1vZGFsIGJhY2tncm91bmQgaXMgcHJlc2VudCBpbiB0aGUgRE9NLlxuICovXG5jbGFzcyBNb2RhbCBleHRlbmRzIERvbUVsZW1lbnQ8SFRNTEVsZW1lbnQ+IHtcbiAgcHJpdmF0ZSBfb2theUhhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9jYW5jZWxIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfa2V5ZG93bkhhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF93aW5kb3dDbGlja0hhbmRsZXI/OiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfdHJpZ2dlckNsaWNrSGFuZGxlcj86IChlOiBFdmVudCkgPT4gdm9pZFxuXG4gIHByaXZhdGUgX2JhY2tkcm9wITogRG9tRWxlbWVudDxIVE1MRGl2RWxlbWVudD5cbiAgcHJpdmF0ZSBfYmFja2Ryb3BQYXJlbnQhOiBFbGVtZW50XG5cbiAgY29uc3RydWN0b3IoZWxlbWVudDogSFRNTEVsZW1lbnQpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgdGhpcy5fb2theUhhbmRsZXIgPSB0aGlzLmNsb3NlLmJpbmQodGhpcylcbiAgICB0aGlzLl9jYW5jZWxIYW5kbGVyID0gdGhpcy5faGFuZGxlQ2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuX2tleWRvd25IYW5kbGVyID0gdGhpcy5faGFuZGxlS2V5ZG93bi5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgcmFuZ2UgbW9kYWwgY29tcG9uZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplKCkge1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBiYWNrZHJvcFxuICAgIHRoaXMuX2JhY2tkcm9wID0gbmV3IERvbUVsZW1lbnQ8SFRNTERpdkVsZW1lbnQ+KFwiZGl2XCIpXG4gICAgICAuYWRkQ2xhc3MoQ0xBU1NfQkFDS0RST1ApXG5cbiAgICB0aGlzLl9iYWNrZHJvcFBhcmVudCA9IGdldFJvb3RFbGVtZW50KClcbiAgICB0aGlzLl9zdWJzY3JpYmVUb1RyaWdnZXIoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9zdWJzY3JpYmVUb1RyaWdnZXIoKSB7XG4gICAgY29uc3QgdHJpZ2dlcklkID0gdGhpcy5lbGVtZW50LmlkXG4gICAgaWYgKCF0cmlnZ2VySWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX3RyaWdnZXJDbGlja0hhbmRsZXIgPSB0aGlzLm9wZW4uYmluZCh0aGlzKVxuXG4gICAgbGV0IHRyaWdnZXJFbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke0NMQVNTX1RSSUdHRVJ9W2hyZWY9JHt0cmlnZ2VySWR9XWApXG4gICAgZm9yIChsZXQgdHJpZ2dlckVsZW1lbnQgb2YgdHJpZ2dlckVsZW1lbnRzKSB7XG4gICAgICB0cmlnZ2VyRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fdHJpZ2dlckNsaWNrSGFuZGxlciEpXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF91bnN1YnNjcmliZUZyb21UcmlnZ2VyKCkge1xuICAgIGNvbnN0IHRyaWdnZXJJZCA9IHRoaXMuZWxlbWVudC5pZFxuICAgIGlmICghdHJpZ2dlcklkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgdHJpZ2dlckVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgLiR7Q0xBU1NfVFJJR0dFUn1baHJlZj0ke3RyaWdnZXJJZH1dYClcbiAgICBmb3IgKGxldCB0cmlnZ2VyRWxlbWVudCBvZiB0cmlnZ2VyRWxlbWVudHMpIHtcbiAgICAgIHRyaWdnZXJFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIhKVxuICAgIH1cblxuICAgIHRoaXMuX3RyaWdnZXJDbGlja0hhbmRsZXIgPSB1bmRlZmluZWRcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlS2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgIGxldCBrZXljb2RlID0gZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZVxuXG4gICAgaWYgKGtleWNvZGUgPT09IElucHV0cy5LRVlfRVNDQVBFKSB7XG4gICAgICAvLyBoYW5kbGUgRXNjYXBlIGtleSAoRVNDKVxuICAgICAgdGhpcy5jYW5jZWwoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVDbGljayhldmVudDogTW91c2VFdmVudCkge1xuICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KVxuICAgIHRoaXMuY2FuY2VsKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfY2xvc2UoKSB7XG4gICAgZW5hYmxlQm9keVNjcm9sbCh0aGlzLmVsZW1lbnQpXG5cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9rZXlkb3duSGFuZGxlcilcbiAgICB0aGlzLl9iYWNrZHJvcC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jYW5jZWxIYW5kbGVyKVxuXG4gICAgdGhpcy5fYmFja2Ryb3AucmVtb3ZlQ2xhc3MoQ0xBU1NfQkFDS0RST1BfT1BFTilcbiAgICB0aGlzLnJlbW92ZUNsYXNzKENMQVNTX09QRU4pXG5cbiAgICBmb3IgKGxldCBjbG9zZUJ1dHRvbiBvZiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChDTEFTU19CVVRUT05TX0NMT1NFKSkge1xuICAgICAgY2xvc2VCdXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2NhbmNlbEhhbmRsZXIpXG4gICAgfVxuXG4gICAgZm9yIChsZXQgb2theUJ1dHRvbiBvZiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChDTEFTU19CVVRUT05TX09LQVkpKSB7XG4gICAgICBva2F5QnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9va2F5SGFuZGxlcilcbiAgICB9XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIC8vIHJlbW92ZSB0aGUgYmFja2Ryb3AgZnJvbSB0aGUgYm9keVxuICAgICAgdGhpcy5fYmFja2Ryb3BQYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy5fYmFja2Ryb3AuZWxlbWVudClcbiAgICB9LCAzMDApXG4gIH1cblxuICAvKipcbiAgICogT3BlbnMgdGhlIG1vZGFsIGRpYWxvZy5cbiAgICogQGZpcmVzIE1vZGFsI29wZW5lZFxuICAgKi9cbiAgcHVibGljIG9wZW4oKSB7XG4gICAgZGlzYWJsZUJvZHlTY3JvbGwodGhpcy5lbGVtZW50LCB7XG4gICAgICBhbGxvd1RvdWNoTW92ZTogKGVsKSA9PiB7XG4gICAgICAgIGxldCBjdXJyZW50RWwgPSBlbFxuXG4gICAgICAgIHdoaWxlIChjdXJyZW50RWwgJiYgY3VycmVudEVsICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHVzZXIgaXMgc2Nyb2xsaW5nIHRoZSBtb2RhbCBib2R5XG4gICAgICAgICAgaWYgKGN1cnJlbnRFbC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfQk9EWSkpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBlbGVtZW50IG92ZXJmbG93c1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRFbC5zY3JvbGxIZWlnaHQgPiBjdXJyZW50RWwuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudEVsID0gY3VycmVudEVsLnBhcmVudE5vZGUgYXMgSFRNTEVsZW1lbnRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBhZGQgdGhlIGJhY2tkcm9wIHRvIHRoZSBib2R5XG4gICAgdGhpcy5fYmFja2Ryb3BQYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5fYmFja2Ryb3AuZWxlbWVudClcblxuICAgIC8vIHNldCB0aGUgZWxlbWVudCB0byBmbGV4IGFzIGl0IGlzIGluaXRpYWxseSBoaWRkZW5cbiAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiXG5cbiAgICAvLyByZW1vdmUgdGhlIHN0eWxlIGFmdGVyIHRoZSBhbmltYXRpb24gY29tcGxldGVzXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiXCJcbiAgICB9LCA4MDApXG5cbiAgICAvLyB3YWl0IGEgYml0IHRvIGFsbG93IHRoZSBicm93c2VyIHRvIGNhdGNoIHVwIGFuZCBzaG93IHRoZSBhbmltYXRpb25cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoQ0xBU1NfT1BFTilcbiAgICAgIHRoaXMuX2JhY2tkcm9wLmFkZENsYXNzKENMQVNTX0JBQ0tEUk9QX09QRU4pXG5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2tleWRvd25IYW5kbGVyKVxuXG4gICAgICB0aGlzLl9iYWNrZHJvcC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jYW5jZWxIYW5kbGVyKVxuXG4gICAgICBmb3IgKGxldCBjbG9zZUJ1dHRvbiBvZiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChDTEFTU19CVVRUT05TX0NMT1NFKSkge1xuICAgICAgICBjbG9zZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fY2FuY2VsSGFuZGxlcilcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgb2theUJ1dHRvbiBvZiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChDTEFTU19CVVRUT05TX09LQVkpKSB7XG4gICAgICAgIG9rYXlCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX29rYXlIYW5kbGVyKVxuICAgICAgfVxuXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJvcGVuZWRcIilcbiAgICB9LCA1MClcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWxzIChhbmQgY2xvc2VzKSB0aGUgbW9kYWwgZGlhbG9nLlxuICAgKiBAZmlyZXMgTW9kYWwjY2FuY2VsbGVkXG4gICAqIEBmaXJlcyBNb2RhbCNjbG9zZWRcbiAgICovXG4gIHB1YmxpYyBjYW5jZWwoKSB7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFwiY2FuY2VsbGVkXCIpXG4gICAgdGhpcy5fY2xvc2UoKVxuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgbW9kYWwgZGlhbG9nLlxuICAgKiBAZmlyZXMgTW9kYWwjY2xvc2VkXG4gICAqL1xuICBwdWJsaWMgY2xvc2UoKSB7XG4gICAgdGhpcy5fY2xvc2UoKVxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcImNsb3NlZFwiKVxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBjb21wb25lbnQgYW5kIGZyZWVzIGFsbCByZWZlcmVuY2VzLlxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jYW5jZWwoKVxuICAgIHRoaXMuX3Vuc3Vic2NyaWJlRnJvbVRyaWdnZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gdGhlIG1vZGFsIGRpYWxvZyBpcyBvcGVuZWQgYnkgdGhlIGFuY2hvciBsaW5rIG9yIHVzaW5nIHRoZVxuICAgKiB7QGxpbmsgTW9kYWwjb3Blbn0gbWV0aG9kLlxuICAgKiBAZXZlbnQgTW9kYWwjb3BlbmVkXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqL1xuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuIHRoZSBtb2RhbCBkaWFsb2cgaXMgY2xvc2VkIGJ5IHRoZSB1c2VyIG9yIHVzaW5nIHRoZVxuICAgKiB7QGxpbmsgTW9kYWwjY2xvc2V9IG1ldGhvZC5cbiAgICogQGV2ZW50IE1vZGFsI2Nsb3NlZFxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKi9cblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgbW9kYWwgZGlhbG9nIGlzIGNhbmNlbGxlZCBieSB0aGUgdXNlciBvciB1c2luZyB0aGVcbiAgICoge0BsaW5rIE1vZGFsI2NhbmNlbH0gbWV0aG9kLlxuICAgKiBAZXZlbnQgTW9kYWwjY2FuY2VsbGVkXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqL1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZTxIVE1MRWxlbWVudD4oXCIubW9kYWxcIiwgKGUpID0+IHtcbiAgICBuZXcgTW9kYWwoZSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgTW9kYWxcbiIsImltcG9ydCBhbmltZSwgeyBBbmltZVRpbWVsaW5lSW5zdGFuY2UgfSBmcm9tIFwiYW5pbWVqc1wiXG5pbXBvcnQgeyBzZWFyY2hBbmRJbml0aWFsaXplIH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCBEb21FbGVtZW50IGZyb20gXCIuLi9Eb21FbGVtZW50XCJcbmltcG9ydCAqIGFzIERvbSBmcm9tIFwiLi4vRG9tRnVuY3Rpb25zXCJcbmltcG9ydCBTZWFyY2hJbnB1dCBmcm9tIFwiLi4vc2VhcmNoL1NlYXJjaElucHV0XCJcblxuY29uc3QgQ0xBU1NfT1BFTiA9IFwiaXMtb3BlblwiXG5jb25zdCBDTEFTU19BQ1RJVkUgPSBcImlzLWFjdGl2ZVwiXG5cbmNvbnN0IFFVRVJZX05BVl9IQU1CVVJHRVIgPSBcIi5uYXYtaGFtYnVyZ2VyXCJcbmNvbnN0IFFVRVJZX05BVl9IQl9CT0RZID0gXCIubmF2X19wcmltYXJ5XCJcblxuY29uc3QgQ0xBU1NfTkFWX0xJTksgPSBcIm5hdi1saW5rLS1oZWFkZXJcIlxuY29uc3QgUVVFUllfTkFWX0xJTktfQUNUSVZFID0gXCIubmF2LWxpbmstLWhlYWRlci5pcy1hY3RpdmVcIlxuXG5jb25zdCBRVUVSWV9OQVZfTU9CSUxFID0gXCIubmF2X19sZXZlbDEgLm5hdl9fbWFpbm5hdiAubmF2X19wcmltYXJ5XCJcbmNvbnN0IFFVRVJZX05BVl9MRVZFTDAgPSBcIi5uYXZfX2xldmVsMFwiXG5jb25zdCBRVUVSWV9OQVZfTEVWRUwwX0NPTlRBSU5FUiA9IFwiLm5hdl9fbGV2ZWwwIC5uYXZfX3N1Ym5hdlwiXG5jb25zdCBRVUVSWV9TRUNUSU9OX09QRU4gPSBcIi5uYXYtc2VjdGlvbi5pcy1vcGVuXCJcblxuY29uc3QgUVVFUllfTkFWX0xFVkVMMSA9IFwiLm5hdl9fbGV2ZWwxIC5uYXZfX21haW5uYXZcIlxuXG5jb25zdCBRVUVSWV9OQVZfTEVWRUwwX0xJTksgPSBcIi5uYXYtbGluay5uYXYtbGluay0taGVhZGVyXCJcbmNvbnN0IFFVRVJZX05BVl9MRVZFTDFfTElOSyA9IFwiLm5hdi1saW5rLS1oZWFkZXJcIlxuXG5jb25zdCBRVUVSWV9OQVZfQ09MVU1OID0gXCIubmF2LWNvbFwiXG5jb25zdCBRVUVSWV9OQVZfQ09MVU1OX0FDVElWRSA9IFwiLm5hdi1jb2wuaXMtYWN0aXZlXCJcblxuY29uc3QgUVVFUllfTkFWX0JPRFkgPSBcIi5uYXYtYm9keVwiXG5jb25zdCBRVUVSWV9OQVZfRk9PVEVSID0gXCIubmF2LWZvb3RlclwiXG5cbmNvbnN0IFFVRVJZX1NFQVJDSF9JQ09OID0gXCIubmF2LXNlYXJjaFwiXG5jb25zdCBRVUVSWV9TRUFSQ0hfRklFTEQgPSBcIi5zZWFyY2hfX2lucHV0XCJcbmNvbnN0IENMQVNTX1NFQVJDSF9ERVNLVE9QID0gXCJzZWFyY2gtLWRlc2t0b3BcIlxuXG5jb25zdCBBTklNQVRJT05fU1RBUlRfREVMQVkgPSAyMDBcbmNvbnN0IEFOSU1BVElPTl9PRkZTRVQgPSA1MFxuXG5jb25zdCBBTklNQVRJT05fQk9EWV9EVVJBVElPTiA9IDMwMFxuY29uc3QgQU5JTUFUSU9OX0ZPT1RFUl9EVVJBVElPTiA9IDEwMFxuXG4vKipcbiAqIFRoZSBuYXZpZ2F0aW9uIGNvbXBvbmVudCBkZWZpbml0aW9uLlxuICovXG5jbGFzcyBOYXZpZ2F0aW9uIGV4dGVuZHMgRG9tRWxlbWVudCB7XG4gIHB1YmxpYyBfbmF2TGV2ZWwwOiBIVE1MRWxlbWVudFxuICBwdWJsaWMgX25hdkxldmVsMEJvZHk6IEhUTUxFbGVtZW50XG4gIHB1YmxpYyBfbmF2TGV2ZWwxOiBIVE1MRWxlbWVudFxuXG4gIHB1YmxpYyBfaGFtYnVyZ2VyRWxlbWVudDogSFRNTEVsZW1lbnRcblxuICBwcml2YXRlIF9uYXZNb2JpbGU6IEhUTUxFbGVtZW50XG5cbiAgcHJpdmF0ZSBfc2VhcmNoQ29tcG9uZW50czogU2VhcmNoSW5wdXRbXVxuXG4gIHByaXZhdGUgX2xldmVsMENsaWNrSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2xldmVsMUNsaWNrSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX3dpbmRvd0NsaWNrSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX3NlYXJjaENsaWNrSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG5cbiAgcHJpdmF0ZSBhbmltYXRpb246IEFuaW1lVGltZWxpbmVJbnN0YW5jZSA9IGFuaW1lLnRpbWVsaW5lKClcbiAgcHJpdmF0ZSBlYXNpbmcgPSB7XG4gICAgLy8gRXF1aXZhbGVudCB0byBnc2FwJ3MgWyBQb3dlcjEuZWFzZUluLCBQb3dlcjQuZWFzZU91dCBdXG4gICAgaW5RdWFkT3V0UXVpbnQ6IFsgMC41NTAsIDAuMDg1LCAwLjMyMCwgMSBdXG4gIH1cblxuICBwcml2YXRlIF9zZWFyY2hEZXNrdG9wPzogU2VhcmNoSW5wdXRcblxuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBFbGVtZW50KSB7XG4gICAgc3VwZXIoZWxlbWVudClcblxuICAgIHRoaXMuX25hdkxldmVsMCA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9MRVZFTDApIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcbiAgICB0aGlzLl9uYXZMZXZlbDBCb2R5ID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfTkFWX0xFVkVMMF9DT05UQUlORVIpIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcbiAgICB0aGlzLl9uYXZMZXZlbDEgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9OQVZfTEVWRUwxKSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXG5cbiAgICB0aGlzLl9uYXZNb2JpbGUgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9OQVZfTU9CSUxFKSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXG4gICAgaWYgKCF0aGlzLl9uYXZNb2JpbGUucGFyZW50RWxlbWVudCkge1xuICAgICAgbGV0IGR1bW15UGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICAgICAgZHVtbXlQYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5fbmF2TW9iaWxlKVxuICAgIH1cblxuICAgIHRoaXMuX2hhbWJ1cmdlckVsZW1lbnQgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9OQVZfSEFNQlVSR0VSKSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXG4gICAgdGhpcy5fc2VhcmNoQ29tcG9uZW50cyA9IFtdXG5cbiAgICB0aGlzLl9sZXZlbDBDbGlja0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVMZXZlbDBDbGljay5iaW5kKHRoaXMpXG4gICAgdGhpcy5fbGV2ZWwxQ2xpY2tIYW5kbGVyID0gdGhpcy5faGFuZGxlTGV2ZWwxQ2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZVdpbmRvd0NsaWNrLmJpbmQodGhpcylcbiAgICB0aGlzLl9zZWFyY2hDbGlja0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVTZWFyY2hDbGljay5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfcmVzZXRNYWluVGltZWxpbmUoLi4uZWxlbWVudHM6IEhUTUxFbGVtZW50W10pIHtcbiAgICB0aGlzLmFuaW1hdGlvbi5wYXVzZSgpXG4gICAgZm9yIChsZXQgZWwgb2YgZWxlbWVudHMpIHtcbiAgICAgIGFuaW1lLnJlbW92ZShlbCEpXG4gICAgfVxuICAgIHRoaXMuYW5pbWF0aW9uID0gYW5pbWUudGltZWxpbmUoKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9pc01vYmlsZSgpIHtcbiAgICByZXR1cm4gRG9tLmlzSGlkZGVuKHRoaXMuX2hhbWJ1cmdlckVsZW1lbnQsIHRydWUpID09PSBmYWxzZVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVMZXZlbDBDbGljayhldmVudDogTW91c2VFdmVudCkge1xuICAgIGNvbnN0IGlzRGVza3RvcCA9ICF0aGlzLl9pc01vYmlsZSgpXG5cbiAgICBpZiAoaXNEZXNrdG9wKSB7XG4gICAgICBsZXQgbmF2SXRlbXMgPSBuZXcgTmF2aWdhdGlvbkl0ZW1zKHRoaXMpXG4gICAgICAgIC5mcm9tTGV2ZWwwKGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudClcblxuICAgICAgaWYgKCFuYXZJdGVtcy5zZWN0aW9uKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBsZXQgcHJldmlvdXNOYXZMaW5rID0gdGhpcy5fbmF2TGV2ZWwwLnF1ZXJ5U2VsZWN0b3IoUVVFUllfTkFWX0xJTktfQUNUSVZFKSEgYXMgSFRNTEVsZW1lbnRcbiAgICAgIGxldCBwcmV2aW91c05hdlNlY3Rpb24gPSB0aGlzLl9uYXZMZXZlbDAucXVlcnlTZWxlY3RvcihRVUVSWV9TRUNUSU9OX09QRU4pISBhcyBIVE1MRWxlbWVudFxuXG4gICAgICB0aGlzLl90b2dnbGVDb250YWluZXIoXG4gICAgICAgIG5hdkl0ZW1zLmxpbmssXG4gICAgICAgIHRoaXMuX25hdkxldmVsMEJvZHksXG4gICAgICAgIG5hdkl0ZW1zLnNlY3Rpb24sXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgcHJldmlvdXNOYXZMaW5rLFxuICAgICAgICB0aGlzLl9uYXZMZXZlbDBCb2R5LFxuICAgICAgICBwcmV2aW91c05hdlNlY3Rpb24sXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdHJ1ZVxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlTGV2ZWwxQ2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICBsZXQgbmF2SXRlbXMgPSBuZXcgTmF2aWdhdGlvbkl0ZW1zKHRoaXMpXG4gICAgICAuZnJvbUxldmVsMShldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnQpXG5cbiAgICBsZXQgcHJldkl0ZW1zID0gbmF2SXRlbXMucHJldmlvdXNMZXZlbDEoKVxuXG4gICAgdGhpcy5fdG9nZ2xlQ29udGFpbmVyKFxuICAgICAgbmF2SXRlbXMubGluayxcbiAgICAgIG5hdkl0ZW1zLmNvbnRhaW5lcixcbiAgICAgIG5hdkl0ZW1zLnNlY3Rpb24sXG4gICAgICBuYXZJdGVtcy5mb290ZXIsXG4gICAgICBwcmV2SXRlbXMubGluayxcbiAgICAgIHByZXZJdGVtcy5jb250YWluZXIsXG4gICAgICBwcmV2SXRlbXMuc2VjdGlvbixcbiAgICAgIHByZXZJdGVtcy5mb290ZXIsXG4gICAgICBmYWxzZVxuICAgIClcblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcHJvdGVjdGVkIF90b2dnbGVDb250YWluZXIoXG4gICAgbmF2TGluazogSFRNTEVsZW1lbnQsXG4gICAgbmF2Q29udGFpbmVyPzogSFRNTEVsZW1lbnQsXG4gICAgbmF2U2VjdGlvbj86IEhUTUxFbGVtZW50LFxuICAgIG5hdkZvb3Rlcj86IEhUTUxFbGVtZW50LFxuICAgIHByZXZpb3VzTmF2TGluaz86IEhUTUxFbGVtZW50LFxuICAgIHByZXZpb3VzTmF2Q29udGFpbmVyPzogSFRNTEVsZW1lbnQsXG4gICAgcHJldmlvdXNOYXZTZWN0aW9uPzogSFRNTEVsZW1lbnQsXG4gICAgcHJldmlvdXNOYXZGb290ZXI/OiBIVE1MRWxlbWVudCxcbiAgICBhbmltYXRlQ29udGFpbmVyID0gZmFsc2VcbiAgKSB7XG4gICAgY29uc3QgaXNEZXNrdG9wID0gIXRoaXMuX2lzTW9iaWxlKClcblxuICAgIGlmIChwcmV2aW91c05hdkxpbmsgJiYgcHJldmlvdXNOYXZMaW5rICE9PSBuYXZMaW5rICYmIG5hdkxpbmsgIT09IHRoaXMuX2hhbWJ1cmdlckVsZW1lbnQpIHtcbiAgICAgIERvbS5yZW1vdmVDbGFzcyhwcmV2aW91c05hdkxpbmssIENMQVNTX0FDVElWRSlcbiAgICB9XG5cbiAgICB0aGlzLl9yZXNldE1haW5UaW1lbGluZShuYXZDb250YWluZXIhLCBuYXZTZWN0aW9uISwgbmF2Rm9vdGVyISwgcHJldmlvdXNOYXZDb250YWluZXIhLCBwcmV2aW91c05hdlNlY3Rpb24hLCBwcmV2aW91c05hdkZvb3RlciEpXG5cbiAgICBpZiAoRG9tLmhhc0NsYXNzKG5hdkxpbmssIENMQVNTX0FDVElWRSkpIHtcbiAgICAgIERvbS5yZW1vdmVDbGFzcyhuYXZMaW5rLCBDTEFTU19BQ1RJVkUpXG5cbiAgICAgIGlmIChpc0Rlc2t0b3ApIHtcbiAgICAgICAgdGhpcy5fb25OYXZpZ2F0aW9uQ2xvc2VkKClcblxuICAgICAgICB0aGlzLl9jbG9zZVNlY3Rpb24obmF2Q29udGFpbmVyLCBuYXZTZWN0aW9uLCBuYXZGb290ZXIsIHRydWUsIGFuaW1hdGVDb250YWluZXIpXG4gICAgICB9IGVsc2UgaWYgKG5hdkxpbmsgPT09IHRoaXMuX2hhbWJ1cmdlckVsZW1lbnQpIHtcbiAgICAgICAgLy8gQ2xvc2UgbW9iaWxlIG5hdmlnYXRpb25cbiAgICAgICAgdGhpcy5fb25OYXZpZ2F0aW9uQ2xvc2VkKClcblxuICAgICAgICB0aGlzLl9jbG9zZVNlY3Rpb24obmF2Q29udGFpbmVyLCBuYXZTZWN0aW9uLCB1bmRlZmluZWQsIGZhbHNlLCBmYWxzZSlcbiAgICAgIH0gZWxzZSBpZiAoIWlzRGVza3RvcCkge1xuICAgICAgICAvLyBDbG9zZSB0aGUgc2VjdGlvblxuICAgICAgICB0aGlzLl9jbG9zZVNlY3Rpb24obmF2Q29udGFpbmVyLCBuYXZTZWN0aW9uLCBuYXZGb290ZXIsIHRydWUsIGFuaW1hdGVDb250YWluZXIpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIERvbS5hZGRDbGFzcyhuYXZMaW5rLCBDTEFTU19BQ1RJVkUpXG5cbiAgICAgIGlmIChpc0Rlc2t0b3ApIHtcbiAgICAgICAgRG9tLmFkZENsYXNzKHRoaXMuX25hdk1vYmlsZSwgQ0xBU1NfT1BFTilcbiAgICAgICAgdGhpcy5fb25OYXZpZ2F0aW9uT3BlbmVkKClcblxuICAgICAgICBpZiAocHJldmlvdXNOYXZDb250YWluZXIgJiYgcHJldmlvdXNOYXZTZWN0aW9uKSB7XG4gICAgICAgICAgdGhpcy5fY2xvc2VTZWN0aW9uKHByZXZpb3VzTmF2Q29udGFpbmVyLCBwcmV2aW91c05hdlNlY3Rpb24sIHByZXZpb3VzTmF2Rm9vdGVyLCB0cnVlLCBhbmltYXRlQ29udGFpbmVyKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29wZW5TZWN0aW9uKG5hdkNvbnRhaW5lciwgbmF2U2VjdGlvbiwgbmF2Rm9vdGVyLCB0cnVlLCBhbmltYXRlQ29udGFpbmVyKVxuICAgICAgfSBlbHNlIGlmIChuYXZMaW5rID09PSB0aGlzLl9oYW1idXJnZXJFbGVtZW50KSB7XG4gICAgICAgIC8vIE9wZW4gbW9iaWxlIG5hdmlnYXRpb25cbiAgICAgICAgdGhpcy5fb25OYXZpZ2F0aW9uT3BlbmVkKClcblxuICAgICAgICB0aGlzLl9vcGVuU2VjdGlvbihuYXZDb250YWluZXIsIG5hdlNlY3Rpb24sIHVuZGVmaW5lZCwgZmFsc2UsIGZhbHNlKVxuICAgICAgfSBlbHNlIGlmICghaXNEZXNrdG9wKSB7XG4gICAgICAgIC8vIE9wZW4gc2VjdGlvblxuICAgICAgICBpZiAocHJldmlvdXNOYXZDb250YWluZXIgJiYgcHJldmlvdXNOYXZTZWN0aW9uKSB7XG4gICAgICAgICAgdGhpcy5fY2xvc2VTZWN0aW9uKHByZXZpb3VzTmF2Q29udGFpbmVyLCBwcmV2aW91c05hdlNlY3Rpb24sIHByZXZpb3VzTmF2Rm9vdGVyLCB0cnVlLCBhbmltYXRlQ29udGFpbmVyKVxuICAgICAgICAgIHRoaXMuYW5pbWF0aW9uID0gYW5pbWUudGltZWxpbmUoKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29wZW5TZWN0aW9uKG5hdkNvbnRhaW5lciwgbmF2U2VjdGlvbiwgbmF2Rm9vdGVyLCB0cnVlLCBhbmltYXRlQ29udGFpbmVyKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfb25OYXZpZ2F0aW9uT3BlbmVkKCkge1xuICAgIERvbS5hZGRDbGFzcyh0aGlzLl9uYXZNb2JpbGUsIENMQVNTX09QRU4pXG4gICAgRG9tLmFkZENsYXNzKHRoaXMuX25hdk1vYmlsZS5wYXJlbnRFbGVtZW50ISwgQ0xBU1NfT1BFTilcbiAgICBEb20uYWRkQ2xhc3ModGhpcy5faGFtYnVyZ2VyRWxlbWVudCwgQ0xBU1NfQUNUSVZFKVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIpXG4gIH1cblxuICBwcm90ZWN0ZWQgX29uTmF2aWdhdGlvbkNsb3NlZCgpIHtcbiAgICBEb20ucmVtb3ZlQ2xhc3ModGhpcy5fbmF2TW9iaWxlLCBDTEFTU19PUEVOKVxuICAgIERvbS5yZW1vdmVDbGFzcyh0aGlzLl9uYXZNb2JpbGUucGFyZW50RWxlbWVudCEsIENMQVNTX09QRU4pXG4gICAgRG9tLnJlbW92ZUNsYXNzKHRoaXMuX2hhbWJ1cmdlckVsZW1lbnQsIENMQVNTX0FDVElWRSlcblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVXaW5kb3dDbGljayhldmVudDogTW91c2VFdmVudCkge1xuICAgIGxldCB0YXJnZXQgPSBldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnRcblxuICAgIHdoaWxlICh0YXJnZXQgIT09IHRoaXMuZWxlbWVudCAmJiB0YXJnZXQucGFyZW50RWxlbWVudCkge1xuICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudEVsZW1lbnRcbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0ICE9PSB0aGlzLmVsZW1lbnQpIHtcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHByb3RlY3RlZCBfb3BlblNlY3Rpb24oXG4gICAgbmF2Q29udGFpbmVyPzogSFRNTEVsZW1lbnQsXG4gICAgbmF2U2VjdGlvbj86IEhUTUxFbGVtZW50LFxuICAgIG5hdkZvb3Rlcj86IEhUTUxFbGVtZW50LFxuICAgIGFuaW1hdGVDb2x1bW5zID0gdHJ1ZSxcbiAgICBhbmltYXRlQ29udGFpbmVyID0gZmFsc2VcbiAgKSB7XG4gICAgaWYgKCFuYXZTZWN0aW9uIHx8ICFuYXZDb250YWluZXIpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBhY3RpdmVJdGVtcyA9IG5hdlNlY3Rpb24ucXVlcnlTZWxlY3RvckFsbChRVUVSWV9OQVZfQ09MVU1OKVxuXG4gICAgaWYgKGFuaW1hdGVDb250YWluZXIgPT09IHRydWUpIHtcbiAgICAgIGxldCBjb250YWluZXIgPSBuYXZDb250YWluZXJcbiAgICAgIG5hdkNvbnRhaW5lciA9IG5hdlNlY3Rpb25cbiAgICAgIG5hdlNlY3Rpb24gPSBjb250YWluZXJcbiAgICB9XG5cbiAgICBEb20uYWRkQ2xhc3MobmF2Q29udGFpbmVyISwgQ0xBU1NfT1BFTilcblxuICAgIG5hdlNlY3Rpb24uc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIlxuXG4gICAgdGhpcy5hbmltYXRpb24uYWRkKHtcbiAgICAgIHRhcmdldHM6IG5hdlNlY3Rpb24sXG4gICAgICBkdXJhdGlvbjogQU5JTUFUSU9OX0JPRFlfRFVSQVRJT04sXG4gICAgICBlYXNpbmc6IHRoaXMuZWFzaW5nLmluUXVhZE91dFF1aW50LFxuICAgICAgaGVpZ2h0OiBhbmltYXRlQ29udGFpbmVyID8gbmF2Q29udGFpbmVyLnNjcm9sbEhlaWdodCA6IG5hdlNlY3Rpb24uc2Nyb2xsSGVpZ2h0LFxuICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgRG9tLmFkZENsYXNzKG5hdlNlY3Rpb24hLCBDTEFTU19PUEVOKVxuICAgICAgICBuZXcgRG9tRWxlbWVudChuYXZTZWN0aW9uISkuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJcIilcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgaWYgKG5hdkZvb3Rlcikge1xuICAgICAgY29uc3QgbmF2SXRlbXMgPSBuYXZGb290ZXIucXVlcnlTZWxlY3RvckFsbChRVUVSWV9OQVZfQ09MVU1OKVxuICAgICAgZm9yIChsZXQgaXRlbSBvZiBuYXZJdGVtcykge1xuICAgICAgICBEb20uYWRkQ2xhc3MoaXRlbSwgQ0xBU1NfQUNUSVZFKVxuICAgICAgfVxuXG4gICAgICBuYXZGb290ZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIlxuXG4gICAgICB0aGlzLmFuaW1hdGlvbi5hZGQoe1xuICAgICAgICB0YXJnZXRzOiBuYXZGb290ZXIsXG4gICAgICAgIGR1cmF0aW9uOiBBTklNQVRJT05fRk9PVEVSX0RVUkFUSU9OLFxuICAgICAgICBlYXNpbmc6IHRoaXMuZWFzaW5nLmluUXVhZE91dFF1aW50LFxuICAgICAgICBoZWlnaHQ6IG5hdkZvb3Rlci5zY3JvbGxIZWlnaHQsXG4gICAgICAgIG9mZnNldDogYC09JHtBTklNQVRJT05fRk9PVEVSX0RVUkFUSU9OfWAsXG4gICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgRG9tLmFkZENsYXNzKG5hdkZvb3RlciEsIENMQVNTX09QRU4pXG4gICAgICAgICAgbmV3IERvbUVsZW1lbnQobmF2Rm9vdGVyISkuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJcIilcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoYW5pbWF0ZUNvbHVtbnMgPT09IHRydWUpIHtcbiAgICAgIGxldCBkZWxheSA9IEFOSU1BVElPTl9TVEFSVF9ERUxBWVxuXG4gICAgICBmb3IgKGxldCBpdGVtIG9mIGFjdGl2ZUl0ZW1zKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uLmFkZCh7XG4gICAgICAgICAgdGFyZ2V0czogaXRlbSxcbiAgICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgICBvZmZzZXQ6IGRlbGF5LFxuICAgICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgICBEb20uYWRkQ2xhc3MoaXRlbSwgQ0xBU1NfQUNUSVZFKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgZGVsYXkgKz0gQU5JTUFUSU9OX09GRlNFVFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfY2xvc2VTZWN0aW9uKFxuICAgIG5hdkNvbnRhaW5lcj86IEhUTUxFbGVtZW50LFxuICAgIG5hdlNlY3Rpb24/OiBIVE1MRWxlbWVudCxcbiAgICBuYXZGb290ZXI/OiBIVE1MRWxlbWVudCxcbiAgICBhbmltYXRlQ29sdW1ucyA9IHRydWUsXG4gICAgYW5pbWF0ZUNvbnRhaW5lciA9IGZhbHNlXG4gICkge1xuICAgIGlmICghbmF2U2VjdGlvbiB8fCAhbmF2Q29udGFpbmVyKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgYWN0aXZlSXRlbXMgPSBuYXZTZWN0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoUVVFUllfTkFWX0NPTFVNTl9BQ1RJVkUpXG5cbiAgICBpZiAoYW5pbWF0ZUNvbnRhaW5lciA9PT0gdHJ1ZSkge1xuICAgICAgbGV0IGNvbnRhaW5lciA9IG5hdkNvbnRhaW5lclxuICAgICAgbmF2Q29udGFpbmVyID0gbmF2U2VjdGlvblxuICAgICAgbmF2U2VjdGlvbiA9IGNvbnRhaW5lclxuICAgIH1cblxuICAgIGlmIChhbmltYXRlQ29sdW1ucyA9PT0gdHJ1ZSkge1xuICAgICAgZm9yIChsZXQgYWN0aXZlIG9mIGFjdGl2ZUl0ZW1zKSB7XG4gICAgICAgIERvbS5yZW1vdmVDbGFzcyhhY3RpdmUsIENMQVNTX0FDVElWRSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFuaW1hdGlvbi5hZGQoe1xuICAgICAgdGFyZ2V0czogbmF2U2VjdGlvbixcbiAgICAgIGR1cmF0aW9uOiBBTklNQVRJT05fQk9EWV9EVVJBVElPTixcbiAgICAgIGVhc2luZzogdGhpcy5lYXNpbmcuaW5RdWFkT3V0UXVpbnQsXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgICBvZmZzZXQ6IDAsXG4gICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICBEb20ucmVtb3ZlQ2xhc3MobmF2Q29udGFpbmVyISwgQ0xBU1NfT1BFTilcbiAgICAgICAgRG9tLnJlbW92ZUNsYXNzKG5hdlNlY3Rpb24hLCBDTEFTU19PUEVOKVxuICAgICAgICBuYXZTZWN0aW9uIS5zdHlsZS5oZWlnaHQgPSBudWxsXG4gICAgICB9XG4gICAgfSlcblxuICAgIGlmIChuYXZGb290ZXIpIHtcbiAgICAgIGZvciAobGV0IGFjdGl2ZSBvZiBuYXZGb290ZXIucXVlcnlTZWxlY3RvckFsbChRVUVSWV9OQVZfQ09MVU1OX0FDVElWRSkpIHtcbiAgICAgICAgRG9tLnJlbW92ZUNsYXNzKGFjdGl2ZSwgQ0xBU1NfQUNUSVZFKVxuICAgICAgfVxuXG4gICAgICB0aGlzLmFuaW1hdGlvbi5hZGQoe1xuICAgICAgICB0YXJnZXRzOiBuYXZGb290ZXIsXG4gICAgICAgIGR1cmF0aW9uOiBBTklNQVRJT05fRk9PVEVSX0RVUkFUSU9OLFxuICAgICAgICBlYXNpbmc6IHRoaXMuZWFzaW5nLmluUXVhZE91dFF1aW50LFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICBEb20ucmVtb3ZlQ2xhc3MobmF2Rm9vdGVyISwgQ0xBU1NfT1BFTilcbiAgICAgICAgICBuYXZGb290ZXIhLnN0eWxlLmhlaWdodCA9IG51bGxcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZVNlYXJjaENsaWNrKCkge1xuICAgIGlmICh0aGlzLl9zZWFyY2hEZXNrdG9wKSB7XG4gICAgICB0aGlzLl9zZWFyY2hEZXNrdG9wLm9wZW4oKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbmF2aWdhdGlvbiBjb21wb25lbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90ZWN0ZWQgX2luaXRpYWxpemUoKSB7XG4gICAgZm9yIChsZXQgbmF2TGluayBvZiB0aGlzLl9uYXZMZXZlbDAucXVlcnlTZWxlY3RvckFsbChRVUVSWV9OQVZfTEVWRUwwX0xJTkspKSB7XG4gICAgICBuYXZMaW5rLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9sZXZlbDBDbGlja0hhbmRsZXIpXG4gICAgfVxuXG4gICAgZm9yIChsZXQgbmF2TGluayBvZiB0aGlzLl9uYXZMZXZlbDEucXVlcnlTZWxlY3RvckFsbChRVUVSWV9OQVZfTEVWRUwxX0xJTkspKSB7XG4gICAgICBuYXZMaW5rLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9sZXZlbDFDbGlja0hhbmRsZXIpXG4gICAgfVxuXG4gICAgdGhpcy5faGFtYnVyZ2VyRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fbGV2ZWwxQ2xpY2tIYW5kbGVyKVxuXG4gICAgLy8gRGVza3RvcCBzZWFyY2ggaWNvblxuICAgIGxldCBzZWFyY2hJY29uID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfU0VBUkNIX0lDT04pXG4gICAgaWYgKHNlYXJjaEljb24pIHtcbiAgICAgIHNlYXJjaEljb24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3NlYXJjaENsaWNrSGFuZGxlcilcbiAgICB9XG5cbiAgICBmb3IgKGxldCBzZWFyY2ggb2YgdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoUVVFUllfU0VBUkNIX0ZJRUxEKSkge1xuICAgICAgbGV0IHNlYXJjaENvbXBvbmVudCA9IG5ldyBTZWFyY2hJbnB1dChzZWFyY2ggYXMgSFRNTEVsZW1lbnQpXG5cbiAgICAgIGlmIChEb20uaGFzQ2xhc3Moc2VhcmNoLCBDTEFTU19TRUFSQ0hfREVTS1RPUCkgfHwgRG9tLmhhc0NsYXNzKHNlYXJjaC5wYXJlbnRFbGVtZW50ISwgQ0xBU1NfU0VBUkNIX0RFU0tUT1ApKSB7XG4gICAgICAgIHRoaXMuX3NlYXJjaERlc2t0b3AgPSBzZWFyY2hDb21wb25lbnRcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2VhcmNoQ29tcG9uZW50cy5wdXNoKHNlYXJjaENvbXBvbmVudClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBuYXZpZ2F0aW9uLlxuICAgKi9cbiAgcHVibGljIGNsb3NlKCkge1xuICAgIGxldCBpc01vYmxlID0gdGhpcy5faXNNb2JpbGUoKVxuXG4gICAgbGV0IGxldmVsMSA9IHRoaXMuX25hdkxldmVsMS5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9MSU5LX0FDVElWRSkgYXMgSFRNTEVsZW1lbnRcbiAgICBsZXQgbGV2ZWwwID0gdGhpcy5fbmF2TGV2ZWwwLnF1ZXJ5U2VsZWN0b3IoUVVFUllfTkFWX0xJTktfQUNUSVZFKSBhcyBIVE1MRWxlbWVudFxuXG4gICAgaWYgKCFsZXZlbDEgJiYgaXNNb2JsZSAmJiBEb20uaGFzQ2xhc3ModGhpcy5faGFtYnVyZ2VyRWxlbWVudCwgQ0xBU1NfQUNUSVZFKSkge1xuICAgICAgbGV2ZWwxID0gdGhpcy5faGFtYnVyZ2VyRWxlbWVudFxuICAgIH1cblxuICAgIGxldCBuYXZJdGVtc1xuXG4gICAgaWYgKGxldmVsMSkge1xuICAgICAgbmF2SXRlbXMgPSBuZXcgTmF2aWdhdGlvbkl0ZW1zKHRoaXMpLmZyb21MZXZlbDEobGV2ZWwxKVxuICAgIH0gZWxzZSBpZiAobGV2ZWwwKSB7XG4gICAgICBuYXZJdGVtcyA9IG5ldyBOYXZpZ2F0aW9uSXRlbXModGhpcykuZnJvbUxldmVsMChsZXZlbDApXG4gICAgfVxuXG4gICAgaWYgKG5hdkl0ZW1zKSB7XG4gICAgICB0aGlzLl9yZXNldE1haW5UaW1lbGluZShuYXZJdGVtcy5jb250YWluZXIhLCBuYXZJdGVtcy5zZWN0aW9uISwgbmF2SXRlbXMuZm9vdGVyISlcbiAgICAgIERvbS5yZW1vdmVDbGFzcyhuYXZJdGVtcy5saW5rLCBDTEFTU19BQ1RJVkUpXG4gICAgICB0aGlzLl9vbk5hdmlnYXRpb25DbG9zZWQoKVxuICAgICAgdGhpcy5fY2xvc2VTZWN0aW9uKG5hdkl0ZW1zLmNvbnRhaW5lciEsIG5hdkl0ZW1zLnNlY3Rpb24hLCBuYXZJdGVtcy5mb290ZXIsICFpc01vYmxlLCBmYWxzZSlcbiAgICB9XG5cbiAgfVxufVxuXG5jbGFzcyBOYXZpZ2F0aW9uSXRlbXMge1xuICBwcml2YXRlIF9uYXZpZ2F0aW9uOiBOYXZpZ2F0aW9uXG4gIHByaXZhdGUgX2xpbmshOiBIVE1MRWxlbWVudFxuICBwcml2YXRlIF9jb250YWluZXI/OiBIVE1MRWxlbWVudFxuICBwcml2YXRlIF9zZWN0aW9uPzogSFRNTEVsZW1lbnRcbiAgcHJpdmF0ZSBfZm9vdGVyPzogSFRNTEVsZW1lbnRcbiAgY29uc3RydWN0b3IobmF2OiBOYXZpZ2F0aW9uKSB7XG4gICAgdGhpcy5fbmF2aWdhdGlvbiA9IG5hdlxuICB9XG5cbiAgZ2V0IGxpbmsoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpbmtcbiAgfVxuXG4gIGdldCBjb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lclxuICB9XG5cbiAgZ2V0IHNlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlY3Rpb25cbiAgfVxuXG4gIGdldCBmb290ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Zvb3RlclxuICB9XG5cbiAgcHVibGljIGZyb21MZXZlbDAobmF2TGluazogSFRNTEVsZW1lbnQpIHtcbiAgICB3aGlsZSAoIURvbS5oYXNDbGFzcyhuYXZMaW5rLCBDTEFTU19OQVZfTElOSykgJiYgbmF2TGluay5wYXJlbnRFbGVtZW50KSB7XG4gICAgICBuYXZMaW5rID0gbmF2TGluay5wYXJlbnRFbGVtZW50XG4gICAgfVxuXG4gICAgdGhpcy5fbGluayA9IG5hdkxpbmtcblxuICAgIGxldCB0b2dnbGVJZCA9IG5hdkxpbmsuZ2V0QXR0cmlidXRlKFwiZGF0YS10b2dnbGVcIilcbiAgICB0aGlzLl9jb250YWluZXIgPSB0aGlzLl9uYXZpZ2F0aW9uLl9uYXZMZXZlbDBCb2R5XG4gICAgdGhpcy5fc2VjdGlvbiA9IHRoaXMuX25hdmlnYXRpb24uX25hdkxldmVsMC5xdWVyeVNlbGVjdG9yKGAjJHt0b2dnbGVJZH1gKSEgYXMgSFRNTEVsZW1lbnRcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwdWJsaWMgZnJvbUxldmVsMShuYXZMaW5rOiBIVE1MRWxlbWVudCkge1xuICAgIHdoaWxlIChuYXZMaW5rLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIGlmICgobmF2TGluayA9PT0gdGhpcy5fbmF2aWdhdGlvbi5faGFtYnVyZ2VyRWxlbWVudCkgfHwgRG9tLmhhc0NsYXNzKG5hdkxpbmssIENMQVNTX05BVl9MSU5LKSkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBuYXZMaW5rID0gbmF2TGluay5wYXJlbnRFbGVtZW50XG4gICAgfVxuXG4gICAgdGhpcy5fbGluayA9IG5hdkxpbmtcbiAgICB0aGlzLl9jb250YWluZXIgPSBuYXZMaW5rLnBhcmVudEVsZW1lbnQhIGFzIEhUTUxFbGVtZW50XG4gICAgdGhpcy5fc2VjdGlvbiA9IHRoaXMuX2NvbnRhaW5lciEucXVlcnlTZWxlY3RvcihRVUVSWV9OQVZfQk9EWSkhIGFzIEhUTUxFbGVtZW50XG4gICAgdGhpcy5fZm9vdGVyID0gdGhpcy5fY29udGFpbmVyIS5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9GT09URVIpISBhcyBIVE1MRWxlbWVudFxuXG4gICAgaWYgKG5hdkxpbmsgPT09IHRoaXMuX25hdmlnYXRpb24uX2hhbWJ1cmdlckVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX2NvbnRhaW5lciA9IHRoaXMuX25hdmlnYXRpb24uX25hdkxldmVsMVxuICAgICAgdGhpcy5fc2VjdGlvbiA9IHRoaXMuX2NvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9IQl9CT0RZKSEgYXMgSFRNTEVsZW1lbnRcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHVibGljIHByZXZpb3VzTGV2ZWwxKCkge1xuICAgIGxldCBwcmV2ID0gbmV3IE5hdmlnYXRpb25JdGVtcyh0aGlzLl9uYXZpZ2F0aW9uKVxuXG4gICAgcHJldi5fbGluayA9IHRoaXMuX25hdmlnYXRpb24uX25hdkxldmVsMS5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9MSU5LX0FDVElWRSkhIGFzIEhUTUxFbGVtZW50XG4gICAgcHJldi5fY29udGFpbmVyID0gcHJldi5fbGluayA/IHByZXYuX2xpbmsucGFyZW50RWxlbWVudCEgOiB1bmRlZmluZWRcbiAgICBwcmV2Ll9zZWN0aW9uID0gcHJldi5fY29udGFpbmVyID8gcHJldi5fY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoUVVFUllfTkFWX0JPRFkpISBhcyBIVE1MRWxlbWVudCA6IHVuZGVmaW5lZFxuICAgIHByZXYuX2Zvb3RlciA9IHByZXYuX2NvbnRhaW5lciA/IHByZXYuX2NvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFFVRVJZX05BVl9GT09URVIpISBhcyBIVE1MRWxlbWVudCA6IHVuZGVmaW5lZFxuXG4gICAgcmV0dXJuIHByZXZcbiAgfVxuXG4gIHB1YmxpYyBpc0hhbWJ1cmdlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fbGluayA9PT0gdGhpcy5fbmF2aWdhdGlvbi5faGFtYnVyZ2VyRWxlbWVudFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBzZWFyY2hBbmRJbml0aWFsaXplKFwiLm5hdlwiLCAoZSkgPT4ge1xuICAgIG5ldyBOYXZpZ2F0aW9uKGUpXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IE5hdmlnYXRpb25cbiIsImltcG9ydCB7IHNlYXJjaEFuZEluaXRpYWxpemUsIHByZXZlbnREZWZhdWx0IH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCBhbmltZSBmcm9tIFwiYW5pbWVqc1wiXG5pbXBvcnQgeyBoYXNDbGFzcywgYWRkQ2xhc3MsIHJlbW92ZUNsYXNzIH0gZnJvbSBcIi4uL0RvbUZ1bmN0aW9uc1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5cbmNvbnN0IENMQVNTX09QRU4gPSBcImlzLW9wZW5cIlxuY29uc3QgQ0xBU1NfQUNUSVZFID0gXCJpcy1hY3RpdmVcIlxuXG5jb25zdCBRVUVSWV9TSVRFX1dSQVBQRVIgPSBcIi5qcy1zaXRlLXdyYXBwZXJcIlxuY29uc3QgUVVFUllfTkFWX0hBTUJVUkdFUiA9IFwiLmpzLXNpdGUtd3JhcHBlciAuanMtaGFtYnVyZ2VyXCJcblxuY29uc3QgUVVFUllfTkFWX0lURU0gPSBcIi5qcy1uYXYtaXRlbVwiXG5cbmNvbnN0IE5BVl9MSU5LX0lOSVRJQUxfU0NBTEUgPSAwLjlcbmNvbnN0IEFOSU1BVElPTl9EVVJBVElPTl9MSU5LUyA9IDEwMFxuY29uc3QgQU5JTUFUSU9OX0RVUkFUSU9OX05BViA9IDMwMFxuXG5jb25zdCBBTklNQVRJT05fU1RBR0dFUl9ERUxBWSA9IDUwXG5cbi8qKlxuICogVGhlIG5hdmlnYXRpb24gc2lkZSBjb21wb25lbnQgZGVmaW5pdGlvbi5cbiAqL1xuY2xhc3MgTmF2aWdhdGlvblNpZGUgZXh0ZW5kcyBEb21FbGVtZW50IHtcbiAgcHJpdmF0ZSBfY2xpY2tIYW5kbGVyOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX3dpbmRvd0NsaWNrSGFuZGxlcjogKGV2ZW50OiBFdmVudCkgPT4gdm9pZFxuXG4gIHByaXZhdGUgX3NpdGVXcmFwcGVyOiBFbGVtZW50XG4gIHByaXZhdGUgX2hhbWJ1cmdlckVsZW1lbnQ6IEVsZW1lbnRcbiAgcHJpdmF0ZSBfbmF2SXRlbXM6IE5vZGVMaXN0T2Y8RWxlbWVudD5cblxuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBFbGVtZW50KSB7XG4gICAgc3VwZXIoZWxlbWVudClcblxuICAgIHRoaXMuX2NsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZUNsaWNrLmJpbmQodGhpcylcbiAgICB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVXaW5kb3dDbGljay5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9zaXRlV3JhcHBlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfU0lURV9XUkFQUEVSKSFcbiAgICB0aGlzLl9oYW1idXJnZXJFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9OQVZfSEFNQlVSR0VSKSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXG4gICAgdGhpcy5fbmF2SXRlbXMgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChRVUVSWV9OQVZfSVRFTSkhXG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLl9oYW1idXJnZXJFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jbGlja0hhbmRsZXIpXG4gICAgdGhpcy5faGFtYnVyZ2VyRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fY2xpY2tIYW5kbGVyKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVDbGljayhldmVudDogTW91c2VFdmVudCkge1xuICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KVxuICAgIHRoaXMudG9nZ2xlKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlV2luZG93Q2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICBsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIEVsZW1lbnRcblxuICAgIHdoaWxlICh0YXJnZXQgIT09IHRoaXMuZWxlbWVudCAmJiB0YXJnZXQucGFyZW50RWxlbWVudCkge1xuICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudEVsZW1lbnRcbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0ICE9PSB0aGlzLmVsZW1lbnQpIHtcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBzaWRlIG5hdmlnYXRpb24uXG4gICAqL1xuICBwdWJsaWMgdG9nZ2xlKCkge1xuICAgIGlmIChoYXNDbGFzcyh0aGlzLmVsZW1lbnQsIENMQVNTX09QRU4pID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5vcGVuKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jbG9zZSgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9wZW5zIHRoZSBzbGlkZSBuYXZpZ2F0aW9uLlxuICAgKi9cbiAgcHVibGljIG9wZW4oKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuICAgIH0sIDUwKVxuXG4gICAgYWRkQ2xhc3ModGhpcy5faGFtYnVyZ2VyRWxlbWVudCwgQ0xBU1NfQUNUSVZFKVxuICAgIGFkZENsYXNzKHRoaXMuZWxlbWVudCwgQ0xBU1NfT1BFTilcbiAgICBhZGRDbGFzcyh0aGlzLl9zaXRlV3JhcHBlciwgQ0xBU1NfT1BFTilcblxuICAgIGNvbnN0IHggPSBhbmltZS50aW1lbGluZSgpXG4gICAgbGV0IG9mZiA9IEFOSU1BVElPTl9EVVJBVElPTl9OQVZcbiAgICB0aGlzLl9uYXZJdGVtcy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICBjb25zdCBlbCA9IGVsZW1lbnQgYXMgSFRNTEVsZW1lbnRcbiAgICAgIGVsLnN0eWxlLm9wYWNpdHkgPSBcIjBcIlxuICAgICAgZWwuc3R5bGUudHJhbnNmb3JtID0gYHNjYWxlKCR7TkFWX0xJTktfSU5JVElBTF9TQ0FMRX0pYFxuICAgICAgeC5hZGQoe1xuICAgICAgICB0YXJnZXRzOiBlbCxcbiAgICAgICAgZHVyYXRpb246IEFOSU1BVElPTl9EVVJBVElPTl9MSU5LUyxcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgc2NhbGU6IDEsXG4gICAgICAgIGVhc2luZzogXCJsaW5lYXJcIixcbiAgICAgICAgb2Zmc2V0OiBvZmZcbiAgICAgIH0pXG4gICAgICBvZmYgKz0gQU5JTUFUSU9OX1NUQUdHRVJfREVMQVlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgc2lkZSBuYXZpZ2F0aW9uLlxuICAgKi9cbiAgcHVibGljIGNsb3NlKCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuXG4gICAgcmVtb3ZlQ2xhc3ModGhpcy5faGFtYnVyZ2VyRWxlbWVudCwgQ0xBU1NfQUNUSVZFKVxuICAgIHJlbW92ZUNsYXNzKHRoaXMuZWxlbWVudCwgQ0xBU1NfT1BFTilcbiAgICByZW1vdmVDbGFzcyh0aGlzLl9zaXRlV3JhcHBlciwgQ0xBU1NfT1BFTilcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgY29tcG9uZW50IGFuZCByZW1vdmVzIGFsbCBldmVudFxuICAgKiBzdWJzY3JpcHRpb25zIGFuZCByZWZlcmVuY2VzLlxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIpXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLl93aW5kb3dDbGlja0hhbmRsZXIpO1xuXG4gICAgKHRoaXMgYXMgYW55KS5fd2luZG93Q2xpY2tIYW5kbGVyID0gbnVsbDtcblxuICAgICh0aGlzIGFzIGFueSkuX2NsaWNrSGFuZGxlciA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fc2l0ZVdyYXBwZXIgPSBudWxsO1xuXG4gICAgKHRoaXMgYXMgYW55KS5faGFtYnVyZ2VyRWxlbWVudCA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fbmF2SXRlbXMgPSBudWxsXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHNlYXJjaEFuZEluaXRpYWxpemUoXCIubmF2LXNpZGVcIiwgKGUpID0+IHtcbiAgICBuZXcgTmF2aWdhdGlvblNpZGUoZSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgTmF2aWdhdGlvblNpZGVcbiIsImltcG9ydCB7IHByZXZlbnREZWZhdWx0IH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCBEb21FbGVtZW50IGZyb20gXCIuLi9Eb21FbGVtZW50XCJcblxuY29uc3QgQ0xBU1NfTk9USUZJQ0FUSU9OID0gXCJub3RpZmljYXRpb24taGVhZGVyXCJcblxuY29uc3QgQ0xBU1NfT1BFTiA9IFwibm90aWZpY2F0aW9uLS1vcGVuXCJcbmNvbnN0IENMQVNTX0JVVFRPTl9DTE9TRSA9IFwibm90aWZpY2F0aW9uX19jbG9zZVwiXG5cbi8qKlxuICogTm90aWZpY2F0aW9uIGNvbXBvbmVudC5cbiAqIEBuYW1lc3BhY2UgTm90aWZpY2F0aW9uXG4gKi9cblxuLyoqXG4gKiBUaGUgbWVzc2FnZSBjbGljayBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBtZW1iZXJvZiBOb3RpZmljYXRpb25cbiAqIEBjYWxsYmFjayBOb3RpZmljYXRpb25+Q2xpY2tcbiAqIEBwcm9wZXJ0eSB7Tm90aWZpY2F0aW9uSGVhZGVyfSBpdGVtIC0gVGhlIGN1cnJlbnQgbm90aWZpY2F0aW9uIGhlYWRlciBpbnN0YW5jZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm4gdHJ1ZSBpZiB0aGUgbm90aWZpY2F0aW9uIHNob3VsZCBiZSBjbG9zZWQ7IHJldHVybiBmYWxzZSBpZiB0aGVcbiAqICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb24gc2hvdWxkIHJlbWFpbiBvcGVuLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1lc3NhZ2VDbGlja0NhbGxiYWNrIHtcbiAgKGhlYWRlcjogTm90aWZpY2F0aW9uSGVhZGVyKTogYm9vbGVhbiB8IHVuZGVmaW5lZFxufVxuXG4vKipcbiAqIFRoZSBjYW5jZWwgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAbWVtYmVyb2YgTm90aWZpY2F0aW9uXG4gKiBAY2FsbGJhY2sgTm90aWZpY2F0aW9ufkNhbmNlbFxuICogQHByb3BlcnR5IHtOb3RpZmljYXRpb25IZWFkZXJ9IGl0ZW0gLSBUaGUgY3VycmVudCBub3RpZmljYXRpb24gaGVhZGVyIGluc3RhbmNlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENhbmNlbENhbGxiYWNrIHtcbiAgKGhlYWRlcjogTm90aWZpY2F0aW9uSGVhZGVyKTogdm9pZFxufVxuXG4vKipcbiAqIENyZWF0ZXMgYW5kIHNob3dzIGEgbm90aWZpY2F0aW9uIHdpdGggdGhlIHNwZWNpZmllZCBtZXNzYWdlLlxuICogQG1lbWJlcm9mIE5vdGlmaWNhdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IGNvbnRhaW5lcklkIC0gVGhlIGlkIG9mIHRoZSBjb250YWluZXIgb24gd2hlcmUgdG8gc2hvdyB0aGUgbm90aWZpY2F0aW9uLlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBzaG93LlxuICogQHBhcmFtIHtOb3RpZmljYXRpb25+Q2xpY2t9IG1lc3NhZ2VDbGlja0NhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIHRoYXQgZ2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gdGhlIG5vdGlmaWNhdGlvbiBtZXNzYWdlIHRleHQuXG4gKiBAcGFyYW0ge05vdGlmaWNhdGlvbn5DYW5jZWx9IGNhbmNlbENhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIHRoYXQgZ2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjYW5jZWxzIHRoZSBub3RpZmljYXRpb24gYnkgY2xvc2luZyBpdC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBtb2RpZmllckNsYXNzIC0gVGhlIGNzcyBtb2RpZmllciBjbGFzcyBmb3IgdGhlIG5vdGlmaWNhdGlvbjsgdGhpcyBpcyBhbiBvcHRpb25hbCBwYXJhbWV0ZXJcbiAqIEByZXR1cm5zIHtOb3RpZmljYXRpb25IZWFkZXJ9IFRoZSBub3RpZmljYXRpb24gaGVhZGVyIGl0ZW0gaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaG93T25IZWFkZXIoXG4gIGNvbnRhaW5lcklkOiBzdHJpbmcsXG4gIG1lc3NhZ2U6IHN0cmluZyxcbiAgbWVzc2FnZUNsaWNrQ2FsbGJhY2s/OiBNZXNzYWdlQ2xpY2tDYWxsYmFjayxcbiAgY2FuY2VsQ2FsbGJhY2s/OiBDYW5jZWxDYWxsYmFjayxcbiAgbW9kaWZpZXJDbGFzcz86IHN0cmluZ1xuKSB7XG5cbiAgY29uc3QgY29udGFpbmVyRSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYCMke2NvbnRhaW5lcklkfWApXG4gIGlmICghY29udGFpbmVyRSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgdGhlIGNvbnRhaW5lciB3aXRoIGlkICR7Y29udGFpbmVySWR9YClcbiAgfVxuXG4gIGNvbnN0IGNvbnRhaW5lckVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChjb250YWluZXJFKVxuICBjb25zdCBub3RpZmljYXRpb25FbGVtZW50ID0gbmV3IE5vdGlmaWNhdGlvbkhlYWRlcigpXG5cbiAgaWYgKG1vZGlmaWVyQ2xhc3MpIHtcbiAgICBub3RpZmljYXRpb25FbGVtZW50LmFkZENsYXNzKG1vZGlmaWVyQ2xhc3MpXG4gIH1cblxuICBub3RpZmljYXRpb25FbGVtZW50Lm1lc3NhZ2UgPSBtZXNzYWdlXG4gIG5vdGlmaWNhdGlvbkVsZW1lbnQubWVzc2FnZUNsaWNrQ2FsbGJhY2sgPSBtZXNzYWdlQ2xpY2tDYWxsYmFja1xuICBub3RpZmljYXRpb25FbGVtZW50LmNhbmNlbENhbGxiYWNrID0gY2FuY2VsQ2FsbGJhY2tcblxuICBjb250YWluZXJFbGVtZW50LmFwcGVuZENoaWxkKG5vdGlmaWNhdGlvbkVsZW1lbnQpXG4gIG5vdGlmaWNhdGlvbkVsZW1lbnQuX29wZW4oKVxuXG4gIHJldHVybiBub3RpZmljYXRpb25FbGVtZW50XG59XG5cbi8qKlxuICogQSBjb21wb25lbnQgZm9yIGRpc3BsYXlpbmcgbm90aWZpY2F0aW9ucyBvbiB0aGUgcGFnZS1oZWFkZXIuXG4gKiBAaW5uZXJcbiAqIEBtZW1iZXJvZiBOb3RpZmljYXRpb25cbiAqL1xuZXhwb3J0IGNsYXNzIE5vdGlmaWNhdGlvbkhlYWRlciBleHRlbmRzIERvbUVsZW1lbnQge1xuICBwcml2YXRlIF9jbG9zZUhhbmRsZXI6IChldmVudDogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfY2xpY2tIYW5kbGVyOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkXG5cbiAgcHJpdmF0ZSBfY2FsbGJhY2s/OiBNZXNzYWdlQ2xpY2tDYWxsYmFja1xuICBwcml2YXRlIF9jYW5jZWxDYWxsYmFjaz86IENhbmNlbENhbGxiYWNrXG5cbiAgcHJpdmF0ZSBfY2xvc2VCdXR0b24hOiBEb21FbGVtZW50PEVsZW1lbnQ+XG4gIHByaXZhdGUgX25vdGlmaWNhdGlvbkJvZHkhOiBEb21FbGVtZW50PEVsZW1lbnQ+XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJkaXZcIilcblxuICAgIHRoaXMuX2Nsb3NlSGFuZGxlciA9IHRoaXMuX2hhbmRsZUNsb3NlLmJpbmQodGhpcylcbiAgICB0aGlzLl9jbGlja0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVDbGljay5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgcmFuZ2UgbW9kYWwgY29tcG9uZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplKCkge1xuICAgIHRoaXMuYWRkQ2xhc3MoQ0xBU1NfTk9USUZJQ0FUSU9OKVxuICAgIHRoaXMuYWRkQ2xhc3MoQ0xBU1NfT1BFTilcblxuICAgIGNvbnN0IG5vdGlmaWNhdGlvbkNvbnRlbnQgPSBuZXcgRG9tRWxlbWVudChcImRpdlwiKVxuICAgICAgLmFkZENsYXNzKFwibm90aWZpY2F0aW9uX19jb250ZW50XCIpXG5cbiAgICB0aGlzLmFwcGVuZENoaWxkKG5vdGlmaWNhdGlvbkNvbnRlbnQpXG5cbiAgICB0aGlzLl9ub3RpZmljYXRpb25Cb2R5ID0gbmV3IERvbUVsZW1lbnQoXCJkaXZcIilcbiAgICAgIC5hZGRDbGFzcyhcIm5vdGlmaWNhdGlvbl9fYm9keVwiKVxuXG4gICAgbm90aWZpY2F0aW9uQ29udGVudC5hcHBlbmRDaGlsZCh0aGlzLl9ub3RpZmljYXRpb25Cb2R5KVxuXG4gICAgdGhpcy5fY2xvc2VCdXR0b24gPSBuZXcgRG9tRWxlbWVudChcImJ1dHRvblwiKVxuICAgICAgLmFkZENsYXNzKENMQVNTX0JVVFRPTl9DTE9TRSlcbiAgICAgIC5hZGRDbGFzcyhcIm5vdGlmaWNhdGlvbi1jYW5jZWxcIilcbiAgICAgIC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwiQ2xvc2VcIilcblxuICAgIGNvbnN0IGNsb3NlSWNvbiA9IG5ldyBEb21FbGVtZW50KFwiaVwiKVxuICAgICAgLmFkZENsYXNzKFwiaWNvblwiKVxuICAgICAgLmFkZENsYXNzKFwiaWNvbi0wMjItY2xvc2VcIilcbiAgICAgIC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIilcblxuICAgIHRoaXMuX2Nsb3NlQnV0dG9uLmFwcGVuZENoaWxkKGNsb3NlSWNvbilcbiAgICBub3RpZmljYXRpb25Db250ZW50LmFwcGVuZENoaWxkKHRoaXMuX2Nsb3NlQnV0dG9uKVxuXG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9jbGlja0hhbmRsZXIpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUNsaWNrKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgcHJldmVudERlZmF1bHQoZXZlbnQpXG5cbiAgICBsZXQgY2xvc2VOb3RpZmljYXRpb24gPSB0cnVlXG4gICAgaWYgKHRoaXMuX2NhbGxiYWNrKSB7XG4gICAgICBpZiAodGhpcy5fY2FsbGJhY2sodGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgIGNsb3NlTm90aWZpY2F0aW9uID0gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2xvc2VOb3RpZmljYXRpb24gPT09IHRydWUpIHtcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlQ2xvc2UoZXZlbnQ6IEV2ZW50KSB7XG4gICAgcHJldmVudERlZmF1bHQoZXZlbnQpXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcblxuICAgIGlmICh0aGlzLl9jYW5jZWxDYWxsYmFjaykge1xuICAgICAgdGhpcy5fY2FuY2VsQ2FsbGJhY2sodGhpcylcbiAgICB9XG5cbiAgICB0aGlzLmNsb3NlKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfY2xvc2UoKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcyhDTEFTU19PUEVOKVxuICAgIHRoaXMuX2Nsb3NlQnV0dG9uLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2Nsb3NlSGFuZGxlcilcblxuICAgIGNvbnN0IGVsID0gdGhpcy5lbGVtZW50XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAvLyByZW1vdmUgdGhlIGVsZW1lbnQgZnJvbSB0aGUgZG9tXG4gICAgICBpZiAoZWwgJiYgZWwucGFyZW50RWxlbWVudCkge1xuICAgICAgICBlbC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGVsKVxuICAgICAgfVxuICAgIH0sIDMwMClcbiAgfVxuXG4gIC8vIGNhbGxlZCBieSBzaG93T25IZWFkZXJcbiAgcHVibGljIF9vcGVuKCkge1xuICAgIHRoaXMuYWRkQ2xhc3MoQ0xBU1NfT1BFTilcblxuICAgIHRoaXMuX2Nsb3NlQnV0dG9uLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2Nsb3NlSGFuZGxlcilcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJvcGVuZWRcIilcbiAgfVxuXG4gIHNldCBtZXNzYWdlQ2xpY2tDYWxsYmFjayhjYWxsYmFjazogTWVzc2FnZUNsaWNrQ2FsbGJhY2sgfCB1bmRlZmluZWQpIHtcbiAgICB0aGlzLl9jYWxsYmFjayA9IGNhbGxiYWNrXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgY2FuY2VsIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsLlxuICAgKi9cbiAgc2V0IGNhbmNlbENhbGxiYWNrKGNhbGxiYWNrOiBDYW5jZWxDYWxsYmFjayB8IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuX2NhbmNlbENhbGxiYWNrID0gY2FsbGJhY2tcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBub3RpZmljYXRpb24gbWVzc2FnZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IC0gVGhlIG1lc3NhZ2UgdG8gc2V0LlxuICAgKi9cbiAgc2V0IG1lc3NhZ2UodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuX25vdGlmaWNhdGlvbkJvZHkuc2V0SHRtbCh2YWx1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIG5vdGlmaWNhdGlvbi5cbiAgICovXG4gIHB1YmxpYyBjbG9zZSgpIHtcbiAgICB0aGlzLl9jbG9zZSgpXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFwiY2xvc2VkXCIpXG4gIH1cbn1cbiIsImltcG9ydCBhbmltZSBmcm9tIFwiYW5pbWVqc1wiXG5pbXBvcnQgeyBzZWFyY2hBbmRJbml0aWFsaXplLCBjbGFtcCwgcHJldmVudERlZmF1bHQgfSBmcm9tIFwiLi4vVXRpbHNcIlxuaW1wb3J0ICogYXMgSW5wdXRzIGZyb20gXCIuLi9JbnB1dHNcIlxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuXG5jb25zdCBDTEFTU19IRUFERVIgPSBcIi5wcm9ncmVzcy1mdWxsX19iYXJcIlxuY29uc3QgQ0xBU1NfU0VDVElPTlMgPSBcIi5wcm9ncmVzcy1mdWxsX19zZWN0aW9ucyA+IHNwYW5cIlxuY29uc3QgQ0xBU1NfU0VDVElPTl9BQ1RJVkUgPSBcInNlY3Rpb24tLWFjdGl2ZVwiXG5cbmNvbnN0IENMQVNTX0lORElDQVRPUiA9IFwiaW5kaWNhdG9yXCJcbmNvbnN0IENMQVNTX0lORElDQVRPUl9DVVJSRU5UID0gXCJpbmRpY2F0b3ItLWN1cnJlbnRcIlxuY29uc3QgQ0xBU1NfSU5ESUNBVE9SX0NPTVBMRVRFRCA9IFwiaW5kaWNhdG9yLS1jb21wbGV0ZWRcIlxuXG4vKipcbiAqIEZ1bGwgcHJvZ3Jlc3MgYmFyIGNvbXBvbmVudFxuICovXG5jbGFzcyBQcm9ncmVzc0Z1bGwgZXh0ZW5kcyBEb21FbGVtZW50IHtcbiAgcHJpdmF0ZSBfYnV0dG9uQ2xpY2tIYW5kbGVyITogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2tleWRvd25IYW5kbGVyITogKGU6IEV2ZW50KSA9PiB2b2lkXG5cbiAgcHJpdmF0ZSBfaGVhZGVyRWxlbWVudCE6IERvbUVsZW1lbnQ8RWxlbWVudD5cbiAgcHJpdmF0ZSBfcGFnZXMhOiBOb2RlTGlzdE9mPEVsZW1lbnQ+XG5cbiAgcHJpdmF0ZSBfbWluVmFsdWUhOiBudW1iZXJcbiAgcHJpdmF0ZSBfdmFsdWUhOiBudW1iZXJcbiAgcHJpdmF0ZSBfdG90YWwhOiBudW1iZXJcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgaW5pdGlhbGl6ZXMgdGhlIFByb2dyZXNzRnVsbCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7RG9tRWxlbWVudH0gLSBUaGUgcm9vdCBlbGVtZW50IG9mIHRoZSBQcm9ncmVzc0Z1bGwgY29tcG9uZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZWxlbWVudDogRWxlbWVudCkge1xuICAgIHN1cGVyKGVsZW1lbnQpXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGxvYWRlciBiYXIgY29tcG9uZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdGVjdGVkIF9pbml0aWFsaXplKCkge1xuICAgIHRoaXMuX2J1dHRvbkNsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZUJ1dHRvbkNsaWNrLmJpbmQodGhpcylcbiAgICB0aGlzLl9rZXlkb3duSGFuZGxlciA9IHRoaXMuX2hhbmRsZUtleWRvd24uYmluZCh0aGlzKVxuXG4gICAgdGhpcy5faGVhZGVyRWxlbWVudCA9IHRoaXMuZmluZChDTEFTU19IRUFERVIpIVxuXG4gICAgdGhpcy5fcGFnZXMgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChDTEFTU19TRUNUSU9OUylcblxuICAgIHRoaXMuX21pblZhbHVlID0gMVxuICAgIHRoaXMuX3ZhbHVlID0gMVxuICAgIHRoaXMuX3RvdGFsID0gdGhpcy5fcGFnZXMubGVuZ3RoXG5cbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fcGFnZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBpZiAodGhpcy5fcGFnZXNbaW5kZXhdLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19TRUNUSU9OX0FDVElWRSkpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBpbmRleCArIDFcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9hZGRJbmNpY2F0b3JzKClcbiAgICB0aGlzLl91cGRhdGUoLTEsIHRoaXMuX3ZhbHVlLCBmYWxzZSlcblxuICAgIC8vIEFwcGx5IHRoZSB0YWIgaW5kZXhcbiAgICBjb25zdCB0YWJJbmRleCA9IHRoaXMuZ2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIilcbiAgICBpZiAodGFiSW5kZXgpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCJcIilcbiAgICAgIHRoaXMuX2hlYWRlckVsZW1lbnQuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgdGFiSW5kZXgpXG4gICAgfVxuXG4gICAgdGhpcy5faGVhZGVyRWxlbWVudC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9idXR0b25DbGlja0hhbmRsZXIpXG4gICAgdGhpcy5faGVhZGVyRWxlbWVudC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2tleWRvd25IYW5kbGVyKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9hZGRJbmNpY2F0b3JzKCkge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLl9wYWdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgbGV0IGluZGljYXRvckVsZW1lbnQgPSBuZXcgRG9tRWxlbWVudChcImJ1dHRvblwiKVxuICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfSU5ESUNBVE9SKVxuICAgICAgICAuc2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiLCBgJHtpICsgMX1gKVxuICAgICAgICAuc2V0SHRtbCgoaSArIDEpLnRvU3RyaW5nKCkpXG5cbiAgICAgIHRoaXMuX2hlYWRlckVsZW1lbnQucHJlcGVuZENoaWxkKGluZGljYXRvckVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF91cGRhdGUob2xkVmFsdWU6IG51bWJlciwgbmV3VmFsdWU6IG51bWJlciwgYW5pbWF0ZSA9IHRydWUpIHtcbiAgICBsZXQgaW5kaWNhdG9ycyA9IHRoaXMuX2hlYWRlckVsZW1lbnQuZWxlbWVudC5jaGlsZE5vZGVzXG5cbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgaW5kaWNhdG9ycy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGxldCBpbmRpY2F0b3JFbGVtZW50ID0gbmV3IERvbUVsZW1lbnQoaW5kaWNhdG9yc1tpbmRleF0gYXMgRWxlbWVudClcblxuICAgICAgaWYgKGluZGV4ICsgMSA8IHRoaXMuX3ZhbHVlKSB7XG4gICAgICAgIGluZGljYXRvckVsZW1lbnRcbiAgICAgICAgICAucmVtb3ZlQ2xhc3MoQ0xBU1NfSU5ESUNBVE9SX0NVUlJFTlQpXG4gICAgICAgICAgLmFkZENsYXNzKENMQVNTX0lORElDQVRPUl9DT01QTEVURUQpXG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCArIDEgPT09IHRoaXMuX3ZhbHVlKSB7XG4gICAgICAgIGluZGljYXRvckVsZW1lbnRcbiAgICAgICAgICAucmVtb3ZlQ2xhc3MoQ0xBU1NfSU5ESUNBVE9SX0NPTVBMRVRFRClcbiAgICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfSU5ESUNBVE9SX0NVUlJFTlQpXG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCArIDEgPiB0aGlzLl92YWx1ZSkge1xuICAgICAgICBpbmRpY2F0b3JFbGVtZW50XG4gICAgICAgICAgLnJlbW92ZUNsYXNzKENMQVNTX0lORElDQVRPUl9DT01QTEVURUQpXG4gICAgICAgICAgLnJlbW92ZUNsYXNzKENMQVNTX0lORElDQVRPUl9DVVJSRU5UKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvbGRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgIGxldCBkaXJlY3Rpb24gPSBNYXRoLnNpZ24ob2xkVmFsdWUgLSBuZXdWYWx1ZSlcblxuICAgICAgaWYgKG9sZFZhbHVlID4gMCAmJiBvbGRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgbGV0IG9sZFNlY3Rpb24gPSBuZXcgRG9tRWxlbWVudCh0aGlzLl9wYWdlc1tvbGRWYWx1ZSAtIDFdKVxuXG4gICAgICAgIGlmIChhbmltYXRlKSB7XG4gICAgICAgICAgYW5pbWUoe1xuICAgICAgICAgICAgdGFyZ2V0czogb2xkU2VjdGlvbi5lbGVtZW50LFxuICAgICAgICAgICAgZHVyYXRpb246IDMwMCxcbiAgICAgICAgICAgIGxlZnQ6IDEwMCAqIGRpcmVjdGlvbixcbiAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICBlYXNpbmc6IFwiZWFzZUluT3V0UXVpbnRcIixcbiAgICAgICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgICAgIG9sZFNlY3Rpb24ucmVtb3ZlQ2xhc3MoQ0xBU1NfU0VDVElPTl9BQ1RJVkUpXG4gICAgICAgICAgICAgIG9sZFNlY3Rpb24uc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJcIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9sZFNlY3Rpb24ucmVtb3ZlQ2xhc3MoQ0xBU1NfU0VDVElPTl9BQ1RJVkUpXG4gICAgICAgICAgb2xkU2VjdGlvbi5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcIlwiKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBuZXdTZWN0aW9uID0gbmV3IERvbUVsZW1lbnQodGhpcy5fcGFnZXNbbmV3VmFsdWUgLSAxXSlcblxuICAgICAgaWYgKGFuaW1hdGUpIHtcbiAgICAgICAgY29uc3QgZWwgPSBuZXdTZWN0aW9uLmVsZW1lbnQgYXMgSFRNTEVsZW1lbnRcbiAgICAgICAgZWwuc3R5bGUubGVmdCA9IGAkey0xMDAgKiBkaXJlY3Rpb259cHhgXG4gICAgICAgIGVsLnN0eWxlLm9wYWNpdHkgPSBcIjBcIlxuICAgICAgICBuZXdTZWN0aW9uLmFkZENsYXNzKENMQVNTX1NFQ1RJT05fQUNUSVZFKVxuICAgICAgICBhbmltZSh7XG4gICAgICAgICAgdGFyZ2V0czogbmV3U2VjdGlvbi5lbGVtZW50LFxuICAgICAgICAgIGR1cmF0aW9uOiAzMDAsXG4gICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgIGVhc2luZzogXCJlYXNlSW5PdXRRdWludFwiLFxuICAgICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgICBuZXdTZWN0aW9uLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiXCIpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3U2VjdGlvbi5hZGRDbGFzcyhDTEFTU19TRUNUSU9OX0FDVElWRSlcbiAgICAgICAgbmV3U2VjdGlvbi5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcIlwiKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlQnV0dG9uQ2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICBsZXQgZWxlbWVudCA9IG5ldyBEb21FbGVtZW50KGV2ZW50LnRhcmdldCBhcyBFbGVtZW50KVxuICAgIGlmICghZWxlbWVudC5oYXNDbGFzcyhDTEFTU19JTkRJQ0FUT1IpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgdmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIilcbiAgICB0aGlzLnZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSEpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUtleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICBsZXQga2V5Y29kZSA9IGV2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGVcblxuICAgIGlmIChrZXljb2RlID09PSBJbnB1dHMuS0VZX0FSUk9XX1JJR0hUKSB7XG4gICAgICB0aGlzLnZhbHVlKytcblxuICAgICAgcHJldmVudERlZmF1bHQoZXZlbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoa2V5Y29kZSA9PT0gSW5wdXRzLktFWV9BUlJPV19MRUZUKSB7XG4gICAgICB0aGlzLnZhbHVlLS1cblxuICAgICAgcHJldmVudERlZmF1bHQoZXZlbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoa2V5Y29kZSA+PSBJbnB1dHMuS0VZX05SXzAgJiYga2V5Y29kZSA8PSBJbnB1dHMuS0VZX05SXzkpIHtcbiAgICAgIHRoaXMudmFsdWUgPSBrZXljb2RlIC0gSW5wdXRzLktFWV9OUl8wXG4gICAgICBwcmV2ZW50RGVmYXVsdChldmVudClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHByb2dyZXNzIHZhbHVlIGluIHRoZSByYW5nZSBvZiAxLi50b3RhbC5cbiAgICovXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IHByb2dyZXNzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gLSBUaGUgcHJvZ3Jlc3MgaW4gdGhlIHJhbmdlIG9mIDEuLnRvdGFsLlxuICAgKi9cbiAgc2V0IHZhbHVlKHZhbDogbnVtYmVyKSB7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLl92YWx1ZVxuXG4gICAgdGhpcy5fdmFsdWUgPSBjbGFtcCh2YWwsIHRoaXMuX21pblZhbHVlLCB0aGlzLl90b3RhbClcbiAgICB0aGlzLl91cGRhdGUob2xkVmFsdWUsIHRoaXMuX3ZhbHVlLCB0cnVlKVxuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFwiY2hhbmdlZFwiKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHRvdGFsIHByb2dyZXNzIHZhbHVlLlxuICAgKi9cbiAgZ2V0IHRvdGFsKCkge1xuICAgIHJldHVybiB0aGlzLl90b3RhbFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBzZWFyY2hBbmRJbml0aWFsaXplKFwiLnByb2dyZXNzLWZ1bGxcIiwgKGUpID0+IHtcbiAgICBuZXcgUHJvZ3Jlc3NGdWxsKGUpXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IFByb2dyZXNzRnVsbFxuIiwiaW1wb3J0IGFuaW1lIGZyb20gXCJhbmltZWpzXCJcbmltcG9ydCB7IHNlYXJjaEFuZEluaXRpYWxpemUsIGNsYW1wIH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCBEb21FbGVtZW50IGZyb20gXCIuLi9Eb21FbGVtZW50XCJcblxuY29uc3QgQ0xBU1NfQkFSID0gXCIucHJvZ3Jlc3MtbGlnaHRfX2JhclwiXG5jb25zdCBDTEFTU19QUk9HUkVTUyA9IFwiLmJhcl9fcHJvZ3Jlc3NcIlxuY29uc3QgQ0xBU1NfUFJPR1JFU1NfQ09NUExFVEVEID0gXCJiYXJfX3Byb2dyZXNzLS1jb21wbGV0ZVwiXG5jb25zdCBDTEFTU19USUNLID0gXCJiYXJfX3RpY2tcIlxuY29uc3QgQ0xBU1NfUEFHRV9DVVJSRU5UID0gXCIuZGV0YWlsX19jdXJyZW50cGFnZVwiXG5jb25zdCBDTEFTU19QQUdFX1RPVEFMID0gXCIuZGV0YWlsX190b3RhbHBhZ2VcIlxuXG5jb25zdCBDTEFTU19ESVNBQkxFRCA9IFwiYXJyb3ctLWRpc2FibGVkXCJcbmNvbnN0IENMQVNTX0JVVFRPTl9MRUZUID0gXCIuYXJyb3ctLWxlZnRcIlxuY29uc3QgQ0xBU1NfQlVUVE9OX1JJR0hUID0gXCIuYXJyb3ctLXJpZ2h0XCJcblxuLyoqXG4gKiBMaWdodCBwcm9ncmVzcyBiYXIgY29tcG9uZW50XG4gKi9cbmNsYXNzIFByb2dyZXNzTGlnaHQgZXh0ZW5kcyBEb21FbGVtZW50IHtcbiAgcHJpdmF0ZSBfYnV0dG9uQ2xpY2tIYW5kbGVyITogKGV2ZW50OiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9hbmltYXRpb25Db21wbGV0ZWRIYW5kbGVyITogKGV2ZW50OiBFdmVudCkgPT4gdm9pZFxuXG4gIHByaXZhdGUgX2JhckVsZW1lbnQhOiBEb21FbGVtZW50PEVsZW1lbnQ+XG4gIHByaXZhdGUgX3Byb2dyZXNzRWxlbWVudCE6IERvbUVsZW1lbnQ8RWxlbWVudD5cbiAgcHJpdmF0ZSBfcGFnZUN1cnJlbnRFbGVtZW50ITogRG9tRWxlbWVudDxFbGVtZW50PlxuICBwcml2YXRlIF9wYWdlVG90YWxFbGVtZW50ITogRG9tRWxlbWVudDxFbGVtZW50PlxuICBwcml2YXRlIF9idXR0b25MZWZ0ITogRG9tRWxlbWVudDxFbGVtZW50PlxuICBwcml2YXRlIF9idXR0b25SaWdodCE6IERvbUVsZW1lbnQ8RWxlbWVudD5cblxuICBwcml2YXRlIF9taW5WYWx1ZSE6IG51bWJlclxuICBwcml2YXRlIF90b3RhbCE6IG51bWJlclxuICBwcml2YXRlIF92YWx1ZSE6IG51bWJlclxuXG4gIHByaXZhdGUgX2l0ZW1XaWR0aD86IG51bWJlclxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuZCBpbml0aWFsaXplcyB0aGUgUHJvZ3Jlc3NMaWdodCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7RG9tRWxlbWVudH0gLSBUaGUgcm9vdCBlbGVtZW50IG9mIHRoZSBQcm9ncmVzc0xpZ2h0IGNvbXBvbmVudC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEVsZW1lbnQpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuICAgIHRoaXMuX2luaXRpYWxpemUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBsb2FkZXIgYmFyIGNvbXBvbmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcblxuICAgIHRoaXMuX2J1dHRvbkNsaWNrSGFuZGxlciA9IHRoaXMuX2hhbmRsZUJ1dHRvbkNsaWNrLmJpbmQodGhpcylcbiAgICB0aGlzLl9hbmltYXRpb25Db21wbGV0ZWRIYW5kbGVyID0gdGhpcy5faGFuZGxlQW5pbWF0aW9uQ29tcGxldGVkLmJpbmQodGhpcylcblxuICAgIHRoaXMuX2JhckVsZW1lbnQgPSB0aGlzLmZpbmQoQ0xBU1NfQkFSKSFcbiAgICB0aGlzLl9wcm9ncmVzc0VsZW1lbnQgPSB0aGlzLmZpbmQoQ0xBU1NfUFJPR1JFU1MpIVxuICAgIHRoaXMuX3BhZ2VDdXJyZW50RWxlbWVudCA9IHRoaXMuZmluZChDTEFTU19QQUdFX0NVUlJFTlQpIVxuICAgIHRoaXMuX3BhZ2VUb3RhbEVsZW1lbnQgPSB0aGlzLmZpbmQoQ0xBU1NfUEFHRV9UT1RBTCkhXG4gICAgdGhpcy5fYnV0dG9uTGVmdCA9IHRoaXMuZmluZChDTEFTU19CVVRUT05fTEVGVCkhXG4gICAgdGhpcy5fYnV0dG9uUmlnaHQgPSB0aGlzLmZpbmQoQ0xBU1NfQlVUVE9OX1JJR0hUKSFcblxuICAgIHRoaXMuX21pblZhbHVlID0gMVxuICAgIHRoaXMuX3RvdGFsID0gTWF0aC5tYXgocGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoXCJ0b3RhbFwiKSB8fCBcIjEwMFwiLCAxMCksIHRoaXMuX21pblZhbHVlKVxuICAgIHRoaXMuX3ZhbHVlID0gY2xhbXAocGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSB8fCBcIjFcIiwgMTApLCB0aGlzLl9taW5WYWx1ZSwgdGhpcy5fdG90YWwpXG5cbiAgICB0aGlzLl9sYXlvdXQoKVxuXG4gICAgdGhpcy5fYWRkVGlja3MoKVxuICAgIHRoaXMuX3VwZGF0ZShmYWxzZSlcblxuICAgIHRoaXMuZW5hYmxlKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfYWRkVGlja3MoKSB7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLl90b3RhbDsgaSsrKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuX2l0ZW1XaWR0aCEgKiBpXG5cbiAgICAgIGxldCB0aWNrRWxlbWVudCA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19USUNLKVxuICAgICAgICAuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgYGxlZnQ6ICR7cG9zaXRpb259JWApXG5cbiAgICAgIHRoaXMuX2JhckVsZW1lbnQucHJlcGVuZENoaWxkKHRpY2tFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfdXBkYXRlKGFuaW1hdGUgPSB0cnVlKSB7XG4gICAgdGhpcy5fcGFnZUN1cnJlbnRFbGVtZW50LnNldEh0bWwodGhpcy5fdmFsdWUudG9TdHJpbmcoKSlcbiAgICB0aGlzLl9wYWdlVG90YWxFbGVtZW50LnNldEh0bWwodGhpcy5fdG90YWwudG9TdHJpbmcoKSlcblxuICAgIGxldCBwb3NpdGlvbiA9IHRoaXMuX3ZhbHVlICogdGhpcy5faXRlbVdpZHRoIVxuXG4gICAgLy8gQWRkIGFkZGl0aW9uYWwgd2lkdGggdG8gdGhlIGxhc3QgZWxlbWVudCB0byBtYWtlIHN1cmVcbiAgICAvLyB0aGUgcm91bmRlZCBib3JkZXIgb24gdGhlIGxlZnQgaXMgZmlsbGVkIGFzIHdlbGxcbiAgICBpZiAodGhpcy5fdmFsdWUgPT09IHRoaXMuX3RvdGFsKSB7XG4gICAgICBwb3NpdGlvbiArPSA1XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3ZhbHVlID49IHRoaXMuX3RvdGFsKSB7XG4gICAgICB0aGlzLl9idXR0b25SaWdodC5hZGRDbGFzcyhDTEFTU19ESVNBQkxFRClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYnV0dG9uUmlnaHQucmVtb3ZlQ2xhc3MoQ0xBU1NfRElTQUJMRUQpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3ZhbHVlIDw9IHRoaXMuX21pblZhbHVlKSB7XG4gICAgICB0aGlzLl9idXR0b25MZWZ0LmFkZENsYXNzKENMQVNTX0RJU0FCTEVEKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9idXR0b25MZWZ0LnJlbW92ZUNsYXNzKENMQVNTX0RJU0FCTEVEKVxuICAgIH1cblxuICAgIGNvbnN0IGVsID0gdGhpcy5fcHJvZ3Jlc3NFbGVtZW50LmVsZW1lbnQgYXMgSFRNTEVsZW1lbnRcbiAgICBpZiAoYW5pbWF0ZSkge1xuICAgICAgYW5pbWUoe1xuICAgICAgICB0YXJnZXRzOiB0aGlzLl9wcm9ncmVzc0VsZW1lbnQuZWxlbWVudCxcbiAgICAgICAgZHVyYXRpb246IDIwMCxcbiAgICAgICAgZWFzaW5nOiBcImVhc2VJbk91dFF1aW50XCIsXG4gICAgICAgIHdpZHRoOiB0aGlzLl9iYXJFbGVtZW50LmVsZW1lbnQuY2xpZW50V2lkdGggKiBwb3NpdGlvbiAvIDEwMCxcbiAgICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICBlbC5zdHlsZS53aWR0aCA9IGAke3Bvc2l0aW9ufSVgXG4gICAgICAgICAgdGhpcy5fYW5pbWF0aW9uQ29tcGxldGVkSGFuZGxlcig8RXZlbnQ+e30pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLndpZHRoID0gYCR7cG9zaXRpb259JWBcbiAgICAgIHRoaXMuX2FuaW1hdGlvbkNvbXBsZXRlZEhhbmRsZXIoPEV2ZW50Pnt9KVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfbGF5b3V0KCkge1xuICAgIHRoaXMuX2l0ZW1XaWR0aCA9IE1hdGguZmxvb3IoMTAwIC8gdGhpcy5fdG90YWwpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUJ1dHRvbkNsaWNrKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcy5fYnV0dG9uTGVmdC5lbGVtZW50KSB7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5fdmFsdWUgLSAxXG4gICAgfSBlbHNlIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMuX2J1dHRvblJpZ2h0LmVsZW1lbnQpIHtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLl92YWx1ZSArIDFcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUFuaW1hdGlvbkNvbXBsZXRlZCgpIHtcbiAgICBpZiAodGhpcy5fdmFsdWUgPT09IHRoaXMuX3RvdGFsKSB7XG4gICAgICB0aGlzLl9wcm9ncmVzc0VsZW1lbnQuYWRkQ2xhc3MoQ0xBU1NfUFJPR1JFU1NfQ09NUExFVEVEKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wcm9ncmVzc0VsZW1lbnQucmVtb3ZlQ2xhc3MoQ0xBU1NfUFJPR1JFU1NfQ09NUExFVEVEKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHByb2dyZXNzIHZhbHVlIGluIHRoZSByYW5nZSBvZiAxLi50b3RhbC5cbiAgICovXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IHByb2dyZXNzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gLSBUaGUgcHJvZ3Jlc3MgaW4gdGhlIHJhbmdlIG9mIDEuLnRvdGFsLlxuICAgKi9cbiAgc2V0IHZhbHVlKHZhbCkge1xuICAgIHRoaXMuX3ZhbHVlID0gY2xhbXAodmFsLCB0aGlzLl9taW5WYWx1ZSwgdGhpcy5fdG90YWwpXG4gICAgdGhpcy5fdXBkYXRlKHRydWUpXG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJjaGFuZ2VkXCIpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdG90YWwgcHJvZ3Jlc3MgdmFsdWUuXG4gICAqL1xuICBnZXQgdG90YWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RvdGFsXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdG90YWwgcHJvZ3Jlc3MgdmFsdWUgYW5kIHVwZGF0ZXMgdGhlIFVJIGFjY29yZGluZ2x5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gLSBUaGUgdG90YWwgcHJvZ3Jlc3MgcG9zaXRpdmUgaW50ZWdlciB2YWx1ZS5cbiAgICovXG4gIHNldCB0b3RhbCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl90b3RhbCA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX3RvdGFsID0gTWF0aC5tYXgodmFsdWUsIHRoaXMuX21pblZhbHVlKVxuICAgIHRoaXMuX3ZhbHVlID0gY2xhbXAodGhpcy5fdmFsdWUsIHRoaXMuX21pblZhbHVlLCB0aGlzLl90b3RhbClcblxuICAgIC8vIENsZWFyIHRoZSB0aWNrc1xuICAgIGZvciAobGV0IHRpY2sgb2YgdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke0NMQVNTX1RJQ0t9YCkpIHtcbiAgICAgIHRoaXMuX2JhckVsZW1lbnQuZWxlbWVudC5yZW1vdmVDaGlsZCh0aWNrKVxuICAgIH1cblxuICAgIHRoaXMuX2xheW91dCgpXG4gICAgdGhpcy5fYWRkVGlja3MoKVxuXG4gICAgdGhpcy5fdXBkYXRlKGZhbHNlKVxuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFwidG90YWxjaGFuZ2VkXCIpXG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlcyB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgcHVibGljIGVuYWJsZSgpIHtcbiAgICB0aGlzLl9idXR0b25MZWZ0LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2J1dHRvbkNsaWNrSGFuZGxlcilcbiAgICB0aGlzLl9idXR0b25SaWdodC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9idXR0b25DbGlja0hhbmRsZXIpXG4gIH1cblxuICAvKipcbiAgICogRGlzYWJsZXMgdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIHB1YmxpYyBkaXNhYmxlKCkge1xuICAgIHRoaXMuX2J1dHRvbkxlZnQuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fYnV0dG9uQ2xpY2tIYW5kbGVyKVxuICAgIHRoaXMuX2J1dHRvblJpZ2h0LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2J1dHRvbkNsaWNrSGFuZGxlcilcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdCgpIHtcbiAgc2VhcmNoQW5kSW5pdGlhbGl6ZShcIi5wcm9ncmVzcy1saWdodFwiLCAoZSkgPT4ge1xuICAgIG5ldyBQcm9ncmVzc0xpZ2h0KGUpXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IFByb2dyZXNzTGlnaHRcbiIsImltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCIuL1V0aWxzXCJcblxuaW1wb3J0IExvYWRlckJhciwgeyBpbml0IGFzIGluaXRMb2FkZXJCYXIgfSBmcm9tIFwiLi9sb2FkZXIvTG9hZGVyQmFyXCJcblxuLyogRm9ybSBDb21wb25lbnRzICovXG5pbXBvcnQgSW5wdXRGaWVsZCwgeyBpbml0IGFzIGluaXRJbnB1dEZpZWxkIH0gZnJvbSBcIi4vZm9ybS9JbnB1dEZpZWxkXCJcbmltcG9ydCBUZXh0YXJlYSwgeyBpbml0IGFzIGluaXRUZXh0YXJlYSB9IGZyb20gXCIuL2Zvcm0vVGV4dGFyZWFcIlxuaW1wb3J0IFNlbGVjdCwgeyBpbml0IGFzIGluaXRTZWxlY3QgfSBmcm9tIFwiLi9mb3JtL1NlbGVjdFwiXG5pbXBvcnQgUmFuZ2UsIHsgaW5pdCBhcyBpbml0UmFuZ2UgfSBmcm9tIFwiLi9mb3JtL1JhbmdlXCJcbmltcG9ydCBBdXRvY29tcGxldGUsIHsgaW5pdCBhcyBpbml0QXV0b2NvbXBsZXRlIH0gZnJvbSBcIi4vZm9ybS9BdXRvY29tcGxldGVcIlxuXG5pbXBvcnQgUHJvZ3Jlc3NMaWdodCwgeyBpbml0IGFzIGluaXRQcm9ncmVzc0xpZ2h0IH0gZnJvbSBcIi4vcHJvZ3Jlc3MvUHJvZ3Jlc3NMaWdodFwiXG5pbXBvcnQgUHJvZ3Jlc3NGdWxsLCB7IGluaXQgYXMgaW5pdFByb2dyZXNzRnVsbCB9IGZyb20gXCIuL3Byb2dyZXNzL1Byb2dyZXNzRnVsbFwiXG5cbmltcG9ydCBNb2RhbCwgeyBpbml0IGFzIGluaXRNb2RhbCB9IGZyb20gXCIuL21vZGFsL01vZGFsXCJcbmltcG9ydCBUb29sYmFyIGZyb20gXCIuL3Rvb2xiYXIvVG9vbGJhclwiXG5cbmltcG9ydCAqIGFzIE5vdGlmaWNhdGlvbiBmcm9tIFwiLi9ub3RpZmljYXRpb24vTm90aWZpY2F0aW9uXCJcblxuaW1wb3J0IENvbGxhcHNlLCB7IGluaXQgYXMgaW5pdENvbGxhcHNlIH0gZnJvbSBcIi4vY29sbGFwc2UvQ29sbGFwc2VcIlxuaW1wb3J0IEFjY29yZGlvbiwgeyBpbml0IGFzIGluaXRBY2NvcmRpb24gfSBmcm9tIFwiLi9hY2NvcmRpb24vQWNjb3JkaW9uXCJcbmltcG9ydCBNZW51Rmx5b3V0LCB7IGluaXQgYXMgaW5pdE1lbnVGbHlvdXQgfSBmcm9tIFwiLi9tZW51L01lbnVGbHlvdXRcIlxuXG5pbXBvcnQgTmF2aWdhdGlvbiwgeyBpbml0IGFzIGluaXROYXZpZ2F0aW9uIH0gZnJvbSBcIi4vbmF2aWdhdGlvbi9OYXZpZ2F0aW9uXCJcbmltcG9ydCBOYXZpZ2F0aW9uU2lkZSwgeyBpbml0IGFzIGluaXROYXZpZ2F0aW9uU2lkZSB9IGZyb20gXCIuL25hdmlnYXRpb24vTmF2aWdhdGlvblNpZGVcIlxuaW1wb3J0IFNlYXJjaElucHV0LCB7IGluaXQgYXMgaW5pdFNlYXJjaElucHV0IH0gZnJvbSBcIi4vc2VhcmNoL1NlYXJjaElucHV0XCJcbmltcG9ydCBFbXB0eVN0YXRlLCB7IGluaXQgYXMgaW5pdEVtcHR5U3RhdGUgfSBmcm9tIFwiLi9lbXB0eS1zdGF0ZXMvRW1wdHlTdGF0ZVwiXG5pbXBvcnQgQ2Fyb3VzZWwsIHsgaW5pdCBhcyBpbml0Q2Fyb3VzZWwgfSBmcm9tIFwiLi9jYXJvdXNlbC9DYXJvdXNlbFwiXG5cbmltcG9ydCBUYWJsZSwgeyBpbml0IGFzIGluaXRUYWJsZSB9IGZyb20gXCIuL3RhYmxlL1RhYmxlXCJcblxuaW1wb3J0IFBpZUNoYXJ0LCB7IGluaXQgYXMgaW5pdFBpZUNoYXJ0IH0gZnJvbSBcIi4vY2hhcnRzL1BpZUNoYXJ0XCJcbmltcG9ydCBCYXJDaGFydEhvcml6b250YWwsIHsgaW5pdCBhcyBpbml0QmFyQ2hhcnRIb3Jpem9udGFsIH0gZnJvbSBcIi4vY2hhcnRzL0JhckNoYXJ0SG9yaXpvbnRhbFwiXG5pbXBvcnQgQmFyQ2hhcnRWZXJ0aWNhbCwgeyBpbml0IGFzIGluaXRCYXJDaGFydFZlcnRpY2FsIH0gZnJvbSBcIi4vY2hhcnRzL0JhckNoYXJ0VmVydGljYWxcIlxuXG5leHBvcnQge1xuICB1dGlscyxcbiAgTG9hZGVyQmFyLCBpbml0TG9hZGVyQmFyLFxuICBJbnB1dEZpZWxkLCBpbml0SW5wdXRGaWVsZCxcbiAgVGV4dGFyZWEsIGluaXRUZXh0YXJlYSxcbiAgU2VsZWN0LCBpbml0U2VsZWN0LFxuICBSYW5nZSwgaW5pdFJhbmdlLFxuICBBdXRvY29tcGxldGUsIGluaXRBdXRvY29tcGxldGUsXG4gIFByb2dyZXNzTGlnaHQsIGluaXRQcm9ncmVzc0xpZ2h0LFxuICBQcm9ncmVzc0Z1bGwsIGluaXRQcm9ncmVzc0Z1bGwsXG4gIE1vZGFsLCBpbml0TW9kYWwsXG4gIFRvb2xiYXIsXG4gIE5vdGlmaWNhdGlvbixcbiAgQ29sbGFwc2UsIGluaXRDb2xsYXBzZSxcbiAgQWNjb3JkaW9uLCBpbml0QWNjb3JkaW9uLFxuICBNZW51Rmx5b3V0LCBpbml0TWVudUZseW91dCxcbiAgTmF2aWdhdGlvbiwgaW5pdE5hdmlnYXRpb24sXG4gIE5hdmlnYXRpb25TaWRlLCBpbml0TmF2aWdhdGlvblNpZGUsXG4gIFNlYXJjaElucHV0LCBpbml0U2VhcmNoSW5wdXQsXG4gIEVtcHR5U3RhdGUsIGluaXRFbXB0eVN0YXRlLFxuICBDYXJvdXNlbCwgaW5pdENhcm91c2VsLFxuICBUYWJsZSwgaW5pdFRhYmxlLFxuICBQaWVDaGFydCwgaW5pdFBpZUNoYXJ0LFxuICBCYXJDaGFydEhvcml6b250YWwsIGluaXRCYXJDaGFydEhvcml6b250YWwsXG4gIEJhckNoYXJ0VmVydGljYWwsIGluaXRCYXJDaGFydFZlcnRpY2FsXG59XG4iLCJpbXBvcnQgYW5pbWUsIHsgQW5pbWVUaW1lbGluZUluc3RhbmNlIH0gZnJvbSBcImFuaW1lanNcIlxuaW1wb3J0IERvbUVsZW1lbnQgZnJvbSBcIi4uL0RvbUVsZW1lbnRcIlxuaW1wb3J0ICogYXMgSW5wdXRzIGZyb20gXCIuLi9JbnB1dHNcIlxuaW1wb3J0IHsgc2VhcmNoQW5kSW5pdGlhbGl6ZSwgcHJldmVudERlZmF1bHQsIGludGVybmV0RXhwbG9yZXJPckVkZ2VWZXJzaW9uIH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCB7IGFkZENsYXNzLCByZW1vdmVDbGFzcywgZ2V0QXR0cmlidXRlUmVmZXJlbmNlLCBwYXJlbnRXaXRoQ2xhc3MgfSBmcm9tIFwiLi4vRG9tRnVuY3Rpb25zXCJcblxuY29uc3QgUVVFUllfU0VBUkNIX0lOUFVUID0gXCJpbnB1dC5zZWFyY2hfX2ZpZWxkXCJcbmNvbnN0IFFVRVJZX0JUTl9DTE9TRSA9IFwiLnNlYXJjaF9faWNvbi1jbG9zZVwiXG5cbmNvbnN0IFFVRVJZX0xJVkVfU1VHRVNUSU9OUyA9IFwiLmpzLXN1Z2dlc3Rpb25zXCJcbmNvbnN0IFFVRVJZX0xJVkVfRk9PVEVSID0gXCIuanMtZm9vdGVyXCJcblxuY29uc3QgQ0xBU1NfQUNUSVZFID0gXCJpcy1hY3RpdmVcIlxuY29uc3QgQ0xBU1NfT1BFTiA9IFwiaXMtb3BlblwiXG5cbmNvbnN0IENMQVNTX1NFQVJDSCA9IFwic2VhcmNoXCJcblxuY29uc3QgQU5JTUFUSU9OX1NVR0dFU1RJT05TX0RVUkFUSU9OID0gMzAwXG5jb25zdCBBTklNQVRJT05fRk9PVEVSX0RVUkFUSU9OID0gMTAwXG5jb25zdCBBTklNQVRJT05fRk9PVEVSX0RFTEFZID0gQU5JTUFUSU9OX1NVR0dFU1RJT05TX0RVUkFUSU9OIC0gQU5JTUFUSU9OX0ZPT1RFUl9EVVJBVElPTlxuXG4vKipcbiAqIFRoZSBzZWFyY2ggaW5wdXQgY29tcG9uZW50IGRlZmluaXRpb24uXG4gKi9cbmNsYXNzIFNlYXJjaElucHV0IGV4dGVuZHMgRG9tRWxlbWVudCB7XG4gIHByaXZhdGUgX2lucHV0OiBIVE1MSW5wdXRFbGVtZW50XG4gIHByaXZhdGUgX2Zvcm06IEhUTUxGb3JtRWxlbWVudFxuICBwcml2YXRlIF9idG5DbG9zZTogSFRNTEVsZW1lbnRcbiAgcHJpdmF0ZSBfbGl2ZVN1Z2dlc3Rpb25zPzogSFRNTEVsZW1lbnRcbiAgcHJpdmF0ZSBfbGl2ZUZvb3Rlcj86IEhUTUxFbGVtZW50XG4gIHByaXZhdGUgX2xpdmVDb250YWluZXI/OiBIVE1MRWxlbWVudFxuXG4gIHByaXZhdGUgX2ZvY3VzSGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX2JsdXJIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfY2xvc2VIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfd2luZG93Q2xpY2tIYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWRcbiAgcHJpdmF0ZSBfa2V5ZG93bkhhbmRsZXI6IChlOiBLZXlib2FyZEV2ZW50KSA9PiB2b2lkXG4gIHByaXZhdGUgX3Jlc2l6ZUhhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuXG4gIHByaXZhdGUgX2lzT3BlbjogYm9vbGVhbiA9IGZhbHNlXG4gIHByaXZhdGUgYW5pbWF0aW9uITogQW5pbWVUaW1lbGluZUluc3RhbmNlXG4gIHByaXZhdGUgZWFzaW5nID0ge1xuICAgIC8vIEVxdWl2YWxlbnQgdG8gZ3NhcCdzIFsgUG93ZXIxLmVhc2VJbiwgUG93ZXI0LmVhc2VPdXQgXVxuICAgIGluUXVhZE91dFF1aW50OiBbIDAuNTUwLCAwLjA4NSwgMC4zMjAsIDEgXVxuICB9XG5cbiAgY29uc3RydWN0b3IoZWxlbWVudDogSFRNTEVsZW1lbnQpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgdGhpcy5faW5wdXQgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihRVUVSWV9TRUFSQ0hfSU5QVVQpIGFzIEhUTUxJbnB1dEVsZW1lbnRcbiAgICB0aGlzLl9mb3JtID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJmb3JtXCIpIVxuICAgIHRoaXMuX2J0bkNsb3NlID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoUVVFUllfQlROX0NMT1NFKSBhcyBIVE1MRWxlbWVudFxuXG4gICAgbGV0IGxpdmVTZWFyY2ggPSBnZXRBdHRyaWJ1dGVSZWZlcmVuY2UodGhpcy5lbGVtZW50LCBcImRhdGEtbGl2ZVwiKVxuICAgIGlmIChsaXZlU2VhcmNoKSB7XG4gICAgICB0aGlzLl9saXZlU3VnZ2VzdGlvbnMgPSBsaXZlU2VhcmNoLnF1ZXJ5U2VsZWN0b3IoUVVFUllfTElWRV9TVUdFU1RJT05TKSBhcyBIVE1MRWxlbWVudCB8fCB1bmRlZmluZWRcbiAgICAgIHRoaXMuX2xpdmVGb290ZXIgPSBsaXZlU2VhcmNoLnF1ZXJ5U2VsZWN0b3IoUVVFUllfTElWRV9GT09URVIpIGFzIEhUTUxFbGVtZW50IHx8IHVuZGVmaW5lZFxuXG4gICAgICBpZiAodGhpcy5fbGl2ZVN1Z2dlc3Rpb25zKSB7XG4gICAgICAgIHRoaXMuX2xpdmVDb250YWluZXIgPSB0aGlzLl9saXZlU3VnZ2VzdGlvbnMucGFyZW50Tm9kZSBhcyBIVE1MRWxlbWVudCB8fCB1bmRlZmluZWRcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9mb2N1c0hhbmRsZXIgPSB0aGlzLl9oYW5kbGVJbnB1dEZvY3VzLmJpbmQodGhpcylcbiAgICB0aGlzLl9ibHVySGFuZGxlciA9IHRoaXMuX2hhbmRsZUlucHV0Qmx1ci5iaW5kKHRoaXMpXG4gICAgdGhpcy5fY2xvc2VIYW5kbGVyID0gdGhpcy5jbG9zZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyID0gdGhpcy5faGFuZGxlV2luZG93Q2xpY2suYmluZCh0aGlzKVxuICAgIHRoaXMuX2tleWRvd25IYW5kbGVyID0gdGhpcy5faGFuZGxlS2V5ZG93bi5iaW5kKHRoaXMpXG4gICAgdGhpcy5fcmVzaXplSGFuZGxlciA9IHRoaXMuX2hhbmRsZVJlc2l6ZS5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5fZm9jdXNIYW5kbGVyKVxuICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuX2JsdXJIYW5kbGVyKVxuXG4gICAgaWYgKGludGVybmV0RXhwbG9yZXJPckVkZ2VWZXJzaW9uKCkgPiAwKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3IgSUUgYnJvd3NlcnMgd2hlcmUgYSBmb2N1c2VkXG4gICAgICAvLyBpbnB1dCdzIGN1cnNvciBibGVlZHMgdHJvdWdoIGV2ZW4gaWYgaGlkZGVuXG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMuX3Jlc2l6ZUhhbmRsZXIpXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9yaWVudGF0aW9uY2hhbmdlXCIsIHRoaXMuX3Jlc2l6ZUhhbmRsZXIpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2J0bkNsb3NlKSB7XG4gICAgICB0aGlzLl9idG5DbG9zZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fY2xvc2VIYW5kbGVyKVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlSW5wdXRGb2N1cygpIHtcbiAgICB0aGlzLmFkZENsYXNzKENMQVNTX0FDVElWRSlcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlSW5wdXRCbHVyKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoQ0xBU1NfQUNUSVZFKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVXaW5kb3dDbGljayhldmVudDogTW91c2VFdmVudCkge1xuICAgIGxldCB0YXJnZXQgPSBldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnRcblxuICAgIGlmICghcGFyZW50V2l0aENsYXNzKHRhcmdldCwgQ0xBU1NfU0VBUkNIKSkge1xuICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVLZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgbGV0IGtleWNvZGUgPSBldmVudC53aGljaCB8fCBldmVudC5rZXlDb2RlXG5cbiAgICBpZiAoa2V5Y29kZSA9PT0gSW5wdXRzLktFWV9FU0NBUEUpIHtcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgcHJldmVudERlZmF1bHQoZXZlbnQpXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9oYW5kbGVSZXNpemUoKSB7XG4gICAgbGV0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5lbGVtZW50KVxuICAgIGlmIChzdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIikge1xuICAgICAgdGhpcy5faW5wdXQuYmx1cigpXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9yZXNldE1haW5UaW1lbGluZSgpIHtcbiAgICBpZiAodGhpcy5hbmltYXRpb24pIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uLnBhdXNlKClcbiAgICB9XG4gICAgYW5pbWUucmVtb3ZlKHRoaXMuX2xpdmVTdWdnZXN0aW9ucyEpXG4gICAgYW5pbWUucmVtb3ZlKHRoaXMuX2xpdmVGb290ZXIhKVxuXG4gICAgdGhpcy5hbmltYXRpb24gPSBhbmltZS50aW1lbGluZSgpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc2VhcmNoIGlucHV0IHRleHQgY29udGVudC5cbiAgICogQHJldHVybnMge1N0cmluZ30gVGhlIGlucHV0IHRleHQuXG4gICAqL1xuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lucHV0LnZhbHVlXG4gIH1cblxuICAvKipcbiAgICogT3BlbnMvYWN0aXZhdGVzIHRoZSBzZWFyY2ggaW5wdXQuXG4gICAqL1xuICBwdWJsaWMgb3BlbigpIHtcbiAgICB0aGlzLmFkZENsYXNzKENMQVNTX09QRU4pXG4gICAgdGhpcy5faW5wdXQuZm9jdXMoKVxuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3dpbmRvd0NsaWNrSGFuZGxlcilcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2tleWRvd25IYW5kbGVyKVxuICAgIH0sIDUwKVxuICB9XG5cbiAgLyoqXG4gICAqIENsb3Nlcy9kZWFjdGl2YXRlcyB0aGUgc2VhcmNoIGlucHV0LlxuICAgKi9cbiAgcHVibGljIGNsb3NlKCkge1xuICAgIHRoaXMuX2Zvcm0ucmVzZXQoKVxuICAgIHRoaXMucmVtb3ZlQ2xhc3MoQ0xBU1NfT1BFTilcblxuICAgIHRoaXMuY2xvc2VMaXZlU2VhcmNoKClcblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9rZXlkb3duSGFuZGxlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVucyB0aGUgbGl2ZSBzZWFyY2ggc3VnZ2VzdGlvbnMuXG4gICAqL1xuICBwdWJsaWMgb3BlbkxpdmVTZWFyY2goKSB7XG4gICAgaWYgKCF0aGlzLl9saXZlU3VnZ2VzdGlvbnMgfHwgdGhpcy5faXNPcGVuKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9pc09wZW4gPSB0cnVlXG4gICAgYWRkQ2xhc3ModGhpcy5fbGl2ZUNvbnRhaW5lciEsIENMQVNTX09QRU4pXG5cbiAgICB0aGlzLl9yZXNldE1haW5UaW1lbGluZSgpXG5cbiAgICB0aGlzLl9saXZlU3VnZ2VzdGlvbnMuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIlxuXG4gICAgdGhpcy5hbmltYXRpb24uYWRkKHtcbiAgICAgIHRhcmdldHM6IHRoaXMuX2xpdmVTdWdnZXN0aW9ucyxcbiAgICAgIGR1cmF0aW9uOiBBTklNQVRJT05fU1VHR0VTVElPTlNfRFVSQVRJT04sXG4gICAgICBoZWlnaHQ6IHRoaXMuX2xpdmVTdWdnZXN0aW9ucy5zY3JvbGxIZWlnaHQgKyBcInB4XCIsXG4gICAgICBlYXNpbmc6IHRoaXMuZWFzaW5nLmluUXVhZE91dFF1aW50LFxuICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgY29uc3QgZG9tRWwgPSBuZXcgRG9tRWxlbWVudCh0aGlzLl9saXZlU3VnZ2VzdGlvbnMhKVxuICAgICAgICBkb21FbC5hZGRDbGFzcyhDTEFTU19PUEVOKVxuICAgICAgICBkb21FbC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcIlwiKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBpZiAodGhpcy5fbGl2ZUZvb3Rlcikge1xuICAgICAgdGhpcy5fbGl2ZUZvb3Rlci5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiXG5cbiAgICAgIHRoaXMuYW5pbWF0aW9uLmFkZCh7XG4gICAgICAgIHRhcmdldHM6IHRoaXMuX2xpdmVGb290ZXIsXG4gICAgICAgIGR1cmF0aW9uOiBBTklNQVRJT05fRk9PVEVSX0RVUkFUSU9OLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuX2xpdmVGb290ZXIuc2Nyb2xsSGVpZ2h0ICsgXCJweFwiLFxuICAgICAgICBlYXNpbmc6IHRoaXMuZWFzaW5nLmluUXVhZE91dFF1aW50LFxuICAgICAgICBvZmZzZXQ6IEFOSU1BVElPTl9GT09URVJfREVMQVksXG4gICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgZG9tRWwgPSBuZXcgRG9tRWxlbWVudCh0aGlzLl9saXZlRm9vdGVyISlcbiAgICAgICAgICBkb21FbC5hZGRDbGFzcyhDTEFTU19PUEVOKVxuICAgICAgICAgIGRvbUVsLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiXCIpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgbGl2ZSBzZWFyY2ggc3VnZ2VzdGlvbnMuXG4gICAqL1xuICBwdWJsaWMgY2xvc2VMaXZlU2VhcmNoKCkge1xuICAgIGlmICghdGhpcy5fbGl2ZVN1Z2dlc3Rpb25zIHx8ICF0aGlzLmlzT3Blbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5faXNPcGVuID0gZmFsc2VcbiAgICB0aGlzLl9yZXNldE1haW5UaW1lbGluZSgpXG5cbiAgICB0aGlzLl9saXZlU3VnZ2VzdGlvbnMuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIlxuXG4gICAgdGhpcy5hbmltYXRpb24uYWRkKHtcbiAgICAgIHRhcmdldHM6IHRoaXMuX2xpdmVTdWdnZXN0aW9ucyxcbiAgICAgIGR1cmF0aW9uOiBBTklNQVRJT05fU1VHR0VTVElPTlNfRFVSQVRJT04sXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgICBlYXNpbmc6IHRoaXMuZWFzaW5nLmluUXVhZE91dFF1aW50LFxuICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgY29uc3QgZG9tRWwgPSBuZXcgRG9tRWxlbWVudCh0aGlzLl9saXZlU3VnZ2VzdGlvbnMhKVxuICAgICAgICBkb21FbC5yZW1vdmVDbGFzcyhDTEFTU19PUEVOKVxuICAgICAgICBkb21FbC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcIlwiKVxuICAgICAgICByZW1vdmVDbGFzcyh0aGlzLl9saXZlQ29udGFpbmVyISwgQ0xBU1NfT1BFTilcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgaWYgKHRoaXMuX2xpdmVGb290ZXIpIHtcbiAgICAgIHRoaXMuX2xpdmVGb290ZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIlxuXG4gICAgICB0aGlzLmFuaW1hdGlvbi5hZGQoe1xuICAgICAgICB0YXJnZXRzOiB0aGlzLl9saXZlRm9vdGVyLFxuICAgICAgICBkdXJhdGlvbjogQU5JTUFUSU9OX0ZPT1RFUl9EVVJBVElPTixcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICBlYXNpbmc6IHRoaXMuZWFzaW5nLmluUXVhZE91dFF1aW50LFxuICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgZG9tRWwgPSBuZXcgRG9tRWxlbWVudCh0aGlzLl9saXZlRm9vdGVyISlcbiAgICAgICAgICBkb21FbC5yZW1vdmVDbGFzcyhDTEFTU19PUEVOKVxuICAgICAgICAgIGRvbUVsLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiXCIpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBjb21wb25lbnQgYW5kIGNsZWFycyBhbGwgcmVmZXJlbmNlcy5cbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fd2luZG93Q2xpY2tIYW5kbGVyKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLl9rZXlkb3duSGFuZGxlcilcblxuICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLl9mb2N1c0hhbmRsZXIpXG4gICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5fYmx1ckhhbmRsZXIpXG5cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLl9yZXNpemVIYW5kbGVyKVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIiwgdGhpcy5fcmVzaXplSGFuZGxlcilcblxuICAgIGlmICh0aGlzLl9idG5DbG9zZSkge1xuICAgICAgdGhpcy5fYnRuQ2xvc2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2Nsb3NlSGFuZGxlcilcbiAgICB9XG5cbiAgICAodGhpcyBhcyBhbnkpLl9pbnB1dCA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fZm9ybSA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fYnRuQ2xvc2UgPSBudWxsO1xuXG4gICAgKHRoaXMgYXMgYW55KS5fZm9jdXNIYW5kbGVyID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9ibHVySGFuZGxlciA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fY2xvc2VIYW5kbGVyID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl93aW5kb3dDbGlja0hhbmRsZXIgPSBudWxsO1xuICAgICh0aGlzIGFzIGFueSkuX2tleWRvd25IYW5kbGVyID0gbnVsbDtcblxuICAgICh0aGlzIGFzIGFueSkuX2xpdmVTdWdnZXN0aW9ucyA9IG51bGw7XG4gICAgKHRoaXMgYXMgYW55KS5fbGl2ZUZvb3RlciA9IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBTZWFyY2hJbnB1dCBpcyBvcGVuL3Zpc2libGUuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IC0gVHJ1ZSBpZiBvcGVuOyBvdGhlcndpc2UgZmFsc2UuXG4gICAqL1xuICBwdWJsaWMgaXNPcGVuKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0NsYXNzKENMQVNTX09QRU4pXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIHNlYXJjaEFuZEluaXRpYWxpemU8SFRNTEVsZW1lbnQ+KFwiLnNlYXJjaC5zZWFyY2hfX2lucHV0XCIsIChlKSA9PiB7XG4gICAgbmV3IFNlYXJjaElucHV0KGUpXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IFNlYXJjaElucHV0XG4iLCJpbXBvcnQgeyBzZWFyY2hBbmRJbml0aWFsaXplIH0gZnJvbSBcIi4uL1V0aWxzXCJcbmltcG9ydCBEb21FbGVtZW50IGZyb20gXCIuLi9Eb21FbGVtZW50XCJcbmltcG9ydCAqIGFzIERvbSBmcm9tIFwiLi4vRG9tRnVuY3Rpb25zXCJcblxuY29uc3QgUVVFUllfSEVBREVSID0gXCJ0aGVhZCB0aFwiXG5cbmNvbnN0IENMQVNTX1NPUlRFRF9BU0NFTkRJTkcgPSBcImpzLWFzY2VuZGluZ1wiXG5jb25zdCBDTEFTU19TT1JURURfREVTQ0VORElORyA9IFwianMtZGVzY2VuZGluZ1wiXG5jb25zdCBDTEFTU19BUlJPVyA9IFwiYXJyb3ctaWNvblwiXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcGFyZXI8VCA9IGFueT4ge1xuICAoaXRlbTE6IFQsIGl0ZW0yOiBUKTogbnVtYmVyXG59XG5cbi8qKlxuICogVGhlIFRhYmxlIGNvbXBvbmVudC4gQWRkcyBhZGRpdGlvbmFsIGNhcGFiaWxpdGllcyB0byBzdGFuZGFyZCBIVE1MIDUgdGFibGVzLlxuICovXG5jbGFzcyBUYWJsZSBleHRlbmRzIERvbUVsZW1lbnQge1xuICBwcml2YXRlIF9oZWFkZXJDbGlja0hhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZFxuICBwcml2YXRlIF9ib2R5OiBIVE1MVGFibGVTZWN0aW9uRWxlbWVudFxuICBwcml2YXRlIF9yb3dzOiBOb2RlTGlzdE9mPEhUTUxUYWJsZVJvd0VsZW1lbnQ+XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIHRhYmxlIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEhUTUxUYWJsZUVsZW1lbnQpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgdGhpcy5faGVhZGVyQ2xpY2tIYW5kbGVyID0gdGhpcy5faGFuZGxlSGVhZGVyQ2xpY2suYmluZCh0aGlzKVxuXG4gICAgdGhpcy5fYm9keSA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwidGJvZHlcIikgYXMgSFRNTFRhYmxlU2VjdGlvbkVsZW1lbnRcbiAgICB0aGlzLl9yb3dzID0gdGhpcy5fYm9keS5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRyXCIpXG5cbiAgICB0aGlzLl9pbml0aWFsaXplKClcbiAgfVxuXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZSgpIHtcbiAgICBmb3IgKGxldCBoZWFkZXIgb2YgdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoUVVFUllfSEVBREVSKSkge1xuICAgICAgaWYgKGhlYWRlci5nZXRBdHRyaWJ1dGUoXCJkYXRhLXR5cGVcIikpIHtcbiAgICAgICAgaGVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9oZWFkZXJDbGlja0hhbmRsZXIpXG5cbiAgICAgICAgbGV0IGFycm93RWxlbWVudCA9IG5ldyBEb21FbGVtZW50KFwiZGl2XCIpXG4gICAgICAgICAgLmFkZENsYXNzKENMQVNTX0FSUk9XKVxuICAgICAgICAgIC5lbGVtZW50XG5cbiAgICAgICAgaGVhZGVyLmFwcGVuZENoaWxkKGFycm93RWxlbWVudClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2hhbmRsZUhlYWRlckNsaWNrKGU6IEV2ZW50KSB7XG4gICAgY29uc3QgdGggPSBlLnRhcmdldCBhcyBIVE1MVGFibGVIZWFkZXJDZWxsRWxlbWVudFxuICAgIHRoaXMuc29ydCh0aClcbiAgfVxuXG4gIC8qKlxuICAgKiBTb3J0cyB0aGUgdGFibGUgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgdGFibGUgaGVhZGVyIGVsZW1lbnQuXG4gICAqIFRoZSBjb2x1bW4gaXMgc29ydGVkIGFzY2VuZGluZyBieSBkZWZhdWx0IGlmIG5vIGRpcmVjdGlvbiBpcyBzcGVjaWZpZWQgYW5kIG5vXG4gICAqIGV4aXN0aW5nIHNvcnQgb3JkZXIgY2xhc3MgaXMgZm91bmQgaW4gdGhlIG1hcmt1cC5cbiAgICpcbiAgICogSWYgdGhlIGRpc3BsYXllZCBkYXRhIGlzIG5vdCBzdWl0YWJsZSBmb3Igc29ydGluZyBgPHRkLz5gIGVsZW1lbnRzIGNhbiBkZWZpbmUgYSBgZGF0YS12YWx1ZWAgYXR0cmlidXRlXG4gICAqIHdoaWNoIGlzIHRoZW4gdXNlZCBmb3IgdGhlIGRhdGEtc291cmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge1RhYmxlSGVhZGVyfSB0YWJsZUhlYWRlciBUaGUgaGVhZGVyIGVsZW1lbnQgb2YgdGhlIHJvdyB0byBzb3J0IGJ5LlxuICAgKiBAcGFyYW0ge051bWJlcn0gZGlyZWN0aW9uIFRoZSBkaXJlY3Rpb24gdG8gc29ydCwgYDFgIGZvciBhc2NlbmRpbmcsIGAtMWAgZm9yIGRlc2NlbmRpbmcgb3JkZXIuIFRoaXMgcGFyYW1ldGVyIGlzIG9wdGlvbmFsLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBlcXVhbGl0eUNvbXBhcmVyIFRoZSBlcXVpYWxpdHkgY29tcGFyZXIgZnVuY3Rpb24gdG8gY29tcGFyZSBpbmRpdmlkdWFsIGNlbGwgdmFsdWVzLlxuICAgKi9cbiAgcHVibGljIHNvcnQoXG4gICAgdGFibGVIZWFkZXI6IEhUTUxUYWJsZUhlYWRlckNlbGxFbGVtZW50LFxuICAgIGRpcmVjdGlvbj86IC0xIHwgMSxcbiAgICBlcXVhbGl0eUNvbXBhcmVyPzogQ29tcGFyZXJcbiAgKSB7XG4gICAgaWYgKCF0YWJsZUhlYWRlciB8fCB0YWJsZUhlYWRlci50YWdOYW1lICE9PSBcIlRIXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBwYXJhbWV0ZXIgJ3RhYmxlSGVhZGVyJyBtdXN0IGJlIGEgdmFsaWQgY29sdW1uIGhlYWRlciBub2RlXCIpXG4gICAgfVxuXG4gICAgaWYgKGRpcmVjdGlvbiAhPT0gMSAmJiBkaXJlY3Rpb24gIT09IC0xICYmIGRpcmVjdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXJhbWV0ZXIgb3V0IG9mIHJhbmdlLCBwYXJhbWV0ZXIgJ2RpcmVjdGlvbicgd2l0aCB2YWx1ZSAnJHtkaXJlY3Rpb259JyBtdXN0IGJlIGVpdGhlciAtMSwgMSBvciB1bmRlZmluZWRgKVxuICAgIH1cblxuICAgIGNvbnN0IGNvbHVtbkluZGV4ID0gdGFibGVIZWFkZXIuY2VsbEluZGV4XG5cbiAgICBpZiAoIWVxdWFsaXR5Q29tcGFyZXIpIHtcbiAgICAgIGxldCBkYXRhVHlwZSA9IHRhYmxlSGVhZGVyLmdldEF0dHJpYnV0ZShcImRhdGEtdHlwZVwiKVxuICAgICAgZXF1YWxpdHlDb21wYXJlciA9IHRoaXMuX2dldENvbXBhcmVyKGRhdGFUeXBlISlcbiAgICB9XG5cbiAgICBpZiAoY29sdW1uSW5kZXggPj0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoUVVFUllfSEVBREVSKS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbHVtbiBvdXQgb2YgcmFuZ2VcIilcbiAgICB9XG5cbiAgICBmb3IgKGxldCBoZWFkZXIgb2YgdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoUVVFUllfSEVBREVSKSkge1xuICAgICAgaWYgKGhlYWRlciAhPT0gdGFibGVIZWFkZXIpIHtcbiAgICAgICAgRG9tLnJlbW92ZUNsYXNzKGhlYWRlciwgQ0xBU1NfU09SVEVEX0FTQ0VORElORylcbiAgICAgICAgRG9tLnJlbW92ZUNsYXNzKGhlYWRlciwgQ0xBU1NfU09SVEVEX0RFU0NFTkRJTkcpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKERvbS5oYXNDbGFzcyh0YWJsZUhlYWRlciwgQ0xBU1NfU09SVEVEX0FTQ0VORElORykpIHtcbiAgICAgIERvbS5yZW1vdmVDbGFzcyh0YWJsZUhlYWRlciwgQ0xBU1NfU09SVEVEX0FTQ0VORElORylcbiAgICAgIERvbS5hZGRDbGFzcyh0YWJsZUhlYWRlciwgQ0xBU1NfU09SVEVEX0RFU0NFTkRJTkcpXG5cbiAgICAgIGRpcmVjdGlvbiA9IGRpcmVjdGlvbiB8fCAtMVxuICAgIH0gZWxzZSB7XG4gICAgICBEb20ucmVtb3ZlQ2xhc3ModGFibGVIZWFkZXIsIENMQVNTX1NPUlRFRF9ERVNDRU5ESU5HKVxuICAgICAgRG9tLmFkZENsYXNzKHRhYmxlSGVhZGVyLCBDTEFTU19TT1JURURfQVNDRU5ESU5HKVxuICAgICAgZGlyZWN0aW9uID0gZGlyZWN0aW9uIHx8IDFcbiAgICB9XG5cbiAgICB0aGlzLl9xdWlja3NvcnQoY29sdW1uSW5kZXgsIDAsIHRoaXMuX3Jvd3MubGVuZ3RoIC0gMSwgZGlyZWN0aW9uLCBlcXVhbGl0eUNvbXBhcmVyKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9nZXRDZWxsKGNvbHVtbjogbnVtYmVyLCByb3c6IG51bWJlcikge1xuICAgIHJldHVybiB0aGlzLl9yb3dzW3Jvd10uY2VsbHNbY29sdW1uXVxuICB9XG5cbiAgcHJvdGVjdGVkIF9nZXRSb3cocm93OiBudW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fcm93c1tyb3ddXG4gIH1cblxuICBwcm90ZWN0ZWQgX2dldENvbXBhcmVyKGRhdGFUeXBlOiBzdHJpbmcpOiBDb21wYXJlcjxzdHJpbmc+IHtcbiAgICBzd2l0Y2ggKGRhdGFUeXBlKSB7XG4gICAgICBjYXNlIFwibnVtYmVyXCI6IHtcbiAgICAgICAgLy8gcGFyc2UgdGhlIHN0cmluZyBhcyBhIG51bWJlclxuICAgICAgICByZXR1cm4gKGEsIGIpID0+IHBhcnNlRmxvYXQoYSkgLSBwYXJzZUZsb2F0KGIpXG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIC8vIGNvbXBhcmUgc3RyaW5nc1xuICAgICAgICByZXR1cm4gKGEsIGIpID0+IHtcbiAgICAgICAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYSA+IGIpIHtcbiAgICAgICAgICAgIHJldHVybiAxXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfcXVpY2tzb3J0KFxuICAgIGNvbHVtbjogbnVtYmVyLFxuICAgIGxlZnQ6IG51bWJlcixcbiAgICByaWdodDogbnVtYmVyLFxuICAgIGRpcmVjdGlvbjogLTEgfCAxID0gMSxcbiAgICBlcXVhbGl0eUNvbXBhcmVyOiBDb21wYXJlcjxzdHJpbmc+XG4gICkge1xuICAgIGlmIChyaWdodCAtIGxlZnQgPiAwKSB7XG5cbiAgICAgIGxldCBwYXJ0aXRpb24gPSB0aGlzLl9wYXJ0aXRpb24oY29sdW1uLCBsZWZ0LCByaWdodCwgZGlyZWN0aW9uLCBlcXVhbGl0eUNvbXBhcmVyKVxuXG4gICAgICBpZiAobGVmdCA8IHBhcnRpdGlvbiAtIDEpIHtcbiAgICAgICAgdGhpcy5fcXVpY2tzb3J0KGNvbHVtbiwgbGVmdCwgcGFydGl0aW9uIC0gMSwgZGlyZWN0aW9uLCBlcXVhbGl0eUNvbXBhcmVyKVxuICAgICAgfVxuXG4gICAgICBpZiAocGFydGl0aW9uIDwgcmlnaHQpIHtcbiAgICAgICAgdGhpcy5fcXVpY2tzb3J0KGNvbHVtbiwgcGFydGl0aW9uLCByaWdodCwgZGlyZWN0aW9uLCBlcXVhbGl0eUNvbXBhcmVyKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfcGFydGl0aW9uKFxuICAgIGNvbHVtbjogbnVtYmVyLFxuICAgIGxlZnQ6IG51bWJlcixcbiAgICByaWdodDogbnVtYmVyLFxuICAgIGRpcmVjdGlvbjogLTEgfCAxID0gMSxcbiAgICBlcXVhbGl0eUNvbXBhcmVyOiBDb21wYXJlcjxzdHJpbmc+XG4gICkge1xuICAgIGxldCBwaXZvdCA9IHRoaXMuX2dldENlbGwoY29sdW1uLCBNYXRoLmZsb29yKChyaWdodCArIGxlZnQpIC8gMikpXG4gICAgbGV0IGkgPSBsZWZ0XG4gICAgbGV0IGogPSByaWdodFxuXG4gICAgd2hpbGUgKGkgPD0gaikge1xuICAgICAgd2hpbGUgKHRoaXMuX2VxdWFscyh0aGlzLl9nZXRDZWxsKGNvbHVtbiwgaSksIHBpdm90LCBlcXVhbGl0eUNvbXBhcmVyKSAqIGRpcmVjdGlvbiA8IDApIHtcbiAgICAgICAgaSsrXG4gICAgICB9XG5cbiAgICAgIHdoaWxlICh0aGlzLl9lcXVhbHModGhpcy5fZ2V0Q2VsbChjb2x1bW4sIGopLCBwaXZvdCwgZXF1YWxpdHlDb21wYXJlcikgKiBkaXJlY3Rpb24gPiAwKSB7XG4gICAgICAgIGotLVxuICAgICAgfVxuXG4gICAgICBpZiAoaSA8PSBqKSB7XG4gICAgICAgIHRoaXMuX3N3YXAoaSwgailcbiAgICAgICAgaSsrXG4gICAgICAgIGotLVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpXG4gIH1cblxuICBwcm90ZWN0ZWQgX2VxdWFscyhcbiAgICBhOiBIVE1MRWxlbWVudCxcbiAgICBiOiBIVE1MRWxlbWVudCxcbiAgICBlcXVhbGl0eUNvbXBhcmVyOiBDb21wYXJlcjxzdHJpbmc+XG4gICkge1xuICAgIGxldCBkYXRhQSA9IGEuZ2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiKVxuICAgIGxldCBkYXRhQiA9IGIuZ2V0QXR0cmlidXRlKFwiZGF0YS12YWx1ZVwiKVxuXG4gICAgZGF0YUEgPSBkYXRhQSB8fCBhLnRleHRDb250ZW50IHx8IGEuaW5uZXJUZXh0XG4gICAgZGF0YUIgPSBkYXRhQiB8fCBiLnRleHRDb250ZW50IHx8IGIuaW5uZXJUZXh0XG5cbiAgICByZXR1cm4gZXF1YWxpdHlDb21wYXJlcihkYXRhQSwgZGF0YUIpXG4gIH1cblxuICBwcm90ZWN0ZWQgX3N3YXAoaTogbnVtYmVyLCBqOiBudW1iZXIpIHtcbiAgICBsZXQgdG1wTm9kZSA9IHRoaXMuX2JvZHkucmVwbGFjZUNoaWxkKHRoaXMuX2dldFJvdyhpKSwgdGhpcy5fZ2V0Um93KGopKVxuICAgIGNvbnN0IHJlZmVyZW5jZVJvdyA9IHRoaXMuX2dldFJvdyhpKVxuXG4gICAgaWYgKCFyZWZlcmVuY2VSb3cpIHtcbiAgICAgIHRoaXMuX2JvZHkuYXBwZW5kQ2hpbGQodG1wTm9kZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYm9keS5pbnNlcnRCZWZvcmUodG1wTm9kZSwgcmVmZXJlbmNlUm93KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgY29tcG9uZW50IGFuZCBjbGVhcnMgYWxsIHJlZmVyZW5jZXMuXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICBmb3IgKGxldCBoZWFkZXIgb2YgdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoUVVFUllfSEVBREVSKSkge1xuICAgICAgaGVhZGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9oZWFkZXJDbGlja0hhbmRsZXIpXG4gICAgfVxuXG4gICAgKHRoaXMgYXMgYW55KS5faGVhZGVyQ2xpY2tIYW5kbGVyID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9ib2R5ID0gbnVsbDtcbiAgICAodGhpcyBhcyBhbnkpLl9yb3dzID0gbnVsbFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0KCkge1xuICBzZWFyY2hBbmRJbml0aWFsaXplKFwidGFibGVcIiwgKGUpID0+IHtcbiAgICBuZXcgVGFibGUoZSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgVGFibGVcbiIsImltcG9ydCBhbmltZSBmcm9tIFwiYW5pbWVqc1wiXG5pbXBvcnQgRG9tRWxlbWVudCBmcm9tIFwiLi4vRG9tRWxlbWVudFwiXG5cbmNvbnN0IENMQVNTX0lURU1TID0gXCIudG9vbGJhcl9faXRlbVwiXG5jb25zdCBDTEFTU19TSE9XID0gXCJpdGVtLS1zaG93XCJcblxuY29uc3QgQU5JTUFUSU9OX1NUQVJUX0RFTEFZID0gMTAwXG5jb25zdCBBTklNQVRJT05fT0ZGU0VUID0gNTBcblxuLyoqXG4gKiBUb29sYmFyIGNvbXBvbmVudC4gVXNlIHRoaXMgY29tcG9uZW50IHRvIHNob3cgYW5kIGhpZGUgdGhlXG4gKiBpbmRpdmlkdWFsIHRvb2xiYXIgaXRlbXMuXG4gKi9cbmNsYXNzIFRvb2xiYXIgZXh0ZW5kcyBEb21FbGVtZW50IHtcblxuICAvKipcbiAgICogTWFrZXMgdGhlIHRvb2xiYXIgaXRlbXMgdmlzaWJsZS5cbiAgICovXG4gIHB1YmxpYyBzaG93KCkge1xuICAgIGxldCBkZWxheSA9IEFOSU1BVElPTl9TVEFSVF9ERUxBWVxuICAgIGxldCBpdGVtcyA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKENMQVNTX0lURU1TKVxuXG4gICAgbGV0IHRpbWVsaW5lID0gYW5pbWUudGltZWxpbmUoKVxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBpdGVtcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHRpbWVsaW5lLmFkZCh7XG4gICAgICAgIHRhcmdldHM6IGl0ZW1zW2luZGV4XSxcbiAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgIG9mZnNldDogZGVsYXksXG4gICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgaXRlbXNbaW5kZXhdLmNsYXNzTGlzdC5hZGQoQ0xBU1NfU0hPVylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIGRlbGF5ICs9IEFOSU1BVElPTl9PRkZTRVRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGlkZXMgdGhlIHRvb2xiYXIgaXRlbXMuXG4gICAqL1xuICBwdWJsaWMgaGlkZSgpIHtcbiAgICBsZXQgZGVsYXkgPSBBTklNQVRJT05fU1RBUlRfREVMQVlcbiAgICBsZXQgaXRlbXMgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChDTEFTU19JVEVNUylcblxuICAgIGxldCB0aW1lbGluZSA9IGFuaW1lLnRpbWVsaW5lKClcbiAgICBmb3IgKGxldCBpbmRleCA9IGl0ZW1zLmxlbmd0aCAtIDE7IGluZGV4ID49IDA7IGluZGV4LS0pIHtcbiAgICAgIHRpbWVsaW5lLmFkZCh7XG4gICAgICAgIHRhcmdldHM6IGl0ZW1zW2luZGV4XSxcbiAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgIG9mZnNldDogZGVsYXksXG4gICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgaXRlbXNbaW5kZXhdLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfU0hPVylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIGRlbGF5ICs9IEFOSU1BVElPTl9PRkZTRVRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgdG9vbGJhciBpdGVtcyB2aXNpYmlsaXR5LlxuICAgKi9cbiAgcHVibGljIHRvZ2dsZSgpIHtcbiAgICBpZiAodGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke0NMQVNTX1NIT1d9YCkubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnNob3coKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhpZGUoKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUb29sYmFyXG4iLCIvKiFcbiAqIG1vZGVybml6ciB2My42LjBcbiAqIEJ1aWxkIGh0dHBzOi8vbW9kZXJuaXpyLmNvbS9kb3dubG9hZD8taGlkZGVuc2Nyb2xsLXRvdWNoZXZlbnRzLXNldGNsYXNzZXMtZG9udG1pblxuICpcbiAqIENvcHlyaWdodCAoYylcbiAqICBGYXJ1ayBBdGVzXG4gKiAgUGF1bCBJcmlzaFxuICogIEFsZXggU2V4dG9uXG4gKiAgUnlhbiBTZWRkb25cbiAqICBQYXRyaWNrIEtldHRuZXJcbiAqICBTdHUgQ294XG4gKiAgUmljaGFyZCBIZXJyZXJhXG5cbiAqIE1JVCBMaWNlbnNlXG4gKi9cblxuLypcbiAqIE1vZGVybml6ciB0ZXN0cyB3aGljaCBuYXRpdmUgQ1NTMyBhbmQgSFRNTDUgZmVhdHVyZXMgYXJlIGF2YWlsYWJsZSBpbiB0aGVcbiAqIGN1cnJlbnQgVUEgYW5kIG1ha2VzIHRoZSByZXN1bHRzIGF2YWlsYWJsZSB0byB5b3UgaW4gdHdvIHdheXM6IGFzIHByb3BlcnRpZXMgb25cbiAqIGEgZ2xvYmFsIGBNb2Rlcm5penJgIG9iamVjdCwgYW5kIGFzIGNsYXNzZXMgb24gdGhlIGA8aHRtbD5gIGVsZW1lbnQuIFRoaXNcbiAqIGluZm9ybWF0aW9uIGFsbG93cyB5b3UgdG8gcHJvZ3Jlc3NpdmVseSBlbmhhbmNlIHlvdXIgcGFnZXMgd2l0aCBhIGdyYW51bGFyIGxldmVsXG4gKiBvZiBjb250cm9sIG92ZXIgdGhlIGV4cGVyaWVuY2UuXG4qL1xuXG47KGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCl7XG4gIHZhciB0ZXN0cyA9IFtdO1xuICBcblxuICAvKipcbiAgICpcbiAgICogTW9kZXJuaXpyUHJvdG8gaXMgdGhlIGNvbnN0cnVjdG9yIGZvciBNb2Rlcm5penJcbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBhY2Nlc3MgcHVibGljXG4gICAqL1xuXG4gIHZhciBNb2Rlcm5penJQcm90byA9IHtcbiAgICAvLyBUaGUgY3VycmVudCB2ZXJzaW9uLCBkdW1teVxuICAgIF92ZXJzaW9uOiAnMy42LjAnLFxuXG4gICAgLy8gQW55IHNldHRpbmdzIHRoYXQgZG9uJ3Qgd29yayBhcyBzZXBhcmF0ZSBtb2R1bGVzXG4gICAgLy8gY2FuIGdvIGluIGhlcmUgYXMgY29uZmlndXJhdGlvbi5cbiAgICBfY29uZmlnOiB7XG4gICAgICAnY2xhc3NQcmVmaXgnOiAnJyxcbiAgICAgICdlbmFibGVDbGFzc2VzJzogdHJ1ZSxcbiAgICAgICdlbmFibGVKU0NsYXNzJzogdHJ1ZSxcbiAgICAgICd1c2VQcmVmaXhlcyc6IHRydWVcbiAgICB9LFxuXG4gICAgLy8gUXVldWUgb2YgdGVzdHNcbiAgICBfcTogW10sXG5cbiAgICAvLyBTdHViIHRoZXNlIGZvciBwZW9wbGUgd2hvIGFyZSBsaXN0ZW5pbmdcbiAgICBvbjogZnVuY3Rpb24odGVzdCwgY2IpIHtcbiAgICAgIC8vIEkgZG9uJ3QgcmVhbGx5IHRoaW5rIHBlb3BsZSBzaG91bGQgZG8gdGhpcywgYnV0IHdlIGNhblxuICAgICAgLy8gc2FmZSBndWFyZCBpdCBhIGJpdC5cbiAgICAgIC8vIC0tIE5PVEU6OiB0aGlzIGdldHMgV0FZIG92ZXJyaWRkZW4gaW4gc3JjL2FkZFRlc3QgZm9yIGFjdHVhbCBhc3luYyB0ZXN0cy5cbiAgICAgIC8vIFRoaXMgaXMgaW4gY2FzZSBwZW9wbGUgbGlzdGVuIHRvIHN5bmNocm9ub3VzIHRlc3RzLiBJIHdvdWxkIGxlYXZlIGl0IG91dCxcbiAgICAgIC8vIGJ1dCB0aGUgY29kZSB0byAqZGlzYWxsb3cqIHN5bmMgdGVzdHMgaW4gdGhlIHJlYWwgdmVyc2lvbiBvZiB0aGlzXG4gICAgICAvLyBmdW5jdGlvbiBpcyBhY3R1YWxseSBsYXJnZXIgdGhhbiB0aGlzLlxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgY2Ioc2VsZlt0ZXN0XSk7XG4gICAgICB9LCAwKTtcbiAgICB9LFxuXG4gICAgYWRkVGVzdDogZnVuY3Rpb24obmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgICAgIHRlc3RzLnB1c2goe25hbWU6IG5hbWUsIGZuOiBmbiwgb3B0aW9uczogb3B0aW9uc30pO1xuICAgIH0sXG5cbiAgICBhZGRBc3luY1Rlc3Q6IGZ1bmN0aW9uKGZuKSB7XG4gICAgICB0ZXN0cy5wdXNoKHtuYW1lOiBudWxsLCBmbjogZm59KTtcbiAgICB9XG4gIH07XG5cbiAgXG5cbiAgLy8gRmFrZSBzb21lIG9mIE9iamVjdC5jcmVhdGUgc28gd2UgY2FuIGZvcmNlIG5vbiB0ZXN0IHJlc3VsdHMgdG8gYmUgbm9uIFwib3duXCIgcHJvcGVydGllcy5cbiAgdmFyIE1vZGVybml6ciA9IGZ1bmN0aW9uKCkge307XG4gIE1vZGVybml6ci5wcm90b3R5cGUgPSBNb2Rlcm5penJQcm90bztcblxuICAvLyBMZWFrIG1vZGVybml6ciBnbG9iYWxseSB3aGVuIHlvdSBgcmVxdWlyZWAgaXQgcmF0aGVyIHRoYW4gZm9yY2UgaXQgaGVyZS5cbiAgLy8gT3ZlcndyaXRlIG5hbWUgc28gY29uc3RydWN0b3IgbmFtZSBpcyBuaWNlciA6RFxuICBNb2Rlcm5penIgPSBuZXcgTW9kZXJuaXpyKCk7XG5cbiAgXG5cbiAgdmFyIGNsYXNzZXMgPSBbXTtcbiAgXG5cbiAgLyoqXG4gICAqIGlzIHJldHVybnMgYSBib29sZWFuIGlmIHRoZSB0eXBlb2YgYW4gb2JqIGlzIGV4YWN0bHkgdHlwZS5cbiAgICpcbiAgICogQGFjY2VzcyBwcml2YXRlXG4gICAqIEBmdW5jdGlvbiBpc1xuICAgKiBAcGFyYW0geyp9IG9iaiAtIEEgdGhpbmcgd2Ugd2FudCB0byBjaGVjayB0aGUgdHlwZSBvZlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIEEgc3RyaW5nIHRvIGNvbXBhcmUgdGhlIHR5cGVvZiBhZ2FpbnN0XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cblxuICBmdW5jdGlvbiBpcyhvYmosIHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gdHlwZTtcbiAgfVxuICA7XG5cbiAgLyoqXG4gICAqIFJ1biB0aHJvdWdoIGFsbCB0ZXN0cyBhbmQgZGV0ZWN0IHRoZWlyIHN1cHBvcnQgaW4gdGhlIGN1cnJlbnQgVUEuXG4gICAqXG4gICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgKi9cblxuICBmdW5jdGlvbiB0ZXN0UnVubmVyKCkge1xuICAgIHZhciBmZWF0dXJlTmFtZXM7XG4gICAgdmFyIGZlYXR1cmU7XG4gICAgdmFyIGFsaWFzSWR4O1xuICAgIHZhciByZXN1bHQ7XG4gICAgdmFyIG5hbWVJZHg7XG4gICAgdmFyIGZlYXR1cmVOYW1lO1xuICAgIHZhciBmZWF0dXJlTmFtZVNwbGl0O1xuXG4gICAgZm9yICh2YXIgZmVhdHVyZUlkeCBpbiB0ZXN0cykge1xuICAgICAgaWYgKHRlc3RzLmhhc093blByb3BlcnR5KGZlYXR1cmVJZHgpKSB7XG4gICAgICAgIGZlYXR1cmVOYW1lcyA9IFtdO1xuICAgICAgICBmZWF0dXJlID0gdGVzdHNbZmVhdHVyZUlkeF07XG4gICAgICAgIC8vIHJ1biB0aGUgdGVzdCwgdGhyb3cgdGhlIHJldHVybiB2YWx1ZSBpbnRvIHRoZSBNb2Rlcm5penIsXG4gICAgICAgIC8vIHRoZW4gYmFzZWQgb24gdGhhdCBib29sZWFuLCBkZWZpbmUgYW4gYXBwcm9wcmlhdGUgY2xhc3NOYW1lXG4gICAgICAgIC8vIGFuZCBwdXNoIGl0IGludG8gYW4gYXJyYXkgb2YgY2xhc3NlcyB3ZSdsbCBqb2luIGxhdGVyLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBuYW1lLCBpdCdzIGFuICdhc3luYycgdGVzdCB0aGF0IGlzIHJ1bixcbiAgICAgICAgLy8gYnV0IG5vdCBkaXJlY3RseSBhZGRlZCB0byB0aGUgb2JqZWN0LiBUaGF0IHNob3VsZFxuICAgICAgICAvLyBiZSBkb25lIHdpdGggYSBwb3N0LXJ1biBhZGRUZXN0IGNhbGwuXG4gICAgICAgIGlmIChmZWF0dXJlLm5hbWUpIHtcbiAgICAgICAgICBmZWF0dXJlTmFtZXMucHVzaChmZWF0dXJlLm5hbWUudG9Mb3dlckNhc2UoKSk7XG5cbiAgICAgICAgICBpZiAoZmVhdHVyZS5vcHRpb25zICYmIGZlYXR1cmUub3B0aW9ucy5hbGlhc2VzICYmIGZlYXR1cmUub3B0aW9ucy5hbGlhc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gQWRkIGFsbCB0aGUgYWxpYXNlcyBpbnRvIHRoZSBuYW1lcyBsaXN0XG4gICAgICAgICAgICBmb3IgKGFsaWFzSWR4ID0gMDsgYWxpYXNJZHggPCBmZWF0dXJlLm9wdGlvbnMuYWxpYXNlcy5sZW5ndGg7IGFsaWFzSWR4KyspIHtcbiAgICAgICAgICAgICAgZmVhdHVyZU5hbWVzLnB1c2goZmVhdHVyZS5vcHRpb25zLmFsaWFzZXNbYWxpYXNJZHhdLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJ1biB0aGUgdGVzdCwgb3IgdXNlIHRoZSByYXcgdmFsdWUgaWYgaXQncyBub3QgYSBmdW5jdGlvblxuICAgICAgICByZXN1bHQgPSBpcyhmZWF0dXJlLmZuLCAnZnVuY3Rpb24nKSA/IGZlYXR1cmUuZm4oKSA6IGZlYXR1cmUuZm47XG5cblxuICAgICAgICAvLyBTZXQgZWFjaCBvZiB0aGUgbmFtZXMgb24gdGhlIE1vZGVybml6ciBvYmplY3RcbiAgICAgICAgZm9yIChuYW1lSWR4ID0gMDsgbmFtZUlkeCA8IGZlYXR1cmVOYW1lcy5sZW5ndGg7IG5hbWVJZHgrKykge1xuICAgICAgICAgIGZlYXR1cmVOYW1lID0gZmVhdHVyZU5hbWVzW25hbWVJZHhdO1xuICAgICAgICAgIC8vIFN1cHBvcnQgZG90IHByb3BlcnRpZXMgYXMgc3ViIHRlc3RzLiBXZSBkb24ndCBkbyBjaGVja2luZyB0byBtYWtlIHN1cmVcbiAgICAgICAgICAvLyB0aGF0IHRoZSBpbXBsaWVkIHBhcmVudCB0ZXN0cyBoYXZlIGJlZW4gYWRkZWQuIFlvdSBtdXN0IGNhbGwgdGhlbSBpblxuICAgICAgICAgIC8vIG9yZGVyIChlaXRoZXIgaW4gdGhlIHRlc3QsIG9yIG1ha2UgdGhlIHBhcmVudCB0ZXN0IGEgZGVwZW5kZW5jeSkuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBDYXAgaXQgdG8gVFdPIHRvIG1ha2UgdGhlIGxvZ2ljIHNpbXBsZSBhbmQgYmVjYXVzZSB3aG8gbmVlZHMgdGhhdCBraW5kIG9mIHN1YnRlc3RpbmdcbiAgICAgICAgICAvLyBoYXNodGFnIGZhbW91cyBsYXN0IHdvcmRzXG4gICAgICAgICAgZmVhdHVyZU5hbWVTcGxpdCA9IGZlYXR1cmVOYW1lLnNwbGl0KCcuJyk7XG5cbiAgICAgICAgICBpZiAoZmVhdHVyZU5hbWVTcGxpdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIE1vZGVybml6cltmZWF0dXJlTmFtZVNwbGl0WzBdXSA9IHJlc3VsdDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY2FzdCB0byBhIEJvb2xlYW4sIGlmIG5vdCBvbmUgYWxyZWFkeVxuICAgICAgICAgICAgaWYgKE1vZGVybml6cltmZWF0dXJlTmFtZVNwbGl0WzBdXSAmJiAhKE1vZGVybml6cltmZWF0dXJlTmFtZVNwbGl0WzBdXSBpbnN0YW5jZW9mIEJvb2xlYW4pKSB7XG4gICAgICAgICAgICAgIE1vZGVybml6cltmZWF0dXJlTmFtZVNwbGl0WzBdXSA9IG5ldyBCb29sZWFuKE1vZGVybml6cltmZWF0dXJlTmFtZVNwbGl0WzBdXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE1vZGVybml6cltmZWF0dXJlTmFtZVNwbGl0WzBdXVtmZWF0dXJlTmFtZVNwbGl0WzFdXSA9IHJlc3VsdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjbGFzc2VzLnB1c2goKHJlc3VsdCA/ICcnIDogJ25vLScpICsgZmVhdHVyZU5hbWVTcGxpdC5qb2luKCctJykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIDtcblxuICAvKipcbiAgICogZG9jRWxlbWVudCBpcyBhIGNvbnZlbmllbmNlIHdyYXBwZXIgdG8gZ3JhYiB0aGUgcm9vdCBlbGVtZW50IG9mIHRoZSBkb2N1bWVudFxuICAgKlxuICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fFNWR0VsZW1lbnR9IFRoZSByb290IGVsZW1lbnQgb2YgdGhlIGRvY3VtZW50XG4gICAqL1xuXG4gIHZhciBkb2NFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICBcblxuICAvKipcbiAgICogQSBjb252ZW5pZW5jZSBoZWxwZXIgdG8gY2hlY2sgaWYgdGhlIGRvY3VtZW50IHdlIGFyZSBydW5uaW5nIGluIGlzIGFuIFNWRyBkb2N1bWVudFxuICAgKlxuICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuXG4gIHZhciBpc1NWRyA9IGRvY0VsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3N2Zyc7XG4gIFxuXG4gIC8qKlxuICAgKiBzZXRDbGFzc2VzIHRha2VzIGFuIGFycmF5IG9mIGNsYXNzIG5hbWVzIGFuZCBhZGRzIHRoZW0gdG8gdGhlIHJvb3QgZWxlbWVudFxuICAgKlxuICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICogQGZ1bmN0aW9uIHNldENsYXNzZXNcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gY2xhc3NlcyAtIEFycmF5IG9mIGNsYXNzIG5hbWVzXG4gICAqL1xuXG4gIC8vIFBhc3MgaW4gYW4gYW5kIGFycmF5IG9mIGNsYXNzIG5hbWVzLCBlLmcuOlxuICAvLyAgWyduby13ZWJwJywgJ2JvcmRlcnJhZGl1cycsIC4uLl1cbiAgZnVuY3Rpb24gc2V0Q2xhc3NlcyhjbGFzc2VzKSB7XG4gICAgdmFyIGNsYXNzTmFtZSA9IGRvY0VsZW1lbnQuY2xhc3NOYW1lO1xuICAgIHZhciBjbGFzc1ByZWZpeCA9IE1vZGVybml6ci5fY29uZmlnLmNsYXNzUHJlZml4IHx8ICcnO1xuXG4gICAgaWYgKGlzU1ZHKSB7XG4gICAgICBjbGFzc05hbWUgPSBjbGFzc05hbWUuYmFzZVZhbDtcbiAgICB9XG5cbiAgICAvLyBDaGFuZ2UgYG5vLWpzYCB0byBganNgIChpbmRlcGVuZGVudGx5IG9mIHRoZSBgZW5hYmxlQ2xhc3Nlc2Agb3B0aW9uKVxuICAgIC8vIEhhbmRsZSBjbGFzc1ByZWZpeCBvbiB0aGlzIHRvb1xuICAgIGlmIChNb2Rlcm5penIuX2NvbmZpZy5lbmFibGVKU0NsYXNzKSB7XG4gICAgICB2YXIgcmVKUyA9IG5ldyBSZWdFeHAoJyhefFxcXFxzKScgKyBjbGFzc1ByZWZpeCArICduby1qcyhcXFxcc3wkKScpO1xuICAgICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lLnJlcGxhY2UocmVKUywgJyQxJyArIGNsYXNzUHJlZml4ICsgJ2pzJDInKTtcbiAgICB9XG5cbiAgICBpZiAoTW9kZXJuaXpyLl9jb25maWcuZW5hYmxlQ2xhc3Nlcykge1xuICAgICAgLy8gQWRkIHRoZSBuZXcgY2xhc3Nlc1xuICAgICAgY2xhc3NOYW1lICs9ICcgJyArIGNsYXNzUHJlZml4ICsgY2xhc3Nlcy5qb2luKCcgJyArIGNsYXNzUHJlZml4KTtcbiAgICAgIGlmIChpc1NWRykge1xuICAgICAgICBkb2NFbGVtZW50LmNsYXNzTmFtZS5iYXNlVmFsID0gY2xhc3NOYW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9jRWxlbWVudC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICA7XG5cbiAgLyoqXG4gICAqIGNyZWF0ZUVsZW1lbnQgaXMgYSBjb252ZW5pZW5jZSB3cmFwcGVyIGFyb3VuZCBkb2N1bWVudC5jcmVhdGVFbGVtZW50LiBTaW5jZSB3ZVxuICAgKiB1c2UgY3JlYXRlRWxlbWVudCBhbGwgb3ZlciB0aGUgcGxhY2UsIHRoaXMgYWxsb3dzIGZvciAoc2xpZ2h0bHkpIHNtYWxsZXIgY29kZVxuICAgKiBhcyB3ZWxsIGFzIGFic3RyYWN0aW5nIGF3YXkgaXNzdWVzIHdpdGggY3JlYXRpbmcgZWxlbWVudHMgaW4gY29udGV4dHMgb3RoZXIgdGhhblxuICAgKiBIVE1MIGRvY3VtZW50cyAoZS5nLiBTVkcgZG9jdW1lbnRzKS5cbiAgICpcbiAgICogQGFjY2VzcyBwcml2YXRlXG4gICAqIEBmdW5jdGlvbiBjcmVhdGVFbGVtZW50XG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudHxTVkdFbGVtZW50fSBBbiBIVE1MIG9yIFNWRyBlbGVtZW50XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQoKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBjYXNlIGluIElFNywgd2hlcmUgdGhlIHR5cGUgb2YgY3JlYXRlRWxlbWVudCBpcyBcIm9iamVjdFwiLlxuICAgICAgLy8gRm9yIHRoaXMgcmVhc29uLCB3ZSBjYW5ub3QgY2FsbCBhcHBseSgpIGFzIE9iamVjdCBpcyBub3QgYSBGdW5jdGlvbi5cbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGFyZ3VtZW50c1swXSk7XG4gICAgfSBlbHNlIGlmIChpc1NWRykge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUy5jYWxsKGRvY3VtZW50LCAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBhcmd1bWVudHNbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudC5hcHBseShkb2N1bWVudCwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICA7XG5cbiAgLyoqXG4gICAqIGdldEJvZHkgcmV0dXJucyB0aGUgYm9keSBvZiBhIGRvY3VtZW50LCBvciBhbiBlbGVtZW50IHRoYXQgY2FuIHN0YW5kIGluIGZvclxuICAgKiB0aGUgYm9keSBpZiBhIHJlYWwgYm9keSBkb2VzIG5vdCBleGlzdFxuICAgKlxuICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICogQGZ1bmN0aW9uIGdldEJvZHlcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fFNWR0VsZW1lbnR9IFJldHVybnMgdGhlIHJlYWwgYm9keSBvZiBhIGRvY3VtZW50LCBvciBhblxuICAgKiBhcnRpZmljaWFsbHkgY3JlYXRlZCBlbGVtZW50IHRoYXQgc3RhbmRzIGluIGZvciB0aGUgYm9keVxuICAgKi9cblxuICBmdW5jdGlvbiBnZXRCb2R5KCkge1xuICAgIC8vIEFmdGVyIHBhZ2UgbG9hZCBpbmplY3RpbmcgYSBmYWtlIGJvZHkgZG9lc24ndCB3b3JrIHNvIGNoZWNrIGlmIGJvZHkgZXhpc3RzXG4gICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuXG4gICAgaWYgKCFib2R5KSB7XG4gICAgICAvLyBDYW4ndCB1c2UgdGhlIHJlYWwgYm9keSBjcmVhdGUgYSBmYWtlIG9uZS5cbiAgICAgIGJvZHkgPSBjcmVhdGVFbGVtZW50KGlzU1ZHID8gJ3N2ZycgOiAnYm9keScpO1xuICAgICAgYm9keS5mYWtlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYm9keTtcbiAgfVxuXG4gIDtcblxuICAvKipcbiAgICogaW5qZWN0RWxlbWVudFdpdGhTdHlsZXMgaW5qZWN0cyBhbiBlbGVtZW50IHdpdGggc3R5bGUgZWxlbWVudCBhbmQgc29tZSBDU1MgcnVsZXNcbiAgICpcbiAgICogQGFjY2VzcyBwcml2YXRlXG4gICAqIEBmdW5jdGlvbiBpbmplY3RFbGVtZW50V2l0aFN0eWxlc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcnVsZSAtIFN0cmluZyByZXByZXNlbnRpbmcgYSBjc3MgcnVsZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIEEgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIHRlc3QgdGhlIGluamVjdGVkIGVsZW1lbnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtub2Rlc10gLSBBbiBpbnRlZ2VyIHJlcHJlc2VudGluZyB0aGUgbnVtYmVyIG9mIGFkZGl0aW9uYWwgbm9kZXMgeW91IHdhbnQgaW5qZWN0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gW3Rlc3RuYW1lc10gLSBBbiBhcnJheSBvZiBzdHJpbmdzIHRoYXQgYXJlIHVzZWQgYXMgaWRzIGZvciB0aGUgYWRkaXRpb25hbCBub2Rlc1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG5cbiAgZnVuY3Rpb24gaW5qZWN0RWxlbWVudFdpdGhTdHlsZXMocnVsZSwgY2FsbGJhY2ssIG5vZGVzLCB0ZXN0bmFtZXMpIHtcbiAgICB2YXIgbW9kID0gJ21vZGVybml6cic7XG4gICAgdmFyIHN0eWxlO1xuICAgIHZhciByZXQ7XG4gICAgdmFyIG5vZGU7XG4gICAgdmFyIGRvY092ZXJmbG93O1xuICAgIHZhciBkaXYgPSBjcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB2YXIgYm9keSA9IGdldEJvZHkoKTtcblxuICAgIGlmIChwYXJzZUludChub2RlcywgMTApKSB7XG4gICAgICAvLyBJbiBvcmRlciBub3QgdG8gZ2l2ZSBmYWxzZSBwb3NpdGl2ZXMgd2UgY3JlYXRlIGEgbm9kZSBmb3IgZWFjaCB0ZXN0XG4gICAgICAvLyBUaGlzIGFsc28gYWxsb3dzIHRoZSBtZXRob2QgdG8gc2NhbGUgZm9yIHVuc3BlY2lmaWVkIHVzZXNcbiAgICAgIHdoaWxlIChub2Rlcy0tKSB7XG4gICAgICAgIG5vZGUgPSBjcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbm9kZS5pZCA9IHRlc3RuYW1lcyA/IHRlc3RuYW1lc1tub2Rlc10gOiBtb2QgKyAobm9kZXMgKyAxKTtcbiAgICAgICAgZGl2LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0eWxlID0gY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBzdHlsZS50eXBlID0gJ3RleHQvY3NzJztcbiAgICBzdHlsZS5pZCA9ICdzJyArIG1vZDtcblxuICAgIC8vIElFNiB3aWxsIGZhbHNlIHBvc2l0aXZlIG9uIHNvbWUgdGVzdHMgZHVlIHRvIHRoZSBzdHlsZSBlbGVtZW50IGluc2lkZSB0aGUgdGVzdCBkaXYgc29tZWhvdyBpbnRlcmZlcmluZyBvZmZzZXRIZWlnaHQsIHNvIGluc2VydCBpdCBpbnRvIGJvZHkgb3IgZmFrZWJvZHkuXG4gICAgLy8gT3BlcmEgd2lsbCBhY3QgYWxsIHF1aXJreSB3aGVuIGluamVjdGluZyBlbGVtZW50cyBpbiBkb2N1bWVudEVsZW1lbnQgd2hlbiBwYWdlIGlzIHNlcnZlZCBhcyB4bWwsIG5lZWRzIGZha2Vib2R5IHRvby4gIzI3MFxuICAgICghYm9keS5mYWtlID8gZGl2IDogYm9keSkuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIGJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcblxuICAgIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBydWxlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShydWxlKSk7XG4gICAgfVxuICAgIGRpdi5pZCA9IG1vZDtcblxuICAgIGlmIChib2R5LmZha2UpIHtcbiAgICAgIC8vYXZvaWQgY3Jhc2hpbmcgSUU4LCBpZiBiYWNrZ3JvdW5kIGltYWdlIGlzIHVzZWRcbiAgICAgIGJvZHkuc3R5bGUuYmFja2dyb3VuZCA9ICcnO1xuICAgICAgLy9TYWZhcmkgNS4xMy81LjEuNCBPU1ggc3RvcHMgbG9hZGluZyBpZiA6Oi13ZWJraXQtc2Nyb2xsYmFyIGlzIHVzZWQgYW5kIHNjcm9sbGJhcnMgYXJlIHZpc2libGVcbiAgICAgIGJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgIGRvY092ZXJmbG93ID0gZG9jRWxlbWVudC5zdHlsZS5vdmVyZmxvdztcbiAgICAgIGRvY0VsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgIGRvY0VsZW1lbnQuYXBwZW5kQ2hpbGQoYm9keSk7XG4gICAgfVxuXG4gICAgcmV0ID0gY2FsbGJhY2soZGl2LCBydWxlKTtcbiAgICAvLyBJZiB0aGlzIGlzIGRvbmUgYWZ0ZXIgcGFnZSBsb2FkIHdlIGRvbid0IHdhbnQgdG8gcmVtb3ZlIHRoZSBib2R5IHNvIGNoZWNrIGlmIGJvZHkgZXhpc3RzXG4gICAgaWYgKGJvZHkuZmFrZSkge1xuICAgICAgYm9keS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGJvZHkpO1xuICAgICAgZG9jRWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9IGRvY092ZXJmbG93O1xuICAgICAgLy8gVHJpZ2dlciBsYXlvdXQgc28ga2luZXRpYyBzY3JvbGxpbmcgaXNuJ3QgZGlzYWJsZWQgaW4gaU9TNitcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgZG9jRWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRpdik7XG4gICAgfVxuXG4gICAgcmV0dXJuICEhcmV0O1xuXG4gIH1cblxuICA7XG5cbiAgLyoqXG4gICAqIHRlc3RTdHlsZXMgaW5qZWN0cyBhbiBlbGVtZW50IHdpdGggc3R5bGUgZWxlbWVudCBhbmQgc29tZSBDU1MgcnVsZXNcbiAgICpcbiAgICogQG1lbWJlcm9mIE1vZGVybml6clxuICAgKiBAbmFtZSBNb2Rlcm5penIudGVzdFN0eWxlc1xuICAgKiBAb3B0aW9uTmFtZSBNb2Rlcm5penIudGVzdFN0eWxlcygpXG4gICAqIEBvcHRpb25Qcm9wIHRlc3RTdHlsZXNcbiAgICogQGFjY2VzcyBwdWJsaWNcbiAgICogQGZ1bmN0aW9uIHRlc3RTdHlsZXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJ1bGUgLSBTdHJpbmcgcmVwcmVzZW50aW5nIGEgY3NzIHJ1bGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBBIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byB0ZXN0IHRoZSBpbmplY3RlZCBlbGVtZW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbm9kZXNdIC0gQW4gaW50ZWdlciByZXByZXNlbnRpbmcgdGhlIG51bWJlciBvZiBhZGRpdGlvbmFsIG5vZGVzIHlvdSB3YW50IGluamVjdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IFt0ZXN0bmFtZXNdIC0gQW4gYXJyYXkgb2Ygc3RyaW5ncyB0aGF0IGFyZSB1c2VkIGFzIGlkcyBmb3IgdGhlIGFkZGl0aW9uYWwgbm9kZXNcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBNb2Rlcm5penIudGVzdFN0eWxlc2AgdGFrZXMgYSBDU1MgcnVsZSBhbmQgaW5qZWN0cyBpdCBvbnRvIHRoZSBjdXJyZW50IHBhZ2VcbiAgICogYWxvbmcgd2l0aCAocG9zc2libHkgbXVsdGlwbGUpIERPTSBlbGVtZW50cy4gVGhpcyBsZXRzIHlvdSBjaGVjayBmb3IgZmVhdHVyZXNcbiAgICogdGhhdCBjYW4gbm90IGJlIGRldGVjdGVkIGJ5IHNpbXBseSBjaGVja2luZyB0aGUgW0lETF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Nb3ppbGxhL0RldmVsb3Blcl9ndWlkZS9JbnRlcmZhY2VfZGV2ZWxvcG1lbnRfZ3VpZGUvSURMX2ludGVyZmFjZV9ydWxlcykuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIE1vZGVybml6ci50ZXN0U3R5bGVzKCcjbW9kZXJuaXpyIHsgd2lkdGg6IDlweDsgY29sb3I6IHBhcGF5YXdoaXA7IH0nLCBmdW5jdGlvbihlbGVtLCBydWxlKSB7XG4gICAqICAgLy8gZWxlbSBpcyB0aGUgZmlyc3QgRE9NIG5vZGUgaW4gdGhlIHBhZ2UgKGJ5IGRlZmF1bHQgI21vZGVybml6cilcbiAgICogICAvLyBydWxlIGlzIHRoZSBmaXJzdCBhcmd1bWVudCB5b3Ugc3VwcGxpZWQgLSB0aGUgQ1NTIHJ1bGUgaW4gc3RyaW5nIGZvcm1cbiAgICpcbiAgICogICBhZGRUZXN0KCd3aWR0aHdvcmtzJywgZWxlbS5zdHlsZS53aWR0aCA9PT0gJzlweCcpXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogSWYgeW91ciB0ZXN0IHJlcXVpcmVzIG11bHRpcGxlIG5vZGVzLCB5b3UgY2FuIGluY2x1ZGUgYSB0aGlyZCBhcmd1bWVudFxuICAgKiBpbmRpY2F0aW5nIGhvdyBtYW55IGFkZGl0aW9uYWwgZGl2IGVsZW1lbnRzIHRvIGluY2x1ZGUgb24gdGhlIHBhZ2UuIFRoZVxuICAgKiBhZGRpdGlvbmFsIG5vZGVzIGFyZSBpbmplY3RlZCBhcyBjaGlsZHJlbiBvZiB0aGUgYGVsZW1gIHRoYXQgaXMgcmV0dXJuZWQgYXNcbiAgICogdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBjYWxsYmFjay5cbiAgICpcbiAgICogYGBganNcbiAgICogTW9kZXJuaXpyLnRlc3RTdHlsZXMoJyNtb2Rlcm5penIge3dpZHRoOiAxcHh9OyAjbW9kZXJuaXpyMiB7d2lkdGg6IDJweH0nLCBmdW5jdGlvbihlbGVtKSB7XG4gICAqICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vZGVybml6cicpLnN0eWxlLndpZHRoID09PSAnMXB4JzsgLy8gdHJ1ZVxuICAgKiAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2Rlcm5penIyJykuc3R5bGUud2lkdGggPT09ICcycHgnOyAvLyB0cnVlXG4gICAqICAgZWxlbS5maXJzdENoaWxkID09PSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9kZXJuaXpyMicpOyAvLyB0cnVlXG4gICAqIH0sIDEpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQnkgZGVmYXVsdCwgYWxsIG9mIHRoZSBhZGRpdGlvbmFsIGVsZW1lbnRzIGhhdmUgYW4gSUQgb2YgYG1vZGVybml6cltuXWAsIHdoZXJlXG4gICAqIGBuYCBpcyBpdHMgaW5kZXggKGUuZy4gdGhlIGZpcnN0IGFkZGl0aW9uYWwsIHNlY29uZCBvdmVyYWxsIGlzIGAjbW9kZXJuaXpyMmAsXG4gICAqIHRoZSBzZWNvbmQgYWRkaXRpb25hbCBpcyBgI21vZGVybml6cjNgLCBldGMuKS5cbiAgICogSWYgeW91IHdhbnQgdG8gaGF2ZSBtb3JlIG1lYW5pbmdmdWwgSURzIGZvciB5b3VyIGZ1bmN0aW9uLCB5b3UgY2FuIHByb3ZpZGVcbiAgICogdGhlbSBhcyB0aGUgZm91cnRoIGFyZ3VtZW50LCBhcyBhbiBhcnJheSBvZiBzdHJpbmdzXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIE1vZGVybml6ci50ZXN0U3R5bGVzKCcjZm9vIHt3aWR0aDogMTBweH07ICNiYXIge2hlaWdodDogMjBweH0nLCBmdW5jdGlvbihlbGVtKSB7XG4gICAqICAgZWxlbS5maXJzdENoaWxkID09PSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZm9vJyk7IC8vIHRydWVcbiAgICogICBlbGVtLmxhc3RDaGlsZCA9PT0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JhcicpOyAvLyB0cnVlXG4gICAqIH0sIDIsIFsnZm9vJywgJ2JhciddKTtcbiAgICogYGBgXG4gICAqXG4gICAqL1xuXG4gIHZhciB0ZXN0U3R5bGVzID0gTW9kZXJuaXpyUHJvdG8udGVzdFN0eWxlcyA9IGluamVjdEVsZW1lbnRXaXRoU3R5bGVzO1xuICBcbi8qIVxue1xuICBcIm5hbWVcIjogXCJIaWRkZW4gU2Nyb2xsYmFyXCIsXG4gIFwicHJvcGVydHlcIjogXCJoaWRkZW5zY3JvbGxcIixcbiAgXCJhdXRob3JzXCI6IFtcIk9sZWcgS29yc3Vuc2t5XCJdLFxuICBcInRhZ3NcIjogW1wib3ZlcmxheVwiXSxcbiAgXCJub3Rlc1wiOiBbe1xuICAgIFwibmFtZVwiOiBcIk92ZXJsYXkgU2Nyb2xsYmFyIGRlc2NyaXB0aW9uXCIsXG4gICAgXCJocmVmXCI6IFwiaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvbWFjL3JlbGVhc2Vub3Rlcy9NYWNPU1gvV2hhdHNOZXdJbk9TWC9BcnRpY2xlcy9NYWNPU1gxMF83Lmh0bWwjLy9hcHBsZV9yZWYvZG9jL3VpZC9UUDQwMDEwMzU1LVNXMzlcIlxuICB9LHtcbiAgICBcIm5hbWVcIjogXCJWaWRlbyBleGFtcGxlIG9mIG92ZXJsYXkgc2Nyb2xsYmFyc1wiLFxuICAgIFwiaHJlZlwiOiBcImh0dHBzOi8vZ2Z5Y2F0LmNvbS9Gb29saXNoTWVhc2x5QXRsYW50aWNzaGFycG5vc2VwdWZmZXJcIlxuICB9XVxufVxuISovXG4vKiBET0NcbkRldGVjdHMgb3ZlcmxheSBzY3JvbGxiYXJzICh3aGVuIHNjcm9sbGJhcnMgb24gb3ZlcmZsb3dlZCBibG9ja3MgYXJlIHZpc2libGUpLiBUaGlzIGlzIGZvdW5kIG1vc3QgY29tbW9ubHkgb24gbW9iaWxlIGFuZCBPUyBYLlxuKi9cblxuICBNb2Rlcm5penIuYWRkVGVzdCgnaGlkZGVuc2Nyb2xsJywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRlc3RTdHlsZXMoJyNtb2Rlcm5penIge3dpZHRoOjEwMHB4O2hlaWdodDoxMDBweDtvdmVyZmxvdzpzY3JvbGx9JywgZnVuY3Rpb24oZWxlbSkge1xuICAgICAgcmV0dXJuIGVsZW0ub2Zmc2V0V2lkdGggPT09IGVsZW0uY2xpZW50V2lkdGg7XG4gICAgfSk7XG4gIH0pO1xuXG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIHNldCBmb3IgY3NzIHRlc3RzLiBTZWUgdGlja2V0ICMyMVxuICAgKiBodHRwOi8vZ2l0LmlvL3ZVR2w0XG4gICAqXG4gICAqIEBtZW1iZXJvZiBNb2Rlcm5penJcbiAgICogQG5hbWUgTW9kZXJuaXpyLl9wcmVmaXhlc1xuICAgKiBAb3B0aW9uTmFtZSBNb2Rlcm5penIuX3ByZWZpeGVzXG4gICAqIEBvcHRpb25Qcm9wIHByZWZpeGVzXG4gICAqIEBhY2Nlc3MgcHVibGljXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIE1vZGVybml6ci5fcHJlZml4ZXMgaXMgdGhlIGludGVybmFsIGxpc3Qgb2YgcHJlZml4ZXMgdGhhdCB3ZSB0ZXN0IGFnYWluc3RcbiAgICogaW5zaWRlIG9mIHRoaW5ncyBsaWtlIFtwcmVmaXhlZF0oI21vZGVybml6ci1wcmVmaXhlZCkgYW5kIFtwcmVmaXhlZENTU10oIy1jb2RlLW1vZGVybml6ci1wcmVmaXhlZGNzcykuIEl0IGlzIHNpbXBseVxuICAgKiBhbiBhcnJheSBvZiBrZWJhYi1jYXNlIHZlbmRvciBwcmVmaXhlcyB5b3UgY2FuIHVzZSB3aXRoaW4geW91ciBjb2RlLlxuICAgKlxuICAgKiBTb21lIGNvbW1vbiB1c2UgY2FzZXMgaW5jbHVkZVxuICAgKlxuICAgKiBHZW5lcmF0aW5nIGFsbCBwb3NzaWJsZSBwcmVmaXhlZCB2ZXJzaW9uIG9mIGEgQ1NTIHByb3BlcnR5XG4gICAqIGBgYGpzXG4gICAqIHZhciBydWxlID0gTW9kZXJuaXpyLl9wcmVmaXhlcy5qb2luKCd0cmFuc2Zvcm06IHJvdGF0ZSgyMGRlZyk7ICcpO1xuICAgKlxuICAgKiBydWxlID09PSAndHJhbnNmb3JtOiByb3RhdGUoMjBkZWcpOyB3ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMjBkZWcpOyBtb3otdHJhbnNmb3JtOiByb3RhdGUoMjBkZWcpOyBvLXRyYW5zZm9ybTogcm90YXRlKDIwZGVnKTsgbXMtdHJhbnNmb3JtOiByb3RhdGUoMjBkZWcpOydcbiAgICogYGBgXG4gICAqXG4gICAqIEdlbmVyYXRpbmcgYWxsIHBvc3NpYmxlIHByZWZpeGVkIHZlcnNpb24gb2YgYSBDU1MgdmFsdWVcbiAgICogYGBganNcbiAgICogcnVsZSA9ICdkaXNwbGF5OicgKyAgTW9kZXJuaXpyLl9wcmVmaXhlcy5qb2luKCdmbGV4OyBkaXNwbGF5OicpICsgJ2ZsZXgnO1xuICAgKlxuICAgKiBydWxlID09PSAnZGlzcGxheTpmbGV4OyBkaXNwbGF5Oi13ZWJraXQtZmxleDsgZGlzcGxheTotbW96LWZsZXg7IGRpc3BsYXk6LW8tZmxleDsgZGlzcGxheTotbXMtZmxleDsgZGlzcGxheTpmbGV4J1xuICAgKiBgYGBcbiAgICovXG5cbiAgLy8gd2UgdXNlIFsnJywnJ10gcmF0aGVyIHRoYW4gYW4gZW1wdHkgYXJyYXkgaW4gb3JkZXIgdG8gYWxsb3cgYSBwYXR0ZXJuIG9mIC5gam9pbigpYGluZyBwcmVmaXhlcyB0byB0ZXN0XG4gIC8vIHZhbHVlcyBpbiBmZWF0dXJlIGRldGVjdHMgdG8gY29udGludWUgdG8gd29ya1xuICB2YXIgcHJlZml4ZXMgPSAoTW9kZXJuaXpyUHJvdG8uX2NvbmZpZy51c2VQcmVmaXhlcyA/ICcgLXdlYmtpdC0gLW1vei0gLW8tIC1tcy0gJy5zcGxpdCgnICcpIDogWycnLCcnXSk7XG5cbiAgLy8gZXhwb3NlIHRoZXNlIGZvciB0aGUgcGx1Z2luIEFQSS4gTG9vayBpbiB0aGUgc291cmNlIGZvciBob3cgdG8gam9pbigpIHRoZW0gYWdhaW5zdCB5b3VyIGlucHV0XG4gIE1vZGVybml6clByb3RvLl9wcmVmaXhlcyA9IHByZWZpeGVzO1xuXG4gIFxuLyohXG57XG4gIFwibmFtZVwiOiBcIlRvdWNoIEV2ZW50c1wiLFxuICBcInByb3BlcnR5XCI6IFwidG91Y2hldmVudHNcIixcbiAgXCJjYW5pdXNlXCIgOiBcInRvdWNoXCIsXG4gIFwidGFnc1wiOiBbXCJtZWRpYVwiLCBcImF0dHJpYnV0ZVwiXSxcbiAgXCJub3Rlc1wiOiBbe1xuICAgIFwibmFtZVwiOiBcIlRvdWNoIEV2ZW50cyBzcGVjXCIsXG4gICAgXCJocmVmXCI6IFwiaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtdG91Y2gtZXZlbnRzLTIwMTMwMTI0L1wiXG4gIH1dLFxuICBcIndhcm5pbmdzXCI6IFtcbiAgICBcIkluZGljYXRlcyBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgVG91Y2ggRXZlbnRzIHNwZWMsIGFuZCBkb2VzIG5vdCBuZWNlc3NhcmlseSByZWZsZWN0IGEgdG91Y2hzY3JlZW4gZGV2aWNlXCJcbiAgXSxcbiAgXCJrbm93bkJ1Z3NcIjogW1xuICAgIFwiRmFsc2UtcG9zaXRpdmUgb24gc29tZSBjb25maWd1cmF0aW9ucyBvZiBOb2tpYSBOOTAwXCIsXG4gICAgXCJGYWxzZS1wb3NpdGl2ZSBvbiBzb21lIEJsYWNrQmVycnkgNi4wIGJ1aWxkcyDigJMgaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvaXNzdWVzLzM3MiNpc3N1ZWNvbW1lbnQtMzExMjY5NVwiXG4gIF1cbn1cbiEqL1xuLyogRE9DXG5JbmRpY2F0ZXMgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIFczQyBUb3VjaCBFdmVudHMgQVBJLlxuXG5UaGlzICpkb2VzIG5vdCogbmVjZXNzYXJpbHkgcmVmbGVjdCBhIHRvdWNoc2NyZWVuIGRldmljZTpcblxuKiBPbGRlciB0b3VjaHNjcmVlbiBkZXZpY2VzIG9ubHkgZW11bGF0ZSBtb3VzZSBldmVudHNcbiogTW9kZXJuIElFIHRvdWNoIGRldmljZXMgaW1wbGVtZW50IHRoZSBQb2ludGVyIEV2ZW50cyBBUEkgaW5zdGVhZDogdXNlIGBNb2Rlcm5penIucG9pbnRlcmV2ZW50c2AgdG8gZGV0ZWN0IHN1cHBvcnQgZm9yIHRoYXRcbiogU29tZSBicm93c2VycyAmIE9TIHNldHVwcyBtYXkgZW5hYmxlIHRvdWNoIEFQSXMgd2hlbiBubyB0b3VjaHNjcmVlbiBpcyBjb25uZWN0ZWRcbiogRnV0dXJlIGJyb3dzZXJzIG1heSBpbXBsZW1lbnQgb3RoZXIgZXZlbnQgbW9kZWxzIGZvciB0b3VjaCBpbnRlcmFjdGlvbnNcblxuU2VlIHRoaXMgYXJ0aWNsZTogW1lvdSBDYW4ndCBEZXRlY3QgQSBUb3VjaHNjcmVlbl0oaHR0cDovL3d3dy5zdHVjb3guY29tL2Jsb2cveW91LWNhbnQtZGV0ZWN0LWEtdG91Y2hzY3JlZW4vKS5cblxuSXQncyByZWNvbW1lbmRlZCB0byBiaW5kIGJvdGggbW91c2UgYW5kIHRvdWNoL3BvaW50ZXIgZXZlbnRzIHNpbXVsdGFuZW91c2x5IOKAkyBzZWUgW3RoaXMgSFRNTDUgUm9ja3MgdHV0b3JpYWxdKGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vbW9iaWxlL3RvdWNoYW5kbW91c2UvKS5cblxuVGhpcyB0ZXN0IHdpbGwgYWxzbyByZXR1cm4gYHRydWVgIGZvciBGaXJlZm94IDQgTXVsdGl0b3VjaCBzdXBwb3J0LlxuKi9cblxuICAvLyBDaHJvbWUgKGRlc2t0b3ApIHVzZWQgdG8gbGllIGFib3V0IGl0cyBzdXBwb3J0IG9uIHRoaXMsIGJ1dCB0aGF0IGhhcyBzaW5jZSBiZWVuIHJlY3RpZmllZDogaHR0cDovL2NyYnVnLmNvbS8zNjQxNVxuICBNb2Rlcm5penIuYWRkVGVzdCgndG91Y2hldmVudHMnLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgYm9vbDtcbiAgICBpZiAoKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykgfHwgd2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiBEb2N1bWVudFRvdWNoKSB7XG4gICAgICBib29sID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW5jbHVkZSB0aGUgJ2hlYXJ0eicgYXMgYSB3YXkgdG8gaGF2ZSBhIG5vbiBtYXRjaGluZyBNUSB0byBoZWxwIHRlcm1pbmF0ZSB0aGUgam9pblxuICAgICAgLy8gaHR0cHM6Ly9naXQuaW8vdnpuRkhcbiAgICAgIHZhciBxdWVyeSA9IFsnQG1lZGlhICgnLCBwcmVmaXhlcy5qb2luKCd0b3VjaC1lbmFibGVkKSwoJyksICdoZWFydHonLCAnKScsICd7I21vZGVybml6cnt0b3A6OXB4O3Bvc2l0aW9uOmFic29sdXRlfX0nXS5qb2luKCcnKTtcbiAgICAgIHRlc3RTdHlsZXMocXVlcnksIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgYm9vbCA9IG5vZGUub2Zmc2V0VG9wID09PSA5O1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBib29sO1xuICB9KTtcblxuXG4gIC8vIFJ1biBlYWNoIHRlc3RcbiAgdGVzdFJ1bm5lcigpO1xuXG4gIC8vIFJlbW92ZSB0aGUgXCJuby1qc1wiIGNsYXNzIGlmIGl0IGV4aXN0c1xuICBzZXRDbGFzc2VzKGNsYXNzZXMpO1xuXG4gIGRlbGV0ZSBNb2Rlcm5penJQcm90by5hZGRUZXN0O1xuICBkZWxldGUgTW9kZXJuaXpyUHJvdG8uYWRkQXN5bmNUZXN0O1xuXG4gIC8vIFJ1biB0aGUgdGhpbmdzIHRoYXQgYXJlIHN1cHBvc2VkIHRvIHJ1biBhZnRlciB0aGUgdGVzdHNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBNb2Rlcm5penIuX3EubGVuZ3RoOyBpKyspIHtcbiAgICBNb2Rlcm5penIuX3FbaV0oKTtcbiAgfVxuXG4gIC8vIExlYWsgTW9kZXJuaXpyIG5hbWVzcGFjZVxuICB3aW5kb3cuTW9kZXJuaXpyID0gTW9kZXJuaXpyO1xuXG5cbjtcblxufSkod2luZG93LCBkb2N1bWVudCk7IiwiLypcbiAyMDE3IEp1bGlhbiBHYXJuaWVyXG4gUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4qL1xudmFyICRqc2NvbXA9e3Njb3BlOnt9fTskanNjb21wLmRlZmluZVByb3BlcnR5PVwiZnVuY3Rpb25cIj09dHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzP09iamVjdC5kZWZpbmVQcm9wZXJ0eTpmdW5jdGlvbihlLHIscCl7aWYocC5nZXR8fHAuc2V0KXRocm93IG5ldyBUeXBlRXJyb3IoXCJFUzMgZG9lcyBub3Qgc3VwcG9ydCBnZXR0ZXJzIGFuZCBzZXR0ZXJzLlwiKTtlIT1BcnJheS5wcm90b3R5cGUmJmUhPU9iamVjdC5wcm90b3R5cGUmJihlW3JdPXAudmFsdWUpfTskanNjb21wLmdldEdsb2JhbD1mdW5jdGlvbihlKXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3c9PT1lP2U6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbCYmbnVsbCE9Z2xvYmFsP2dsb2JhbDplfTskanNjb21wLmdsb2JhbD0kanNjb21wLmdldEdsb2JhbCh0aGlzKTskanNjb21wLlNZTUJPTF9QUkVGSVg9XCJqc2NvbXBfc3ltYm9sX1wiO1xuJGpzY29tcC5pbml0U3ltYm9sPWZ1bmN0aW9uKCl7JGpzY29tcC5pbml0U3ltYm9sPWZ1bmN0aW9uKCl7fTskanNjb21wLmdsb2JhbC5TeW1ib2x8fCgkanNjb21wLmdsb2JhbC5TeW1ib2w9JGpzY29tcC5TeW1ib2wpfTskanNjb21wLnN5bWJvbENvdW50ZXJfPTA7JGpzY29tcC5TeW1ib2w9ZnVuY3Rpb24oZSl7cmV0dXJuICRqc2NvbXAuU1lNQk9MX1BSRUZJWCsoZXx8XCJcIikrJGpzY29tcC5zeW1ib2xDb3VudGVyXysrfTtcbiRqc2NvbXAuaW5pdFN5bWJvbEl0ZXJhdG9yPWZ1bmN0aW9uKCl7JGpzY29tcC5pbml0U3ltYm9sKCk7dmFyIGU9JGpzY29tcC5nbG9iYWwuU3ltYm9sLml0ZXJhdG9yO2V8fChlPSRqc2NvbXAuZ2xvYmFsLlN5bWJvbC5pdGVyYXRvcj0kanNjb21wLmdsb2JhbC5TeW1ib2woXCJpdGVyYXRvclwiKSk7XCJmdW5jdGlvblwiIT10eXBlb2YgQXJyYXkucHJvdG90eXBlW2VdJiYkanNjb21wLmRlZmluZVByb3BlcnR5KEFycmF5LnByb3RvdHlwZSxlLHtjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gJGpzY29tcC5hcnJheUl0ZXJhdG9yKHRoaXMpfX0pOyRqc2NvbXAuaW5pdFN5bWJvbEl0ZXJhdG9yPWZ1bmN0aW9uKCl7fX07JGpzY29tcC5hcnJheUl0ZXJhdG9yPWZ1bmN0aW9uKGUpe3ZhciByPTA7cmV0dXJuICRqc2NvbXAuaXRlcmF0b3JQcm90b3R5cGUoZnVuY3Rpb24oKXtyZXR1cm4gcjxlLmxlbmd0aD97ZG9uZTohMSx2YWx1ZTplW3IrK119Ontkb25lOiEwfX0pfTtcbiRqc2NvbXAuaXRlcmF0b3JQcm90b3R5cGU9ZnVuY3Rpb24oZSl7JGpzY29tcC5pbml0U3ltYm9sSXRlcmF0b3IoKTtlPXtuZXh0OmV9O2VbJGpzY29tcC5nbG9iYWwuU3ltYm9sLml0ZXJhdG9yXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfTtyZXR1cm4gZX07JGpzY29tcC5hcnJheT0kanNjb21wLmFycmF5fHx7fTskanNjb21wLml0ZXJhdG9yRnJvbUFycmF5PWZ1bmN0aW9uKGUscil7JGpzY29tcC5pbml0U3ltYm9sSXRlcmF0b3IoKTtlIGluc3RhbmNlb2YgU3RyaW5nJiYoZSs9XCJcIik7dmFyIHA9MCxtPXtuZXh0OmZ1bmN0aW9uKCl7aWYocDxlLmxlbmd0aCl7dmFyIHU9cCsrO3JldHVybnt2YWx1ZTpyKHUsZVt1XSksZG9uZTohMX19bS5uZXh0PWZ1bmN0aW9uKCl7cmV0dXJue2RvbmU6ITAsdmFsdWU6dm9pZCAwfX07cmV0dXJuIG0ubmV4dCgpfX07bVtTeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIG19O3JldHVybiBtfTtcbiRqc2NvbXAucG9seWZpbGw9ZnVuY3Rpb24oZSxyLHAsbSl7aWYocil7cD0kanNjb21wLmdsb2JhbDtlPWUuc3BsaXQoXCIuXCIpO2ZvcihtPTA7bTxlLmxlbmd0aC0xO20rKyl7dmFyIHU9ZVttXTt1IGluIHB8fChwW3VdPXt9KTtwPXBbdV19ZT1lW2UubGVuZ3RoLTFdO209cFtlXTtyPXIobSk7ciE9bSYmbnVsbCE9ciYmJGpzY29tcC5kZWZpbmVQcm9wZXJ0eShwLGUse2NvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpyfSl9fTskanNjb21wLnBvbHlmaWxsKFwiQXJyYXkucHJvdG90eXBlLmtleXNcIixmdW5jdGlvbihlKXtyZXR1cm4gZT9lOmZ1bmN0aW9uKCl7cmV0dXJuICRqc2NvbXAuaXRlcmF0b3JGcm9tQXJyYXkodGhpcyxmdW5jdGlvbihlKXtyZXR1cm4gZX0pfX0sXCJlczYtaW1wbFwiLFwiZXMzXCIpO3ZhciAkanNjb21wJHRoaXM9dGhpcztcbihmdW5jdGlvbihlLHIpe1wiZnVuY3Rpb25cIj09PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtdLHIpOlwib2JqZWN0XCI9PT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cz9tb2R1bGUuZXhwb3J0cz1yKCk6ZS5hbmltZT1yKCl9KSh0aGlzLGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShhKXtpZighaC5jb2woYSkpdHJ5e3JldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGEpfWNhdGNoKGMpe319ZnVuY3Rpb24gcihhLGMpe2Zvcih2YXIgZD1hLmxlbmd0aCxiPTI8PWFyZ3VtZW50cy5sZW5ndGg/YXJndW1lbnRzWzFdOnZvaWQgMCxmPVtdLG49MDtuPGQ7bisrKWlmKG4gaW4gYSl7dmFyIGs9YVtuXTtjLmNhbGwoYixrLG4sYSkmJmYucHVzaChrKX1yZXR1cm4gZn1mdW5jdGlvbiBwKGEpe3JldHVybiBhLnJlZHVjZShmdW5jdGlvbihhLGQpe3JldHVybiBhLmNvbmNhdChoLmFycihkKT9wKGQpOmQpfSxbXSl9ZnVuY3Rpb24gbShhKXtpZihoLmFycihhKSlyZXR1cm4gYTtcbmguc3RyKGEpJiYoYT1lKGEpfHxhKTtyZXR1cm4gYSBpbnN0YW5jZW9mIE5vZGVMaXN0fHxhIGluc3RhbmNlb2YgSFRNTENvbGxlY3Rpb24/W10uc2xpY2UuY2FsbChhKTpbYV19ZnVuY3Rpb24gdShhLGMpe3JldHVybiBhLnNvbWUoZnVuY3Rpb24oYSl7cmV0dXJuIGE9PT1jfSl9ZnVuY3Rpb24gQyhhKXt2YXIgYz17fSxkO2ZvcihkIGluIGEpY1tkXT1hW2RdO3JldHVybiBjfWZ1bmN0aW9uIEQoYSxjKXt2YXIgZD1DKGEpLGI7Zm9yKGIgaW4gYSlkW2JdPWMuaGFzT3duUHJvcGVydHkoYik/Y1tiXTphW2JdO3JldHVybiBkfWZ1bmN0aW9uIHooYSxjKXt2YXIgZD1DKGEpLGI7Zm9yKGIgaW4gYylkW2JdPWgudW5kKGFbYl0pP2NbYl06YVtiXTtyZXR1cm4gZH1mdW5jdGlvbiBUKGEpe2E9YS5yZXBsYWNlKC9eIz8oW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSkkL2ksZnVuY3Rpb24oYSxjLGQsayl7cmV0dXJuIGMrYytkK2QraytrfSk7dmFyIGM9L14jPyhbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KSQvaS5leGVjKGEpO1xuYT1wYXJzZUludChjWzFdLDE2KTt2YXIgZD1wYXJzZUludChjWzJdLDE2KSxjPXBhcnNlSW50KGNbM10sMTYpO3JldHVyblwicmdiYShcIithK1wiLFwiK2QrXCIsXCIrYytcIiwxKVwifWZ1bmN0aW9uIFUoYSl7ZnVuY3Rpb24gYyhhLGMsYil7MD5iJiYoYis9MSk7MTxiJiYtLWI7cmV0dXJuIGI8MS82P2ErNiooYy1hKSpiOi41PmI/YzpiPDIvMz9hKyhjLWEpKigyLzMtYikqNjphfXZhciBkPS9oc2xcXCgoXFxkKyksXFxzKihbXFxkLl0rKSUsXFxzKihbXFxkLl0rKSVcXCkvZy5leGVjKGEpfHwvaHNsYVxcKChcXGQrKSxcXHMqKFtcXGQuXSspJSxcXHMqKFtcXGQuXSspJSxcXHMqKFtcXGQuXSspXFwpL2cuZXhlYyhhKTthPXBhcnNlSW50KGRbMV0pLzM2MDt2YXIgYj1wYXJzZUludChkWzJdKS8xMDAsZj1wYXJzZUludChkWzNdKS8xMDAsZD1kWzRdfHwxO2lmKDA9PWIpZj1iPWE9ZjtlbHNle3ZhciBuPS41PmY/ZiooMStiKTpmK2ItZipiLGs9MipmLW4sZj1jKGssbixhKzEvMyksYj1jKGssbixhKTthPWMoayxuLGEtMS8zKX1yZXR1cm5cInJnYmEoXCIrXG4yNTUqZitcIixcIisyNTUqYitcIixcIisyNTUqYStcIixcIitkK1wiKVwifWZ1bmN0aW9uIHkoYSl7aWYoYT0vKFtcXCtcXC1dP1swLTkjXFwuXSspKCV8cHh8cHR8ZW18cmVtfGlufGNtfG1tfGV4fGNofHBjfHZ3fHZofHZtaW58dm1heHxkZWd8cmFkfHR1cm4pPyQvLmV4ZWMoYSkpcmV0dXJuIGFbMl19ZnVuY3Rpb24gVihhKXtpZigtMTxhLmluZGV4T2YoXCJ0cmFuc2xhdGVcIil8fFwicGVyc3BlY3RpdmVcIj09PWEpcmV0dXJuXCJweFwiO2lmKC0xPGEuaW5kZXhPZihcInJvdGF0ZVwiKXx8LTE8YS5pbmRleE9mKFwic2tld1wiKSlyZXR1cm5cImRlZ1wifWZ1bmN0aW9uIEkoYSxjKXtyZXR1cm4gaC5mbmMoYSk/YShjLnRhcmdldCxjLmlkLGMudG90YWwpOmF9ZnVuY3Rpb24gRShhLGMpe2lmKGMgaW4gYS5zdHlsZSlyZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShhKS5nZXRQcm9wZXJ0eVZhbHVlKGMucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZyxcIiQxLSQyXCIpLnRvTG93ZXJDYXNlKCkpfHxcIjBcIn1mdW5jdGlvbiBKKGEsYyl7aWYoaC5kb20oYSkmJlxudShXLGMpKXJldHVyblwidHJhbnNmb3JtXCI7aWYoaC5kb20oYSkmJihhLmdldEF0dHJpYnV0ZShjKXx8aC5zdmcoYSkmJmFbY10pKXJldHVyblwiYXR0cmlidXRlXCI7aWYoaC5kb20oYSkmJlwidHJhbnNmb3JtXCIhPT1jJiZFKGEsYykpcmV0dXJuXCJjc3NcIjtpZihudWxsIT1hW2NdKXJldHVyblwib2JqZWN0XCJ9ZnVuY3Rpb24gWChhLGMpe3ZhciBkPVYoYyksZD0tMTxjLmluZGV4T2YoXCJzY2FsZVwiKT8xOjArZDthPWEuc3R5bGUudHJhbnNmb3JtO2lmKCFhKXJldHVybiBkO2Zvcih2YXIgYj1bXSxmPVtdLG49W10saz0vKFxcdyspXFwoKC4rPylcXCkvZztiPWsuZXhlYyhhKTspZi5wdXNoKGJbMV0pLG4ucHVzaChiWzJdKTthPXIobixmdW5jdGlvbihhLGIpe3JldHVybiBmW2JdPT09Y30pO3JldHVybiBhLmxlbmd0aD9hWzBdOmR9ZnVuY3Rpb24gSyhhLGMpe3N3aXRjaChKKGEsYykpe2Nhc2UgXCJ0cmFuc2Zvcm1cIjpyZXR1cm4gWChhLGMpO2Nhc2UgXCJjc3NcIjpyZXR1cm4gRShhLGMpO2Nhc2UgXCJhdHRyaWJ1dGVcIjpyZXR1cm4gYS5nZXRBdHRyaWJ1dGUoYyl9cmV0dXJuIGFbY118fFxuMH1mdW5jdGlvbiBMKGEsYyl7dmFyIGQ9L14oXFwqPXxcXCs9fC09KS8uZXhlYyhhKTtpZighZClyZXR1cm4gYTt2YXIgYj15KGEpfHwwO2M9cGFyc2VGbG9hdChjKTthPXBhcnNlRmxvYXQoYS5yZXBsYWNlKGRbMF0sXCJcIikpO3N3aXRjaChkWzBdWzBdKXtjYXNlIFwiK1wiOnJldHVybiBjK2ErYjtjYXNlIFwiLVwiOnJldHVybiBjLWErYjtjYXNlIFwiKlwiOnJldHVybiBjKmErYn19ZnVuY3Rpb24gRihhLGMpe3JldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coYy54LWEueCwyKStNYXRoLnBvdyhjLnktYS55LDIpKX1mdW5jdGlvbiBNKGEpe2E9YS5wb2ludHM7Zm9yKHZhciBjPTAsZCxiPTA7YjxhLm51bWJlck9mSXRlbXM7YisrKXt2YXIgZj1hLmdldEl0ZW0oYik7MDxiJiYoYys9RihkLGYpKTtkPWZ9cmV0dXJuIGN9ZnVuY3Rpb24gTihhKXtpZihhLmdldFRvdGFsTGVuZ3RoKXJldHVybiBhLmdldFRvdGFsTGVuZ3RoKCk7c3dpdGNoKGEudGFnTmFtZS50b0xvd2VyQ2FzZSgpKXtjYXNlIFwiY2lyY2xlXCI6cmV0dXJuIDIqXG5NYXRoLlBJKmEuZ2V0QXR0cmlidXRlKFwiclwiKTtjYXNlIFwicmVjdFwiOnJldHVybiAyKmEuZ2V0QXR0cmlidXRlKFwid2lkdGhcIikrMiphLmdldEF0dHJpYnV0ZShcImhlaWdodFwiKTtjYXNlIFwibGluZVwiOnJldHVybiBGKHt4OmEuZ2V0QXR0cmlidXRlKFwieDFcIikseTphLmdldEF0dHJpYnV0ZShcInkxXCIpfSx7eDphLmdldEF0dHJpYnV0ZShcIngyXCIpLHk6YS5nZXRBdHRyaWJ1dGUoXCJ5MlwiKX0pO2Nhc2UgXCJwb2x5bGluZVwiOnJldHVybiBNKGEpO2Nhc2UgXCJwb2x5Z29uXCI6dmFyIGM9YS5wb2ludHM7cmV0dXJuIE0oYSkrRihjLmdldEl0ZW0oYy5udW1iZXJPZkl0ZW1zLTEpLGMuZ2V0SXRlbSgwKSl9fWZ1bmN0aW9uIFkoYSxjKXtmdW5jdGlvbiBkKGIpe2I9dm9pZCAwPT09Yj8wOmI7cmV0dXJuIGEuZWwuZ2V0UG9pbnRBdExlbmd0aCgxPD1jK2I/YytiOjApfXZhciBiPWQoKSxmPWQoLTEpLG49ZCgxKTtzd2l0Y2goYS5wcm9wZXJ0eSl7Y2FzZSBcInhcIjpyZXR1cm4gYi54O2Nhc2UgXCJ5XCI6cmV0dXJuIGIueTtcbmNhc2UgXCJhbmdsZVwiOnJldHVybiAxODAqTWF0aC5hdGFuMihuLnktZi55LG4ueC1mLngpL01hdGguUEl9fWZ1bmN0aW9uIE8oYSxjKXt2YXIgZD0vLT9cXGQqXFwuP1xcZCsvZyxiO2I9aC5wdGgoYSk/YS50b3RhbExlbmd0aDphO2lmKGguY29sKGIpKWlmKGgucmdiKGIpKXt2YXIgZj0vcmdiXFwoKFxcZCssXFxzKltcXGRdKyxcXHMqW1xcZF0rKVxcKS9nLmV4ZWMoYik7Yj1mP1wicmdiYShcIitmWzFdK1wiLDEpXCI6Yn1lbHNlIGI9aC5oZXgoYik/VChiKTpoLmhzbChiKT9VKGIpOnZvaWQgMDtlbHNlIGY9KGY9eShiKSk/Yi5zdWJzdHIoMCxiLmxlbmd0aC1mLmxlbmd0aCk6YixiPWMmJiEvXFxzL2cudGVzdChiKT9mK2M6ZjtiKz1cIlwiO3JldHVybntvcmlnaW5hbDpiLG51bWJlcnM6Yi5tYXRjaChkKT9iLm1hdGNoKGQpLm1hcChOdW1iZXIpOlswXSxzdHJpbmdzOmguc3RyKGEpfHxjP2Iuc3BsaXQoZCk6W119fWZ1bmN0aW9uIFAoYSl7YT1hP3AoaC5hcnIoYSk/YS5tYXAobSk6bShhKSk6W107cmV0dXJuIHIoYSxcbmZ1bmN0aW9uKGEsZCxiKXtyZXR1cm4gYi5pbmRleE9mKGEpPT09ZH0pfWZ1bmN0aW9uIFooYSl7dmFyIGM9UChhKTtyZXR1cm4gYy5tYXAoZnVuY3Rpb24oYSxiKXtyZXR1cm57dGFyZ2V0OmEsaWQ6Yix0b3RhbDpjLmxlbmd0aH19KX1mdW5jdGlvbiBhYShhLGMpe3ZhciBkPUMoYyk7aWYoaC5hcnIoYSkpe3ZhciBiPWEubGVuZ3RoOzIhPT1ifHxoLm9iaihhWzBdKT9oLmZuYyhjLmR1cmF0aW9uKXx8KGQuZHVyYXRpb249Yy5kdXJhdGlvbi9iKTphPXt2YWx1ZTphfX1yZXR1cm4gbShhKS5tYXAoZnVuY3Rpb24oYSxiKXtiPWI/MDpjLmRlbGF5O2E9aC5vYmooYSkmJiFoLnB0aChhKT9hOnt2YWx1ZTphfTtoLnVuZChhLmRlbGF5KSYmKGEuZGVsYXk9Yik7cmV0dXJuIGF9KS5tYXAoZnVuY3Rpb24oYSl7cmV0dXJuIHooYSxkKX0pfWZ1bmN0aW9uIGJhKGEsYyl7dmFyIGQ9e30sYjtmb3IoYiBpbiBhKXt2YXIgZj1JKGFbYl0sYyk7aC5hcnIoZikmJihmPWYubWFwKGZ1bmN0aW9uKGEpe3JldHVybiBJKGEsXG5jKX0pLDE9PT1mLmxlbmd0aCYmKGY9ZlswXSkpO2RbYl09Zn1kLmR1cmF0aW9uPXBhcnNlRmxvYXQoZC5kdXJhdGlvbik7ZC5kZWxheT1wYXJzZUZsb2F0KGQuZGVsYXkpO3JldHVybiBkfWZ1bmN0aW9uIGNhKGEpe3JldHVybiBoLmFycihhKT9BLmFwcGx5KHRoaXMsYSk6UVthXX1mdW5jdGlvbiBkYShhLGMpe3ZhciBkO3JldHVybiBhLnR3ZWVucy5tYXAoZnVuY3Rpb24oYil7Yj1iYShiLGMpO3ZhciBmPWIudmFsdWUsZT1LKGMudGFyZ2V0LGEubmFtZSksaz1kP2QudG8ub3JpZ2luYWw6ZSxrPWguYXJyKGYpP2ZbMF06ayx3PUwoaC5hcnIoZik/ZlsxXTpmLGspLGU9eSh3KXx8eShrKXx8eShlKTtiLmZyb209TyhrLGUpO2IudG89Tyh3LGUpO2Iuc3RhcnQ9ZD9kLmVuZDphLm9mZnNldDtiLmVuZD1iLnN0YXJ0K2IuZGVsYXkrYi5kdXJhdGlvbjtiLmVhc2luZz1jYShiLmVhc2luZyk7Yi5lbGFzdGljaXR5PSgxRTMtTWF0aC5taW4oTWF0aC5tYXgoYi5lbGFzdGljaXR5LDEpLDk5OSkpL1xuMUUzO2IuaXNQYXRoPWgucHRoKGYpO2IuaXNDb2xvcj1oLmNvbChiLmZyb20ub3JpZ2luYWwpO2IuaXNDb2xvciYmKGIucm91bmQ9MSk7cmV0dXJuIGQ9Yn0pfWZ1bmN0aW9uIGVhKGEsYyl7cmV0dXJuIHIocChhLm1hcChmdW5jdGlvbihhKXtyZXR1cm4gYy5tYXAoZnVuY3Rpb24oYil7dmFyIGM9SihhLnRhcmdldCxiLm5hbWUpO2lmKGMpe3ZhciBkPWRhKGIsYSk7Yj17dHlwZTpjLHByb3BlcnR5OmIubmFtZSxhbmltYXRhYmxlOmEsdHdlZW5zOmQsZHVyYXRpb246ZFtkLmxlbmd0aC0xXS5lbmQsZGVsYXk6ZFswXS5kZWxheX19ZWxzZSBiPXZvaWQgMDtyZXR1cm4gYn0pfSkpLGZ1bmN0aW9uKGEpe3JldHVybiFoLnVuZChhKX0pfWZ1bmN0aW9uIFIoYSxjLGQsYil7dmFyIGY9XCJkZWxheVwiPT09YTtyZXR1cm4gYy5sZW5ndGg/KGY/TWF0aC5taW46TWF0aC5tYXgpLmFwcGx5KE1hdGgsYy5tYXAoZnVuY3Rpb24oYil7cmV0dXJuIGJbYV19KSk6Zj9iLmRlbGF5OmQub2Zmc2V0K2IuZGVsYXkrXG5iLmR1cmF0aW9ufWZ1bmN0aW9uIGZhKGEpe3ZhciBjPUQoZ2EsYSksZD1EKFMsYSksYj1aKGEudGFyZ2V0cyksZj1bXSxlPXooYyxkKSxrO2ZvcihrIGluIGEpZS5oYXNPd25Qcm9wZXJ0eShrKXx8XCJ0YXJnZXRzXCI9PT1rfHxmLnB1c2goe25hbWU6ayxvZmZzZXQ6ZS5vZmZzZXQsdHdlZW5zOmFhKGFba10sZCl9KTthPWVhKGIsZik7cmV0dXJuIHooYyx7Y2hpbGRyZW46W10sYW5pbWF0YWJsZXM6YixhbmltYXRpb25zOmEsZHVyYXRpb246UihcImR1cmF0aW9uXCIsYSxjLGQpLGRlbGF5OlIoXCJkZWxheVwiLGEsYyxkKX0pfWZ1bmN0aW9uIHEoYSl7ZnVuY3Rpb24gYygpe3JldHVybiB3aW5kb3cuUHJvbWlzZSYmbmV3IFByb21pc2UoZnVuY3Rpb24oYSl7cmV0dXJuIHA9YX0pfWZ1bmN0aW9uIGQoYSl7cmV0dXJuIGcucmV2ZXJzZWQ/Zy5kdXJhdGlvbi1hOmF9ZnVuY3Rpb24gYihhKXtmb3IodmFyIGI9MCxjPXt9LGQ9Zy5hbmltYXRpb25zLGY9ZC5sZW5ndGg7YjxmOyl7dmFyIGU9ZFtiXSxcbms9ZS5hbmltYXRhYmxlLGg9ZS50d2VlbnMsbj1oLmxlbmd0aC0xLGw9aFtuXTtuJiYobD1yKGgsZnVuY3Rpb24oYil7cmV0dXJuIGE8Yi5lbmR9KVswXXx8bCk7Zm9yKHZhciBoPU1hdGgubWluKE1hdGgubWF4KGEtbC5zdGFydC1sLmRlbGF5LDApLGwuZHVyYXRpb24pL2wuZHVyYXRpb24sdz1pc05hTihoKT8xOmwuZWFzaW5nKGgsbC5lbGFzdGljaXR5KSxoPWwudG8uc3RyaW5ncyxwPWwucm91bmQsbj1bXSxtPXZvaWQgMCxtPWwudG8ubnVtYmVycy5sZW5ndGgsdD0wO3Q8bTt0Kyspe3ZhciB4PXZvaWQgMCx4PWwudG8ubnVtYmVyc1t0XSxxPWwuZnJvbS5udW1iZXJzW3RdLHg9bC5pc1BhdGg/WShsLnZhbHVlLHcqeCk6cSt3Kih4LXEpO3AmJihsLmlzQ29sb3ImJjI8dHx8KHg9TWF0aC5yb3VuZCh4KnApL3ApKTtuLnB1c2goeCl9aWYobD1oLmxlbmd0aClmb3IobT1oWzBdLHc9MDt3PGw7dysrKXA9aFt3KzFdLHQ9blt3XSxpc05hTih0KXx8KG09cD9tKyh0K3ApOm0rKHQrXCIgXCIpKTtcbmVsc2UgbT1uWzBdO2hhW2UudHlwZV0oay50YXJnZXQsZS5wcm9wZXJ0eSxtLGMsay5pZCk7ZS5jdXJyZW50VmFsdWU9bTtiKyt9aWYoYj1PYmplY3Qua2V5cyhjKS5sZW5ndGgpZm9yKGQ9MDtkPGI7ZCsrKUh8fChIPUUoZG9jdW1lbnQuYm9keSxcInRyYW5zZm9ybVwiKT9cInRyYW5zZm9ybVwiOlwiLXdlYmtpdC10cmFuc2Zvcm1cIiksZy5hbmltYXRhYmxlc1tkXS50YXJnZXQuc3R5bGVbSF09Y1tkXS5qb2luKFwiIFwiKTtnLmN1cnJlbnRUaW1lPWE7Zy5wcm9ncmVzcz1hL2cuZHVyYXRpb24qMTAwfWZ1bmN0aW9uIGYoYSl7aWYoZ1thXSlnW2FdKGcpfWZ1bmN0aW9uIGUoKXtnLnJlbWFpbmluZyYmITAhPT1nLnJlbWFpbmluZyYmZy5yZW1haW5pbmctLX1mdW5jdGlvbiBrKGEpe3ZhciBrPWcuZHVyYXRpb24sbj1nLm9mZnNldCx3PW4rZy5kZWxheSxyPWcuY3VycmVudFRpbWUseD1nLnJldmVyc2VkLHE9ZChhKTtpZihnLmNoaWxkcmVuLmxlbmd0aCl7dmFyIHU9Zy5jaGlsZHJlbix2PXUubGVuZ3RoO1xuaWYocT49Zy5jdXJyZW50VGltZSlmb3IodmFyIEc9MDtHPHY7RysrKXVbR10uc2VlayhxKTtlbHNlIGZvcig7di0tOyl1W3ZdLnNlZWsocSl9aWYocT49d3x8IWspZy5iZWdhbnx8KGcuYmVnYW49ITAsZihcImJlZ2luXCIpKSxmKFwicnVuXCIpO2lmKHE+biYmcTxrKWIocSk7ZWxzZSBpZihxPD1uJiYwIT09ciYmKGIoMCkseCYmZSgpKSxxPj1rJiZyIT09a3x8IWspYihrKSx4fHxlKCk7ZihcInVwZGF0ZVwiKTthPj1rJiYoZy5yZW1haW5pbmc/KHQ9aCxcImFsdGVybmF0ZVwiPT09Zy5kaXJlY3Rpb24mJihnLnJldmVyc2VkPSFnLnJldmVyc2VkKSk6KGcucGF1c2UoKSxnLmNvbXBsZXRlZHx8KGcuY29tcGxldGVkPSEwLGYoXCJjb21wbGV0ZVwiKSxcIlByb21pc2VcImluIHdpbmRvdyYmKHAoKSxtPWMoKSkpKSxsPTApfWE9dm9pZCAwPT09YT97fTphO3ZhciBoLHQsbD0wLHA9bnVsbCxtPWMoKSxnPWZhKGEpO2cucmVzZXQ9ZnVuY3Rpb24oKXt2YXIgYT1nLmRpcmVjdGlvbixjPWcubG9vcDtnLmN1cnJlbnRUaW1lPVxuMDtnLnByb2dyZXNzPTA7Zy5wYXVzZWQ9ITA7Zy5iZWdhbj0hMTtnLmNvbXBsZXRlZD0hMTtnLnJldmVyc2VkPVwicmV2ZXJzZVwiPT09YTtnLnJlbWFpbmluZz1cImFsdGVybmF0ZVwiPT09YSYmMT09PWM/MjpjO2IoMCk7Zm9yKGE9Zy5jaGlsZHJlbi5sZW5ndGg7YS0tOylnLmNoaWxkcmVuW2FdLnJlc2V0KCl9O2cudGljaz1mdW5jdGlvbihhKXtoPWE7dHx8KHQ9aCk7aygobCtoLXQpKnEuc3BlZWQpfTtnLnNlZWs9ZnVuY3Rpb24oYSl7ayhkKGEpKX07Zy5wYXVzZT1mdW5jdGlvbigpe3ZhciBhPXYuaW5kZXhPZihnKTstMTxhJiZ2LnNwbGljZShhLDEpO2cucGF1c2VkPSEwfTtnLnBsYXk9ZnVuY3Rpb24oKXtnLnBhdXNlZCYmKGcucGF1c2VkPSExLHQ9MCxsPWQoZy5jdXJyZW50VGltZSksdi5wdXNoKGcpLEJ8fGlhKCkpfTtnLnJldmVyc2U9ZnVuY3Rpb24oKXtnLnJldmVyc2VkPSFnLnJldmVyc2VkO3Q9MDtsPWQoZy5jdXJyZW50VGltZSl9O2cucmVzdGFydD1mdW5jdGlvbigpe2cucGF1c2UoKTtcbmcucmVzZXQoKTtnLnBsYXkoKX07Zy5maW5pc2hlZD1tO2cucmVzZXQoKTtnLmF1dG9wbGF5JiZnLnBsYXkoKTtyZXR1cm4gZ312YXIgZ2E9e3VwZGF0ZTp2b2lkIDAsYmVnaW46dm9pZCAwLHJ1bjp2b2lkIDAsY29tcGxldGU6dm9pZCAwLGxvb3A6MSxkaXJlY3Rpb246XCJub3JtYWxcIixhdXRvcGxheTohMCxvZmZzZXQ6MH0sUz17ZHVyYXRpb246MUUzLGRlbGF5OjAsZWFzaW5nOlwiZWFzZU91dEVsYXN0aWNcIixlbGFzdGljaXR5OjUwMCxyb3VuZDowfSxXPVwidHJhbnNsYXRlWCB0cmFuc2xhdGVZIHRyYW5zbGF0ZVogcm90YXRlIHJvdGF0ZVggcm90YXRlWSByb3RhdGVaIHNjYWxlIHNjYWxlWCBzY2FsZVkgc2NhbGVaIHNrZXdYIHNrZXdZIHBlcnNwZWN0aXZlXCIuc3BsaXQoXCIgXCIpLEgsaD17YXJyOmZ1bmN0aW9uKGEpe3JldHVybiBBcnJheS5pc0FycmF5KGEpfSxvYmo6ZnVuY3Rpb24oYSl7cmV0dXJuLTE8T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpLmluZGV4T2YoXCJPYmplY3RcIil9LFxucHRoOmZ1bmN0aW9uKGEpe3JldHVybiBoLm9iaihhKSYmYS5oYXNPd25Qcm9wZXJ0eShcInRvdGFsTGVuZ3RoXCIpfSxzdmc6ZnVuY3Rpb24oYSl7cmV0dXJuIGEgaW5zdGFuY2VvZiBTVkdFbGVtZW50fSxkb206ZnVuY3Rpb24oYSl7cmV0dXJuIGEubm9kZVR5cGV8fGguc3ZnKGEpfSxzdHI6ZnVuY3Rpb24oYSl7cmV0dXJuXCJzdHJpbmdcIj09PXR5cGVvZiBhfSxmbmM6ZnVuY3Rpb24oYSl7cmV0dXJuXCJmdW5jdGlvblwiPT09dHlwZW9mIGF9LHVuZDpmdW5jdGlvbihhKXtyZXR1cm5cInVuZGVmaW5lZFwiPT09dHlwZW9mIGF9LGhleDpmdW5jdGlvbihhKXtyZXR1cm4vKF4jWzAtOUEtRl17Nn0kKXwoXiNbMC05QS1GXXszfSQpL2kudGVzdChhKX0scmdiOmZ1bmN0aW9uKGEpe3JldHVybi9ecmdiLy50ZXN0KGEpfSxoc2w6ZnVuY3Rpb24oYSl7cmV0dXJuL15oc2wvLnRlc3QoYSl9LGNvbDpmdW5jdGlvbihhKXtyZXR1cm4gaC5oZXgoYSl8fGgucmdiKGEpfHxoLmhzbChhKX19LEE9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGEsXG5kLGIpe3JldHVybigoKDEtMypiKzMqZCkqYSsoMypiLTYqZCkpKmErMypkKSphfXJldHVybiBmdW5jdGlvbihjLGQsYixmKXtpZigwPD1jJiYxPj1jJiYwPD1iJiYxPj1iKXt2YXIgZT1uZXcgRmxvYXQzMkFycmF5KDExKTtpZihjIT09ZHx8YiE9PWYpZm9yKHZhciBrPTA7MTE+azsrK2spZVtrXT1hKC4xKmssYyxiKTtyZXR1cm4gZnVuY3Rpb24oayl7aWYoYz09PWQmJmI9PT1mKXJldHVybiBrO2lmKDA9PT1rKXJldHVybiAwO2lmKDE9PT1rKXJldHVybiAxO2Zvcih2YXIgaD0wLGw9MTsxMCE9PWwmJmVbbF08PWs7KytsKWgrPS4xOy0tbDt2YXIgbD1oKyhrLWVbbF0pLyhlW2wrMV0tZVtsXSkqLjEsbj0zKigxLTMqYiszKmMpKmwqbCsyKigzKmItNipjKSpsKzMqYztpZiguMDAxPD1uKXtmb3IoaD0wOzQ+aDsrK2gpe249MyooMS0zKmIrMypjKSpsKmwrMiooMypiLTYqYykqbCszKmM7aWYoMD09PW4pYnJlYWs7dmFyIG09YShsLGMsYiktayxsPWwtbS9ufWs9bH1lbHNlIGlmKDA9PT1cbm4paz1sO2Vsc2V7dmFyIGw9aCxoPWgrLjEsZz0wO2RvIG09bCsoaC1sKS8yLG49YShtLGMsYiktaywwPG4/aD1tOmw9bTt3aGlsZSgxZS03PE1hdGguYWJzKG4pJiYxMD4rK2cpO2s9bX1yZXR1cm4gYShrLGQsZil9fX19KCksUT1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoYSxiKXtyZXR1cm4gMD09PWF8fDE9PT1hP2E6LU1hdGgucG93KDIsMTAqKGEtMSkpKk1hdGguc2luKDIqKGEtMS1iLygyKk1hdGguUEkpKk1hdGguYXNpbigxKSkqTWF0aC5QSS9iKX12YXIgYz1cIlF1YWQgQ3ViaWMgUXVhcnQgUXVpbnQgU2luZSBFeHBvIENpcmMgQmFjayBFbGFzdGljXCIuc3BsaXQoXCIgXCIpLGQ9e0luOltbLjU1LC4wODUsLjY4LC41M10sWy41NSwuMDU1LC42NzUsLjE5XSxbLjg5NSwuMDMsLjY4NSwuMjJdLFsuNzU1LC4wNSwuODU1LC4wNl0sWy40NywwLC43NDUsLjcxNV0sWy45NSwuMDUsLjc5NSwuMDM1XSxbLjYsLjA0LC45OCwuMzM1XSxbLjYsLS4yOCwuNzM1LC4wNDVdLGFdLE91dDpbWy4yNSxcbi40NiwuNDUsLjk0XSxbLjIxNSwuNjEsLjM1NSwxXSxbLjE2NSwuODQsLjQ0LDFdLFsuMjMsMSwuMzIsMV0sWy4zOSwuNTc1LC41NjUsMV0sWy4xOSwxLC4yMiwxXSxbLjA3NSwuODIsLjE2NSwxXSxbLjE3NSwuODg1LC4zMiwxLjI3NV0sZnVuY3Rpb24oYixjKXtyZXR1cm4gMS1hKDEtYixjKX1dLEluT3V0OltbLjQ1NSwuMDMsLjUxNSwuOTU1XSxbLjY0NSwuMDQ1LC4zNTUsMV0sWy43NywwLC4xNzUsMV0sWy44NiwwLC4wNywxXSxbLjQ0NSwuMDUsLjU1LC45NV0sWzEsMCwwLDFdLFsuNzg1LC4xMzUsLjE1LC44Nl0sWy42OCwtLjU1LC4yNjUsMS41NV0sZnVuY3Rpb24oYixjKXtyZXR1cm4uNT5iP2EoMipiLGMpLzI6MS1hKC0yKmIrMixjKS8yfV19LGI9e2xpbmVhcjpBKC4yNSwuMjUsLjc1LC43NSl9LGY9e30sZTtmb3IoZSBpbiBkKWYudHlwZT1lLGRbZi50eXBlXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbihkLGYpe2JbXCJlYXNlXCIrYS50eXBlK2NbZl1dPWguZm5jKGQpP1xuZDpBLmFwcGx5KCRqc2NvbXAkdGhpcyxkKX19KGYpKSxmPXt0eXBlOmYudHlwZX07cmV0dXJuIGJ9KCksaGE9e2NzczpmdW5jdGlvbihhLGMsZCl7cmV0dXJuIGEuc3R5bGVbY109ZH0sYXR0cmlidXRlOmZ1bmN0aW9uKGEsYyxkKXtyZXR1cm4gYS5zZXRBdHRyaWJ1dGUoYyxkKX0sb2JqZWN0OmZ1bmN0aW9uKGEsYyxkKXtyZXR1cm4gYVtjXT1kfSx0cmFuc2Zvcm06ZnVuY3Rpb24oYSxjLGQsYixmKXtiW2ZdfHwoYltmXT1bXSk7YltmXS5wdXNoKGMrXCIoXCIrZCtcIilcIil9fSx2PVtdLEI9MCxpYT1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoKXtCPXJlcXVlc3RBbmltYXRpb25GcmFtZShjKX1mdW5jdGlvbiBjKGMpe3ZhciBiPXYubGVuZ3RoO2lmKGIpe2Zvcih2YXIgZD0wO2Q8YjspdltkXSYmdltkXS50aWNrKGMpLGQrKzthKCl9ZWxzZSBjYW5jZWxBbmltYXRpb25GcmFtZShCKSxCPTB9cmV0dXJuIGF9KCk7cS52ZXJzaW9uPVwiMi4yLjBcIjtxLnNwZWVkPTE7cS5ydW5uaW5nPXY7cS5yZW1vdmU9XG5mdW5jdGlvbihhKXthPVAoYSk7Zm9yKHZhciBjPXYubGVuZ3RoO2MtLTspZm9yKHZhciBkPXZbY10sYj1kLmFuaW1hdGlvbnMsZj1iLmxlbmd0aDtmLS07KXUoYSxiW2ZdLmFuaW1hdGFibGUudGFyZ2V0KSYmKGIuc3BsaWNlKGYsMSksYi5sZW5ndGh8fGQucGF1c2UoKSl9O3EuZ2V0VmFsdWU9SztxLnBhdGg9ZnVuY3Rpb24oYSxjKXt2YXIgZD1oLnN0cihhKT9lKGEpWzBdOmEsYj1jfHwxMDA7cmV0dXJuIGZ1bmN0aW9uKGEpe3JldHVybntlbDpkLHByb3BlcnR5OmEsdG90YWxMZW5ndGg6TihkKSooYi8xMDApfX19O3Euc2V0RGFzaG9mZnNldD1mdW5jdGlvbihhKXt2YXIgYz1OKGEpO2Euc2V0QXR0cmlidXRlKFwic3Ryb2tlLWRhc2hhcnJheVwiLGMpO3JldHVybiBjfTtxLmJlemllcj1BO3EuZWFzaW5ncz1RO3EudGltZWxpbmU9ZnVuY3Rpb24oYSl7dmFyIGM9cShhKTtjLnBhdXNlKCk7Yy5kdXJhdGlvbj0wO2MuYWRkPWZ1bmN0aW9uKGQpe2MuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihhKXthLmJlZ2FuPVxuITA7YS5jb21wbGV0ZWQ9ITB9KTttKGQpLmZvckVhY2goZnVuY3Rpb24oYil7dmFyIGQ9eihiLEQoUyxhfHx7fSkpO2QudGFyZ2V0cz1kLnRhcmdldHN8fGEudGFyZ2V0cztiPWMuZHVyYXRpb247dmFyIGU9ZC5vZmZzZXQ7ZC5hdXRvcGxheT0hMTtkLmRpcmVjdGlvbj1jLmRpcmVjdGlvbjtkLm9mZnNldD1oLnVuZChlKT9iOkwoZSxiKTtjLmJlZ2FuPSEwO2MuY29tcGxldGVkPSEwO2Muc2VlayhkLm9mZnNldCk7ZD1xKGQpO2QuYmVnYW49ITA7ZC5jb21wbGV0ZWQ9ITA7ZC5kdXJhdGlvbj5iJiYoYy5kdXJhdGlvbj1kLmR1cmF0aW9uKTtjLmNoaWxkcmVuLnB1c2goZCl9KTtjLnNlZWsoMCk7Yy5yZXNldCgpO2MuYXV0b3BsYXkmJmMucmVzdGFydCgpO3JldHVybiBjfTtyZXR1cm4gY307cS5yYW5kb209ZnVuY3Rpb24oYSxjKXtyZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKihjLWErMSkpK2F9O3JldHVybiBxfSk7IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2FycmF5L2Zyb21cIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vbWF0aC9zaWduXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL21hdGgvdHJ1bmNcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vbnVtYmVyL2lzLW5hblwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9udW1iZXIvbWF4LXNhZmUtaW50ZWdlclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbFwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9pdGVyYXRvciA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvclwiKTtcblxudmFyIF9pdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pdGVyYXRvcik7XG5cbnZhciBfc3ltYm9sID0gcmVxdWlyZShcIi4uL2NvcmUtanMvc3ltYm9sXCIpO1xuXG52YXIgX3N5bWJvbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zeW1ib2wpO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIF9pdGVyYXRvcjIuZGVmYXVsdCA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgJiYgb2JqICE9PSBfc3ltYm9sMi5kZWZhdWx0LnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIF90eXBlb2YoX2l0ZXJhdG9yMi5kZWZhdWx0KSA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCAmJiBvYmogIT09IF9zeW1ib2wyLmRlZmF1bHQucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopO1xufTsiLCIhZnVuY3Rpb24oZSx0KXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQpZGVmaW5lKFtcImV4cG9ydHNcIl0sdCk7ZWxzZSBpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgZXhwb3J0cyl0KGV4cG9ydHMpO2Vsc2V7dmFyIG89e307dChvKSxlLmJvZHlTY3JvbGxMb2NrPW99fSh0aGlzLGZ1bmN0aW9uKGV4cG9ydHMpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSl7aWYoQXJyYXkuaXNBcnJheShlKSl7Zm9yKHZhciB0PTAsbz1BcnJheShlLmxlbmd0aCk7dDxlLmxlbmd0aDt0Kyspb1t0XT1lW3RdO3JldHVybiBvfXJldHVybiBBcnJheS5mcm9tKGUpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBsPSExO2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cpe3ZhciBlPXtnZXQgcGFzc2l2ZSgpe2w9ITB9fTt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRlc3RQYXNzaXZlXCIsbnVsbCxlKSx3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRlc3RQYXNzaXZlXCIsbnVsbCxlKX12YXIgZD1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3cubmF2aWdhdG9yJiZ3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtJiYvaVAoYWR8aG9uZXxvZCkvLnRlc3Qod2luZG93Lm5hdmlnYXRvci5wbGF0Zm9ybSksYz1bXSx1PSExLGE9LTEscz12b2lkIDAsdj12b2lkIDAsZj1mdW5jdGlvbih0KXtyZXR1cm4gYy5zb21lKGZ1bmN0aW9uKGUpe3JldHVybiEoIWUub3B0aW9ucy5hbGxvd1RvdWNoTW92ZXx8IWUub3B0aW9ucy5hbGxvd1RvdWNoTW92ZSh0KSl9KX0sbT1mdW5jdGlvbihlKXt2YXIgdD1lfHx3aW5kb3cuZXZlbnQ7cmV0dXJuISFmKHQudGFyZ2V0KXx8KDE8dC50b3VjaGVzLmxlbmd0aHx8KHQucHJldmVudERlZmF1bHQmJnQucHJldmVudERlZmF1bHQoKSwhMSkpfSxvPWZ1bmN0aW9uKCl7c2V0VGltZW91dChmdW5jdGlvbigpe3ZvaWQgMCE9PXYmJihkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodD12LHY9dm9pZCAwKSx2b2lkIDAhPT1zJiYoZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdz1zLHM9dm9pZCAwKX0pfTtleHBvcnRzLmRpc2FibGVCb2R5U2Nyb2xsPWZ1bmN0aW9uKGksZSl7aWYoZCl7aWYoIWkpcmV0dXJuIHZvaWQgY29uc29sZS5lcnJvcihcImRpc2FibGVCb2R5U2Nyb2xsIHVuc3VjY2Vzc2Z1bCAtIHRhcmdldEVsZW1lbnQgbXVzdCBiZSBwcm92aWRlZCB3aGVuIGNhbGxpbmcgZGlzYWJsZUJvZHlTY3JvbGwgb24gSU9TIGRldmljZXMuXCIpO2lmKGkmJiFjLnNvbWUoZnVuY3Rpb24oZSl7cmV0dXJuIGUudGFyZ2V0RWxlbWVudD09PWl9KSl7dmFyIHQ9e3RhcmdldEVsZW1lbnQ6aSxvcHRpb25zOmV8fHt9fTtjPVtdLmNvbmNhdChyKGMpLFt0XSksaS5vbnRvdWNoc3RhcnQ9ZnVuY3Rpb24oZSl7MT09PWUudGFyZ2V0VG91Y2hlcy5sZW5ndGgmJihhPWUudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRZKX0saS5vbnRvdWNobW92ZT1mdW5jdGlvbihlKXt2YXIgdCxvLG4scjsxPT09ZS50YXJnZXRUb3VjaGVzLmxlbmd0aCYmKG89aSxyPSh0PWUpLnRhcmdldFRvdWNoZXNbMF0uY2xpZW50WS1hLCFmKHQudGFyZ2V0KSYmKG8mJjA9PT1vLnNjcm9sbFRvcCYmMDxyP20odCk6KG49bykmJm4uc2Nyb2xsSGVpZ2h0LW4uc2Nyb2xsVG9wPD1uLmNsaWVudEhlaWdodCYmcjwwP20odCk6dC5zdG9wUHJvcGFnYXRpb24oKSkpfSx1fHwoZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLG0sbD97cGFzc2l2ZTohMX06dm9pZCAwKSx1PSEwKX19ZWxzZXtuPWUsc2V0VGltZW91dChmdW5jdGlvbigpe2lmKHZvaWQgMD09PXYpe3ZhciBlPSEhbiYmITA9PT1uLnJlc2VydmVTY3JvbGxCYXJHYXAsdD13aW5kb3cuaW5uZXJXaWR0aC1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7ZSYmMDx0JiYodj1kb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodCxkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodD10K1wicHhcIil9dm9pZCAwPT09cyYmKHM9ZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyxkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93PVwiaGlkZGVuXCIpfSk7dmFyIG89e3RhcmdldEVsZW1lbnQ6aSxvcHRpb25zOmV8fHt9fTtjPVtdLmNvbmNhdChyKGMpLFtvXSl9dmFyIG59LGV4cG9ydHMuY2xlYXJBbGxCb2R5U2Nyb2xsTG9ja3M9ZnVuY3Rpb24oKXtkPyhjLmZvckVhY2goZnVuY3Rpb24oZSl7ZS50YXJnZXRFbGVtZW50Lm9udG91Y2hzdGFydD1udWxsLGUudGFyZ2V0RWxlbWVudC5vbnRvdWNobW92ZT1udWxsfSksdSYmKGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIixtLGw/e3Bhc3NpdmU6ITF9OnZvaWQgMCksdT0hMSksYz1bXSxhPS0xKToobygpLGM9W10pfSxleHBvcnRzLmVuYWJsZUJvZHlTY3JvbGw9ZnVuY3Rpb24odCl7aWYoZCl7aWYoIXQpcmV0dXJuIHZvaWQgY29uc29sZS5lcnJvcihcImVuYWJsZUJvZHlTY3JvbGwgdW5zdWNjZXNzZnVsIC0gdGFyZ2V0RWxlbWVudCBtdXN0IGJlIHByb3ZpZGVkIHdoZW4gY2FsbGluZyBlbmFibGVCb2R5U2Nyb2xsIG9uIElPUyBkZXZpY2VzLlwiKTt0Lm9udG91Y2hzdGFydD1udWxsLHQub250b3VjaG1vdmU9bnVsbCxjPWMuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBlLnRhcmdldEVsZW1lbnQhPT10fSksdSYmMD09PWMubGVuZ3RoJiYoZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLG0sbD97cGFzc2l2ZTohMX06dm9pZCAwKSx1PSExKX1lbHNlIDE9PT1jLmxlbmd0aCYmY1swXS50YXJnZXRFbGVtZW50PT09dD8obygpLGM9W10pOmM9Yy5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGUudGFyZ2V0RWxlbWVudCE9PXR9KX19KTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuYXJyYXkuZnJvbScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuQXJyYXkuZnJvbTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm1hdGguc2lnbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuTWF0aC5zaWduO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYubWF0aC50cnVuYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuTWF0aC50cnVuYztcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm51bWJlci5pcy1uYW4nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk51bWJlci5pc05hTjtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm51bWJlci5tYXgtc2FmZS1pbnRlZ2VyJyk7XG5tb2R1bGUuZXhwb3J0cyA9IDB4MWZmZmZmZmZmZmZmZmY7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3QuYXNzaWduO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3ltYm9sJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5TeW1ib2w7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL193a3MtZXh0JykuZignaXRlcmF0b3InKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcbiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG4iLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBBUkcgPSBjb2YoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG4iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi42LjUnIH07XG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgaW5kZXgsIHZhbHVlKSB7XG4gIGlmIChpbmRleCBpbiBvYmplY3QpICRkZWZpbmVQcm9wZXJ0eS5mKG9iamVjdCwgaW5kZXgsIGNyZWF0ZURlc2MoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbaW5kZXhdID0gdmFsdWU7XG59O1xuIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG4iLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcbiIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IGdldEtleXMoaXQpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYgKGdldFN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpO1xuICAgIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAoc3ltYm9scy5sZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBzb3VyY2UpIHtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkY7XG4gIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xuICB2YXIgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuUztcbiAgdmFyIElTX1BST1RPID0gdHlwZSAmICRleHBvcnQuUDtcbiAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xuICB2YXIgSVNfV1JBUCA9IHR5cGUgJiAkZXhwb3J0Llc7XG4gIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSk7XG4gIHZhciBleHBQcm90byA9IGV4cG9ydHNbUFJPVE9UWVBFXTtcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV07XG4gIHZhciBrZXksIG93biwgb3V0O1xuICBpZiAoSVNfR0xPQkFMKSBzb3VyY2UgPSBuYW1lO1xuICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChvd24gJiYgaGFzKGV4cG9ydHMsIGtleSkpIGNvbnRpbnVlO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcbiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcbiAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbClcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxuICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24gKEMpIHtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBDKSB7XG4gICAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQygpO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQyhhLCBiKTtcbiAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTtcbiAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcbiAgICAgIHJldHVybiBGO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSVcbiAgICBpZiAoSVNfUFJPVE8pIHtcbiAgICAgIChleHBvcnRzLnZpcnR1YWwgfHwgKGV4cG9ydHMudmlydHVhbCA9IHt9KSlba2V5XSA9IG91dDtcbiAgICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5wcm90b3R5cGUuJU5BTUUlXG4gICAgICBpZiAodHlwZSAmICRleHBvcnQuUiAmJiBleHBQcm90byAmJiAhZXhwUHJvdG9ba2V5XSkgaGlkZShleHBQcm90bywga2V5LCBvdXQpO1xuICAgIH1cbiAgfVxufTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSBfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG4iLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG4iLCJ2YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuIiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcbiIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG4iLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcbiIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG4iLCIvLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIGVudHJpZXMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIHJldCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIGFuT2JqZWN0KHJldC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyICRpdGVyQ3JlYXRlID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBCVUdHWSA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKTsgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxudmFyIEZGX0lURVJBVE9SID0gJ0BAaXRlcmF0b3InO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uIChraW5kKSB7XG4gICAgaWYgKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKSByZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFUztcbiAgdmFyIFZBTFVFU19CVUcgPSBmYWxzZTtcbiAgdmFyIHByb3RvID0gQmFzZS5wcm90b3R5cGU7XG4gIHZhciAkbmF0aXZlID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdO1xuICB2YXIgJGRlZmF1bHQgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKTtcbiAgdmFyICRlbnRyaWVzID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZDtcbiAgdmFyICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlO1xuICB2YXIgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZiAoJGFueU5hdGl2ZSkge1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKCkpKTtcbiAgICBpZiAoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgSXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmICghTElCUkFSWSAmJiB0eXBlb2YgSXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdICE9ICdmdW5jdGlvbicpIGhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZiAoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmICgoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSkge1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gPSByZXR1cm5UaGlzO1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChrZXkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKCEoa2V5IGluIHByb3RvKSkgcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTtcbiIsInZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uICgpIHsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjLCBza2lwQ2xvc2luZykge1xuICBpZiAoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gWzddO1xuICAgIHZhciBpdGVyID0gYXJyW0lURVJBVE9SXSgpO1xuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHsgZG9uZTogc2FmZSA9IHRydWUgfTsgfTtcbiAgICBhcnJbSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gc2FmZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb25lLCB2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZSB9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge307XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHRydWU7XG4iLCIvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbiBzaWduKHgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICByZXR1cm4gKHggPSAreCkgPT0gMCB8fCB4ICE9IHggPyB4IDogeCA8IDAgPyAtMSA6IDE7XG59O1xuIiwidmFyIE1FVEEgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgc2V0RGVzYyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaWQgPSAwO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uIChpdCkge1xuICBzZXREZXNjKGl0LCBNRVRBLCB7IHZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSB9KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9IHJldHVybiBpdFtNRVRBXS5pO1xufTtcbnZhciBnZXRXZWFrID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiB0cnVlO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpIHNldE1ldGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgS0VZOiBNRVRBLFxuICBORUVEOiBmYWxzZSxcbiAgZmFzdEtleTogZmFzdEtleSxcbiAgZ2V0V2VhazogZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBTID0gU3ltYm9sKCk7XG4gIHZhciBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGspIHsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgPSB0b09iamVjdCh0YXJnZXQpO1xuICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICB2YXIgaXNFbnVtID0gcElFLmY7XG4gIHdoaWxlIChhTGVuID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSBpZiAoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSkgVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG4iLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGRQcyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpO1xuICB2YXIgaSA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBkUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG4gIHZhciBQO1xuICB3aGlsZSAobGVuZ3RoID4gaSkgZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXMoTywgUCkpIHJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07XG4iLCIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcbiAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uIChpdCkge1xuICB0cnkge1xuICAgIHJldHVybiBnT1BOKGl0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBnT1BOKHRvSU9iamVjdChpdCkpO1xufTtcbiIsIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG4iLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuIiwiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKE8pIHtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZiAoaGFzKE8sIElFX1BST1RPKSkgcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZiAodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07XG4iLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG4iLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbiIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgdGFnLCBzdGF0KSB7XG4gIGlmIChpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKSBkZWYoaXQsIFRBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWcgfSk7XG59O1xuIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG4iLCJ2YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gIHZlcnNpb246IGNvcmUudmVyc2lvbixcbiAgbW9kZTogcmVxdWlyZSgnLi9fbGlicmFyeScpID8gJ3B1cmUnIDogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMTkgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknXG59KTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUT19TVFJJTkcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBwb3MpIHtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbiAgICB2YXIgaSA9IHRvSW50ZWdlcihwb3MpO1xuICAgIHZhciBsID0gcy5sZW5ndGg7XG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKGkgPCAwIHx8IGkgPj0gbCkgcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcbiIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgUykge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICh0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG4iLCJ2YXIgaWQgPSAwO1xudmFyIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgd2tzRXh0ID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcbiAgaWYgKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpIGRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHsgdmFsdWU6IHdrc0V4dC5mKG5hbWUpIH0pO1xufTtcbiIsImV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX3drcycpO1xuIiwidmFyIHN0b3JlID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbDtcbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpO1xudmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcbnZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uIChpdGVyKSB7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UgLyogLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBtYXBmbiA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBpdGVyRm4gPSBnZXRJdGVyRm4oTyk7XG4gICAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZiAobWFwcGluZykgbWFwZm4gPSBjdHgobWFwZm4sIGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkLCAyKTtcbiAgICAvLyBpZiBvYmplY3QgaXNuJ3QgaXRlcmFibGUgb3IgaXQncyBhcnJheSB3aXRoIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2Ugc2ltcGxlIGNhc2VcbiAgICBpZiAoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXIoaXRlckZuKSkpIHtcbiAgICAgIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgcmVzdWx0ID0gbmV3IEMoKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKSB7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBjYWxsKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgICAgZm9yIChyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKTtcbnZhciBzdGVwID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAvLyBraW5kXG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIga2luZCA9IHRoaXMuX2s7XG4gIHZhciBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYgKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKSB7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcbiAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcbiIsIi8vIDIwLjIuMi4yOCBNYXRoLnNpZ24oeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHsgc2lnbjogcmVxdWlyZSgnLi9fbWF0aC1zaWduJykgfSk7XG4iLCIvLyAyMC4yLjIuMzQgTWF0aC50cnVuYyh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICB0cnVuYzogZnVuY3Rpb24gdHJ1bmMoaXQpIHtcbiAgICByZXR1cm4gKGl0ID4gMCA/IE1hdGguZmxvb3IgOiBNYXRoLmNlaWwpKGl0KTtcbiAgfVxufSk7XG4iLCIvLyAyMC4xLjIuNCBOdW1iZXIuaXNOYU4obnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzTmFOOiBmdW5jdGlvbiBpc05hTihudW1iZXIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgcmV0dXJuIG51bWJlciAhPSBudW1iZXI7XG4gIH1cbn0pO1xuIiwiLy8gMjAuMS4yLjYgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywgeyBNQVhfU0FGRV9JTlRFR0VSOiAweDFmZmZmZmZmZmZmZmZmIH0pO1xuIiwiLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0JywgeyBhc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKSB9KTtcbiIsIiIsIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBpbmRleCA9IHRoaXMuX2k7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IE8ubGVuZ3RoKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7IHZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2UgfTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIE1FVEEgPSByZXF1aXJlKCcuL19tZXRhJykuS0VZO1xudmFyICRmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcbnZhciB3a3NEZWZpbmUgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJyk7XG52YXIgZW51bUtleXMgPSByZXF1aXJlKCcuL19lbnVtLWtleXMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBfY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGdPUE5FeHQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKTtcbnZhciAkR09QRCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJyk7XG52YXIgJERQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUEQgPSAkR09QRC5mO1xudmFyIGRQID0gJERQLmY7XG52YXIgZ09QTiA9IGdPUE5FeHQuZjtcbnZhciAkU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciAkSlNPTiA9IGdsb2JhbC5KU09OO1xudmFyIF9zdHJpbmdpZnkgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgSElEREVOID0gd2tzKCdfaGlkZGVuJyk7XG52YXIgVE9fUFJJTUlUSVZFID0gd2tzKCd0b1ByaW1pdGl2ZScpO1xudmFyIGlzRW51bSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKTtcbnZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7XG52YXIgT1BTeW1ib2xzID0gc2hhcmVkKCdvcC1zeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3RbUFJPVE9UWVBFXTtcbnZhciBVU0VfTkFUSVZFID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcbnZhciBRT2JqZWN0ID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBzZXR0ZXIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZFAodGhpcywgJ2EnLCB7IHZhbHVlOiA3IH0pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24gKGl0LCBrZXksIEQpIHtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmIChwcm90b0Rlc2MpIGRlbGV0ZSBPYmplY3RQcm90b1trZXldO1xuICBkUChpdCwga2V5LCBEKTtcbiAgaWYgKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pIGRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogZFA7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24gKHRhZykge1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCkge1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvKSAkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpO1xuICBhbk9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEQpO1xuICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSkpIHtcbiAgICBpZiAoIUQuZW51bWVyYWJsZSkge1xuICAgICAgaWYgKCFoYXMoaXQsIEhJRERFTikpIGRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSBpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHsgZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSkgfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gZFAoaXQsIGtleSwgRCk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCkge1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSk7XG4gIHZhciBpID0gMDtcbiAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGwgPiBpKSAkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKSB7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KSB7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XG4gIGlmICh0aGlzID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICBpdCA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybjtcbiAgdmFyIEQgPSBnT1BEKGl0LCBrZXkpO1xuICBpZiAoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKSBELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHZhciBuYW1lcyA9IGdPUE4odG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmICghaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4gJiYga2V5ICE9IE1FVEEpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkge1xuICB2YXIgSVNfT1AgPSBpdCA9PT0gT2JqZWN0UHJvdG87XG4gIHZhciBuYW1lcyA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG8sIGtleSkgOiB0cnVlKSkgcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpIHRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICAgIHZhciAkc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8pICRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmIChoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKSB0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmIChERVNDUklQVE9SUyAmJiBzZXR0ZXIpIHNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldCB9KTtcbiAgICByZXR1cm4gd3JhcCh0YWcpO1xuICB9O1xuICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgPSAkZGVmaW5lUHJvcGVydHk7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZiA9IGdPUE5FeHQuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZiA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZiAoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vX2xpYnJhcnknKSkge1xuICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG5cbiAgd2tzRXh0LmYgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgU3ltYm9sOiAkU3ltYm9sIH0pO1xuXG5mb3IgKHZhciBlczZTeW1ib2xzID0gKFxuICAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNFxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4pLnNwbGl0KCcsJyksIGogPSAwOyBlczZTeW1ib2xzLmxlbmd0aCA+IGo7KXdrcyhlczZTeW1ib2xzW2orK10pO1xuXG5mb3IgKHZhciB3ZWxsS25vd25TeW1ib2xzID0gJGtleXMod2tzLnN0b3JlKSwgayA9IDA7IHdlbGxLbm93blN5bWJvbHMubGVuZ3RoID4gazspIHdrc0RlZmluZSh3ZWxsS25vd25TeW1ib2xzW2srK10pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnU3ltYm9sJywge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKHN5bSkge1xuICAgIGlmICghaXNTeW1ib2woc3ltKSkgdGhyb3cgVHlwZUVycm9yKHN5bSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuICAgIGZvciAodmFyIGtleSBpbiBTeW1ib2xSZWdpc3RyeSkgaWYgKFN5bWJvbFJlZ2lzdHJ5W2tleV0gPT09IHN5bSkgcmV0dXJuIGtleTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBTID0gJFN5bWJvbCgpO1xuICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgcmV0dXJuIF9zdHJpbmdpZnkoW1NdKSAhPSAnW251bGxdJyB8fCBfc3RyaW5naWZ5KHsgYTogUyB9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xufSkpLCAnSlNPTicsIHtcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpIHtcbiAgICB2YXIgYXJncyA9IFtpdF07XG4gICAgdmFyIGkgPSAxO1xuICAgIHZhciByZXBsYWNlciwgJHJlcGxhY2VyO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICAkcmVwbGFjZXIgPSByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYgKCFpc09iamVjdChyZXBsYWNlcikgJiYgaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpIHJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICAgIGlmICghaXNBcnJheShyZXBsYWNlcikpIHJlcGxhY2VyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgJHJlcGxhY2VyID09ICdmdW5jdGlvbicpIHZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZiAoIWlzU3ltYm9sKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTtcbiAgfVxufSk7XG5cbi8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludClcbiRTeW1ib2xbUFJPVE9UWVBFXVtUT19QUklNSVRJVkVdIHx8IHJlcXVpcmUoJy4vX2hpZGUnKSgkU3ltYm9sW1BST1RPVFlQRV0sIFRPX1BSSU1JVElWRSwgJFN5bWJvbFtQUk9UT1RZUEVdLnZhbHVlT2YpO1xuLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcbi8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhnbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTtcbiIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnYXN5bmNJdGVyYXRvcicpO1xuIiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdvYnNlcnZhYmxlJyk7XG4iLCJyZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG52YXIgRE9NSXRlcmFibGVzID0gKCdDU1NSdWxlTGlzdCxDU1NTdHlsZURlY2xhcmF0aW9uLENTU1ZhbHVlTGlzdCxDbGllbnRSZWN0TGlzdCxET01SZWN0TGlzdCxET01TdHJpbmdMaXN0LCcgK1xuICAnRE9NVG9rZW5MaXN0LERhdGFUcmFuc2Zlckl0ZW1MaXN0LEZpbGVMaXN0LEhUTUxBbGxDb2xsZWN0aW9uLEhUTUxDb2xsZWN0aW9uLEhUTUxGb3JtRWxlbWVudCxIVE1MU2VsZWN0RWxlbWVudCwnICtcbiAgJ01lZGlhTGlzdCxNaW1lVHlwZUFycmF5LE5hbWVkTm9kZU1hcCxOb2RlTGlzdCxQYWludFJlcXVlc3RMaXN0LFBsdWdpbixQbHVnaW5BcnJheSxTVkdMZW5ndGhMaXN0LFNWR051bWJlckxpc3QsJyArXG4gICdTVkdQYXRoU2VnTGlzdCxTVkdQb2ludExpc3QsU1ZHU3RyaW5nTGlzdCxTVkdUcmFuc2Zvcm1MaXN0LFNvdXJjZUJ1ZmZlckxpc3QsU3R5bGVTaGVldExpc3QsVGV4dFRyYWNrQ3VlTGlzdCwnICtcbiAgJ1RleHRUcmFja0xpc3QsVG91Y2hMaXN0Jykuc3BsaXQoJywnKTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCBET01JdGVyYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgdmFyIE5BTUUgPSBET01JdGVyYWJsZXNbaV07XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdO1xuICB2YXIgcHJvdG8gPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICBpZiAocHJvdG8gJiYgIXByb3RvW1RPX1NUUklOR19UQUddKSBoaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgSXRlcmF0b3JzW05BTUVdID0gSXRlcmF0b3JzLkFycmF5O1xufVxuIiwiLyogZmxhdHBpY2tyIHY0LjUuNywgQGxpY2Vuc2UgTUlUICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLmZsYXRwaWNrciA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICAgIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG4gICAgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuICAgIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG4gICAgVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4gICAgS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG4gICAgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuICAgIE1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG4gICAgU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbiAgICBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuICAgIHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH07XG5cbiAgICB2YXIgSE9PS1MgPSBbXG4gICAgICAgIFwib25DaGFuZ2VcIixcbiAgICAgICAgXCJvbkNsb3NlXCIsXG4gICAgICAgIFwib25EYXlDcmVhdGVcIixcbiAgICAgICAgXCJvbkRlc3Ryb3lcIixcbiAgICAgICAgXCJvbktleURvd25cIixcbiAgICAgICAgXCJvbk1vbnRoQ2hhbmdlXCIsXG4gICAgICAgIFwib25PcGVuXCIsXG4gICAgICAgIFwib25QYXJzZUNvbmZpZ1wiLFxuICAgICAgICBcIm9uUmVhZHlcIixcbiAgICAgICAgXCJvblZhbHVlVXBkYXRlXCIsXG4gICAgICAgIFwib25ZZWFyQ2hhbmdlXCIsXG4gICAgICAgIFwib25QcmVDYWxlbmRhclBvc2l0aW9uXCIsXG4gICAgXTtcbiAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgIF9kaXNhYmxlOiBbXSxcbiAgICAgICAgX2VuYWJsZTogW10sXG4gICAgICAgIGFsbG93SW5wdXQ6IGZhbHNlLFxuICAgICAgICBhbHRGb3JtYXQ6IFwiRiBqLCBZXCIsXG4gICAgICAgIGFsdElucHV0OiBmYWxzZSxcbiAgICAgICAgYWx0SW5wdXRDbGFzczogXCJmb3JtLWNvbnRyb2wgaW5wdXRcIixcbiAgICAgICAgYW5pbWF0ZTogdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIk1TSUVcIikgPT09IC0xLFxuICAgICAgICBhcmlhRGF0ZUZvcm1hdDogXCJGIGosIFlcIixcbiAgICAgICAgY2xpY2tPcGVuczogdHJ1ZSxcbiAgICAgICAgY2xvc2VPblNlbGVjdDogdHJ1ZSxcbiAgICAgICAgY29uanVuY3Rpb246IFwiLCBcIixcbiAgICAgICAgZGF0ZUZvcm1hdDogXCJZLW0tZFwiLFxuICAgICAgICBkZWZhdWx0SG91cjogMTIsXG4gICAgICAgIGRlZmF1bHRNaW51dGU6IDAsXG4gICAgICAgIGRlZmF1bHRTZWNvbmRzOiAwLFxuICAgICAgICBkaXNhYmxlOiBbXSxcbiAgICAgICAgZGlzYWJsZU1vYmlsZTogZmFsc2UsXG4gICAgICAgIGVuYWJsZTogW10sXG4gICAgICAgIGVuYWJsZVNlY29uZHM6IGZhbHNlLFxuICAgICAgICBlbmFibGVUaW1lOiBmYWxzZSxcbiAgICAgICAgZXJyb3JIYW5kbGVyOiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKGVycik7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFdlZWs6IGZ1bmN0aW9uIChnaXZlbkRhdGUpIHtcbiAgICAgICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoZ2l2ZW5EYXRlLmdldFRpbWUoKSk7XG4gICAgICAgICAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgICAgICAgLy8gVGh1cnNkYXkgaW4gY3VycmVudCB3ZWVrIGRlY2lkZXMgdGhlIHllYXIuXG4gICAgICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyAzIC0gKChkYXRlLmdldERheSgpICsgNikgJSA3KSk7XG4gICAgICAgICAgICAvLyBKYW51YXJ5IDQgaXMgYWx3YXlzIGluIHdlZWsgMS5cbiAgICAgICAgICAgIHZhciB3ZWVrMSA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgNCk7XG4gICAgICAgICAgICAvLyBBZGp1c3QgdG8gVGh1cnNkYXkgaW4gd2VlayAxIGFuZCBjb3VudCBudW1iZXIgb2Ygd2Vla3MgZnJvbSBkYXRlIHRvIHdlZWsxLlxuICAgICAgICAgICAgcmV0dXJuICgxICtcbiAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKCgoZGF0ZS5nZXRUaW1lKCkgLSB3ZWVrMS5nZXRUaW1lKCkpIC8gODY0MDAwMDAgLVxuICAgICAgICAgICAgICAgICAgICAzICtcbiAgICAgICAgICAgICAgICAgICAgKCh3ZWVrMS5nZXREYXkoKSArIDYpICUgNykpIC9cbiAgICAgICAgICAgICAgICAgICAgNykpO1xuICAgICAgICB9LFxuICAgICAgICBob3VySW5jcmVtZW50OiAxLFxuICAgICAgICBpZ25vcmVkRm9jdXNFbGVtZW50czogW10sXG4gICAgICAgIGlubGluZTogZmFsc2UsXG4gICAgICAgIGxvY2FsZTogXCJkZWZhdWx0XCIsXG4gICAgICAgIG1pbnV0ZUluY3JlbWVudDogNSxcbiAgICAgICAgbW9kZTogXCJzaW5nbGVcIixcbiAgICAgICAgbmV4dEFycm93OiBcIjxzdmcgdmVyc2lvbj0nMS4xJyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHhtbG5zOnhsaW5rPSdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyB2aWV3Qm94PScwIDAgMTcgMTcnPjxnPjwvZz48cGF0aCBkPSdNMTMuMjA3IDguNDcybC03Ljg1NCA3Ljg1NC0wLjcwNy0wLjcwNyA3LjE0Ni03LjE0Ni03LjE0Ni03LjE0OCAwLjcwNy0wLjcwNyA3Ljg1NCA3Ljg1NHonIC8+PC9zdmc+XCIsXG4gICAgICAgIG5vQ2FsZW5kYXI6IGZhbHNlLFxuICAgICAgICBub3c6IG5ldyBEYXRlKCksXG4gICAgICAgIG9uQ2hhbmdlOiBbXSxcbiAgICAgICAgb25DbG9zZTogW10sXG4gICAgICAgIG9uRGF5Q3JlYXRlOiBbXSxcbiAgICAgICAgb25EZXN0cm95OiBbXSxcbiAgICAgICAgb25LZXlEb3duOiBbXSxcbiAgICAgICAgb25Nb250aENoYW5nZTogW10sXG4gICAgICAgIG9uT3BlbjogW10sXG4gICAgICAgIG9uUGFyc2VDb25maWc6IFtdLFxuICAgICAgICBvblJlYWR5OiBbXSxcbiAgICAgICAgb25WYWx1ZVVwZGF0ZTogW10sXG4gICAgICAgIG9uWWVhckNoYW5nZTogW10sXG4gICAgICAgIG9uUHJlQ2FsZW5kYXJQb3NpdGlvbjogW10sXG4gICAgICAgIHBsdWdpbnM6IFtdLFxuICAgICAgICBwb3NpdGlvbjogXCJhdXRvXCIsXG4gICAgICAgIHBvc2l0aW9uRWxlbWVudDogdW5kZWZpbmVkLFxuICAgICAgICBwcmV2QXJyb3c6IFwiPHN2ZyB2ZXJzaW9uPScxLjEnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgeG1sbnM6eGxpbms9J2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnIHZpZXdCb3g9JzAgMCAxNyAxNyc+PGc+PC9nPjxwYXRoIGQ9J001LjIwNyA4LjQ3MWw3LjE0NiA3LjE0Ny0wLjcwNyAwLjcwNy03Ljg1My03Ljg1NCA3Ljg1NC03Ljg1MyAwLjcwNyAwLjcwNy03LjE0NyA3LjE0NnonIC8+PC9zdmc+XCIsXG4gICAgICAgIHNob3J0aGFuZEN1cnJlbnRNb250aDogZmFsc2UsXG4gICAgICAgIHNob3dNb250aHM6IDEsXG4gICAgICAgIHN0YXRpYzogZmFsc2UsXG4gICAgICAgIHRpbWVfMjRocjogZmFsc2UsXG4gICAgICAgIHdlZWtOdW1iZXJzOiBmYWxzZSxcbiAgICAgICAgd3JhcDogZmFsc2VcbiAgICB9O1xuXG4gICAgdmFyIGVuZ2xpc2ggPSB7XG4gICAgICAgIHdlZWtkYXlzOiB7XG4gICAgICAgICAgICBzaG9ydGhhbmQ6IFtcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiXSxcbiAgICAgICAgICAgIGxvbmdoYW5kOiBbXG4gICAgICAgICAgICAgICAgXCJTdW5kYXlcIixcbiAgICAgICAgICAgICAgICBcIk1vbmRheVwiLFxuICAgICAgICAgICAgICAgIFwiVHVlc2RheVwiLFxuICAgICAgICAgICAgICAgIFwiV2VkbmVzZGF5XCIsXG4gICAgICAgICAgICAgICAgXCJUaHVyc2RheVwiLFxuICAgICAgICAgICAgICAgIFwiRnJpZGF5XCIsXG4gICAgICAgICAgICAgICAgXCJTYXR1cmRheVwiLFxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBtb250aHM6IHtcbiAgICAgICAgICAgIHNob3J0aGFuZDogW1xuICAgICAgICAgICAgICAgIFwiSmFuXCIsXG4gICAgICAgICAgICAgICAgXCJGZWJcIixcbiAgICAgICAgICAgICAgICBcIk1hclwiLFxuICAgICAgICAgICAgICAgIFwiQXByXCIsXG4gICAgICAgICAgICAgICAgXCJNYXlcIixcbiAgICAgICAgICAgICAgICBcIkp1blwiLFxuICAgICAgICAgICAgICAgIFwiSnVsXCIsXG4gICAgICAgICAgICAgICAgXCJBdWdcIixcbiAgICAgICAgICAgICAgICBcIlNlcFwiLFxuICAgICAgICAgICAgICAgIFwiT2N0XCIsXG4gICAgICAgICAgICAgICAgXCJOb3ZcIixcbiAgICAgICAgICAgICAgICBcIkRlY1wiLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGxvbmdoYW5kOiBbXG4gICAgICAgICAgICAgICAgXCJKYW51YXJ5XCIsXG4gICAgICAgICAgICAgICAgXCJGZWJydWFyeVwiLFxuICAgICAgICAgICAgICAgIFwiTWFyY2hcIixcbiAgICAgICAgICAgICAgICBcIkFwcmlsXCIsXG4gICAgICAgICAgICAgICAgXCJNYXlcIixcbiAgICAgICAgICAgICAgICBcIkp1bmVcIixcbiAgICAgICAgICAgICAgICBcIkp1bHlcIixcbiAgICAgICAgICAgICAgICBcIkF1Z3VzdFwiLFxuICAgICAgICAgICAgICAgIFwiU2VwdGVtYmVyXCIsXG4gICAgICAgICAgICAgICAgXCJPY3RvYmVyXCIsXG4gICAgICAgICAgICAgICAgXCJOb3ZlbWJlclwiLFxuICAgICAgICAgICAgICAgIFwiRGVjZW1iZXJcIixcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgZGF5c0luTW9udGg6IFszMSwgMjgsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXSxcbiAgICAgICAgZmlyc3REYXlPZldlZWs6IDAsXG4gICAgICAgIG9yZGluYWw6IGZ1bmN0aW9uIChudGgpIHtcbiAgICAgICAgICAgIHZhciBzID0gbnRoICUgMTAwO1xuICAgICAgICAgICAgaWYgKHMgPiAzICYmIHMgPCAyMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ0aFwiO1xuICAgICAgICAgICAgc3dpdGNoIChzICUgMTApIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInN0XCI7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJuZFwiO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicmRcIjtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ0aFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByYW5nZVNlcGFyYXRvcjogXCIgdG8gXCIsXG4gICAgICAgIHdlZWtBYmJyZXZpYXRpb246IFwiV2tcIixcbiAgICAgICAgc2Nyb2xsVGl0bGU6IFwiU2Nyb2xsIHRvIGluY3JlbWVudFwiLFxuICAgICAgICB0b2dnbGVUaXRsZTogXCJDbGljayB0byB0b2dnbGVcIixcbiAgICAgICAgYW1QTTogW1wiQU1cIiwgXCJQTVwiXSxcbiAgICAgICAgeWVhckFyaWFMYWJlbDogXCJZZWFyXCJcbiAgICB9O1xuXG4gICAgdmFyIHBhZCA9IGZ1bmN0aW9uIChudW1iZXIpIHsgcmV0dXJuIChcIjBcIiArIG51bWJlcikuc2xpY2UoLTIpOyB9O1xuICAgIHZhciBpbnQgPSBmdW5jdGlvbiAoYm9vbCkgeyByZXR1cm4gKGJvb2wgPT09IHRydWUgPyAxIDogMCk7IH07XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICAgICAgaWYgKGltbWVkaWF0ZSA9PT0gdm9pZCAwKSB7IGltbWVkaWF0ZSA9IGZhbHNlOyB9XG4gICAgICAgIHZhciB0aW1lb3V0O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgdGltZW91dCAhPT0gbnVsbCAmJiBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghaW1tZWRpYXRlKVxuICAgICAgICAgICAgICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgfSwgd2FpdCk7XG4gICAgICAgICAgICBpZiAoaW1tZWRpYXRlICYmICF0aW1lb3V0KVxuICAgICAgICAgICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBhcnJheWlmeSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEFycmF5ID8gb2JqIDogW29ial07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGVsZW0sIGNsYXNzTmFtZSwgYm9vbCkge1xuICAgICAgICBpZiAoYm9vbCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgICAgZWxlbS5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnLCBjbGFzc05hbWUsIGNvbnRlbnQpIHtcbiAgICAgICAgdmFyIGUgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBjbGFzc05hbWUgPSBjbGFzc05hbWUgfHwgXCJcIjtcbiAgICAgICAgY29udGVudCA9IGNvbnRlbnQgfHwgXCJcIjtcbiAgICAgICAgZS5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgIGlmIChjb250ZW50ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBlLnRleHRDb250ZW50ID0gY29udGVudDtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFyTm9kZShub2RlKSB7XG4gICAgICAgIHdoaWxlIChub2RlLmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRQYXJlbnQobm9kZSwgY29uZGl0aW9uKSB7XG4gICAgICAgIGlmIChjb25kaXRpb24obm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZpbmRQYXJlbnQobm9kZS5wYXJlbnROb2RlLCBjb25kaXRpb24pO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBub3RoaW5nIGZvdW5kXG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU51bWJlcklucHV0KGlucHV0Q2xhc3NOYW1lLCBvcHRzKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcIm51bUlucHV0V3JhcHBlclwiKSwgbnVtSW5wdXQgPSBjcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgXCJudW1JbnB1dCBcIiArIGlucHV0Q2xhc3NOYW1lKSwgYXJyb3dVcCA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiYXJyb3dVcFwiKSwgYXJyb3dEb3duID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJhcnJvd0Rvd25cIik7XG4gICAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJNU0lFIDkuMFwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIG51bUlucHV0LnR5cGUgPSBcIm51bWJlclwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbnVtSW5wdXQudHlwZSA9IFwidGV4dFwiO1xuICAgICAgICAgICAgbnVtSW5wdXQucGF0dGVybiA9IFwiXFxcXGQqXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRzKVxuICAgICAgICAgICAgICAgIG51bUlucHV0LnNldEF0dHJpYnV0ZShrZXksIG9wdHNba2V5XSk7XG4gICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQobnVtSW5wdXQpO1xuICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGFycm93VXApO1xuICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGFycm93RG93bik7XG4gICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRFdmVudFRhcmdldChldmVudCkge1xuICAgICAgICBpZiAodHlwZW9mIGV2ZW50LmNvbXBvc2VkUGF0aCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IGV2ZW50LmNvbXBvc2VkUGF0aCgpO1xuICAgICAgICAgICAgcmV0dXJuIHBhdGhbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50LnRhcmdldDtcbiAgICB9XG5cbiAgICB2YXIgZG9fbm90aGluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfTtcbiAgICB2YXIgbW9udGhUb1N0ciA9IGZ1bmN0aW9uIChtb250aE51bWJlciwgc2hvcnRoYW5kLCBsb2NhbGUpIHsgcmV0dXJuIGxvY2FsZS5tb250aHNbc2hvcnRoYW5kID8gXCJzaG9ydGhhbmRcIiA6IFwibG9uZ2hhbmRcIl1bbW9udGhOdW1iZXJdOyB9O1xuICAgIHZhciByZXZGb3JtYXQgPSB7XG4gICAgICAgIEQ6IGRvX25vdGhpbmcsXG4gICAgICAgIEY6IGZ1bmN0aW9uIChkYXRlT2JqLCBtb250aE5hbWUsIGxvY2FsZSkge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRNb250aChsb2NhbGUubW9udGhzLmxvbmdoYW5kLmluZGV4T2YobW9udGhOYW1lKSk7XG4gICAgICAgIH0sXG4gICAgICAgIEc6IGZ1bmN0aW9uIChkYXRlT2JqLCBob3VyKSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldEhvdXJzKHBhcnNlRmxvYXQoaG91cikpO1xuICAgICAgICB9LFxuICAgICAgICBIOiBmdW5jdGlvbiAoZGF0ZU9iaiwgaG91cikge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRIb3VycyhwYXJzZUZsb2F0KGhvdXIpKTtcbiAgICAgICAgfSxcbiAgICAgICAgSjogZnVuY3Rpb24gKGRhdGVPYmosIGRheSkge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXREYXRlKHBhcnNlRmxvYXQoZGF5KSk7XG4gICAgICAgIH0sXG4gICAgICAgIEs6IGZ1bmN0aW9uIChkYXRlT2JqLCBhbVBNLCBsb2NhbGUpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0SG91cnMoKGRhdGVPYmouZ2V0SG91cnMoKSAlIDEyKSArXG4gICAgICAgICAgICAgICAgMTIgKiBpbnQobmV3IFJlZ0V4cChsb2NhbGUuYW1QTVsxXSwgXCJpXCIpLnRlc3QoYW1QTSkpKTtcbiAgICAgICAgfSxcbiAgICAgICAgTTogZnVuY3Rpb24gKGRhdGVPYmosIHNob3J0TW9udGgsIGxvY2FsZSkge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRNb250aChsb2NhbGUubW9udGhzLnNob3J0aGFuZC5pbmRleE9mKHNob3J0TW9udGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgUzogZnVuY3Rpb24gKGRhdGVPYmosIHNlY29uZHMpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0U2Vjb25kcyhwYXJzZUZsb2F0KHNlY29uZHMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgVTogZnVuY3Rpb24gKF8sIHVuaXhTZWNvbmRzKSB7IHJldHVybiBuZXcgRGF0ZShwYXJzZUZsb2F0KHVuaXhTZWNvbmRzKSAqIDEwMDApOyB9LFxuICAgICAgICBXOiBmdW5jdGlvbiAoZGF0ZU9iaiwgd2Vla051bSkge1xuICAgICAgICAgICAgdmFyIHdlZWtOdW1iZXIgPSBwYXJzZUludCh3ZWVrTnVtKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlT2JqLmdldEZ1bGxZZWFyKCksIDAsIDIgKyAod2Vla051bWJlciAtIDEpICogNywgMCwgMCwgMCwgMCk7XG4gICAgICAgIH0sXG4gICAgICAgIFk6IGZ1bmN0aW9uIChkYXRlT2JqLCB5ZWFyKSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldEZ1bGxZZWFyKHBhcnNlRmxvYXQoeWVhcikpO1xuICAgICAgICB9LFxuICAgICAgICBaOiBmdW5jdGlvbiAoXywgSVNPRGF0ZSkgeyByZXR1cm4gbmV3IERhdGUoSVNPRGF0ZSk7IH0sXG4gICAgICAgIGQ6IGZ1bmN0aW9uIChkYXRlT2JqLCBkYXkpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0RGF0ZShwYXJzZUZsb2F0KGRheSkpO1xuICAgICAgICB9LFxuICAgICAgICBoOiBmdW5jdGlvbiAoZGF0ZU9iaiwgaG91cikge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRIb3VycyhwYXJzZUZsb2F0KGhvdXIpKTtcbiAgICAgICAgfSxcbiAgICAgICAgaTogZnVuY3Rpb24gKGRhdGVPYmosIG1pbnV0ZXMpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0TWludXRlcyhwYXJzZUZsb2F0KG1pbnV0ZXMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgajogZnVuY3Rpb24gKGRhdGVPYmosIGRheSkge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXREYXRlKHBhcnNlRmxvYXQoZGF5KSk7XG4gICAgICAgIH0sXG4gICAgICAgIGw6IGRvX25vdGhpbmcsXG4gICAgICAgIG06IGZ1bmN0aW9uIChkYXRlT2JqLCBtb250aCkge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRNb250aChwYXJzZUZsb2F0KG1vbnRoKSAtIDEpO1xuICAgICAgICB9LFxuICAgICAgICBuOiBmdW5jdGlvbiAoZGF0ZU9iaiwgbW9udGgpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0TW9udGgocGFyc2VGbG9hdChtb250aCkgLSAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgczogZnVuY3Rpb24gKGRhdGVPYmosIHNlY29uZHMpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0U2Vjb25kcyhwYXJzZUZsb2F0KHNlY29uZHMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgdTogZnVuY3Rpb24gKF8sIHVuaXhNaWxsU2Vjb25kcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHBhcnNlRmxvYXQodW5peE1pbGxTZWNvbmRzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHc6IGRvX25vdGhpbmcsXG4gICAgICAgIHk6IGZ1bmN0aW9uIChkYXRlT2JqLCB5ZWFyKSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldEZ1bGxZZWFyKDIwMDAgKyBwYXJzZUZsb2F0KHllYXIpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHRva2VuUmVnZXggPSB7XG4gICAgICAgIEQ6IFwiKFxcXFx3KylcIixcbiAgICAgICAgRjogXCIoXFxcXHcrKVwiLFxuICAgICAgICBHOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuICAgICAgICBIOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuICAgICAgICBKOiBcIihcXFxcZFxcXFxkfFxcXFxkKVxcXFx3K1wiLFxuICAgICAgICBLOiBcIlwiLFxuICAgICAgICBNOiBcIihcXFxcdyspXCIsXG4gICAgICAgIFM6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICAgIFU6IFwiKC4rKVwiLFxuICAgICAgICBXOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuICAgICAgICBZOiBcIihcXFxcZHs0fSlcIixcbiAgICAgICAgWjogXCIoLispXCIsXG4gICAgICAgIGQ6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICAgIGg6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICAgIGk6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICAgIGo6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICAgIGw6IFwiKFxcXFx3KylcIixcbiAgICAgICAgbTogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgbjogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgczogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgdTogXCIoLispXCIsXG4gICAgICAgIHc6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICAgIHk6IFwiKFxcXFxkezJ9KVwiXG4gICAgfTtcbiAgICB2YXIgZm9ybWF0cyA9IHtcbiAgICAgICAgLy8gZ2V0IHRoZSBkYXRlIGluIFVUQ1xuICAgICAgICBaOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS50b0lTT1N0cmluZygpOyB9LFxuICAgICAgICAvLyB3ZWVrZGF5IG5hbWUsIHNob3J0LCBlLmcuIFRodVxuICAgICAgICBEOiBmdW5jdGlvbiAoZGF0ZSwgbG9jYWxlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzLnNob3J0aGFuZFtmb3JtYXRzLncoZGF0ZSwgbG9jYWxlLCBvcHRpb25zKV07XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGZ1bGwgbW9udGggbmFtZSBlLmcuIEphbnVhcnlcbiAgICAgICAgRjogZnVuY3Rpb24gKGRhdGUsIGxvY2FsZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIG1vbnRoVG9TdHIoZm9ybWF0cy5uKGRhdGUsIGxvY2FsZSwgb3B0aW9ucykgLSAxLCBmYWxzZSwgbG9jYWxlKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gcGFkZGVkIGhvdXIgMS0xMlxuICAgICAgICBHOiBmdW5jdGlvbiAoZGF0ZSwgbG9jYWxlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFkKGZvcm1hdHMuaChkYXRlLCBsb2NhbGUsIG9wdGlvbnMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gaG91cnMgd2l0aCBsZWFkaW5nIHplcm8gZS5nLiAwM1xuICAgICAgICBIOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gcGFkKGRhdGUuZ2V0SG91cnMoKSk7IH0sXG4gICAgICAgIC8vIGRheSAoMS0zMCkgd2l0aCBvcmRpbmFsIHN1ZmZpeCBlLmcuIDFzdCwgMm5kXG4gICAgICAgIEo6IGZ1bmN0aW9uIChkYXRlLCBsb2NhbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUub3JkaW5hbCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBkYXRlLmdldERhdGUoKSArIGxvY2FsZS5vcmRpbmFsKGRhdGUuZ2V0RGF0ZSgpKVxuICAgICAgICAgICAgICAgIDogZGF0ZS5nZXREYXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEFNL1BNXG4gICAgICAgIEs6IGZ1bmN0aW9uIChkYXRlLCBsb2NhbGUpIHsgcmV0dXJuIGxvY2FsZS5hbVBNW2ludChkYXRlLmdldEhvdXJzKCkgPiAxMSldOyB9LFxuICAgICAgICAvLyBzaG9ydGhhbmQgbW9udGggZS5nLiBKYW4sIFNlcCwgT2N0LCBldGNcbiAgICAgICAgTTogZnVuY3Rpb24gKGRhdGUsIGxvY2FsZSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vbnRoVG9TdHIoZGF0ZS5nZXRNb250aCgpLCB0cnVlLCBsb2NhbGUpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBzZWNvbmRzIDAwLTU5XG4gICAgICAgIFM6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBwYWQoZGF0ZS5nZXRTZWNvbmRzKCkpOyB9LFxuICAgICAgICAvLyB1bml4IHRpbWVzdGFtcFxuICAgICAgICBVOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS5nZXRUaW1lKCkgLyAxMDAwOyB9LFxuICAgICAgICBXOiBmdW5jdGlvbiAoZGF0ZSwgXywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZ2V0V2VlayhkYXRlKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gZnVsbCB5ZWFyIGUuZy4gMjAxNlxuICAgICAgICBZOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS5nZXRGdWxsWWVhcigpOyB9LFxuICAgICAgICAvLyBkYXkgaW4gbW9udGgsIHBhZGRlZCAoMDEtMzApXG4gICAgICAgIGQ6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBwYWQoZGF0ZS5nZXREYXRlKCkpOyB9LFxuICAgICAgICAvLyBob3VyIGZyb20gMS0xMiAoYW0vcG0pXG4gICAgICAgIGg6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiAoZGF0ZS5nZXRIb3VycygpICUgMTIgPyBkYXRlLmdldEhvdXJzKCkgJSAxMiA6IDEyKTsgfSxcbiAgICAgICAgLy8gbWludXRlcywgcGFkZGVkIHdpdGggbGVhZGluZyB6ZXJvIGUuZy4gMDlcbiAgICAgICAgaTogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIHBhZChkYXRlLmdldE1pbnV0ZXMoKSk7IH0sXG4gICAgICAgIC8vIGRheSBpbiBtb250aCAoMS0zMClcbiAgICAgICAgajogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0RGF0ZSgpOyB9LFxuICAgICAgICAvLyB3ZWVrZGF5IG5hbWUsIGZ1bGwsIGUuZy4gVGh1cnNkYXlcbiAgICAgICAgbDogZnVuY3Rpb24gKGRhdGUsIGxvY2FsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5cy5sb25naGFuZFtkYXRlLmdldERheSgpXTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gcGFkZGVkIG1vbnRoIG51bWJlciAoMDEtMTIpXG4gICAgICAgIG06IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBwYWQoZGF0ZS5nZXRNb250aCgpICsgMSk7IH0sXG4gICAgICAgIC8vIHRoZSBtb250aCBudW1iZXIgKDEtMTIpXG4gICAgICAgIG46IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLmdldE1vbnRoKCkgKyAxOyB9LFxuICAgICAgICAvLyBzZWNvbmRzIDAtNTlcbiAgICAgICAgczogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0U2Vjb25kcygpOyB9LFxuICAgICAgICAvLyBVbml4IE1pbGxpc2Vjb25kc1xuICAgICAgICB1OiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS5nZXRUaW1lKCk7IH0sXG4gICAgICAgIC8vIG51bWJlciBvZiB0aGUgZGF5IG9mIHRoZSB3ZWVrXG4gICAgICAgIHc6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLmdldERheSgpOyB9LFxuICAgICAgICAvLyBsYXN0IHR3byBkaWdpdHMgb2YgeWVhciBlLmcuIDE2IGZvciAyMDE2XG4gICAgICAgIHk6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBTdHJpbmcoZGF0ZS5nZXRGdWxsWWVhcigpKS5zdWJzdHJpbmcoMik7IH1cbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZURhdGVGb3JtYXR0ZXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX2EuY29uZmlnLCBjb25maWcgPSBfYiA9PT0gdm9pZCAwID8gZGVmYXVsdHMgOiBfYiwgX2MgPSBfYS5sMTBuLCBsMTBuID0gX2MgPT09IHZvaWQgMCA/IGVuZ2xpc2ggOiBfYztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlT2JqLCBmcm10LCBvdmVycmlkZUxvY2FsZSkge1xuICAgICAgICAgICAgdmFyIGxvY2FsZSA9IG92ZXJyaWRlTG9jYWxlIHx8IGwxMG47XG4gICAgICAgICAgICBpZiAoY29uZmlnLmZvcm1hdERhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25maWcuZm9ybWF0RGF0ZShkYXRlT2JqLCBmcm10LCBsb2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZybXRcbiAgICAgICAgICAgICAgICAuc3BsaXQoXCJcIilcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChjLCBpLCBhcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0c1tjXSAmJiBhcnJbaSAtIDFdICE9PSBcIlxcXFxcIlxuICAgICAgICAgICAgICAgICAgICA/IGZvcm1hdHNbY10oZGF0ZU9iaiwgbG9jYWxlLCBjb25maWcpXG4gICAgICAgICAgICAgICAgICAgIDogYyAhPT0gXCJcXFxcXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuam9pbihcIlwiKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBjcmVhdGVEYXRlUGFyc2VyID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9hLmNvbmZpZywgY29uZmlnID0gX2IgPT09IHZvaWQgMCA/IGRlZmF1bHRzIDogX2IsIF9jID0gX2EubDEwbiwgbDEwbiA9IF9jID09PSB2b2lkIDAgPyBlbmdsaXNoIDogX2M7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0ZSwgZ2l2ZW5Gb3JtYXQsIHRpbWVsZXNzLCBjdXN0b21Mb2NhbGUpIHtcbiAgICAgICAgICAgIGlmIChkYXRlICE9PSAwICYmICFkYXRlKVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgbG9jYWxlID0gY3VzdG9tTG9jYWxlIHx8IGwxMG47XG4gICAgICAgICAgICB2YXIgcGFyc2VkRGF0ZTtcbiAgICAgICAgICAgIHZhciBkYXRlX29yaWcgPSBkYXRlO1xuICAgICAgICAgICAgaWYgKGRhdGUgaW5zdGFuY2VvZiBEYXRlKVxuICAgICAgICAgICAgICAgIHBhcnNlZERhdGUgPSBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZGF0ZSAhPT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGRhdGUudG9GaXhlZCAhPT0gdW5kZWZpbmVkIC8vIHRpbWVzdGFtcFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIGNvcHlcbiAgICAgICAgICAgICAgICBwYXJzZWREYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZGF0ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIC8vIGRhdGUgc3RyaW5nXG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdCA9IGdpdmVuRm9ybWF0IHx8IChjb25maWcgfHwgZGVmYXVsdHMpLmRhdGVGb3JtYXQ7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGVzdHIgPSBTdHJpbmcoZGF0ZSkudHJpbSgpO1xuICAgICAgICAgICAgICAgIGlmIChkYXRlc3RyID09PSBcInRvZGF5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkRGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVsZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoL1okLy50ZXN0KGRhdGVzdHIpIHx8XG4gICAgICAgICAgICAgICAgICAgIC9HTVQkLy50ZXN0KGRhdGVzdHIpIC8vIGRhdGVzdHJpbmdzIHcvIHRpbWV6b25lXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnICYmIGNvbmZpZy5wYXJzZURhdGUpXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZERhdGUgPSBjb25maWcucGFyc2VEYXRlKGRhdGUsIGZvcm1hdCk7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZERhdGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgIWNvbmZpZyB8fCAhY29uZmlnLm5vQ2FsZW5kYXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG5ldyBEYXRlKG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSwgMCwgMSwgMCwgMCwgMCwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG5ldyBEYXRlKG5ldyBEYXRlKCkuc2V0SG91cnMoMCwgMCwgMCwgMCkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlZCA9IHZvaWQgMCwgb3BzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBtYXRjaEluZGV4ID0gMCwgcmVnZXhTdHIgPSBcIlwiOyBpIDwgZm9ybWF0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9rZW5fMSA9IGZvcm1hdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0JhY2tTbGFzaCA9IHRva2VuXzEgPT09IFwiXFxcXFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVzY2FwZWQgPSBmb3JtYXRbaSAtIDFdID09PSBcIlxcXFxcIiB8fCBpc0JhY2tTbGFzaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlblJlZ2V4W3Rva2VuXzFdICYmICFlc2NhcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhTdHIgKz0gdG9rZW5SZWdleFt0b2tlbl8xXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBuZXcgUmVnRXhwKHJlZ2V4U3RyKS5leGVjKGRhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCAmJiAobWF0Y2hlZCA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wc1t0b2tlbl8xICE9PSBcIllcIiA/IFwicHVzaFwiIDogXCJ1bnNoaWZ0XCJdKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuOiByZXZGb3JtYXRbdG9rZW5fMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWw6IG1hdGNoWysrbWF0Y2hJbmRleF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzQmFja1NsYXNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4U3RyICs9IFwiLlwiOyAvLyBkb24ndCByZWFsbHkgY2FyZVxuICAgICAgICAgICAgICAgICAgICAgICAgb3BzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gX2EuZm4sIHZhbCA9IF9hLnZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHBhcnNlZERhdGUgPSBmbihwYXJzZWREYXRlLCB2YWwsIGxvY2FsZSkgfHwgcGFyc2VkRGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRlID0gbWF0Y2hlZCA/IHBhcnNlZERhdGUgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGlmICghKHBhcnNlZERhdGUgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTihwYXJzZWREYXRlLmdldFRpbWUoKSkpKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLmVycm9ySGFuZGxlcihuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGUgcHJvdmlkZWQ6IFwiICsgZGF0ZV9vcmlnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aW1lbGVzcyA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICBwYXJzZWREYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZERhdGU7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBkaWZmZXJlbmNlIGluIGRhdGVzLCBtZWFzdXJlZCBpbiBtc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVEYXRlcyhkYXRlMSwgZGF0ZTIsIHRpbWVsZXNzKSB7XG4gICAgICAgIGlmICh0aW1lbGVzcyA9PT0gdm9pZCAwKSB7IHRpbWVsZXNzID0gdHJ1ZTsgfVxuICAgICAgICBpZiAodGltZWxlc3MgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gKG5ldyBEYXRlKGRhdGUxLmdldFRpbWUoKSkuc2V0SG91cnMoMCwgMCwgMCwgMCkgLVxuICAgICAgICAgICAgICAgIG5ldyBEYXRlKGRhdGUyLmdldFRpbWUoKSkuc2V0SG91cnMoMCwgMCwgMCwgMCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlMS5nZXRUaW1lKCkgLSBkYXRlMi5nZXRUaW1lKCk7XG4gICAgfVxuICAgIHZhciBpc0JldHdlZW4gPSBmdW5jdGlvbiAodHMsIHRzMSwgdHMyKSB7XG4gICAgICAgIHJldHVybiB0cyA+IE1hdGgubWluKHRzMSwgdHMyKSAmJiB0cyA8IE1hdGgubWF4KHRzMSwgdHMyKTtcbiAgICB9O1xuICAgIHZhciBkdXJhdGlvbiA9IHtcbiAgICAgICAgREFZOiA4NjQwMDAwMFxuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBPYmplY3QuYXNzaWduID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gKHRhcmdldFtrZXldID0gc291cmNlW2tleV0pOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBhcmdzXzEgPSBhcmdzOyBfYSA8IGFyZ3NfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gYXJnc18xW19hXTtcbiAgICAgICAgICAgICAgICBfbG9vcF8xKHNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBERUJPVU5DRURfQ0hBTkdFX01TID0gMzAwO1xuICAgIGZ1bmN0aW9uIEZsYXRwaWNrckluc3RhbmNlKGVsZW1lbnQsIGluc3RhbmNlQ29uZmlnKSB7XG4gICAgICAgIHZhciBzZWxmID0ge1xuICAgICAgICAgICAgY29uZmlnOiBfX2Fzc2lnbih7fSwgZmxhdHBpY2tyLmRlZmF1bHRDb25maWcpLFxuICAgICAgICAgICAgbDEwbjogZW5nbGlzaFxuICAgICAgICB9O1xuICAgICAgICBzZWxmLnBhcnNlRGF0ZSA9IGNyZWF0ZURhdGVQYXJzZXIoeyBjb25maWc6IHNlbGYuY29uZmlnLCBsMTBuOiBzZWxmLmwxMG4gfSk7XG4gICAgICAgIHNlbGYuX2hhbmRsZXJzID0gW107XG4gICAgICAgIHNlbGYuX2JpbmQgPSBiaW5kO1xuICAgICAgICBzZWxmLl9zZXRIb3Vyc0Zyb21EYXRlID0gc2V0SG91cnNGcm9tRGF0ZTtcbiAgICAgICAgc2VsZi5fcG9zaXRpb25DYWxlbmRhciA9IHBvc2l0aW9uQ2FsZW5kYXI7XG4gICAgICAgIHNlbGYuY2hhbmdlTW9udGggPSBjaGFuZ2VNb250aDtcbiAgICAgICAgc2VsZi5jaGFuZ2VZZWFyID0gY2hhbmdlWWVhcjtcbiAgICAgICAgc2VsZi5jbGVhciA9IGNsZWFyO1xuICAgICAgICBzZWxmLmNsb3NlID0gY2xvc2U7XG4gICAgICAgIHNlbGYuX2NyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50O1xuICAgICAgICBzZWxmLmRlc3Ryb3kgPSBkZXN0cm95O1xuICAgICAgICBzZWxmLmlzRW5hYmxlZCA9IGlzRW5hYmxlZDtcbiAgICAgICAgc2VsZi5qdW1wVG9EYXRlID0ganVtcFRvRGF0ZTtcbiAgICAgICAgc2VsZi5vcGVuID0gb3BlbjtcbiAgICAgICAgc2VsZi5yZWRyYXcgPSByZWRyYXc7XG4gICAgICAgIHNlbGYuc2V0ID0gc2V0O1xuICAgICAgICBzZWxmLnNldERhdGUgPSBzZXREYXRlO1xuICAgICAgICBzZWxmLnRvZ2dsZSA9IHRvZ2dsZTtcbiAgICAgICAgZnVuY3Rpb24gc2V0dXBIZWxwZXJGdW5jdGlvbnMoKSB7XG4gICAgICAgICAgICBzZWxmLnV0aWxzID0ge1xuICAgICAgICAgICAgICAgIGdldERheXNJbk1vbnRoOiBmdW5jdGlvbiAobW9udGgsIHlyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb250aCA9PT0gdm9pZCAwKSB7IG1vbnRoID0gc2VsZi5jdXJyZW50TW9udGg7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHlyID09PSB2b2lkIDApIHsgeXIgPSBzZWxmLmN1cnJlbnRZZWFyOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb250aCA9PT0gMSAmJiAoKHlyICUgNCA9PT0gMCAmJiB5ciAlIDEwMCAhPT0gMCkgfHwgeXIgJSA0MDAgPT09IDApKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDI5O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5sMTBuLmRheXNJbk1vbnRoW21vbnRoXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgICAgICBzZWxmLmVsZW1lbnQgPSBzZWxmLmlucHV0ID0gZWxlbWVudDtcbiAgICAgICAgICAgIHNlbGYuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgICAgICBwYXJzZUNvbmZpZygpO1xuICAgICAgICAgICAgc2V0dXBMb2NhbGUoKTtcbiAgICAgICAgICAgIHNldHVwSW5wdXRzKCk7XG4gICAgICAgICAgICBzZXR1cERhdGVzKCk7XG4gICAgICAgICAgICBzZXR1cEhlbHBlckZ1bmN0aW9ucygpO1xuICAgICAgICAgICAgaWYgKCFzZWxmLmlzTW9iaWxlKVxuICAgICAgICAgICAgICAgIGJ1aWxkKCk7XG4gICAgICAgICAgICBiaW5kRXZlbnRzKCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCB8fCBzZWxmLmNvbmZpZy5ub0NhbGVuZGFyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmVuYWJsZVRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0SG91cnNGcm9tRGF0ZShzZWxmLmNvbmZpZy5ub0NhbGVuZGFyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqIHx8IHNlbGYuY29uZmlnLm1pbkRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXBkYXRlVmFsdWUoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0Q2FsZW5kYXJXaWR0aCgpO1xuICAgICAgICAgICAgc2VsZi5zaG93VGltZUlucHV0ID1cbiAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID4gMCB8fCBzZWxmLmNvbmZpZy5ub0NhbGVuZGFyO1xuICAgICAgICAgICAgdmFyIGlzU2FmYXJpID0gL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgICAgICAgIC8qIFRPRE86IGludmVzdGlnYXRlIHRoaXMgZnVydGhlclxuICAgICAgICBcbiAgICAgICAgICAgICAgQ3VycmVudGx5LCB0aGVyZSBpcyB3ZWlyZCBwb3NpdGlvbmluZyBiZWhhdmlvciBpbiBzYWZhcmkgY2F1c2luZyBwYWdlc1xuICAgICAgICAgICAgICB0byBzY3JvbGwgdXAuIGh0dHBzOi8vZ2l0aHViLmNvbS9jaG1sbi9mbGF0cGlja3IvaXNzdWVzLzU2M1xuICAgICAgICBcbiAgICAgICAgICAgICAgSG93ZXZlciwgbW9zdCBicm93c2VycyBhcmUgbm90IFNhZmFyaSBhbmQgcG9zaXRpb25pbmcgaXMgZXhwZW5zaXZlIHdoZW4gdXNlZFxuICAgICAgICAgICAgICBpbiBzY2FsZS4gaHR0cHM6Ly9naXRodWIuY29tL2NobWxuL2ZsYXRwaWNrci9pc3N1ZXMvMTA5NlxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICghc2VsZi5pc01vYmlsZSAmJiBpc1NhZmFyaSkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uQ2FsZW5kYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uUmVhZHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmluZFRvSW5zdGFuY2UoZm4pIHtcbiAgICAgICAgICAgIHJldHVybiBmbi5iaW5kKHNlbGYpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldENhbGVuZGFyV2lkdGgoKSB7XG4gICAgICAgICAgICB2YXIgY29uZmlnID0gc2VsZi5jb25maWc7XG4gICAgICAgICAgICBpZiAoY29uZmlnLndlZWtOdW1iZXJzID09PSBmYWxzZSAmJiBjb25maWcuc2hvd01vbnRocyA9PT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBlbHNlIGlmIChjb25maWcubm9DYWxlbmRhciAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5jYWxlbmRhckNvbnRhaW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmRheXNDb250YWluZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRheXNXaWR0aCA9IChzZWxmLmRheXMub2Zmc2V0V2lkdGggKyAxKSAqIGNvbmZpZy5zaG93TW9udGhzO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kYXlzQ29udGFpbmVyLnN0eWxlLndpZHRoID0gZGF5c1dpZHRoICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS53aWR0aCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF5c1dpZHRoICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNlbGYud2Vla1dyYXBwZXIgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLndlZWtXcmFwcGVyLm9mZnNldFdpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcInZpc2liaWxpdHlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLnJlbW92ZVByb3BlcnR5KFwiZGlzcGxheVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaGFuZGxlciBmb3IgYWxsIGV2ZW50cyB0YXJnZXRpbmcgdGhlIHRpbWUgaW5wdXRzXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiB1cGRhdGVUaW1lKGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc2V0RGVmYXVsdFRpbWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlICE9PSB1bmRlZmluZWQgJiYgZS50eXBlICE9PSBcImJsdXJcIikge1xuICAgICAgICAgICAgICAgIHRpbWVXcmFwcGVyKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByZXZWYWx1ZSA9IHNlbGYuX2lucHV0LnZhbHVlO1xuICAgICAgICAgICAgc2V0SG91cnNGcm9tSW5wdXRzKCk7XG4gICAgICAgICAgICB1cGRhdGVWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKHNlbGYuX2lucHV0LnZhbHVlICE9PSBwcmV2VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9kZWJvdW5jZWRDaGFuZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhbXBtMm1pbGl0YXJ5KGhvdXIsIGFtUE0pIHtcbiAgICAgICAgICAgIHJldHVybiAoaG91ciAlIDEyKSArIDEyICogaW50KGFtUE0gPT09IHNlbGYubDEwbi5hbVBNWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtaWxpdGFyeTJhbXBtKGhvdXIpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaG91ciAlIDI0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxMjtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaG91ciAlIDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTeW5jcyB0aGUgc2VsZWN0ZWQgZGF0ZSBvYmplY3QgdGltZSB3aXRoIHVzZXIncyB0aW1lIGlucHV0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBzZXRIb3Vyc0Zyb21JbnB1dHMoKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5ob3VyRWxlbWVudCA9PT0gdW5kZWZpbmVkIHx8IHNlbGYubWludXRlRWxlbWVudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBob3VycyA9IChwYXJzZUludChzZWxmLmhvdXJFbGVtZW50LnZhbHVlLnNsaWNlKC0yKSwgMTApIHx8IDApICUgMjQsIG1pbnV0ZXMgPSAocGFyc2VJbnQoc2VsZi5taW51dGVFbGVtZW50LnZhbHVlLCAxMCkgfHwgMCkgJSA2MCwgc2Vjb25kcyA9IHNlbGYuc2Vjb25kRWxlbWVudCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyAocGFyc2VJbnQoc2VsZi5zZWNvbmRFbGVtZW50LnZhbHVlLCAxMCkgfHwgMCkgJSA2MFxuICAgICAgICAgICAgICAgIDogMDtcbiAgICAgICAgICAgIGlmIChzZWxmLmFtUE0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGhvdXJzID0gYW1wbTJtaWxpdGFyeShob3Vycywgc2VsZi5hbVBNLnRleHRDb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsaW1pdE1pbkhvdXJzID0gc2VsZi5jb25maWcubWluVGltZSAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgKHNlbGYuY29uZmlnLm1pbkRhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5taW5EYXRlSGFzVGltZSAmJlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiAmJlxuICAgICAgICAgICAgICAgICAgICBjb21wYXJlRGF0ZXMoc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmosIHNlbGYuY29uZmlnLm1pbkRhdGUsIHRydWUpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgMCk7XG4gICAgICAgICAgICB2YXIgbGltaXRNYXhIb3VycyA9IHNlbGYuY29uZmlnLm1heFRpbWUgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgIChzZWxmLmNvbmZpZy5tYXhEYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubWF4RGF0ZUhhc1RpbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogJiZcbiAgICAgICAgICAgICAgICAgICAgY29tcGFyZURhdGVzKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqLCBzZWxmLmNvbmZpZy5tYXhEYXRlLCB0cnVlKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIDApO1xuICAgICAgICAgICAgaWYgKGxpbWl0TWF4SG91cnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF4VGltZSA9IHNlbGYuY29uZmlnLm1heFRpbWUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLm1heFRpbWVcbiAgICAgICAgICAgICAgICAgICAgOiBzZWxmLmNvbmZpZy5tYXhEYXRlO1xuICAgICAgICAgICAgICAgIGhvdXJzID0gTWF0aC5taW4oaG91cnMsIG1heFRpbWUuZ2V0SG91cnMoKSk7XG4gICAgICAgICAgICAgICAgaWYgKGhvdXJzID09PSBtYXhUaW1lLmdldEhvdXJzKCkpXG4gICAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBNYXRoLm1pbihtaW51dGVzLCBtYXhUaW1lLmdldE1pbnV0ZXMoKSk7XG4gICAgICAgICAgICAgICAgaWYgKG1pbnV0ZXMgPT09IG1heFRpbWUuZ2V0TWludXRlcygpKVxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRzID0gTWF0aC5taW4oc2Vjb25kcywgbWF4VGltZS5nZXRTZWNvbmRzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpbWl0TWluSG91cnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWluVGltZSA9IHNlbGYuY29uZmlnLm1pblRpbWUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLm1pblRpbWVcbiAgICAgICAgICAgICAgICAgICAgOiBzZWxmLmNvbmZpZy5taW5EYXRlO1xuICAgICAgICAgICAgICAgIGhvdXJzID0gTWF0aC5tYXgoaG91cnMsIG1pblRpbWUuZ2V0SG91cnMoKSk7XG4gICAgICAgICAgICAgICAgaWYgKGhvdXJzID09PSBtaW5UaW1lLmdldEhvdXJzKCkpXG4gICAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBNYXRoLm1heChtaW51dGVzLCBtaW5UaW1lLmdldE1pbnV0ZXMoKSk7XG4gICAgICAgICAgICAgICAgaWYgKG1pbnV0ZXMgPT09IG1pblRpbWUuZ2V0TWludXRlcygpKVxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRzID0gTWF0aC5tYXgoc2Vjb25kcywgbWluVGltZS5nZXRTZWNvbmRzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0SG91cnMoaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTeW5jcyB0aW1lIGlucHV0IHZhbHVlcyB3aXRoIGEgZGF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gc2V0SG91cnNGcm9tRGF0ZShkYXRlT2JqKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IGRhdGVPYmogfHwgc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmo7XG4gICAgICAgICAgICBpZiAoZGF0ZSlcbiAgICAgICAgICAgICAgICBzZXRIb3VycyhkYXRlLmdldEhvdXJzKCksIGRhdGUuZ2V0TWludXRlcygpLCBkYXRlLmdldFNlY29uZHMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0RGVmYXVsdEhvdXJzKCkge1xuICAgICAgICAgICAgdmFyIGhvdXJzID0gc2VsZi5jb25maWcuZGVmYXVsdEhvdXI7XG4gICAgICAgICAgICB2YXIgbWludXRlcyA9IHNlbGYuY29uZmlnLmRlZmF1bHRNaW51dGU7XG4gICAgICAgICAgICB2YXIgc2Vjb25kcyA9IHNlbGYuY29uZmlnLmRlZmF1bHRTZWNvbmRzO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1pbkRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBtaW5faHIgPSBzZWxmLmNvbmZpZy5taW5EYXRlLmdldEhvdXJzKCk7XG4gICAgICAgICAgICAgICAgdmFyIG1pbl9taW51dGVzID0gc2VsZi5jb25maWcubWluRGF0ZS5nZXRNaW51dGVzKCk7XG4gICAgICAgICAgICAgICAgaG91cnMgPSBNYXRoLm1heChob3VycywgbWluX2hyKTtcbiAgICAgICAgICAgICAgICBpZiAoaG91cnMgPT09IG1pbl9ocilcbiAgICAgICAgICAgICAgICAgICAgbWludXRlcyA9IE1hdGgubWF4KG1pbl9taW51dGVzLCBtaW51dGVzKTtcbiAgICAgICAgICAgICAgICBpZiAoaG91cnMgPT09IG1pbl9ociAmJiBtaW51dGVzID09PSBtaW5fbWludXRlcylcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0U2Vjb25kcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1heERhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXhfaHIgPSBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldEhvdXJzKCk7XG4gICAgICAgICAgICAgICAgdmFyIG1heF9taW51dGVzID0gc2VsZi5jb25maWcubWF4RGF0ZS5nZXRNaW51dGVzKCk7XG4gICAgICAgICAgICAgICAgaG91cnMgPSBNYXRoLm1pbihob3VycywgbWF4X2hyKTtcbiAgICAgICAgICAgICAgICBpZiAoaG91cnMgPT09IG1heF9ocilcbiAgICAgICAgICAgICAgICAgICAgbWludXRlcyA9IE1hdGgubWluKG1heF9taW51dGVzLCBtaW51dGVzKTtcbiAgICAgICAgICAgICAgICBpZiAoaG91cnMgPT09IG1heF9ociAmJiBtaW51dGVzID09PSBtYXhfbWludXRlcylcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0U2Vjb25kcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0SG91cnMoaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBob3VycywgbWludXRlcywgYW5kIG9wdGlvbmFsbHkgc2Vjb25kc1xuICAgICAgICAgKiBvZiB0aGUgbGF0ZXN0IHNlbGVjdGVkIGRhdGUgb2JqZWN0IGFuZCB0aGVcbiAgICAgICAgICogY29ycmVzcG9uZGluZyB0aW1lIGlucHV0c1xuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaG91cnMgdGhlIGhvdXIuIHdoZXRoZXIgaXRzIG1pbGl0YXJ5XG4gICAgICAgICAqICAgICAgICAgICAgICAgICBvciBhbS1wbSBnZXRzIGluZmVycmVkIGZyb20gY29uZmlnXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtaW51dGVzIHRoZSBtaW51dGVzXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzZWNvbmRzIHRoZSBzZWNvbmRzIChvcHRpb25hbClcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHNldEhvdXJzKGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqLnNldEhvdXJzKGhvdXJzICUgMjQsIG1pbnV0ZXMsIHNlY29uZHMgfHwgMCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNlbGYuaG91ckVsZW1lbnQgfHwgIXNlbGYubWludXRlRWxlbWVudCB8fCBzZWxmLmlzTW9iaWxlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQudmFsdWUgPSBwYWQoIXNlbGYuY29uZmlnLnRpbWVfMjRoclxuICAgICAgICAgICAgICAgID8gKCgxMiArIGhvdXJzKSAlIDEyKSArIDEyICogaW50KGhvdXJzICUgMTIgPT09IDApXG4gICAgICAgICAgICAgICAgOiBob3Vycyk7XG4gICAgICAgICAgICBzZWxmLm1pbnV0ZUVsZW1lbnQudmFsdWUgPSBwYWQobWludXRlcyk7XG4gICAgICAgICAgICBpZiAoc2VsZi5hbVBNICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgc2VsZi5hbVBNLnRleHRDb250ZW50ID0gc2VsZi5sMTBuLmFtUE1baW50KGhvdXJzID49IDEyKV07XG4gICAgICAgICAgICBpZiAoc2VsZi5zZWNvbmRFbGVtZW50ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgc2VsZi5zZWNvbmRFbGVtZW50LnZhbHVlID0gcGFkKHNlY29uZHMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYW5kbGVzIHRoZSB5ZWFyIGlucHV0IGFuZCBpbmNyZW1lbnRpbmcgZXZlbnRzXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IHRoZSBrZXl1cCBvciBpbmNyZW1lbnQgZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIG9uWWVhcklucHV0KGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgeWVhciA9IHBhcnNlSW50KGV2ZW50LnRhcmdldC52YWx1ZSkgKyAoZXZlbnQuZGVsdGEgfHwgMCk7XG4gICAgICAgICAgICBpZiAoeWVhciAvIDEwMDAgPiAxIHx8XG4gICAgICAgICAgICAgICAgKGV2ZW50LmtleSA9PT0gXCJFbnRlclwiICYmICEvW15cXGRdLy50ZXN0KHllYXIudG9TdHJpbmcoKSkpKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlWWVhcih5ZWFyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRXNzZW50aWFsbHkgYWRkRXZlbnRMaXN0ZW5lciArIHRyYWNraW5nXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCB0aGUgZWxlbWVudCB0byBhZGRFdmVudExpc3RlbmVyIHRvXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCB0aGUgZXZlbnQgbmFtZVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIHRoZSBldmVudCBoYW5kbGVyXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBiaW5kKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQuZm9yRWFjaChmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIGJpbmQoZWxlbWVudCwgZXYsIGhhbmRsZXIsIG9wdGlvbnMpOyB9KTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgQXJyYXkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGJpbmQoZWwsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTsgfSk7XG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgc2VsZi5faGFuZGxlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQSBtb3VzZWRvd24gaGFuZGxlciB3aGljaCBtaW1pY3MgY2xpY2suXG4gICAgICAgICAqIE1pbmltaXplcyBsYXRlbmN5LCBzaW5jZSB3ZSBkb24ndCBuZWVkIHRvIHdhaXQgZm9yIG1vdXNldXAgaW4gbW9zdCBjYXNlcy5cbiAgICAgICAgICogQWxzbywgYXZvaWRzIGhhbmRsaW5nIHJpZ2h0IGNsaWNrcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciB0aGUgZXZlbnQgaGFuZGxlclxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gb25DbGljayhoYW5kbGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICAgIGV2dC53aGljaCA9PT0gMSAmJiBoYW5kbGVyKGV2dCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRyaWdnZXJDaGFuZ2UoKSB7XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbkNoYW5nZVwiKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhbGwgdGhlIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGJpbmRFdmVudHMoKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcud3JhcCkge1xuICAgICAgICAgICAgICAgIFtcIm9wZW5cIiwgXCJjbG9zZVwiLCBcInRvZ2dsZVwiLCBcImNsZWFyXCJdLmZvckVhY2goZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHNlbGYuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtXCIgKyBldnQgKyBcIl1cIiksIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJpbmQoZWwsIFwiY2xpY2tcIiwgc2VsZltldnRdKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5pc01vYmlsZSkge1xuICAgICAgICAgICAgICAgIHNldHVwTW9iaWxlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRlYm91bmNlZFJlc2l6ZSA9IGRlYm91bmNlKG9uUmVzaXplLCA1MCk7XG4gICAgICAgICAgICBzZWxmLl9kZWJvdW5jZWRDaGFuZ2UgPSBkZWJvdW5jZSh0cmlnZ2VyQ2hhbmdlLCBERUJPVU5DRURfQ0hBTkdFX01TKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmRheXNDb250YWluZXIgJiYgIS9pUGhvbmV8aVBhZHxpUG9kL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSlcbiAgICAgICAgICAgICAgICBiaW5kKHNlbGYuZGF5c0NvbnRhaW5lciwgXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1vZGUgPT09IFwicmFuZ2VcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uTW91c2VPdmVyKGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJpbmQod2luZG93LmRvY3VtZW50LmJvZHksIFwia2V5ZG93blwiLCBvbktleURvd24pO1xuICAgICAgICAgICAgaWYgKCFzZWxmLmNvbmZpZy5zdGF0aWMpXG4gICAgICAgICAgICAgICAgYmluZChzZWxmLl9pbnB1dCwgXCJrZXlkb3duXCIsIG9uS2V5RG93bik7XG4gICAgICAgICAgICBpZiAoIXNlbGYuY29uZmlnLmlubGluZSAmJiAhc2VsZi5jb25maWcuc3RhdGljKVxuICAgICAgICAgICAgICAgIGJpbmQod2luZG93LCBcInJlc2l6ZVwiLCBkZWJvdW5jZWRSZXNpemUpO1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5vbnRvdWNoc3RhcnQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBiaW5kKHdpbmRvdy5kb2N1bWVudCwgXCJjbGlja1wiLCBkb2N1bWVudENsaWNrKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBiaW5kKHdpbmRvdy5kb2N1bWVudCwgXCJtb3VzZWRvd25cIiwgb25DbGljayhkb2N1bWVudENsaWNrKSk7XG4gICAgICAgICAgICBiaW5kKHdpbmRvdy5kb2N1bWVudCwgXCJmb2N1c1wiLCBkb2N1bWVudENsaWNrLCB7IGNhcHR1cmU6IHRydWUgfSk7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuY2xpY2tPcGVucyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGJpbmQoc2VsZi5faW5wdXQsIFwiZm9jdXNcIiwgc2VsZi5vcGVuKTtcbiAgICAgICAgICAgICAgICBiaW5kKHNlbGYuX2lucHV0LCBcIm1vdXNlZG93blwiLCBvbkNsaWNrKHNlbGYub3BlbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuZGF5c0NvbnRhaW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYmluZChzZWxmLm1vbnRoTmF2LCBcIm1vdXNlZG93blwiLCBvbkNsaWNrKG9uTW9udGhOYXZDbGljaykpO1xuICAgICAgICAgICAgICAgIGJpbmQoc2VsZi5tb250aE5hdiwgW1wia2V5dXBcIiwgXCJpbmNyZW1lbnRcIl0sIG9uWWVhcklucHV0KTtcbiAgICAgICAgICAgICAgICBiaW5kKHNlbGYuZGF5c0NvbnRhaW5lciwgXCJtb3VzZWRvd25cIiwgb25DbGljayhzZWxlY3REYXRlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi50aW1lQ29udGFpbmVyICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBzZWxmLm1pbnV0ZUVsZW1lbnQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxUZXh0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUudGFyZ2V0LnNlbGVjdCgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYmluZChzZWxmLnRpbWVDb250YWluZXIsIFtcImluY3JlbWVudFwiXSwgdXBkYXRlVGltZSk7XG4gICAgICAgICAgICAgICAgYmluZChzZWxmLnRpbWVDb250YWluZXIsIFwiYmx1clwiLCB1cGRhdGVUaW1lLCB7IGNhcHR1cmU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgYmluZChzZWxmLnRpbWVDb250YWluZXIsIFwibW91c2Vkb3duXCIsIG9uQ2xpY2sodGltZUluY3JlbWVudCkpO1xuICAgICAgICAgICAgICAgIGJpbmQoW3NlbGYuaG91ckVsZW1lbnQsIHNlbGYubWludXRlRWxlbWVudF0sIFtcImZvY3VzXCIsIFwiY2xpY2tcIl0sIHNlbFRleHQpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnNlY29uZEVsZW1lbnQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgYmluZChzZWxmLnNlY29uZEVsZW1lbnQsIFwiZm9jdXNcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZi5zZWNvbmRFbGVtZW50ICYmIHNlbGYuc2Vjb25kRWxlbWVudC5zZWxlY3QoKTsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuYW1QTSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmQoc2VsZi5hbVBNLCBcIm1vdXNlZG93blwiLCBvbkNsaWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVUaW1lKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckNoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGNhbGVuZGFyIHZpZXcgdG8gYSBwYXJ0aWN1bGFyIGRhdGUuXG4gICAgICAgICAqIEBwYXJhbSB7RGF0ZX0ganVtcERhdGUgdGhlIGRhdGUgdG8gc2V0IHRoZSB2aWV3IHRvXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBqdW1wVG9EYXRlKGp1bXBEYXRlKSB7XG4gICAgICAgICAgICB2YXIganVtcFRvID0ganVtcERhdGUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gc2VsZi5wYXJzZURhdGUoanVtcERhdGUpXG4gICAgICAgICAgICAgICAgOiBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiB8fFxuICAgICAgICAgICAgICAgICAgICAoc2VsZi5jb25maWcubWluRGF0ZSAmJiBzZWxmLmNvbmZpZy5taW5EYXRlID4gc2VsZi5ub3dcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZi5jb25maWcubWluRGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzZWxmLmNvbmZpZy5tYXhEYXRlICYmIHNlbGYuY29uZmlnLm1heERhdGUgPCBzZWxmLm5vd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZi5jb25maWcubWF4RGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogc2VsZi5ub3cpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoanVtcFRvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhciA9IGp1bXBUby5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRNb250aCA9IGp1bXBUby5nZXRNb250aCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPSBcIkludmFsaWQgZGF0ZSBzdXBwbGllZDogXCIgKyBqdW1wVG87XG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcuZXJyb3JIYW5kbGVyKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5yZWRyYXcoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVwL2Rvd24gYXJyb3cgaGFuZGxlciBmb3IgdGltZSBpbnB1dHNcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZSB0aGUgY2xpY2sgZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHRpbWVJbmNyZW1lbnQoZSkge1xuICAgICAgICAgICAgaWYgKH5lLnRhcmdldC5jbGFzc05hbWUuaW5kZXhPZihcImFycm93XCIpKVxuICAgICAgICAgICAgICAgIGluY3JlbWVudE51bUlucHV0KGUsIGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcImFycm93VXBcIikgPyAxIDogLTEpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmNyZW1lbnRzL2RlY3JlbWVudHMgdGhlIHZhbHVlIG9mIGlucHV0IGFzc29jaS1cbiAgICAgICAgICogYXRlZCB3aXRoIHRoZSB1cC9kb3duIGFycm93IGJ5IGRpc3BhdGNoaW5nIGFuXG4gICAgICAgICAqIFwiaW5jcmVtZW50XCIgZXZlbnQgb24gdGhlIGlucHV0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIHRoZSBjbGljayBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGEgdGhlIGRpZmYgKHVzdWFsbHkgMSBvciAtMSlcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBpbnB1dEVsZW0gdGhlIGlucHV0IGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGluY3JlbWVudE51bUlucHV0KGUsIGRlbHRhLCBpbnB1dEVsZW0pIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlICYmIGUudGFyZ2V0O1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gaW5wdXRFbGVtIHx8XG4gICAgICAgICAgICAgICAgKHRhcmdldCAmJiB0YXJnZXQucGFyZW50Tm9kZSAmJiB0YXJnZXQucGFyZW50Tm9kZS5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIHZhciBldmVudCA9IGNyZWF0ZUV2ZW50KFwiaW5jcmVtZW50XCIpO1xuICAgICAgICAgICAgZXZlbnQuZGVsdGEgPSBkZWx0YTtcbiAgICAgICAgICAgIGlucHV0ICYmIGlucHV0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkKCkge1xuICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLWNhbGVuZGFyXCIpO1xuICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgaWYgKCFzZWxmLmNvbmZpZy5ub0NhbGVuZGFyKSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoYnVpbGRNb250aE5hdigpKTtcbiAgICAgICAgICAgICAgICBzZWxmLmlubmVyQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci1pbm5lckNvbnRhaW5lclwiKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcud2Vla051bWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gYnVpbGRXZWVrcygpLCB3ZWVrV3JhcHBlciA9IF9hLndlZWtXcmFwcGVyLCB3ZWVrTnVtYmVycyA9IF9hLndlZWtOdW1iZXJzO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmlubmVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHdlZWtXcmFwcGVyKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi53ZWVrTnVtYmVycyA9IHdlZWtOdW1iZXJzO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLndlZWtXcmFwcGVyID0gd2Vla1dyYXBwZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYuckNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3ItckNvbnRhaW5lclwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLnJDb250YWluZXIuYXBwZW5kQ2hpbGQoYnVpbGRXZWVrZGF5cygpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGYuZGF5c0NvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRheXNDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLWRheXNcIik7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGF5c0NvbnRhaW5lci50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWlsZERheXMoKTtcbiAgICAgICAgICAgICAgICBzZWxmLnJDb250YWluZXIuYXBwZW5kQ2hpbGQoc2VsZi5kYXlzQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICBzZWxmLmlubmVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHNlbGYuckNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoc2VsZi5pbm5lckNvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuZW5hYmxlVGltZSkge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGJ1aWxkVGltZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYuY2FsZW5kYXJDb250YWluZXIsIFwicmFuZ2VNb2RlXCIsIHNlbGYuY29uZmlnLm1vZGUgPT09IFwicmFuZ2VcIik7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBcImFuaW1hdGVcIiwgc2VsZi5jb25maWcuYW5pbWF0ZSA9PT0gdHJ1ZSk7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBcIm11bHRpTW9udGhcIiwgc2VsZi5jb25maWcuc2hvd01vbnRocyA+IDEpO1xuICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4gICAgICAgICAgICB2YXIgY3VzdG9tQXBwZW5kID0gc2VsZi5jb25maWcuYXBwZW5kVG8gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmFwcGVuZFRvLm5vZGVUeXBlICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuaW5saW5lIHx8IHNlbGYuY29uZmlnLnN0YXRpYykge1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuY2xhc3NMaXN0LmFkZChzZWxmLmNvbmZpZy5pbmxpbmUgPyBcImlubGluZVwiIDogXCJzdGF0aWNcIik7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmlubGluZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1c3RvbUFwcGVuZCAmJiBzZWxmLmVsZW1lbnQucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBzZWxmLl9pbnB1dC5uZXh0U2libGluZyk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYuY29uZmlnLmFwcGVuZFRvICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5hcHBlbmRUby5hcHBlbmRDaGlsZChzZWxmLmNhbGVuZGFyQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnN0YXRpYykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgd3JhcHBlciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3Itd3JhcHBlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuZWxlbWVudC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHdyYXBwZXIsIHNlbGYuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoc2VsZi5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYWx0SW5wdXQpXG4gICAgICAgICAgICAgICAgICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHNlbGYuYWx0SW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHNlbGYuY2FsZW5kYXJDb250YWluZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsZi5jb25maWcuc3RhdGljICYmICFzZWxmLmNvbmZpZy5pbmxpbmUpXG4gICAgICAgICAgICAgICAgKHNlbGYuY29uZmlnLmFwcGVuZFRvICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5hcHBlbmRUb1xuICAgICAgICAgICAgICAgICAgICA6IHdpbmRvdy5kb2N1bWVudC5ib2R5KS5hcHBlbmRDaGlsZChzZWxmLmNhbGVuZGFyQ29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVEYXkoY2xhc3NOYW1lLCBkYXRlLCBkYXlOdW1iZXIsIGkpIHtcbiAgICAgICAgICAgIHZhciBkYXRlSXNFbmFibGVkID0gaXNFbmFibGVkKGRhdGUsIHRydWUpLCBkYXlFbGVtZW50ID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJmbGF0cGlja3ItZGF5IFwiICsgY2xhc3NOYW1lLCBkYXRlLmdldERhdGUoKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGRheUVsZW1lbnQuZGF0ZU9iaiA9IGRhdGU7XG4gICAgICAgICAgICBkYXlFbGVtZW50LiRpID0gaTtcbiAgICAgICAgICAgIGRheUVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBzZWxmLmZvcm1hdERhdGUoZGF0ZSwgc2VsZi5jb25maWcuYXJpYURhdGVGb3JtYXQpKTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUuaW5kZXhPZihcImhpZGRlblwiKSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlRGF0ZXMoZGF0ZSwgc2VsZi5ub3cpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc2VsZi50b2RheURhdGVFbGVtID0gZGF5RWxlbWVudDtcbiAgICAgICAgICAgICAgICBkYXlFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJ0b2RheVwiKTtcbiAgICAgICAgICAgICAgICBkYXlFbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtY3VycmVudFwiLCBcImRhdGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0ZUlzRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGRheUVsZW1lbnQudGFiSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICBpZiAoaXNEYXRlU2VsZWN0ZWQoZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF5RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlRWxlbSA9IGRheUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvZ2dsZUNsYXNzKGRheUVsZW1lbnQsIFwic3RhcnRSYW5nZVwiLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMF0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wYXJlRGF0ZXMoZGF0ZSwgc2VsZi5zZWxlY3RlZERhdGVzWzBdLCB0cnVlKSA9PT0gMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2dnbGVDbGFzcyhkYXlFbGVtZW50LCBcImVuZFJhbmdlXCIsIHNlbGYuc2VsZWN0ZWREYXRlc1sxXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhcmVEYXRlcyhkYXRlLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMV0sIHRydWUpID09PSAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT09IFwibmV4dE1vbnRoRGF5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF5RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiaW5SYW5nZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRheUVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImRpc2FibGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1vZGUgPT09IFwicmFuZ2VcIikge1xuICAgICAgICAgICAgICAgIGlmIChpc0RhdGVJblJhbmdlKGRhdGUpICYmICFpc0RhdGVTZWxlY3RlZChkYXRlKSlcbiAgICAgICAgICAgICAgICAgICAgZGF5RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiaW5SYW5nZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLndlZWtOdW1iZXJzICYmXG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcuc2hvd01vbnRocyA9PT0gMSAmJlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSAhPT0gXCJwcmV2TW9udGhEYXlcIiAmJlxuICAgICAgICAgICAgICAgIGRheU51bWJlciAlIDcgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBzZWxmLndlZWtOdW1iZXJzLmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCBcIjxzcGFuIGNsYXNzPSdmbGF0cGlja3ItZGF5Jz5cIiArIHNlbGYuY29uZmlnLmdldFdlZWsoZGF0ZSkgKyBcIjwvc3Bhbj5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbkRheUNyZWF0ZVwiLCBkYXlFbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiBkYXlFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZvY3VzT25EYXlFbGVtKHRhcmdldE5vZGUpIHtcbiAgICAgICAgICAgIHRhcmdldE5vZGUuZm9jdXMoKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIpXG4gICAgICAgICAgICAgICAgb25Nb3VzZU92ZXIodGFyZ2V0Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0Rmlyc3RBdmFpbGFibGVEYXkoZGVsdGEpIHtcbiAgICAgICAgICAgIHZhciBzdGFydE1vbnRoID0gZGVsdGEgPiAwID8gMCA6IHNlbGYuY29uZmlnLnNob3dNb250aHMgLSAxO1xuICAgICAgICAgICAgdmFyIGVuZE1vbnRoID0gZGVsdGEgPiAwID8gc2VsZi5jb25maWcuc2hvd01vbnRocyA6IC0xO1xuICAgICAgICAgICAgZm9yICh2YXIgbSA9IHN0YXJ0TW9udGg7IG0gIT0gZW5kTW9udGg7IG0gKz0gZGVsdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbW9udGggPSBzZWxmLmRheXNDb250YWluZXIuY2hpbGRyZW5bbV07XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBkZWx0YSA+IDAgPyAwIDogbW9udGguY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBkZWx0YSA+IDAgPyBtb250aC5jaGlsZHJlbi5sZW5ndGggOiAtMTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSAhPSBlbmRJbmRleDsgaSArPSBkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IG1vbnRoLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYy5jbGFzc05hbWUuaW5kZXhPZihcImhpZGRlblwiKSA9PT0gLTEgJiYgaXNFbmFibGVkKGMuZGF0ZU9iaikpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldE5leHRBdmFpbGFibGVEYXkoY3VycmVudCwgZGVsdGEpIHtcbiAgICAgICAgICAgIHZhciBnaXZlbk1vbnRoID0gY3VycmVudC5jbGFzc05hbWUuaW5kZXhPZihcIk1vbnRoXCIpID09PSAtMVxuICAgICAgICAgICAgICAgID8gY3VycmVudC5kYXRlT2JqLmdldE1vbnRoKClcbiAgICAgICAgICAgICAgICA6IHNlbGYuY3VycmVudE1vbnRoO1xuICAgICAgICAgICAgdmFyIGVuZE1vbnRoID0gZGVsdGEgPiAwID8gc2VsZi5jb25maWcuc2hvd01vbnRocyA6IC0xO1xuICAgICAgICAgICAgdmFyIGxvb3BEZWx0YSA9IGRlbHRhID4gMCA/IDEgOiAtMTtcbiAgICAgICAgICAgIGZvciAodmFyIG0gPSBnaXZlbk1vbnRoIC0gc2VsZi5jdXJyZW50TW9udGg7IG0gIT0gZW5kTW9udGg7IG0gKz0gbG9vcERlbHRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vbnRoID0gc2VsZi5kYXlzQ29udGFpbmVyLmNoaWxkcmVuW21dO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gZ2l2ZW5Nb250aCAtIHNlbGYuY3VycmVudE1vbnRoID09PSBtXG4gICAgICAgICAgICAgICAgICAgID8gY3VycmVudC4kaSArIGRlbHRhXG4gICAgICAgICAgICAgICAgICAgIDogZGVsdGEgPCAwXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG1vbnRoLmNoaWxkcmVuLmxlbmd0aCAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgIDogMDtcbiAgICAgICAgICAgICAgICB2YXIgbnVtTW9udGhEYXlzID0gbW9udGguY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpID49IDAgJiYgaSA8IG51bU1vbnRoRGF5cyAmJiBpICE9IChkZWx0YSA+IDAgPyBudW1Nb250aERheXMgOiAtMSk7IGkgKz0gbG9vcERlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gbW9udGguY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjLmNsYXNzTmFtZS5pbmRleE9mKFwiaGlkZGVuXCIpID09PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNFbmFibGVkKGMuZGF0ZU9iaikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKGN1cnJlbnQuJGkgLSBpKSA+PSBNYXRoLmFicyhkZWx0YSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm9jdXNPbkRheUVsZW0oYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5jaGFuZ2VNb250aChsb29wRGVsdGEpO1xuICAgICAgICAgICAgZm9jdXNPbkRheShnZXRGaXJzdEF2YWlsYWJsZURheShsb29wRGVsdGEpLCAwKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZm9jdXNPbkRheShjdXJyZW50LCBvZmZzZXQpIHtcbiAgICAgICAgICAgIHZhciBkYXlGb2N1c2VkID0gaXNJblZpZXcoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCB8fCBkb2N1bWVudC5ib2R5KTtcbiAgICAgICAgICAgIHZhciBzdGFydEVsZW0gPSBjdXJyZW50ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IGN1cnJlbnRcbiAgICAgICAgICAgICAgICA6IGRheUZvY3VzZWRcbiAgICAgICAgICAgICAgICAgICAgPyBkb2N1bWVudC5hY3RpdmVFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIDogc2VsZi5zZWxlY3RlZERhdGVFbGVtICE9PSB1bmRlZmluZWQgJiYgaXNJblZpZXcoc2VsZi5zZWxlY3RlZERhdGVFbGVtKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLnNlbGVjdGVkRGF0ZUVsZW1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogc2VsZi50b2RheURhdGVFbGVtICE9PSB1bmRlZmluZWQgJiYgaXNJblZpZXcoc2VsZi50b2RheURhdGVFbGVtKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZi50b2RheURhdGVFbGVtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBnZXRGaXJzdEF2YWlsYWJsZURheShvZmZzZXQgPiAwID8gMSA6IC0xKTtcbiAgICAgICAgICAgIGlmIChzdGFydEVsZW0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5faW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgIGlmICghZGF5Rm9jdXNlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9jdXNPbkRheUVsZW0oc3RhcnRFbGVtKTtcbiAgICAgICAgICAgIGdldE5leHRBdmFpbGFibGVEYXkoc3RhcnRFbGVtLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkTW9udGhEYXlzKHllYXIsIG1vbnRoKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RPZk1vbnRoID0gKG5ldyBEYXRlKHllYXIsIG1vbnRoLCAxKS5nZXREYXkoKSAtIHNlbGYubDEwbi5maXJzdERheU9mV2VlayArIDcpICUgNztcbiAgICAgICAgICAgIHZhciBwcmV2TW9udGhEYXlzID0gc2VsZi51dGlscy5nZXREYXlzSW5Nb250aCgobW9udGggLSAxICsgMTIpICUgMTIpO1xuICAgICAgICAgICAgdmFyIGRheXNJbk1vbnRoID0gc2VsZi51dGlscy5nZXREYXlzSW5Nb250aChtb250aCksIGRheXMgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBpc011bHRpTW9udGggPSBzZWxmLmNvbmZpZy5zaG93TW9udGhzID4gMSwgcHJldk1vbnRoRGF5Q2xhc3MgPSBpc011bHRpTW9udGggPyBcInByZXZNb250aERheSBoaWRkZW5cIiA6IFwicHJldk1vbnRoRGF5XCIsIG5leHRNb250aERheUNsYXNzID0gaXNNdWx0aU1vbnRoID8gXCJuZXh0TW9udGhEYXkgaGlkZGVuXCIgOiBcIm5leHRNb250aERheVwiO1xuICAgICAgICAgICAgdmFyIGRheU51bWJlciA9IHByZXZNb250aERheXMgKyAxIC0gZmlyc3RPZk1vbnRoLCBkYXlJbmRleCA9IDA7XG4gICAgICAgICAgICAvLyBwcmVwZW5kIGRheXMgZnJvbSB0aGUgZW5kaW5nIG9mIHByZXZpb3VzIG1vbnRoXG4gICAgICAgICAgICBmb3IgKDsgZGF5TnVtYmVyIDw9IHByZXZNb250aERheXM7IGRheU51bWJlcisrLCBkYXlJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgZGF5cy5hcHBlbmRDaGlsZChjcmVhdGVEYXkocHJldk1vbnRoRGF5Q2xhc3MsIG5ldyBEYXRlKHllYXIsIG1vbnRoIC0gMSwgZGF5TnVtYmVyKSwgZGF5TnVtYmVyLCBkYXlJbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RhcnQgYXQgMSBzaW5jZSB0aGVyZSBpcyBubyAwdGggZGF5XG4gICAgICAgICAgICBmb3IgKGRheU51bWJlciA9IDE7IGRheU51bWJlciA8PSBkYXlzSW5Nb250aDsgZGF5TnVtYmVyKyssIGRheUluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBkYXlzLmFwcGVuZENoaWxkKGNyZWF0ZURheShcIlwiLCBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5TnVtYmVyKSwgZGF5TnVtYmVyLCBkYXlJbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXBwZW5kIGRheXMgZnJvbSB0aGUgbmV4dCBtb250aFxuICAgICAgICAgICAgZm9yICh2YXIgZGF5TnVtID0gZGF5c0luTW9udGggKyAxOyBkYXlOdW0gPD0gNDIgLSBmaXJzdE9mTW9udGggJiZcbiAgICAgICAgICAgICAgICAoc2VsZi5jb25maWcuc2hvd01vbnRocyA9PT0gMSB8fCBkYXlJbmRleCAlIDcgIT09IDApOyBkYXlOdW0rKywgZGF5SW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGRheXMuYXBwZW5kQ2hpbGQoY3JlYXRlRGF5KG5leHRNb250aERheUNsYXNzLCBuZXcgRGF0ZSh5ZWFyLCBtb250aCArIDEsIGRheU51bSAlIGRheXNJbk1vbnRoKSwgZGF5TnVtLCBkYXlJbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy91cGRhdGVOYXZpZ2F0aW9uQ3VycmVudE1vbnRoKCk7XG4gICAgICAgICAgICB2YXIgZGF5Q29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImRheUNvbnRhaW5lclwiKTtcbiAgICAgICAgICAgIGRheUNvbnRhaW5lci5hcHBlbmRDaGlsZChkYXlzKTtcbiAgICAgICAgICAgIHJldHVybiBkYXlDb250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYnVpbGREYXlzKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuZGF5c0NvbnRhaW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xlYXJOb2RlKHNlbGYuZGF5c0NvbnRhaW5lcik7XG4gICAgICAgICAgICAvLyBUT0RPOiB3ZWVrIG51bWJlcnMgZm9yIGVhY2ggbW9udGhcbiAgICAgICAgICAgIGlmIChzZWxmLndlZWtOdW1iZXJzKVxuICAgICAgICAgICAgICAgIGNsZWFyTm9kZShzZWxmLndlZWtOdW1iZXJzKTtcbiAgICAgICAgICAgIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmNvbmZpZy5zaG93TW9udGhzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IG5ldyBEYXRlKHNlbGYuY3VycmVudFllYXIsIHNlbGYuY3VycmVudE1vbnRoLCAxKTtcbiAgICAgICAgICAgICAgICBkLnNldE1vbnRoKHNlbGYuY3VycmVudE1vbnRoICsgaSk7XG4gICAgICAgICAgICAgICAgZnJhZy5hcHBlbmRDaGlsZChidWlsZE1vbnRoRGF5cyhkLmdldEZ1bGxZZWFyKCksIGQuZ2V0TW9udGgoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5kYXlzQ29udGFpbmVyLmFwcGVuZENoaWxkKGZyYWcpO1xuICAgICAgICAgICAgc2VsZi5kYXlzID0gc2VsZi5kYXlzQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiICYmIHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBvbk1vdXNlT3ZlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkTW9udGgoKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci1tb250aFwiKTtcbiAgICAgICAgICAgIHZhciBtb250aE5hdkZyYWdtZW50ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgIHZhciBtb250aEVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KFwic3BhblwiLCBcImN1ci1tb250aFwiKTtcbiAgICAgICAgICAgIHZhciB5ZWFySW5wdXQgPSBjcmVhdGVOdW1iZXJJbnB1dChcImN1ci15ZWFyXCIsIHsgdGFiaW5kZXg6IFwiLTFcIiB9KTtcbiAgICAgICAgICAgIHZhciB5ZWFyRWxlbWVudCA9IHllYXJJbnB1dC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpWzBdO1xuICAgICAgICAgICAgeWVhckVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBzZWxmLmwxMG4ueWVhckFyaWFMYWJlbCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubWluRGF0ZSkge1xuICAgICAgICAgICAgICAgIHllYXJFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1pblwiLCBzZWxmLmNvbmZpZy5taW5EYXRlLmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubWF4RGF0ZSkge1xuICAgICAgICAgICAgICAgIHllYXJFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1heFwiLCBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgeWVhckVsZW1lbnQuZGlzYWJsZWQgPVxuICAgICAgICAgICAgICAgICAgICAhIXNlbGYuY29uZmlnLm1pbkRhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0RnVsbFllYXIoKSA9PT0gc2VsZi5jb25maWcubWF4RGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGN1cnJlbnRNb250aCA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3ItY3VycmVudC1tb250aFwiKTtcbiAgICAgICAgICAgIGN1cnJlbnRNb250aC5hcHBlbmRDaGlsZChtb250aEVsZW1lbnQpO1xuICAgICAgICAgICAgY3VycmVudE1vbnRoLmFwcGVuZENoaWxkKHllYXJJbnB1dCk7XG4gICAgICAgICAgICBtb250aE5hdkZyYWdtZW50LmFwcGVuZENoaWxkKGN1cnJlbnRNb250aCk7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobW9udGhOYXZGcmFnbWVudCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgICAgICAgICAgIHllYXJFbGVtZW50OiB5ZWFyRWxlbWVudCxcbiAgICAgICAgICAgICAgICBtb250aEVsZW1lbnQ6IG1vbnRoRWxlbWVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBidWlsZE1vbnRocygpIHtcbiAgICAgICAgICAgIGNsZWFyTm9kZShzZWxmLm1vbnRoTmF2KTtcbiAgICAgICAgICAgIHNlbGYubW9udGhOYXYuYXBwZW5kQ2hpbGQoc2VsZi5wcmV2TW9udGhOYXYpO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnNob3dNb250aHMpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnllYXJFbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIHNlbGYubW9udGhFbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgbSA9IHNlbGYuY29uZmlnLnNob3dNb250aHM7IG0tLTspIHtcbiAgICAgICAgICAgICAgICB2YXIgbW9udGggPSBidWlsZE1vbnRoKCk7XG4gICAgICAgICAgICAgICAgc2VsZi55ZWFyRWxlbWVudHMucHVzaChtb250aC55ZWFyRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgc2VsZi5tb250aEVsZW1lbnRzLnB1c2gobW9udGgubW9udGhFbGVtZW50KTtcbiAgICAgICAgICAgICAgICBzZWxmLm1vbnRoTmF2LmFwcGVuZENoaWxkKG1vbnRoLmNvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLm1vbnRoTmF2LmFwcGVuZENoaWxkKHNlbGYubmV4dE1vbnRoTmF2KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBidWlsZE1vbnRoTmF2KCkge1xuICAgICAgICAgICAgc2VsZi5tb250aE5hdiA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3ItbW9udGhzXCIpO1xuICAgICAgICAgICAgc2VsZi55ZWFyRWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgIHNlbGYubW9udGhFbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgc2VsZi5wcmV2TW9udGhOYXYgPSBjcmVhdGVFbGVtZW50KFwic3BhblwiLCBcImZsYXRwaWNrci1wcmV2LW1vbnRoXCIpO1xuICAgICAgICAgICAgc2VsZi5wcmV2TW9udGhOYXYuaW5uZXJIVE1MID0gc2VsZi5jb25maWcucHJldkFycm93O1xuICAgICAgICAgICAgc2VsZi5uZXh0TW9udGhOYXYgPSBjcmVhdGVFbGVtZW50KFwic3BhblwiLCBcImZsYXRwaWNrci1uZXh0LW1vbnRoXCIpO1xuICAgICAgICAgICAgc2VsZi5uZXh0TW9udGhOYXYuaW5uZXJIVE1MID0gc2VsZi5jb25maWcubmV4dEFycm93O1xuICAgICAgICAgICAgYnVpbGRNb250aHMoKTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBcIl9oaWRlUHJldk1vbnRoQXJyb3dcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZi5fX2hpZGVQcmV2TW9udGhBcnJvdzsgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChib29sKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLl9faGlkZVByZXZNb250aEFycm93ICE9PSBib29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2dnbGVDbGFzcyhzZWxmLnByZXZNb250aE5hdiwgXCJkaXNhYmxlZFwiLCBib29sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX19oaWRlUHJldk1vbnRoQXJyb3cgPSBib29sO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgXCJfaGlkZU5leHRNb250aEFycm93XCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuX19oaWRlTmV4dE1vbnRoQXJyb3c7IH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoYm9vbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fX2hpZGVOZXh0TW9udGhBcnJvdyAhPT0gYm9vbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5uZXh0TW9udGhOYXYsIFwiZGlzYWJsZWRcIiwgYm9vbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9faGlkZU5leHRNb250aEFycm93ID0gYm9vbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhckVsZW1lbnQgPSBzZWxmLnllYXJFbGVtZW50c1swXTtcbiAgICAgICAgICAgIHVwZGF0ZU5hdmlnYXRpb25DdXJyZW50TW9udGgoKTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLm1vbnRoTmF2O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkVGltZSgpIHtcbiAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhhc1RpbWVcIik7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubm9DYWxlbmRhcilcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJub0NhbGVuZGFyXCIpO1xuICAgICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci10aW1lXCIpO1xuICAgICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyLnRhYkluZGV4ID0gLTE7XG4gICAgICAgICAgICB2YXIgc2VwYXJhdG9yID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJmbGF0cGlja3ItdGltZS1zZXBhcmF0b3JcIiwgXCI6XCIpO1xuICAgICAgICAgICAgdmFyIGhvdXJJbnB1dCA9IGNyZWF0ZU51bWJlcklucHV0KFwiZmxhdHBpY2tyLWhvdXJcIik7XG4gICAgICAgICAgICBzZWxmLmhvdXJFbGVtZW50ID0gaG91cklucHV0LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5wdXRcIilbMF07XG4gICAgICAgICAgICB2YXIgbWludXRlSW5wdXQgPSBjcmVhdGVOdW1iZXJJbnB1dChcImZsYXRwaWNrci1taW51dGVcIik7XG4gICAgICAgICAgICBzZWxmLm1pbnV0ZUVsZW1lbnQgPSBtaW51dGVJbnB1dC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpWzBdO1xuICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudC50YWJJbmRleCA9IHNlbGYubWludXRlRWxlbWVudC50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudC52YWx1ZSA9IHBhZChzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9ialxuICAgICAgICAgICAgICAgID8gc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmouZ2V0SG91cnMoKVxuICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcudGltZV8yNGhyXG4gICAgICAgICAgICAgICAgICAgID8gc2VsZi5jb25maWcuZGVmYXVsdEhvdXJcbiAgICAgICAgICAgICAgICAgICAgOiBtaWxpdGFyeTJhbXBtKHNlbGYuY29uZmlnLmRlZmF1bHRIb3VyKSk7XG4gICAgICAgICAgICBzZWxmLm1pbnV0ZUVsZW1lbnQudmFsdWUgPSBwYWQoc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmpcbiAgICAgICAgICAgICAgICA/IHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqLmdldE1pbnV0ZXMoKVxuICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcuZGVmYXVsdE1pbnV0ZSk7XG4gICAgICAgICAgICBzZWxmLmhvdXJFbGVtZW50LnNldEF0dHJpYnV0ZShcInN0ZXBcIiwgc2VsZi5jb25maWcuaG91ckluY3JlbWVudC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHNlbGYubWludXRlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzdGVwXCIsIHNlbGYuY29uZmlnLm1pbnV0ZUluY3JlbWVudC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWluXCIsIHNlbGYuY29uZmlnLnRpbWVfMjRociA/IFwiMFwiIDogXCIxXCIpO1xuICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtYXhcIiwgc2VsZi5jb25maWcudGltZV8yNGhyID8gXCIyM1wiIDogXCIxMlwiKTtcbiAgICAgICAgICAgIHNlbGYubWludXRlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtaW5cIiwgXCIwXCIpO1xuICAgICAgICAgICAgc2VsZi5taW51dGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1heFwiLCBcIjU5XCIpO1xuICAgICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyLmFwcGVuZENoaWxkKGhvdXJJbnB1dCk7XG4gICAgICAgICAgICBzZWxmLnRpbWVDb250YWluZXIuYXBwZW5kQ2hpbGQoc2VwYXJhdG9yKTtcbiAgICAgICAgICAgIHNlbGYudGltZUNvbnRhaW5lci5hcHBlbmRDaGlsZChtaW51dGVJbnB1dCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcudGltZV8yNGhyKVxuICAgICAgICAgICAgICAgIHNlbGYudGltZUNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidGltZTI0aHJcIik7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuZW5hYmxlU2Vjb25kcykge1xuICAgICAgICAgICAgICAgIHNlbGYudGltZUNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGFzU2Vjb25kc1wiKTtcbiAgICAgICAgICAgICAgICB2YXIgc2Vjb25kSW5wdXQgPSBjcmVhdGVOdW1iZXJJbnB1dChcImZsYXRwaWNrci1zZWNvbmRcIik7XG4gICAgICAgICAgICAgICAgc2VsZi5zZWNvbmRFbGVtZW50ID0gc2Vjb25kSW5wdXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKVswXTtcbiAgICAgICAgICAgICAgICBzZWxmLnNlY29uZEVsZW1lbnQudmFsdWUgPSBwYWQoc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmpcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iai5nZXRTZWNvbmRzKClcbiAgICAgICAgICAgICAgICAgICAgOiBzZWxmLmNvbmZpZy5kZWZhdWx0U2Vjb25kcyk7XG4gICAgICAgICAgICAgICAgc2VsZi5zZWNvbmRFbGVtZW50LnNldEF0dHJpYnV0ZShcInN0ZXBcIiwgc2VsZi5taW51dGVFbGVtZW50LmdldEF0dHJpYnV0ZShcInN0ZXBcIikpO1xuICAgICAgICAgICAgICAgIHNlbGYuc2Vjb25kRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtaW5cIiwgXCIwXCIpO1xuICAgICAgICAgICAgICAgIHNlbGYuc2Vjb25kRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtYXhcIiwgXCI1OVwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLnRpbWVDb250YWluZXIuYXBwZW5kQ2hpbGQoY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJmbGF0cGlja3ItdGltZS1zZXBhcmF0b3JcIiwgXCI6XCIpKTtcbiAgICAgICAgICAgICAgICBzZWxmLnRpbWVDb250YWluZXIuYXBwZW5kQ2hpbGQoc2Vjb25kSW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzZWxmLmNvbmZpZy50aW1lXzI0aHIpIHtcbiAgICAgICAgICAgICAgICAvLyBhZGQgc2VsZi5hbVBNIGlmIGFwcHJvcHJpYXRlXG4gICAgICAgICAgICAgICAgc2VsZi5hbVBNID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJmbGF0cGlja3ItYW0tcG1cIiwgc2VsZi5sMTBuLmFtUE1baW50KChzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9ialxuICAgICAgICAgICAgICAgICAgICA/IHNlbGYuaG91ckVsZW1lbnQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiBzZWxmLmNvbmZpZy5kZWZhdWx0SG91cikgPiAxMSldKTtcbiAgICAgICAgICAgICAgICBzZWxmLmFtUE0udGl0bGUgPSBzZWxmLmwxMG4udG9nZ2xlVGl0bGU7XG4gICAgICAgICAgICAgICAgc2VsZi5hbVBNLnRhYkluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyLmFwcGVuZENoaWxkKHNlbGYuYW1QTSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VsZi50aW1lQ29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkV2Vla2RheXMoKSB7XG4gICAgICAgICAgICBpZiAoIXNlbGYud2Vla2RheUNvbnRhaW5lcilcbiAgICAgICAgICAgICAgICBzZWxmLndlZWtkYXlDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLXdlZWtkYXlzXCIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNsZWFyTm9kZShzZWxmLndlZWtkYXlDb250YWluZXIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHNlbGYuY29uZmlnLnNob3dNb250aHM7IGktLTspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci13ZWVrZGF5Y29udGFpbmVyXCIpO1xuICAgICAgICAgICAgICAgIHNlbGYud2Vla2RheUNvbnRhaW5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlV2Vla2RheXMoKTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLndlZWtkYXlDb250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlV2Vla2RheXMoKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3REYXlPZldlZWsgPSBzZWxmLmwxMG4uZmlyc3REYXlPZldlZWs7XG4gICAgICAgICAgICB2YXIgd2Vla2RheXMgPSBzZWxmLmwxMG4ud2Vla2RheXMuc2hvcnRoYW5kLnNsaWNlKCk7XG4gICAgICAgICAgICBpZiAoZmlyc3REYXlPZldlZWsgPiAwICYmIGZpcnN0RGF5T2ZXZWVrIDwgd2Vla2RheXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgd2Vla2RheXMgPSB3ZWVrZGF5cy5zcGxpY2UoZmlyc3REYXlPZldlZWssIHdlZWtkYXlzLmxlbmd0aCkuY29uY2F0KHdlZWtkYXlzLnNwbGljZSgwLCBmaXJzdERheU9mV2VlaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHNlbGYuY29uZmlnLnNob3dNb250aHM7IGktLTspIHtcbiAgICAgICAgICAgICAgICBzZWxmLndlZWtkYXlDb250YWluZXIuY2hpbGRyZW5baV0uaW5uZXJIVE1MID0gXCJcXG4gICAgICA8c3BhbiBjbGFzcz0nZmxhdHBpY2tyLXdlZWtkYXknPlxcbiAgICAgICAgXCIgKyB3ZWVrZGF5cy5qb2luKFwiPC9zcGFuPjxzcGFuIGNsYXNzPSdmbGF0cGlja3Itd2Vla2RheSc+XCIpICsgXCJcXG4gICAgICA8L3NwYW4+XFxuICAgICAgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZnVuY3Rpb24gYnVpbGRXZWVrcygpIHtcbiAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhhc1dlZWtzXCIpO1xuICAgICAgICAgICAgdmFyIHdlZWtXcmFwcGVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci13ZWVrd3JhcHBlclwiKTtcbiAgICAgICAgICAgIHdlZWtXcmFwcGVyLmFwcGVuZENoaWxkKGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiZmxhdHBpY2tyLXdlZWtkYXlcIiwgc2VsZi5sMTBuLndlZWtBYmJyZXZpYXRpb24pKTtcbiAgICAgICAgICAgIHZhciB3ZWVrTnVtYmVycyA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3Itd2Vla3NcIik7XG4gICAgICAgICAgICB3ZWVrV3JhcHBlci5hcHBlbmRDaGlsZCh3ZWVrTnVtYmVycyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdlZWtXcmFwcGVyOiB3ZWVrV3JhcHBlcixcbiAgICAgICAgICAgICAgICB3ZWVrTnVtYmVyczogd2Vla051bWJlcnNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2hhbmdlTW9udGgodmFsdWUsIGlzX29mZnNldCkge1xuICAgICAgICAgICAgaWYgKGlzX29mZnNldCA9PT0gdm9pZCAwKSB7IGlzX29mZnNldCA9IHRydWU7IH1cbiAgICAgICAgICAgIHZhciBkZWx0YSA9IGlzX29mZnNldCA/IHZhbHVlIDogdmFsdWUgLSBzZWxmLmN1cnJlbnRNb250aDtcbiAgICAgICAgICAgIGlmICgoZGVsdGEgPCAwICYmIHNlbGYuX2hpZGVQcmV2TW9udGhBcnJvdyA9PT0gdHJ1ZSkgfHxcbiAgICAgICAgICAgICAgICAoZGVsdGEgPiAwICYmIHNlbGYuX2hpZGVOZXh0TW9udGhBcnJvdyA9PT0gdHJ1ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2VsZi5jdXJyZW50TW9udGggKz0gZGVsdGE7XG4gICAgICAgICAgICBpZiAoc2VsZi5jdXJyZW50TW9udGggPCAwIHx8IHNlbGYuY3VycmVudE1vbnRoID4gMTEpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRZZWFyICs9IHNlbGYuY3VycmVudE1vbnRoID4gMTEgPyAxIDogLTE7XG4gICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50TW9udGggPSAoc2VsZi5jdXJyZW50TW9udGggKyAxMikgJSAxMjtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvblllYXJDaGFuZ2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWlsZERheXMoKTtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uTW9udGhDaGFuZ2VcIik7XG4gICAgICAgICAgICB1cGRhdGVOYXZpZ2F0aW9uQ3VycmVudE1vbnRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2xlYXIodHJpZ2dlckNoYW5nZUV2ZW50LCB0b0luaXRpYWwpIHtcbiAgICAgICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlRXZlbnQgPT09IHZvaWQgMCkgeyB0cmlnZ2VyQ2hhbmdlRXZlbnQgPSB0cnVlOyB9XG4gICAgICAgICAgICBpZiAodG9Jbml0aWFsID09PSB2b2lkIDApIHsgdG9Jbml0aWFsID0gdHJ1ZTsgfVxuICAgICAgICAgICAgc2VsZi5pbnB1dC52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoc2VsZi5hbHRJbnB1dCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHNlbGYuYWx0SW5wdXQudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKHNlbGYubW9iaWxlSW5wdXQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcyA9IFtdO1xuICAgICAgICAgICAgc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodG9Jbml0aWFsID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhciA9IHNlbGYuX2luaXRpYWxEYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50TW9udGggPSBzZWxmLl9pbml0aWFsRGF0ZS5nZXRNb250aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5zaG93VGltZUlucHV0ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuZW5hYmxlVGltZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHNldERlZmF1bHRIb3VycygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5yZWRyYXcoKTtcbiAgICAgICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlRXZlbnQpXG4gICAgICAgICAgICAgICAgLy8gdHJpZ2dlckNoYW5nZUV2ZW50IGlzIHRydWUgKGRlZmF1bHQpIG9yIGFuIEV2ZW50XG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25DaGFuZ2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgICAgICBzZWxmLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFzZWxmLmlzTW9iaWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY2FsZW5kYXJDb250YWluZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoXCJvcGVuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5faW5wdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9pbnB1dC5jbGFzc0xpc3QucmVtb3ZlKFwiYWN0aXZlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uQ2xvc2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uRGVzdHJveVwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzZWxmLl9oYW5kbGVycy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgICAgICB2YXIgaCA9IHNlbGYuX2hhbmRsZXJzW2ldO1xuICAgICAgICAgICAgICAgIGguZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGguZXZlbnQsIGguaGFuZGxlciwgaC5vcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuX2hhbmRsZXJzID0gW107XG4gICAgICAgICAgICBpZiAoc2VsZi5tb2JpbGVJbnB1dCkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLm1vYmlsZUlucHV0LnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzZWxmLm1vYmlsZUlucHV0KTtcbiAgICAgICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2VsZi5jYWxlbmRhckNvbnRhaW5lciAmJiBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuc3RhdGljICYmIHNlbGYuY2FsZW5kYXJDb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgd3JhcHBlciA9IHNlbGYuY2FsZW5kYXJDb250YWluZXIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlci5sYXN0Q2hpbGQgJiYgd3JhcHBlci5yZW1vdmVDaGlsZCh3cmFwcGVyLmxhc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3cmFwcGVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh3cmFwcGVyLmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlci5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh3cmFwcGVyLmZpcnN0Q2hpbGQsIHdyYXBwZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHdyYXBwZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNlbGYuY2FsZW5kYXJDb250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuYWx0SW5wdXQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmlucHV0LnR5cGUgPSBcInRleHRcIjtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5hbHRJbnB1dC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmFsdElucHV0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2VsZi5hbHRJbnB1dCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNlbGYuYWx0SW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5pbnB1dCkge1xuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQudHlwZSA9IHNlbGYuaW5wdXQuX3R5cGU7XG4gICAgICAgICAgICAgICAgc2VsZi5pbnB1dC5jbGFzc0xpc3QucmVtb3ZlKFwiZmxhdHBpY2tyLWlucHV0XCIpO1xuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQucmVtb3ZlQXR0cmlidXRlKFwicmVhZG9ubHlcIik7XG4gICAgICAgICAgICAgICAgc2VsZi5pbnB1dC52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJfc2hvd1RpbWVJbnB1dFwiLFxuICAgICAgICAgICAgICAgIFwibGF0ZXN0U2VsZWN0ZWREYXRlT2JqXCIsXG4gICAgICAgICAgICAgICAgXCJfaGlkZU5leHRNb250aEFycm93XCIsXG4gICAgICAgICAgICAgICAgXCJfaGlkZVByZXZNb250aEFycm93XCIsXG4gICAgICAgICAgICAgICAgXCJfX2hpZGVOZXh0TW9udGhBcnJvd1wiLFxuICAgICAgICAgICAgICAgIFwiX19oaWRlUHJldk1vbnRoQXJyb3dcIixcbiAgICAgICAgICAgICAgICBcImlzTW9iaWxlXCIsXG4gICAgICAgICAgICAgICAgXCJpc09wZW5cIixcbiAgICAgICAgICAgICAgICBcInNlbGVjdGVkRGF0ZUVsZW1cIixcbiAgICAgICAgICAgICAgICBcIm1pbkRhdGVIYXNUaW1lXCIsXG4gICAgICAgICAgICAgICAgXCJtYXhEYXRlSGFzVGltZVwiLFxuICAgICAgICAgICAgICAgIFwiZGF5c1wiLFxuICAgICAgICAgICAgICAgIFwiZGF5c0NvbnRhaW5lclwiLFxuICAgICAgICAgICAgICAgIFwiX2lucHV0XCIsXG4gICAgICAgICAgICAgICAgXCJfcG9zaXRpb25FbGVtZW50XCIsXG4gICAgICAgICAgICAgICAgXCJpbm5lckNvbnRhaW5lclwiLFxuICAgICAgICAgICAgICAgIFwickNvbnRhaW5lclwiLFxuICAgICAgICAgICAgICAgIFwibW9udGhOYXZcIixcbiAgICAgICAgICAgICAgICBcInRvZGF5RGF0ZUVsZW1cIixcbiAgICAgICAgICAgICAgICBcImNhbGVuZGFyQ29udGFpbmVyXCIsXG4gICAgICAgICAgICAgICAgXCJ3ZWVrZGF5Q29udGFpbmVyXCIsXG4gICAgICAgICAgICAgICAgXCJwcmV2TW9udGhOYXZcIixcbiAgICAgICAgICAgICAgICBcIm5leHRNb250aE5hdlwiLFxuICAgICAgICAgICAgICAgIFwiY3VycmVudE1vbnRoRWxlbWVudFwiLFxuICAgICAgICAgICAgICAgIFwiY3VycmVudFllYXJFbGVtZW50XCIsXG4gICAgICAgICAgICAgICAgXCJuYXZpZ2F0aW9uQ3VycmVudE1vbnRoXCIsXG4gICAgICAgICAgICAgICAgXCJzZWxlY3RlZERhdGVFbGVtXCIsXG4gICAgICAgICAgICAgICAgXCJjb25maWdcIixcbiAgICAgICAgICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzZWxmW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0NhbGVuZGFyRWxlbShlbGVtKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuYXBwZW5kVG8gJiYgc2VsZi5jb25maWcuYXBwZW5kVG8uY29udGFpbnMoZWxlbSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5jYWxlbmRhckNvbnRhaW5lci5jb250YWlucyhlbGVtKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkb2N1bWVudENsaWNrKGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmlzT3BlbiAmJiAhc2VsZi5jb25maWcuaW5saW5lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50VGFyZ2V0XzEgPSBnZXRFdmVudFRhcmdldChlKTtcbiAgICAgICAgICAgICAgICB2YXIgaXNDYWxlbmRhckVsZW1lbnQgPSBpc0NhbGVuZGFyRWxlbShldmVudFRhcmdldF8xKTtcbiAgICAgICAgICAgICAgICB2YXIgaXNJbnB1dCA9IGV2ZW50VGFyZ2V0XzEgPT09IHNlbGYuaW5wdXQgfHxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRUYXJnZXRfMSA9PT0gc2VsZi5hbHRJbnB1dCB8fFxuICAgICAgICAgICAgICAgICAgICBzZWxmLmVsZW1lbnQuY29udGFpbnMoZXZlbnRUYXJnZXRfMSkgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gd2ViIGNvbXBvbmVudHNcbiAgICAgICAgICAgICAgICAgICAgLy8gZS5wYXRoIGlzIG5vdCBwcmVzZW50IGluIGFsbCBicm93c2Vycy4gY2lyY3VtdmVudGluZyB0eXBlY2hlY2tzXG4gICAgICAgICAgICAgICAgICAgIChlLnBhdGggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucGF0aC5pbmRleE9mICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAofmUucGF0aC5pbmRleE9mKHNlbGYuaW5wdXQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfmUucGF0aC5pbmRleE9mKHNlbGYuYWx0SW5wdXQpKSk7XG4gICAgICAgICAgICAgICAgdmFyIGxvc3RGb2N1cyA9IGUudHlwZSA9PT0gXCJibHVyXCJcbiAgICAgICAgICAgICAgICAgICAgPyBpc0lucHV0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnJlbGF0ZWRUYXJnZXQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFpc0NhbGVuZGFyRWxlbShlLnJlbGF0ZWRUYXJnZXQpXG4gICAgICAgICAgICAgICAgICAgIDogIWlzSW5wdXQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFpc0NhbGVuZGFyRWxlbWVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWlzQ2FsZW5kYXJFbGVtKGUucmVsYXRlZFRhcmdldCk7XG4gICAgICAgICAgICAgICAgdmFyIGlzSWdub3JlZCA9ICFzZWxmLmNvbmZpZy5pZ25vcmVkRm9jdXNFbGVtZW50cy5zb21lKGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmNvbnRhaW5zKGV2ZW50VGFyZ2V0XzEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChsb3N0Rm9jdXMgJiYgaXNJZ25vcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1vZGUgPT09IFwicmFuZ2VcIiAmJiBzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNsZWFyKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVkcmF3KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2hhbmdlWWVhcihuZXdZZWFyKSB7XG4gICAgICAgICAgICBpZiAoIW5ld1llYXIgfHxcbiAgICAgICAgICAgICAgICAoc2VsZi5jb25maWcubWluRGF0ZSAmJiBuZXdZZWFyIDwgc2VsZi5jb25maWcubWluRGF0ZS5nZXRGdWxsWWVhcigpKSB8fFxuICAgICAgICAgICAgICAgIChzZWxmLmNvbmZpZy5tYXhEYXRlICYmIG5ld1llYXIgPiBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldEZ1bGxZZWFyKCkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBuZXdZZWFyTnVtID0gbmV3WWVhciwgaXNOZXdZZWFyID0gc2VsZi5jdXJyZW50WWVhciAhPT0gbmV3WWVhck51bTtcbiAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXIgPSBuZXdZZWFyTnVtIHx8IHNlbGYuY3VycmVudFllYXI7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubWF4RGF0ZSAmJlxuICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXIgPT09IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0RnVsbFllYXIoKSkge1xuICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudE1vbnRoID0gTWF0aC5taW4oc2VsZi5jb25maWcubWF4RGF0ZS5nZXRNb250aCgpLCBzZWxmLmN1cnJlbnRNb250aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZWxmLmNvbmZpZy5taW5EYXRlICYmXG4gICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhciA9PT0gc2VsZi5jb25maWcubWluRGF0ZS5nZXRGdWxsWWVhcigpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50TW9udGggPSBNYXRoLm1heChzZWxmLmNvbmZpZy5taW5EYXRlLmdldE1vbnRoKCksIHNlbGYuY3VycmVudE1vbnRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc05ld1llYXIpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJlZHJhdygpO1xuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uWWVhckNoYW5nZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0VuYWJsZWQoZGF0ZSwgdGltZWxlc3MpIHtcbiAgICAgICAgICAgIGlmICh0aW1lbGVzcyA9PT0gdm9pZCAwKSB7IHRpbWVsZXNzID0gdHJ1ZTsgfVxuICAgICAgICAgICAgdmFyIGRhdGVUb0NoZWNrID0gc2VsZi5wYXJzZURhdGUoZGF0ZSwgdW5kZWZpbmVkLCB0aW1lbGVzcyk7IC8vIHRpbWVsZXNzXG4gICAgICAgICAgICBpZiAoKHNlbGYuY29uZmlnLm1pbkRhdGUgJiZcbiAgICAgICAgICAgICAgICBkYXRlVG9DaGVjayAmJlxuICAgICAgICAgICAgICAgIGNvbXBhcmVEYXRlcyhkYXRlVG9DaGVjaywgc2VsZi5jb25maWcubWluRGF0ZSwgdGltZWxlc3MgIT09IHVuZGVmaW5lZCA/IHRpbWVsZXNzIDogIXNlbGYubWluRGF0ZUhhc1RpbWUpIDwgMCkgfHxcbiAgICAgICAgICAgICAgICAoc2VsZi5jb25maWcubWF4RGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBkYXRlVG9DaGVjayAmJlxuICAgICAgICAgICAgICAgICAgICBjb21wYXJlRGF0ZXMoZGF0ZVRvQ2hlY2ssIHNlbGYuY29uZmlnLm1heERhdGUsIHRpbWVsZXNzICE9PSB1bmRlZmluZWQgPyB0aW1lbGVzcyA6ICFzZWxmLm1heERhdGVIYXNUaW1lKSA+IDApKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5lbmFibGUubGVuZ3RoID09PSAwICYmIHNlbGYuY29uZmlnLmRpc2FibGUubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKGRhdGVUb0NoZWNrID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgdmFyIGJvb2wgPSBzZWxmLmNvbmZpZy5lbmFibGUubGVuZ3RoID4gMCwgYXJyYXkgPSBib29sID8gc2VsZi5jb25maWcuZW5hYmxlIDogc2VsZi5jb25maWcuZGlzYWJsZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBkID0gdm9pZCAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkID0gYXJyYXlbaV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgZChkYXRlVG9DaGVjaykgLy8gZGlzYWJsZWQgYnkgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBib29sO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGQgaW5zdGFuY2VvZiBEYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIGRhdGVUb0NoZWNrICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgZC5nZXRUaW1lKCkgPT09IGRhdGVUb0NoZWNrLmdldFRpbWUoKSlcbiAgICAgICAgICAgICAgICAgICAgLy8gZGlzYWJsZWQgYnkgZGF0ZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm9vbDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZCA9PT0gXCJzdHJpbmdcIiAmJiBkYXRlVG9DaGVjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRpc2FibGVkIGJ5IGRhdGUgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZWQgPSBzZWxmLnBhcnNlRGF0ZShkLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkICYmIHBhcnNlZC5nZXRUaW1lKCkgPT09IGRhdGVUb0NoZWNrLmdldFRpbWUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBib29sXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICFib29sO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAvLyBkaXNhYmxlZCBieSByYW5nZVxuICAgICAgICAgICAgICAgIHR5cGVvZiBkID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgICAgIGRhdGVUb0NoZWNrICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgZC5mcm9tICYmXG4gICAgICAgICAgICAgICAgICAgIGQudG8gJiZcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVRvQ2hlY2suZ2V0VGltZSgpID49IGQuZnJvbS5nZXRUaW1lKCkgJiZcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVRvQ2hlY2suZ2V0VGltZSgpIDw9IGQudG8uZ2V0VGltZSgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm9vbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAhYm9vbDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0luVmlldyhlbGVtKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5kYXlzQ29udGFpbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIChlbGVtLmNsYXNzTmFtZS5pbmRleE9mKFwiaGlkZGVuXCIpID09PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmRheXNDb250YWluZXIuY29udGFpbnMoZWxlbSkpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uS2V5RG93bihlKSB7XG4gICAgICAgICAgICAvLyBlLmtleSAgICAgICAgICAgICAgICAgICAgICBlLmtleUNvZGVcbiAgICAgICAgICAgIC8vIFwiQmFja3NwYWNlXCIgICAgICAgICAgICAgICAgICAgICAgICA4XG4gICAgICAgICAgICAvLyBcIlRhYlwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOVxuICAgICAgICAgICAgLy8gXCJFbnRlclwiICAgICAgICAgICAgICAgICAgICAgICAgICAgMTNcbiAgICAgICAgICAgIC8vIFwiRXNjYXBlXCIgICAgIChJRSBcIkVzY1wiKSAgICAgICAgICAgMjdcbiAgICAgICAgICAgIC8vIFwiQXJyb3dMZWZ0XCIgIChJRSBcIkxlZnRcIikgICAgICAgICAgMzdcbiAgICAgICAgICAgIC8vIFwiQXJyb3dVcFwiICAgIChJRSBcIlVwXCIpICAgICAgICAgICAgMzhcbiAgICAgICAgICAgIC8vIFwiQXJyb3dSaWdodFwiIChJRSBcIlJpZ2h0XCIpICAgICAgICAgMzlcbiAgICAgICAgICAgIC8vIFwiQXJyb3dEb3duXCIgIChJRSBcIkRvd25cIikgICAgICAgICAgNDBcbiAgICAgICAgICAgIC8vIFwiRGVsZXRlXCIgICAgIChJRSBcIkRlbFwiKSAgICAgICAgICAgNDZcbiAgICAgICAgICAgIHZhciBpc0lucHV0ID0gZS50YXJnZXQgPT09IHNlbGYuX2lucHV0O1xuICAgICAgICAgICAgdmFyIGFsbG93SW5wdXQgPSBzZWxmLmNvbmZpZy5hbGxvd0lucHV0O1xuICAgICAgICAgICAgdmFyIGFsbG93S2V5ZG93biA9IHNlbGYuaXNPcGVuICYmICghYWxsb3dJbnB1dCB8fCAhaXNJbnB1dCk7XG4gICAgICAgICAgICB2YXIgYWxsb3dJbmxpbmVLZXlkb3duID0gc2VsZi5jb25maWcuaW5saW5lICYmIGlzSW5wdXQgJiYgIWFsbG93SW5wdXQ7XG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAxMyAmJiBpc0lucHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGFsbG93SW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXREYXRlKHNlbGYuX2lucHV0LnZhbHVlLCB0cnVlLCBlLnRhcmdldCA9PT0gc2VsZi5hbHRJbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5hbHRGb3JtYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcuZGF0ZUZvcm1hdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLnRhcmdldC5ibHVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5vcGVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0NhbGVuZGFyRWxlbShlLnRhcmdldCkgfHxcbiAgICAgICAgICAgICAgICBhbGxvd0tleWRvd24gfHxcbiAgICAgICAgICAgICAgICBhbGxvd0lubGluZUtleWRvd24pIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNUaW1lT2JqID0gISFzZWxmLnRpbWVDb250YWluZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyLmNvbnRhaW5zKGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGUua2V5Q29kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVGltZU9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVRpbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZENsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0RGF0ZShlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI3OiAvLyBlc2NhcGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbnB1dCAmJiAhc2VsZi5jb25maWcuYWxsb3dJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNUaW1lT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmRheXNDb250YWluZXIgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYWxsb3dJbnB1dCA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGlzSW5WaWV3KGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhXzEgPSBlLmtleUNvZGUgPT09IDM5ID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWUuY3RybEtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzT25EYXkodW5kZWZpbmVkLCBkZWx0YV8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlTW9udGgoZGVsdGFfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2N1c09uRGF5KGdldEZpcnN0QXZhaWxhYmxlRGF5KDEpLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYuaG91ckVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGEgPSBlLmtleUNvZGUgPT09IDQwID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChzZWxmLmRheXNDb250YWluZXIgJiYgZS50YXJnZXQuJGkgIT09IHVuZGVmaW5lZCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnRhcmdldCA9PT0gc2VsZi5pbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmN0cmxLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlWWVhcihzZWxmLmN1cnJlbnRZZWFyIC0gZGVsdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2N1c09uRGF5KGdldEZpcnN0QXZhaWxhYmxlRGF5KDEpLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzVGltZU9iailcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNPbkRheSh1bmRlZmluZWQsIGRlbHRhICogNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWxmLmNvbmZpZy5lbmFibGVUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1RpbWVPYmogJiYgc2VsZi5ob3VyRWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVRpbWUoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fZGVib3VuY2VkQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVGltZU9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5taW51dGVFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNlY29uZEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYW1QTSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBlbGVtcy5pbmRleE9mKGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IGVsZW1zW2kgKyAoZS5zaGlmdEtleSA/IC0xIDogMSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2lucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmFtUE0gIT09IHVuZGVmaW5lZCAmJiBlLnRhcmdldCA9PT0gc2VsZi5hbVBNKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChlLmtleSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHNlbGYubDEwbi5hbVBNWzBdLmNoYXJBdCgwKTpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBzZWxmLmwxMG4uYW1QTVswXS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYW1QTS50ZXh0Q29udGVudCA9IHNlbGYubDEwbi5hbVBNWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0SG91cnNGcm9tSW5wdXRzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2Ugc2VsZi5sMTBuLmFtUE1bMV0uY2hhckF0KDApOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIHNlbGYubDEwbi5hbVBNWzFdLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hbVBNLnRleHRDb250ZW50ID0gc2VsZi5sMTBuLmFtUE1bMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRIb3Vyc0Zyb21JbnB1dHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbktleURvd25cIiwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25Nb3VzZU92ZXIoZWxlbSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggIT09IDEgfHxcbiAgICAgICAgICAgICAgICAoZWxlbSAmJlxuICAgICAgICAgICAgICAgICAgICAoIWVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKFwiZmxhdHBpY2tyLWRheVwiKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5jbGFzc0xpc3QuY29udGFpbnMoXCJkaXNhYmxlZFwiKSkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBob3ZlckRhdGUgPSBlbGVtXG4gICAgICAgICAgICAgICAgPyBlbGVtLmRhdGVPYmouZ2V0VGltZSgpXG4gICAgICAgICAgICAgICAgOiBzZWxmLmRheXMuZmlyc3RFbGVtZW50Q2hpbGQuZGF0ZU9iai5nZXRUaW1lKCksIGluaXRpYWxEYXRlID0gc2VsZi5wYXJzZURhdGUoc2VsZi5zZWxlY3RlZERhdGVzWzBdLCB1bmRlZmluZWQsIHRydWUpLmdldFRpbWUoKSwgcmFuZ2VTdGFydERhdGUgPSBNYXRoLm1pbihob3ZlckRhdGUsIHNlbGYuc2VsZWN0ZWREYXRlc1swXS5nZXRUaW1lKCkpLCByYW5nZUVuZERhdGUgPSBNYXRoLm1heChob3ZlckRhdGUsIHNlbGYuc2VsZWN0ZWREYXRlc1swXS5nZXRUaW1lKCkpLCBsYXN0RGF0ZSA9IHNlbGYuZGF5c0NvbnRhaW5lci5sYXN0Q2hpbGRcbiAgICAgICAgICAgICAgICAubGFzdENoaWxkLmRhdGVPYmouZ2V0VGltZSgpO1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5zRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBtaW5SYW5nZSA9IDAsIG1heFJhbmdlID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIHQgPSByYW5nZVN0YXJ0RGF0ZTsgdCA8IGxhc3REYXRlOyB0ICs9IGR1cmF0aW9uLkRBWSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNFbmFibGVkKG5ldyBEYXRlKHQpLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluc0Rpc2FibGVkID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zRGlzYWJsZWQgfHwgKHQgPiByYW5nZVN0YXJ0RGF0ZSAmJiB0IDwgcmFuZ2VFbmREYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgPCBpbml0aWFsRGF0ZSAmJiAoIW1pblJhbmdlIHx8IHQgPiBtaW5SYW5nZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5SYW5nZSA9IHQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHQgPiBpbml0aWFsRGF0ZSAmJiAoIW1heFJhbmdlIHx8IHQgPCBtYXhSYW5nZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhSYW5nZSA9IHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCBzZWxmLmNvbmZpZy5zaG93TW9udGhzOyBtKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbW9udGggPSBzZWxmLmRheXNDb250YWluZXIuY2hpbGRyZW5bbV07XG4gICAgICAgICAgICAgICAgdmFyIHByZXZNb250aCA9IHNlbGYuZGF5c0NvbnRhaW5lci5jaGlsZHJlblttIC0gMV07XG4gICAgICAgICAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSwgbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF5RWxlbSA9IG1vbnRoLmNoaWxkcmVuW2ldLCBkYXRlID0gZGF5RWxlbS5kYXRlT2JqO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZXN0YW1wID0gZGF0ZS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXRPZlJhbmdlID0gKG1pblJhbmdlID4gMCAmJiB0aW1lc3RhbXAgPCBtaW5SYW5nZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChtYXhSYW5nZSA+IDAgJiYgdGltZXN0YW1wID4gbWF4UmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3V0T2ZSYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF5RWxlbS5jbGFzc0xpc3QuYWRkKFwibm90QWxsb3dlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtcImluUmFuZ2VcIiwgXCJzdGFydFJhbmdlXCIsIFwiZW5kUmFuZ2VcIl0uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRheUVsZW0uY2xhc3NMaXN0LnJlbW92ZShjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250YWluc0Rpc2FibGVkICYmICFvdXRPZlJhbmdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgICAgICAgICAgW1wic3RhcnRSYW5nZVwiLCBcImluUmFuZ2VcIiwgXCJlbmRSYW5nZVwiLCBcIm5vdEFsbG93ZWRcIl0uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF5RWxlbS5jbGFzc0xpc3QucmVtb3ZlKGMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5jbGFzc0xpc3QuYWRkKGhvdmVyRGF0ZSA8IHNlbGYuc2VsZWN0ZWREYXRlc1swXS5nZXRUaW1lKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFwic3RhcnRSYW5nZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcImVuZFJhbmdlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vbnRoLmNvbnRhaW5zKGVsZW0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIShtID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2TW9udGggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldk1vbnRoLmxhc3RDaGlsZC5kYXRlT2JqLmdldFRpbWUoKSA+PSB0aW1lc3RhbXApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluaXRpYWxEYXRlIDwgaG92ZXJEYXRlICYmIHRpbWVzdGFtcCA9PT0gaW5pdGlhbERhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRheUVsZW0uY2xhc3NMaXN0LmFkZChcInN0YXJ0UmFuZ2VcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5pdGlhbERhdGUgPiBob3ZlckRhdGUgJiYgdGltZXN0YW1wID09PSBpbml0aWFsRGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF5RWxlbS5jbGFzc0xpc3QuYWRkKFwiZW5kUmFuZ2VcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVzdGFtcCA+PSBtaW5SYW5nZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWF4UmFuZ2UgPT09IDAgfHwgdGltZXN0YW1wIDw9IG1heFJhbmdlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0JldHdlZW4odGltZXN0YW1wLCBpbml0aWFsRGF0ZSwgaG92ZXJEYXRlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF5RWxlbS5jbGFzc0xpc3QuYWRkKFwiaW5SYW5nZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBtb250aC5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgX2xvb3BfMShpLCBsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25SZXNpemUoKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5pc09wZW4gJiYgIXNlbGYuY29uZmlnLnN0YXRpYyAmJiAhc2VsZi5jb25maWcuaW5saW5lKVxuICAgICAgICAgICAgICAgIHBvc2l0aW9uQ2FsZW5kYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXREZWZhdWx0VGltZSgpIHtcbiAgICAgICAgICAgIHNlbGYuc2V0RGF0ZShzZWxmLmNvbmZpZy5taW5EYXRlICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG5ldyBEYXRlKHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0VGltZSgpKVxuICAgICAgICAgICAgICAgIDogbmV3IERhdGUoKSwgZmFsc2UpO1xuICAgICAgICAgICAgc2V0RGVmYXVsdEhvdXJzKCk7XG4gICAgICAgICAgICB1cGRhdGVWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9wZW4oZSwgcG9zaXRpb25FbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb25FbGVtZW50ID09PSB2b2lkIDApIHsgcG9zaXRpb25FbGVtZW50ID0gc2VsZi5fcG9zaXRpb25FbGVtZW50OyB9XG4gICAgICAgICAgICBpZiAoc2VsZi5pc01vYmlsZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS50YXJnZXQgJiYgZS50YXJnZXQuYmx1cigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5tb2JpbGVJbnB1dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC5jbGljaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbk9wZW5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuX2lucHV0LmRpc2FibGVkIHx8IHNlbGYuY29uZmlnLmlubGluZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgd2FzT3BlbiA9IHNlbGYuaXNPcGVuO1xuICAgICAgICAgICAgc2VsZi5pc09wZW4gPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCF3YXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwib3BlblwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9pbnB1dC5jbGFzc0xpc3QuYWRkKFwiYWN0aXZlXCIpO1xuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uT3BlblwiKTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkNhbGVuZGFyKHBvc2l0aW9uRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuZW5hYmxlVGltZSA9PT0gdHJ1ZSAmJiBzZWxmLmNvbmZpZy5ub0NhbGVuZGFyID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0RGVmYXVsdFRpbWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmFsbG93SW5wdXQgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgICAgIChlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICFzZWxmLnRpbWVDb250YWluZXIuY29udGFpbnMoZS5yZWxhdGVkVGFyZ2V0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLmhvdXJFbGVtZW50LnNlbGVjdCgpOyB9LCA1MCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1pbk1heERhdGVTZXR0ZXIodHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGVPYmogPSAoc2VsZi5jb25maWdbXCJfXCIgKyB0eXBlICsgXCJEYXRlXCJdID0gc2VsZi5wYXJzZURhdGUoZGF0ZSwgc2VsZi5jb25maWcuZGF0ZUZvcm1hdCkpO1xuICAgICAgICAgICAgICAgIHZhciBpbnZlcnNlRGF0ZU9iaiA9IHNlbGYuY29uZmlnW1wiX1wiICsgKHR5cGUgPT09IFwibWluXCIgPyBcIm1heFwiIDogXCJtaW5cIikgKyBcIkRhdGVcIl07XG4gICAgICAgICAgICAgICAgaWYgKGRhdGVPYmogIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmW3R5cGUgPT09IFwibWluXCIgPyBcIm1pbkRhdGVIYXNUaW1lXCIgOiBcIm1heERhdGVIYXNUaW1lXCJdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVPYmouZ2V0SG91cnMoKSA+IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRlT2JqLmdldE1pbnV0ZXMoKSA+IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRlT2JqLmdldFNlY29uZHMoKSA+IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxmLnNlbGVjdGVkRGF0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzID0gc2VsZi5zZWxlY3RlZERhdGVzLmZpbHRlcihmdW5jdGlvbiAoZCkgeyByZXR1cm4gaXNFbmFibGVkKGQpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoICYmIHR5cGUgPT09IFwibWluXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRIb3Vyc0Zyb21EYXRlKGRhdGVPYmopO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5kYXlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZHJhdygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0ZU9iaiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhckVsZW1lbnRbdHlwZV0gPSBkYXRlT2JqLmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhckVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRZZWFyRWxlbWVudC5kaXNhYmxlZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAhIWludmVyc2VEYXRlT2JqICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZU9iaiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW52ZXJzZURhdGVPYmouZ2V0RnVsbFllYXIoKSA9PT0gZGF0ZU9iai5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VDb25maWcoKSB7XG4gICAgICAgICAgICB2YXIgYm9vbE9wdHMgPSBbXG4gICAgICAgICAgICAgICAgXCJ3cmFwXCIsXG4gICAgICAgICAgICAgICAgXCJ3ZWVrTnVtYmVyc1wiLFxuICAgICAgICAgICAgICAgIFwiYWxsb3dJbnB1dFwiLFxuICAgICAgICAgICAgICAgIFwiY2xpY2tPcGVuc1wiLFxuICAgICAgICAgICAgICAgIFwidGltZV8yNGhyXCIsXG4gICAgICAgICAgICAgICAgXCJlbmFibGVUaW1lXCIsXG4gICAgICAgICAgICAgICAgXCJub0NhbGVuZGFyXCIsXG4gICAgICAgICAgICAgICAgXCJhbHRJbnB1dFwiLFxuICAgICAgICAgICAgICAgIFwic2hvcnRoYW5kQ3VycmVudE1vbnRoXCIsXG4gICAgICAgICAgICAgICAgXCJpbmxpbmVcIixcbiAgICAgICAgICAgICAgICBcInN0YXRpY1wiLFxuICAgICAgICAgICAgICAgIFwiZW5hYmxlU2Vjb25kc1wiLFxuICAgICAgICAgICAgICAgIFwiZGlzYWJsZU1vYmlsZVwiLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHZhciB1c2VyQ29uZmlnID0gX19hc3NpZ24oe30sIGluc3RhbmNlQ29uZmlnLCBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGVsZW1lbnQuZGF0YXNldCB8fCB7fSkpKTtcbiAgICAgICAgICAgIHZhciBmb3JtYXRzID0ge307XG4gICAgICAgICAgICBzZWxmLmNvbmZpZy5wYXJzZURhdGUgPSB1c2VyQ29uZmlnLnBhcnNlRGF0ZTtcbiAgICAgICAgICAgIHNlbGYuY29uZmlnLmZvcm1hdERhdGUgPSB1c2VyQ29uZmlnLmZvcm1hdERhdGU7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi5jb25maWcsIFwiZW5hYmxlXCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuY29uZmlnLl9lbmFibGU7IH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoZGF0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcuX2VuYWJsZSA9IHBhcnNlRGF0ZVJ1bGVzKGRhdGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLmNvbmZpZywgXCJkaXNhYmxlXCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuY29uZmlnLl9kaXNhYmxlOyB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGRhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLl9kaXNhYmxlID0gcGFyc2VEYXRlUnVsZXMoZGF0ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHRpbWVNb2RlID0gdXNlckNvbmZpZy5tb2RlID09PSBcInRpbWVcIjtcbiAgICAgICAgICAgIGlmICghdXNlckNvbmZpZy5kYXRlRm9ybWF0ICYmICh1c2VyQ29uZmlnLmVuYWJsZVRpbWUgfHwgdGltZU1vZGUpKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0cy5kYXRlRm9ybWF0ID1cbiAgICAgICAgICAgICAgICAgICAgdXNlckNvbmZpZy5ub0NhbGVuZGFyIHx8IHRpbWVNb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFwiSDppXCIgKyAodXNlckNvbmZpZy5lbmFibGVTZWNvbmRzID8gXCI6U1wiIDogXCJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZmxhdHBpY2tyLmRlZmF1bHRDb25maWcuZGF0ZUZvcm1hdCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgSDppXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh1c2VyQ29uZmlnLmVuYWJsZVNlY29uZHMgPyBcIjpTXCIgOiBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1c2VyQ29uZmlnLmFsdElucHV0ICYmXG4gICAgICAgICAgICAgICAgKHVzZXJDb25maWcuZW5hYmxlVGltZSB8fCB0aW1lTW9kZSkgJiZcbiAgICAgICAgICAgICAgICAhdXNlckNvbmZpZy5hbHRGb3JtYXQpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXRzLmFsdEZvcm1hdCA9XG4gICAgICAgICAgICAgICAgICAgIHVzZXJDb25maWcubm9DYWxlbmRhciB8fCB0aW1lTW9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcImg6aVwiICsgKHVzZXJDb25maWcuZW5hYmxlU2Vjb25kcyA/IFwiOlMgS1wiIDogXCIgS1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBmbGF0cGlja3IuZGVmYXVsdENvbmZpZy5hbHRGb3JtYXQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcIiBoOmlcIiArICh1c2VyQ29uZmlnLmVuYWJsZVNlY29uZHMgPyBcIjpTXCIgOiBcIlwiKSArIFwiIEtcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi5jb25maWcsIFwibWluRGF0ZVwiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLmNvbmZpZy5fbWluRGF0ZTsgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IG1pbk1heERhdGVTZXR0ZXIoXCJtaW5cIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuY29uZmlnLCBcIm1heERhdGVcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZi5jb25maWcuX21heERhdGU7IH0sXG4gICAgICAgICAgICAgICAgc2V0OiBtaW5NYXhEYXRlU2V0dGVyKFwibWF4XCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBtaW5NYXhUaW1lU2V0dGVyID0gZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZ1t0eXBlID09PSBcIm1pblwiID8gXCJfbWluVGltZVwiIDogXCJfbWF4VGltZVwiXSA9IHNlbGYucGFyc2VEYXRlKHZhbCwgXCJIOmlcIik7XG4gICAgICAgICAgICB9OyB9O1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuY29uZmlnLCBcIm1pblRpbWVcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZi5jb25maWcuX21pblRpbWU7IH0sXG4gICAgICAgICAgICAgICAgc2V0OiBtaW5NYXhUaW1lU2V0dGVyKFwibWluXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLmNvbmZpZywgXCJtYXhUaW1lXCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuY29uZmlnLl9tYXhUaW1lOyB9LFxuICAgICAgICAgICAgICAgIHNldDogbWluTWF4VGltZVNldHRlcihcIm1heFwiKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodXNlckNvbmZpZy5tb2RlID09PSBcInRpbWVcIikge1xuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm5vQ2FsZW5kYXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmVuYWJsZVRpbWUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzZWxmLmNvbmZpZywgZm9ybWF0cywgdXNlckNvbmZpZyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb2xPcHRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnW2Jvb2xPcHRzW2ldXSA9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnW2Jvb2xPcHRzW2ldXSA9PT0gdHJ1ZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWdbYm9vbE9wdHNbaV1dID09PSBcInRydWVcIjtcbiAgICAgICAgICAgIEhPT0tTLmZpbHRlcihmdW5jdGlvbiAoaG9vaykgeyByZXR1cm4gc2VsZi5jb25maWdbaG9va10gIT09IHVuZGVmaW5lZDsgfSkuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnW2hvb2tdID0gYXJyYXlpZnkoc2VsZi5jb25maWdbaG9va10gfHwgW10pLm1hcChiaW5kVG9JbnN0YW5jZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGYuaXNNb2JpbGUgPVxuICAgICAgICAgICAgICAgICFzZWxmLmNvbmZpZy5kaXNhYmxlTW9iaWxlICYmXG4gICAgICAgICAgICAgICAgICAgICFzZWxmLmNvbmZpZy5pbmxpbmUgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcubW9kZSA9PT0gXCJzaW5nbGVcIiAmJlxuICAgICAgICAgICAgICAgICAgICAhc2VsZi5jb25maWcuZGlzYWJsZS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgIXNlbGYuY29uZmlnLmVuYWJsZS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgIXNlbGYuY29uZmlnLndlZWtOdW1iZXJzICYmXG4gICAgICAgICAgICAgICAgICAgIC9BbmRyb2lkfHdlYk9TfGlQaG9uZXxpUGFkfGlQb2R8QmxhY2tCZXJyeXxJRU1vYmlsZXxPcGVyYSBNaW5pL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5jb25maWcucGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwbHVnaW5Db25mID0gc2VsZi5jb25maWcucGx1Z2luc1tpXShzZWxmKSB8fCB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcGx1Z2luQ29uZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoSE9PS1MuaW5kZXhPZihrZXkpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnW2tleV0gPSBhcnJheWlmeShwbHVnaW5Db25mW2tleV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChiaW5kVG9JbnN0YW5jZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHNlbGYuY29uZmlnW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB1c2VyQ29uZmlnW2tleV0gPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZ1trZXldID0gcGx1Z2luQ29uZltrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uUGFyc2VDb25maWdcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0dXBMb2NhbGUoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlbGYuY29uZmlnLmxvY2FsZSAhPT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBmbGF0cGlja3IubDEwbnNbc2VsZi5jb25maWcubG9jYWxlXSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5lcnJvckhhbmRsZXIobmV3IEVycm9yKFwiZmxhdHBpY2tyOiBpbnZhbGlkIGxvY2FsZSBcIiArIHNlbGYuY29uZmlnLmxvY2FsZSkpO1xuICAgICAgICAgICAgc2VsZi5sMTBuID0gX19hc3NpZ24oe30sIGZsYXRwaWNrci5sMTBuc1tcImRlZmF1bHRcIl0sICh0eXBlb2Ygc2VsZi5jb25maWcubG9jYWxlID09PSBcIm9iamVjdFwiXG4gICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5sb2NhbGVcbiAgICAgICAgICAgICAgICA6IHNlbGYuY29uZmlnLmxvY2FsZSAhPT0gXCJkZWZhdWx0XCJcbiAgICAgICAgICAgICAgICAgICAgPyBmbGF0cGlja3IubDEwbnNbc2VsZi5jb25maWcubG9jYWxlXVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCkpO1xuICAgICAgICAgICAgdG9rZW5SZWdleC5LID0gXCIoXCIgKyBzZWxmLmwxMG4uYW1QTVswXSArIFwifFwiICsgc2VsZi5sMTBuLmFtUE1bMV0gKyBcInxcIiArIHNlbGYubDEwbi5hbVBNWzBdLnRvTG93ZXJDYXNlKCkgKyBcInxcIiArIHNlbGYubDEwbi5hbVBNWzFdLnRvTG93ZXJDYXNlKCkgKyBcIilcIjtcbiAgICAgICAgICAgIHNlbGYuZm9ybWF0RGF0ZSA9IGNyZWF0ZURhdGVGb3JtYXR0ZXIoc2VsZik7XG4gICAgICAgICAgICBzZWxmLnBhcnNlRGF0ZSA9IGNyZWF0ZURhdGVQYXJzZXIoeyBjb25maWc6IHNlbGYuY29uZmlnLCBsMTBuOiBzZWxmLmwxMG4gfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcG9zaXRpb25DYWxlbmRhcihjdXN0b21Qb3NpdGlvbkVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmNhbGVuZGFyQ29udGFpbmVyID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25QcmVDYWxlbmRhclBvc2l0aW9uXCIpO1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uRWxlbWVudCA9IGN1c3RvbVBvc2l0aW9uRWxlbWVudCB8fCBzZWxmLl9wb3NpdGlvbkVsZW1lbnQ7XG4gICAgICAgICAgICB2YXIgY2FsZW5kYXJIZWlnaHQgPSBBcnJheS5wcm90b3R5cGUucmVkdWNlLmNhbGwoc2VsZi5jYWxlbmRhckNvbnRhaW5lci5jaGlsZHJlbiwgKGZ1bmN0aW9uIChhY2MsIGNoaWxkKSB7IHJldHVybiBhY2MgKyBjaGlsZC5vZmZzZXRIZWlnaHQ7IH0pLCAwKSwgY2FsZW5kYXJXaWR0aCA9IHNlbGYuY2FsZW5kYXJDb250YWluZXIub2Zmc2V0V2lkdGgsIGNvbmZpZ1BvcyA9IHNlbGYuY29uZmlnLnBvc2l0aW9uLnNwbGl0KFwiIFwiKSwgY29uZmlnUG9zVmVydGljYWwgPSBjb25maWdQb3NbMF0sIGNvbmZpZ1Bvc0hvcml6b250YWwgPSBjb25maWdQb3MubGVuZ3RoID4gMSA/IGNvbmZpZ1Bvc1sxXSA6IG51bGwsIGlucHV0Qm91bmRzID0gcG9zaXRpb25FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBkaXN0YW5jZUZyb21Cb3R0b20gPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSBpbnB1dEJvdW5kcy5ib3R0b20sIHNob3dPblRvcCA9IGNvbmZpZ1Bvc1ZlcnRpY2FsID09PSBcImFib3ZlXCIgfHxcbiAgICAgICAgICAgICAgICAoY29uZmlnUG9zVmVydGljYWwgIT09IFwiYmVsb3dcIiAmJlxuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZUZyb21Cb3R0b20gPCBjYWxlbmRhckhlaWdodCAmJlxuICAgICAgICAgICAgICAgICAgICBpbnB1dEJvdW5kcy50b3AgPiBjYWxlbmRhckhlaWdodCk7XG4gICAgICAgICAgICB2YXIgdG9wID0gd2luZG93LnBhZ2VZT2Zmc2V0ICtcbiAgICAgICAgICAgICAgICBpbnB1dEJvdW5kcy50b3AgK1xuICAgICAgICAgICAgICAgICghc2hvd09uVG9wID8gcG9zaXRpb25FbGVtZW50Lm9mZnNldEhlaWdodCArIDIgOiAtY2FsZW5kYXJIZWlnaHQgLSAyKTtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYuY2FsZW5kYXJDb250YWluZXIsIFwiYXJyb3dUb3BcIiwgIXNob3dPblRvcCk7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBcImFycm93Qm90dG9tXCIsIHNob3dPblRvcCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuaW5saW5lKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gd2luZG93LnBhZ2VYT2Zmc2V0ICtcbiAgICAgICAgICAgICAgICBpbnB1dEJvdW5kcy5sZWZ0IC1cbiAgICAgICAgICAgICAgICAoY29uZmlnUG9zSG9yaXpvbnRhbCAhPSBudWxsICYmIGNvbmZpZ1Bvc0hvcml6b250YWwgPT09IFwiY2VudGVyXCJcbiAgICAgICAgICAgICAgICAgICAgPyAoY2FsZW5kYXJXaWR0aCAtIGlucHV0Qm91bmRzLndpZHRoKSAvIDJcbiAgICAgICAgICAgICAgICAgICAgOiAwKTtcbiAgICAgICAgICAgIHZhciByaWdodCA9IHdpbmRvdy5kb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoIC0gaW5wdXRCb3VuZHMucmlnaHQ7XG4gICAgICAgICAgICB2YXIgcmlnaHRNb3N0ID0gbGVmdCArIGNhbGVuZGFyV2lkdGggPiB3aW5kb3cuZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIHZhciBjZW50ZXJNb3N0ID0gcmlnaHQgKyBjYWxlbmRhcldpZHRoID4gd2luZG93LmRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBcInJpZ2h0TW9zdFwiLCByaWdodE1vc3QpO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnN0YXRpYylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLnRvcCA9IHRvcCArIFwicHhcIjtcbiAgICAgICAgICAgIGlmICghcmlnaHRNb3N0KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gbGVmdCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLnJpZ2h0ID0gXCJhdXRvXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghY2VudGVyTW9zdCkge1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUubGVmdCA9IFwiYXV0b1wiO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUucmlnaHQgPSByaWdodCArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBkb2MgPSBkb2N1bWVudC5zdHlsZVNoZWV0c1swXTtcbiAgICAgICAgICAgICAgICAvLyBzb21lIHRlc3RpbmcgZW52aXJvbm1lbnRzIGRvbid0IGhhdmUgY3NzIHN1cHBvcnRcbiAgICAgICAgICAgICAgICBpZiAoZG9jID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgYm9keVdpZHRoID0gd2luZG93LmRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIGNlbnRlckxlZnQgPSBNYXRoLm1heCgwLCBib2R5V2lkdGggLyAyIC0gY2FsZW5kYXJXaWR0aCAvIDIpO1xuICAgICAgICAgICAgICAgIHZhciBjZW50ZXJCZWZvcmUgPSBcIi5mbGF0cGlja3ItY2FsZW5kYXIuY2VudGVyTW9zdDpiZWZvcmVcIjtcbiAgICAgICAgICAgICAgICB2YXIgY2VudGVyQWZ0ZXIgPSBcIi5mbGF0cGlja3ItY2FsZW5kYXIuY2VudGVyTW9zdDphZnRlclwiO1xuICAgICAgICAgICAgICAgIHZhciBjZW50ZXJJbmRleCA9IGRvYy5jc3NSdWxlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIGNlbnRlclN0eWxlID0gXCJ7bGVmdDpcIiArIGlucHV0Qm91bmRzLmxlZnQgKyBcInB4O3JpZ2h0OmF1dG87fVwiO1xuICAgICAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYuY2FsZW5kYXJDb250YWluZXIsIFwicmlnaHRNb3N0XCIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0b2dnbGVDbGFzcyhzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBcImNlbnRlck1vc3RcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZG9jLmluc2VydFJ1bGUoY2VudGVyQmVmb3JlICsgXCIsXCIgKyBjZW50ZXJBZnRlciArIGNlbnRlclN0eWxlLCBjZW50ZXJJbmRleCk7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gY2VudGVyTGVmdCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLnJpZ2h0ID0gXCJhdXRvXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVkcmF3KCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm5vQ2FsZW5kYXIgfHwgc2VsZi5pc01vYmlsZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB1cGRhdGVOYXZpZ2F0aW9uQ3VycmVudE1vbnRoKCk7XG4gICAgICAgICAgICBidWlsZERheXMoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmb2N1c0FuZENsb3NlKCkge1xuICAgICAgICAgICAgc2VsZi5faW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgIGlmICh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiTVNJRVwiKSAhPT0gLTEgfHxcbiAgICAgICAgICAgICAgICBuYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gaGFjayAtIGJ1Z3MgaW4gdGhlIHdheSBJRSBoYW5kbGVzIGZvY3VzIGtlZXBzIHRoZSBjYWxlbmRhciBvcGVuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChzZWxmLmNsb3NlLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZWxlY3REYXRlKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB2YXIgaXNTZWxlY3RhYmxlID0gZnVuY3Rpb24gKGRheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXkuY2xhc3NMaXN0ICYmXG4gICAgICAgICAgICAgICAgICAgIGRheS5jbGFzc0xpc3QuY29udGFpbnMoXCJmbGF0cGlja3ItZGF5XCIpICYmXG4gICAgICAgICAgICAgICAgICAgICFkYXkuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZGlzYWJsZWRcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgIWRheS5jbGFzc0xpc3QuY29udGFpbnMoXCJub3RBbGxvd2VkXCIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB0ID0gZmluZFBhcmVudChlLnRhcmdldCwgaXNTZWxlY3RhYmxlKTtcbiAgICAgICAgICAgIGlmICh0ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHQ7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWREYXRlID0gKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqID0gbmV3IERhdGUodGFyZ2V0LmRhdGVPYmouZ2V0VGltZSgpKSk7XG4gICAgICAgICAgICB2YXIgc2hvdWxkQ2hhbmdlTW9udGggPSAoc2VsZWN0ZWREYXRlLmdldE1vbnRoKCkgPCBzZWxmLmN1cnJlbnRNb250aCB8fFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkRGF0ZS5nZXRNb250aCgpID5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50TW9udGggKyBzZWxmLmNvbmZpZy5zaG93TW9udGhzIC0gMSkgJiZcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5tb2RlICE9PSBcInJhbmdlXCI7XG4gICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZUVsZW0gPSB0YXJnZXQ7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJzaW5nbGVcIilcbiAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMgPSBbc2VsZWN0ZWREYXRlXTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYuY29uZmlnLm1vZGUgPT09IFwibXVsdGlwbGVcIikge1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZEluZGV4ID0gaXNEYXRlU2VsZWN0ZWQoc2VsZWN0ZWREYXRlKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRJbmRleClcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzLnNwbGljZShwYXJzZUludChzZWxlY3RlZEluZGV4KSwgMSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMucHVzaChzZWxlY3RlZERhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jbGVhcihmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiA9IHNlbGVjdGVkRGF0ZTtcbiAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMucHVzaChzZWxlY3RlZERhdGUpO1xuICAgICAgICAgICAgICAgIC8vIHVubGVzcyBzZWxlY3Rpbmcgc2FtZSBkYXRlIHR3aWNlLCBzb3J0IGFzY2VuZGluZ2x5XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmVEYXRlcyhzZWxlY3RlZERhdGUsIHNlbGYuc2VsZWN0ZWREYXRlc1swXSwgdHJ1ZSkgIT09IDApXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmdldFRpbWUoKSAtIGIuZ2V0VGltZSgpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEhvdXJzRnJvbUlucHV0cygpO1xuICAgICAgICAgICAgaWYgKHNob3VsZENoYW5nZU1vbnRoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzTmV3WWVhciA9IHNlbGYuY3VycmVudFllYXIgIT09IHNlbGVjdGVkRGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXIgPSBzZWxlY3RlZERhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRNb250aCA9IHNlbGVjdGVkRGF0ZS5nZXRNb250aCgpO1xuICAgICAgICAgICAgICAgIGlmIChpc05ld1llYXIpXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uWWVhckNoYW5nZVwiKTtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbk1vbnRoQ2hhbmdlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlTmF2aWdhdGlvbkN1cnJlbnRNb250aCgpO1xuICAgICAgICAgICAgYnVpbGREYXlzKCk7XG4gICAgICAgICAgICB1cGRhdGVWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmVuYWJsZVRpbWUpXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiAoc2VsZi5zaG93VGltZUlucHV0ID0gdHJ1ZSk7IH0sIDUwKTtcbiAgICAgICAgICAgIC8vIG1haW50YWluIGZvY3VzXG4gICAgICAgICAgICBpZiAoIXNob3VsZENoYW5nZU1vbnRoICYmXG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcubW9kZSAhPT0gXCJyYW5nZVwiICYmXG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcuc2hvd01vbnRocyA9PT0gMSlcbiAgICAgICAgICAgICAgICBmb2N1c09uRGF5RWxlbSh0YXJnZXQpO1xuICAgICAgICAgICAgZWxzZSBpZiAoc2VsZi5zZWxlY3RlZERhdGVFbGVtICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBzZWxmLmhvdXJFbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZUVsZW0gJiYgc2VsZi5zZWxlY3RlZERhdGVFbGVtLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5ob3VyRWxlbWVudCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQgIT09IHVuZGVmaW5lZCAmJiBzZWxmLmhvdXJFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuY2xvc2VPblNlbGVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBzaW5nbGUgPSBzZWxmLmNvbmZpZy5tb2RlID09PSBcInNpbmdsZVwiICYmICFzZWxmLmNvbmZpZy5lbmFibGVUaW1lO1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHNlbGYuY29uZmlnLm1vZGUgPT09IFwicmFuZ2VcIiAmJlxuICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICAgICAgICAgICFzZWxmLmNvbmZpZy5lbmFibGVUaW1lO1xuICAgICAgICAgICAgICAgIGlmIChzaW5nbGUgfHwgcmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRDbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaWdnZXJDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgQ0FMTEJBQ0tTID0ge1xuICAgICAgICAgICAgbG9jYWxlOiBbc2V0dXBMb2NhbGUsIHVwZGF0ZVdlZWtkYXlzXSxcbiAgICAgICAgICAgIHNob3dNb250aHM6IFtidWlsZE1vbnRocywgc2V0Q2FsZW5kYXJXaWR0aCwgYnVpbGRXZWVrZGF5c11cbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gc2V0KG9wdGlvbiwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb24gIT09IG51bGwgJiYgdHlwZW9mIG9wdGlvbiA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHNlbGYuY29uZmlnLCBvcHRpb24pO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWdbb3B0aW9uXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChDQUxMQkFDS1Nbb3B0aW9uXSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBDQUxMQkFDS1Nbb3B0aW9uXS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4KCk7IH0pO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEhPT0tTLmluZGV4T2Yob3B0aW9uKSA+IC0xKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZ1tvcHRpb25dID0gYXJyYXlpZnkodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5yZWRyYXcoKTtcbiAgICAgICAgICAgIHVwZGF0ZVZhbHVlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXRTZWxlY3RlZERhdGUoaW5wdXREYXRlLCBmb3JtYXQpIHtcbiAgICAgICAgICAgIHZhciBkYXRlcyA9IFtdO1xuICAgICAgICAgICAgaWYgKGlucHV0RGF0ZSBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgICAgIGRhdGVzID0gaW5wdXREYXRlLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gc2VsZi5wYXJzZURhdGUoZCwgZm9ybWF0KTsgfSk7XG4gICAgICAgICAgICBlbHNlIGlmIChpbnB1dERhdGUgaW5zdGFuY2VvZiBEYXRlIHx8IHR5cGVvZiBpbnB1dERhdGUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgZGF0ZXMgPSBbc2VsZi5wYXJzZURhdGUoaW5wdXREYXRlLCBmb3JtYXQpXTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dERhdGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNlbGYuY29uZmlnLm1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNpbmdsZVwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGltZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZXMgPSBbc2VsZi5wYXJzZURhdGUoaW5wdXREYXRlLCBmb3JtYXQpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibXVsdGlwbGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVzID0gaW5wdXREYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNwbGl0KHNlbGYuY29uZmlnLmNvbmp1bmN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIHNlbGYucGFyc2VEYXRlKGRhdGUsIGZvcm1hdCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyYW5nZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZXMgPSBpbnB1dERhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3BsaXQoc2VsZi5sMTBuLnJhbmdlU2VwYXJhdG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIHNlbGYucGFyc2VEYXRlKGRhdGUsIGZvcm1hdCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcuZXJyb3JIYW5kbGVyKG5ldyBFcnJvcihcIkludmFsaWQgZGF0ZSBzdXBwbGllZDogXCIgKyBKU09OLnN0cmluZ2lmeShpbnB1dERhdGUpKSk7XG4gICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMgPSBkYXRlcy5maWx0ZXIoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQgaW5zdGFuY2VvZiBEYXRlICYmIGlzRW5hYmxlZChkLCBmYWxzZSk7IH0pO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1vZGUgPT09IFwicmFuZ2VcIilcbiAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5nZXRUaW1lKCkgLSBiLmdldFRpbWUoKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0RGF0ZShkYXRlLCB0cmlnZ2VyQ2hhbmdlLCBmb3JtYXQpIHtcbiAgICAgICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlID09PSB2b2lkIDApIHsgdHJpZ2dlckNoYW5nZSA9IGZhbHNlOyB9XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSB2b2lkIDApIHsgZm9ybWF0ID0gc2VsZi5jb25maWcuZGF0ZUZvcm1hdDsgfVxuICAgICAgICAgICAgaWYgKChkYXRlICE9PSAwICYmICFkYXRlKSB8fCAoZGF0ZSBpbnN0YW5jZW9mIEFycmF5ICYmIGRhdGUubGVuZ3RoID09PSAwKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jbGVhcih0cmlnZ2VyQ2hhbmdlKTtcbiAgICAgICAgICAgIHNldFNlbGVjdGVkRGF0ZShkYXRlLCBmb3JtYXQpO1xuICAgICAgICAgICAgc2VsZi5zaG93VGltZUlucHV0ID0gc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiA9IHNlbGYuc2VsZWN0ZWREYXRlc1swXTtcbiAgICAgICAgICAgIHNlbGYucmVkcmF3KCk7XG4gICAgICAgICAgICBqdW1wVG9EYXRlKCk7XG4gICAgICAgICAgICBzZXRIb3Vyc0Zyb21EYXRlKCk7XG4gICAgICAgICAgICB1cGRhdGVWYWx1ZSh0cmlnZ2VyQ2hhbmdlKTtcbiAgICAgICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlKVxuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uQ2hhbmdlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlRGF0ZVJ1bGVzKGFycikge1xuICAgICAgICAgICAgcmV0dXJuIGFyclxuICAgICAgICAgICAgICAgIC5zbGljZSgpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcnVsZSA9PT0gXCJzdHJpbmdcIiB8fFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcnVsZSA9PT0gXCJudW1iZXJcIiB8fFxuICAgICAgICAgICAgICAgICAgICBydWxlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5wYXJzZURhdGUocnVsZSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocnVsZSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcnVsZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgICAgICBydWxlLmZyb20gJiZcbiAgICAgICAgICAgICAgICAgICAgcnVsZS50bylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IHNlbGYucGFyc2VEYXRlKHJ1bGUuZnJvbSwgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBzZWxmLnBhcnNlRGF0ZShydWxlLnRvLCB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0pOyAvLyByZW1vdmUgZmFsc3kgdmFsdWVzXG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0dXBEYXRlcygpIHtcbiAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcyA9IFtdO1xuICAgICAgICAgICAgc2VsZi5ub3cgPSBzZWxmLnBhcnNlRGF0ZShzZWxmLmNvbmZpZy5ub3cpIHx8IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAvLyBXb3JrYXJvdW5kIElFMTEgc2V0dGluZyBwbGFjZWhvbGRlciBhcyB0aGUgaW5wdXQncyB2YWx1ZVxuICAgICAgICAgICAgdmFyIHByZWxvYWRlZERhdGUgPSBzZWxmLmNvbmZpZy5kZWZhdWx0RGF0ZSB8fFxuICAgICAgICAgICAgICAgICgoc2VsZi5pbnB1dC5ub2RlTmFtZSA9PT0gXCJJTlBVVFwiIHx8XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQubm9kZU5hbWUgPT09IFwiVEVYVEFSRUFcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbnB1dC5wbGFjZWhvbGRlciAmJlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmlucHV0LnZhbHVlID09PSBzZWxmLmlucHV0LnBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICA6IHNlbGYuaW5wdXQudmFsdWUpO1xuICAgICAgICAgICAgaWYgKHByZWxvYWRlZERhdGUpXG4gICAgICAgICAgICAgICAgc2V0U2VsZWN0ZWREYXRlKHByZWxvYWRlZERhdGUsIHNlbGYuY29uZmlnLmRhdGVGb3JtYXQpO1xuICAgICAgICAgICAgc2VsZi5faW5pdGlhbERhdGUgPVxuICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgICAgID8gc2VsZi5zZWxlY3RlZERhdGVzWzBdXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcubWluRGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcubWluRGF0ZS5nZXRUaW1lKCkgPiBzZWxmLm5vdy5nZXRUaW1lKClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZi5jb25maWcubWluRGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzZWxmLmNvbmZpZy5tYXhEYXRlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcubWF4RGF0ZS5nZXRUaW1lKCkgPCBzZWxmLm5vdy5nZXRUaW1lKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLm1heERhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHNlbGYubm93O1xuICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhciA9IHNlbGYuX2luaXRpYWxEYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICBzZWxmLmN1cnJlbnRNb250aCA9IHNlbGYuX2luaXRpYWxEYXRlLmdldE1vbnRoKCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogPSBzZWxmLnNlbGVjdGVkRGF0ZXNbMF07XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubWluVGltZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1pblRpbWUgPSBzZWxmLnBhcnNlRGF0ZShzZWxmLmNvbmZpZy5taW5UaW1lLCBcIkg6aVwiKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tYXhUaW1lICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcubWF4VGltZSA9IHNlbGYucGFyc2VEYXRlKHNlbGYuY29uZmlnLm1heFRpbWUsIFwiSDppXCIpO1xuICAgICAgICAgICAgc2VsZi5taW5EYXRlSGFzVGltZSA9XG4gICAgICAgICAgICAgICAgISFzZWxmLmNvbmZpZy5taW5EYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIChzZWxmLmNvbmZpZy5taW5EYXRlLmdldEhvdXJzKCkgPiAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5taW5EYXRlLmdldE1pbnV0ZXMoKSA+IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0U2Vjb25kcygpID4gMCk7XG4gICAgICAgICAgICBzZWxmLm1heERhdGVIYXNUaW1lID1cbiAgICAgICAgICAgICAgICAhIXNlbGYuY29uZmlnLm1heERhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgKHNlbGYuY29uZmlnLm1heERhdGUuZ2V0SG91cnMoKSA+IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1heERhdGUuZ2V0TWludXRlcygpID4gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcubWF4RGF0ZS5nZXRTZWNvbmRzKCkgPiAwKTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBcInNob3dUaW1lSW5wdXRcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZi5fc2hvd1RpbWVJbnB1dDsgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChib29sKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3Nob3dUaW1lSW5wdXQgPSBib29sO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5jYWxlbmRhckNvbnRhaW5lcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYuY2FsZW5kYXJDb250YWluZXIsIFwic2hvd1RpbWVJbnB1dFwiLCBib29sKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pc09wZW4gJiYgcG9zaXRpb25DYWxlbmRhcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldHVwSW5wdXRzKCkge1xuICAgICAgICAgICAgc2VsZi5pbnB1dCA9IHNlbGYuY29uZmlnLndyYXBcbiAgICAgICAgICAgICAgICA/IGVsZW1lbnQucXVlcnlTZWxlY3RvcihcIltkYXRhLWlucHV0XVwiKVxuICAgICAgICAgICAgICAgIDogZWxlbWVudDtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZiAoIXNlbGYuaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5lcnJvckhhbmRsZXIobmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBlbGVtZW50IHNwZWNpZmllZFwiKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaGFjazogc3RvcmUgcHJldmlvdXMgdHlwZSB0byByZXN0b3JlIGl0IGFmdGVyIGRlc3Ryb3koKVxuICAgICAgICAgICAgc2VsZi5pbnB1dC5fdHlwZSA9IHNlbGYuaW5wdXQudHlwZTtcbiAgICAgICAgICAgIHNlbGYuaW5wdXQudHlwZSA9IFwidGV4dFwiO1xuICAgICAgICAgICAgc2VsZi5pbnB1dC5jbGFzc0xpc3QuYWRkKFwiZmxhdHBpY2tyLWlucHV0XCIpO1xuICAgICAgICAgICAgc2VsZi5faW5wdXQgPSBzZWxmLmlucHV0O1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmFsdElucHV0KSB7XG4gICAgICAgICAgICAgICAgLy8gcmVwbGljYXRlIHNlbGYuZWxlbWVudFxuICAgICAgICAgICAgICAgIHNlbGYuYWx0SW5wdXQgPSBjcmVhdGVFbGVtZW50KHNlbGYuaW5wdXQubm9kZU5hbWUsIHNlbGYuaW5wdXQuY2xhc3NOYW1lICsgXCIgXCIgKyBzZWxmLmNvbmZpZy5hbHRJbnB1dENsYXNzKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9pbnB1dCA9IHNlbGYuYWx0SW5wdXQ7XG4gICAgICAgICAgICAgICAgc2VsZi5hbHRJbnB1dC5wbGFjZWhvbGRlciA9IHNlbGYuaW5wdXQucGxhY2Vob2xkZXI7XG4gICAgICAgICAgICAgICAgc2VsZi5hbHRJbnB1dC5kaXNhYmxlZCA9IHNlbGYuaW5wdXQuZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgc2VsZi5hbHRJbnB1dC5yZXF1aXJlZCA9IHNlbGYuaW5wdXQucmVxdWlyZWQ7XG4gICAgICAgICAgICAgICAgc2VsZi5hbHRJbnB1dC50YWJJbmRleCA9IHNlbGYuaW5wdXQudGFiSW5kZXg7XG4gICAgICAgICAgICAgICAgc2VsZi5hbHRJbnB1dC50eXBlID0gXCJ0ZXh0XCI7XG4gICAgICAgICAgICAgICAgc2VsZi5pbnB1dC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwiaGlkZGVuXCIpO1xuICAgICAgICAgICAgICAgIGlmICghc2VsZi5jb25maWcuc3RhdGljICYmIHNlbGYuaW5wdXQucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbnB1dC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzZWxmLmFsdElucHV0LCBzZWxmLmlucHV0Lm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsZi5jb25maWcuYWxsb3dJbnB1dClcbiAgICAgICAgICAgICAgICBzZWxmLl9pbnB1dC5zZXRBdHRyaWJ1dGUoXCJyZWFkb25seVwiLCBcInJlYWRvbmx5XCIpO1xuICAgICAgICAgICAgc2VsZi5fcG9zaXRpb25FbGVtZW50ID0gc2VsZi5jb25maWcucG9zaXRpb25FbGVtZW50IHx8IHNlbGYuX2lucHV0O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldHVwTW9iaWxlKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0VHlwZSA9IHNlbGYuY29uZmlnLmVuYWJsZVRpbWVcbiAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLm5vQ2FsZW5kYXJcbiAgICAgICAgICAgICAgICAgICAgPyBcInRpbWVcIlxuICAgICAgICAgICAgICAgICAgICA6IFwiZGF0ZXRpbWUtbG9jYWxcIlxuICAgICAgICAgICAgICAgIDogXCJkYXRlXCI7XG4gICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0ID0gY3JlYXRlRWxlbWVudChcImlucHV0XCIsIHNlbGYuaW5wdXQuY2xhc3NOYW1lICsgXCIgZmxhdHBpY2tyLW1vYmlsZVwiKTtcbiAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQuc3RlcCA9IHNlbGYuaW5wdXQuZ2V0QXR0cmlidXRlKFwic3RlcFwiKSB8fCBcImFueVwiO1xuICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC50YWJJbmRleCA9IDE7XG4gICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LnR5cGUgPSBpbnB1dFR5cGU7XG4gICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LmRpc2FibGVkID0gc2VsZi5pbnB1dC5kaXNhYmxlZDtcbiAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQucmVxdWlyZWQgPSBzZWxmLmlucHV0LnJlcXVpcmVkO1xuICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC5wbGFjZWhvbGRlciA9IHNlbGYuaW5wdXQucGxhY2Vob2xkZXI7XG4gICAgICAgICAgICBzZWxmLm1vYmlsZUZvcm1hdFN0ciA9XG4gICAgICAgICAgICAgICAgaW5wdXRUeXBlID09PSBcImRhdGV0aW1lLWxvY2FsXCJcbiAgICAgICAgICAgICAgICAgICAgPyBcIlktbS1kXFxcXFRIOmk6U1wiXG4gICAgICAgICAgICAgICAgICAgIDogaW5wdXRUeXBlID09PSBcImRhdGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcIlktbS1kXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJIOmk6U1wiO1xuICAgICAgICAgICAgaWYgKHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC5kZWZhdWx0VmFsdWUgPSBzZWxmLm1vYmlsZUlucHV0LnZhbHVlID0gc2VsZi5mb3JtYXREYXRlKHNlbGYuc2VsZWN0ZWREYXRlc1swXSwgc2VsZi5tb2JpbGVGb3JtYXRTdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1pbkRhdGUpXG4gICAgICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC5taW4gPSBzZWxmLmZvcm1hdERhdGUoc2VsZi5jb25maWcubWluRGF0ZSwgXCJZLW0tZFwiKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tYXhEYXRlKVxuICAgICAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQubWF4ID0gc2VsZi5mb3JtYXREYXRlKHNlbGYuY29uZmlnLm1heERhdGUsIFwiWS1tLWRcIik7XG4gICAgICAgICAgICBzZWxmLmlucHV0LnR5cGUgPSBcImhpZGRlblwiO1xuICAgICAgICAgICAgaWYgKHNlbGYuYWx0SW5wdXQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBzZWxmLmFsdElucHV0LnR5cGUgPSBcImhpZGRlblwiO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5pbnB1dC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmlucHV0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNlbGYubW9iaWxlSW5wdXQsIHNlbGYuaW5wdXQubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICAgICAgICAgIGJpbmQoc2VsZi5tb2JpbGVJbnB1dCwgXCJjaGFuZ2VcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNldERhdGUoZS50YXJnZXQudmFsdWUsIGZhbHNlLCBzZWxmLm1vYmlsZUZvcm1hdFN0cik7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25DaGFuZ2VcIik7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25DbG9zZVwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRvZ2dsZShlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5pc09wZW4gPT09IHRydWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2xvc2UoKTtcbiAgICAgICAgICAgIHNlbGYub3BlbihlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0cmlnZ2VyRXZlbnQoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQgYWxyZWFkeSwgYWxsIGhvb2tzIGhhdmUgYmVlbiByZW1vdmVkXG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgaG9va3MgPSBzZWxmLmNvbmZpZ1tldmVudF07XG4gICAgICAgICAgICBpZiAoaG9va3MgIT09IHVuZGVmaW5lZCAmJiBob29rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGhvb2tzW2ldICYmIGkgPCBob29rcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaG9va3NbaV0oc2VsZi5zZWxlY3RlZERhdGVzLCBzZWxmLmlucHV0LnZhbHVlLCBzZWxmLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChldmVudCA9PT0gXCJvbkNoYW5nZVwiKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pbnB1dC5kaXNwYXRjaEV2ZW50KGNyZWF0ZUV2ZW50KFwiY2hhbmdlXCIpKTtcbiAgICAgICAgICAgICAgICAvLyBtYW55IGZyb250LWVuZCBmcmFtZXdvcmtzIGJpbmQgdG8gdGhlIGlucHV0IGV2ZW50XG4gICAgICAgICAgICAgICAgc2VsZi5pbnB1dC5kaXNwYXRjaEV2ZW50KGNyZWF0ZUV2ZW50KFwiaW5wdXRcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUV2ZW50KG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTtcbiAgICAgICAgICAgIGUuaW5pdEV2ZW50KG5hbWUsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNEYXRlU2VsZWN0ZWQoZGF0ZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZURhdGVzKHNlbGYuc2VsZWN0ZWREYXRlc1tpXSwgZGF0ZSkgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiICsgaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0RhdGVJblJhbmdlKGRhdGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tb2RlICE9PSBcInJhbmdlXCIgfHwgc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA8IDIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIChjb21wYXJlRGF0ZXMoZGF0ZSwgc2VsZi5zZWxlY3RlZERhdGVzWzBdKSA+PSAwICYmXG4gICAgICAgICAgICAgICAgY29tcGFyZURhdGVzKGRhdGUsIHNlbGYuc2VsZWN0ZWREYXRlc1sxXSkgPD0gMCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlTmF2aWdhdGlvbkN1cnJlbnRNb250aCgpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5ub0NhbGVuZGFyIHx8IHNlbGYuaXNNb2JpbGUgfHwgIXNlbGYubW9udGhOYXYpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2VsZi55ZWFyRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoeWVhckVsZW1lbnQsIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IG5ldyBEYXRlKHNlbGYuY3VycmVudFllYXIsIHNlbGYuY3VycmVudE1vbnRoLCAxKTtcbiAgICAgICAgICAgICAgICBkLnNldE1vbnRoKHNlbGYuY3VycmVudE1vbnRoICsgaSk7XG4gICAgICAgICAgICAgICAgc2VsZi5tb250aEVsZW1lbnRzW2ldLnRleHRDb250ZW50ID1cbiAgICAgICAgICAgICAgICAgICAgbW9udGhUb1N0cihkLmdldE1vbnRoKCksIHNlbGYuY29uZmlnLnNob3J0aGFuZEN1cnJlbnRNb250aCwgc2VsZi5sMTBuKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBcIjtcbiAgICAgICAgICAgICAgICB5ZWFyRWxlbWVudC52YWx1ZSA9IGQuZ2V0RnVsbFllYXIoKS50b1N0cmluZygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxmLl9oaWRlUHJldk1vbnRoQXJyb3cgPVxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1pbkRhdGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAoc2VsZi5jdXJyZW50WWVhciA9PT0gc2VsZi5jb25maWcubWluRGF0ZS5nZXRGdWxsWWVhcigpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY3VycmVudE1vbnRoIDw9IHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0TW9udGgoKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzZWxmLmN1cnJlbnRZZWFyIDwgc2VsZi5jb25maWcubWluRGF0ZS5nZXRGdWxsWWVhcigpKTtcbiAgICAgICAgICAgIHNlbGYuX2hpZGVOZXh0TW9udGhBcnJvdyA9XG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcubWF4RGF0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIChzZWxmLmN1cnJlbnRZZWFyID09PSBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldEZ1bGxZZWFyKClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZi5jdXJyZW50TW9udGggKyAxID4gc2VsZi5jb25maWcubWF4RGF0ZS5nZXRNb250aCgpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHNlbGYuY3VycmVudFllYXIgPiBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldEZ1bGxZZWFyKCkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldERhdGVTdHIoZm9ybWF0KSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5zZWxlY3RlZERhdGVzXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZE9iaikgeyByZXR1cm4gc2VsZi5mb3JtYXREYXRlKGRPYmosIGZvcm1hdCk7IH0pXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZCwgaSwgYXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY29uZmlnLm1vZGUgIT09IFwicmFuZ2VcIiB8fFxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5lbmFibGVUaW1lIHx8XG4gICAgICAgICAgICAgICAgICAgIGFyci5pbmRleE9mKGQpID09PSBpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuam9pbihzZWxmLmNvbmZpZy5tb2RlICE9PSBcInJhbmdlXCJcbiAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLmNvbmp1bmN0aW9uXG4gICAgICAgICAgICAgICAgOiBzZWxmLmwxMG4ucmFuZ2VTZXBhcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIHRoZSB2YWx1ZXMgb2YgaW5wdXRzIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2FsZW5kYXJcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVZhbHVlKHRyaWdnZXJDaGFuZ2UpIHtcbiAgICAgICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlID09PSB2b2lkIDApIHsgdHJpZ2dlckNoYW5nZSA9IHRydWU7IH1cbiAgICAgICAgICAgIGlmIChzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNsZWFyKHRyaWdnZXJDaGFuZ2UpO1xuICAgICAgICAgICAgaWYgKHNlbGYubW9iaWxlSW5wdXQgIT09IHVuZGVmaW5lZCAmJiBzZWxmLm1vYmlsZUZvcm1hdFN0cikge1xuICAgICAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQudmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYuZm9ybWF0RGF0ZShzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiwgc2VsZi5tb2JpbGVGb3JtYXRTdHIpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmlucHV0LnZhbHVlID0gZ2V0RGF0ZVN0cihzZWxmLmNvbmZpZy5kYXRlRm9ybWF0KTtcbiAgICAgICAgICAgIGlmIChzZWxmLmFsdElucHV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmFsdElucHV0LnZhbHVlID0gZ2V0RGF0ZVN0cihzZWxmLmNvbmZpZy5hbHRGb3JtYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyaWdnZXJDaGFuZ2UgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uVmFsdWVVcGRhdGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25Nb250aE5hdkNsaWNrKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHZhciBpc1ByZXZNb250aCA9IHNlbGYucHJldk1vbnRoTmF2LmNvbnRhaW5zKGUudGFyZ2V0KTtcbiAgICAgICAgICAgIHZhciBpc05leHRNb250aCA9IHNlbGYubmV4dE1vbnRoTmF2LmNvbnRhaW5zKGUudGFyZ2V0KTtcbiAgICAgICAgICAgIGlmIChpc1ByZXZNb250aCB8fCBpc05leHRNb250aCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZU1vbnRoKGlzUHJldk1vbnRoID8gLTEgOiAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYueWVhckVsZW1lbnRzLmluZGV4T2YoZS50YXJnZXQpID49IDApIHtcbiAgICAgICAgICAgICAgICBlLnRhcmdldC5zZWxlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcImFycm93VXBcIikpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNoYW5nZVllYXIoc2VsZi5jdXJyZW50WWVhciArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZS50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYXJyb3dEb3duXCIpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jaGFuZ2VZZWFyKHNlbGYuY3VycmVudFllYXIgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0aW1lV3JhcHBlcihlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB2YXIgaXNLZXlEb3duID0gZS50eXBlID09PSBcImtleWRvd25cIiwgaW5wdXQgPSBlLnRhcmdldDtcbiAgICAgICAgICAgIGlmIChzZWxmLmFtUE0gIT09IHVuZGVmaW5lZCAmJiBlLnRhcmdldCA9PT0gc2VsZi5hbVBNKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5hbVBNLnRleHRDb250ZW50ID1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sMTBuLmFtUE1baW50KHNlbGYuYW1QTS50ZXh0Q29udGVudCA9PT0gc2VsZi5sMTBuLmFtUE1bMF0pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtaW4gPSBwYXJzZUZsb2F0KGlucHV0LmdldEF0dHJpYnV0ZShcIm1pblwiKSksIG1heCA9IHBhcnNlRmxvYXQoaW5wdXQuZ2V0QXR0cmlidXRlKFwibWF4XCIpKSwgc3RlcCA9IHBhcnNlRmxvYXQoaW5wdXQuZ2V0QXR0cmlidXRlKFwic3RlcFwiKSksIGN1clZhbHVlID0gcGFyc2VJbnQoaW5wdXQudmFsdWUsIDEwKSwgZGVsdGEgPSBlLmRlbHRhIHx8XG4gICAgICAgICAgICAgICAgKGlzS2V5RG93biA/IChlLndoaWNoID09PSAzOCA/IDEgOiAtMSkgOiAwKTtcbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IGN1clZhbHVlICsgc3RlcCAqIGRlbHRhO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dC52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpbnB1dC52YWx1ZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNIb3VyRWxlbSA9IGlucHV0ID09PSBzZWxmLmhvdXJFbGVtZW50LCBpc01pbnV0ZUVsZW0gPSBpbnB1dCA9PT0gc2VsZi5taW51dGVFbGVtZW50O1xuICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA8IG1pbikge1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXggK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnQoIWlzSG91ckVsZW0pICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaW50KGlzSG91ckVsZW0pICYmIGludCghc2VsZi5hbVBNKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01pbnV0ZUVsZW0pXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnROdW1JbnB1dCh1bmRlZmluZWQsIC0xLCBzZWxmLmhvdXJFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmV3VmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQgPT09IHNlbGYuaG91ckVsZW1lbnQgPyBuZXdWYWx1ZSAtIG1heCAtIGludCghc2VsZi5hbVBNKSA6IG1pbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTWludXRlRWxlbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY3JlbWVudE51bUlucHV0KHVuZGVmaW5lZCwgMSwgc2VsZi5ob3VyRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmFtUE0gJiZcbiAgICAgICAgICAgICAgICAgICAgaXNIb3VyRWxlbSAmJlxuICAgICAgICAgICAgICAgICAgICAoc3RlcCA9PT0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXdWYWx1ZSArIGN1clZhbHVlID09PSAyM1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBNYXRoLmFicyhuZXdWYWx1ZSAtIGN1clZhbHVlKSA+IHN0ZXApKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYW1QTS50ZXh0Q29udGVudCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmwxMG4uYW1QTVtpbnQoc2VsZi5hbVBNLnRleHRDb250ZW50ID09PSBzZWxmLmwxMG4uYW1QTVswXSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnB1dC52YWx1ZSA9IHBhZChuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5pdCgpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBmdW5jdGlvbiBfZmxhdHBpY2tyKG5vZGVMaXN0LCBjb25maWcpIHtcbiAgICAgICAgLy8gc3RhdGljIGxpc3RcbiAgICAgICAgdmFyIG5vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlXG4gICAgICAgICAgICAuY2FsbChub2RlTGlzdClcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggaW5zdGFuY2VvZiBIVE1MRWxlbWVudDsgfSk7XG4gICAgICAgIHZhciBpbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1mcC1vbWl0XCIpICE9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5fZmxhdHBpY2tyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fZmxhdHBpY2tyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fZmxhdHBpY2tyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLl9mbGF0cGlja3IgPSBGbGF0cGlja3JJbnN0YW5jZShub2RlLCBjb25maWcgfHwge30pO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlcy5wdXNoKG5vZGUuX2ZsYXRwaWNrcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlcy5sZW5ndGggPT09IDEgPyBpbnN0YW5jZXNbMF0gOiBpbnN0YW5jZXM7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvLyBicm93c2VyIGVudlxuICAgICAgICBIVE1MQ29sbGVjdGlvbi5wcm90b3R5cGUuZmxhdHBpY2tyID0gTm9kZUxpc3QucHJvdG90eXBlLmZsYXRwaWNrciA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiBfZmxhdHBpY2tyKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIH07XG4gICAgICAgIEhUTUxFbGVtZW50LnByb3RvdHlwZS5mbGF0cGlja3IgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gX2ZsYXRwaWNrcihbdGhpc10sIGNvbmZpZyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdmFyIGZsYXRwaWNrciA9IGZ1bmN0aW9uIChzZWxlY3RvciwgY29uZmlnKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBfZmxhdHBpY2tyKHdpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZWxlY3RvciBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfZmxhdHBpY2tyKFtzZWxlY3Rvcl0sIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gX2ZsYXRwaWNrcihzZWxlY3RvciwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBmbGF0cGlja3IuZGVmYXVsdENvbmZpZyA9IGRlZmF1bHRzO1xuICAgIGZsYXRwaWNrci5sMTBucyA9IHtcbiAgICAgICAgZW46IF9fYXNzaWduKHt9LCBlbmdsaXNoKSxcbiAgICAgICAgXCJkZWZhdWx0XCI6IF9fYXNzaWduKHt9LCBlbmdsaXNoKVxuICAgIH07XG4gICAgZmxhdHBpY2tyLmxvY2FsaXplID0gZnVuY3Rpb24gKGwxMG4pIHtcbiAgICAgICAgZmxhdHBpY2tyLmwxMG5zW1wiZGVmYXVsdFwiXSA9IF9fYXNzaWduKHt9LCBmbGF0cGlja3IubDEwbnNbXCJkZWZhdWx0XCJdLCBsMTBuKTtcbiAgICB9O1xuICAgIGZsYXRwaWNrci5zZXREZWZhdWx0cyA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgZmxhdHBpY2tyLmRlZmF1bHRDb25maWcgPSBfX2Fzc2lnbih7fSwgZmxhdHBpY2tyLmRlZmF1bHRDb25maWcsIGNvbmZpZyk7XG4gICAgfTtcbiAgICBmbGF0cGlja3IucGFyc2VEYXRlID0gY3JlYXRlRGF0ZVBhcnNlcih7fSk7XG4gICAgZmxhdHBpY2tyLmZvcm1hdERhdGUgPSBjcmVhdGVEYXRlRm9ybWF0dGVyKHt9KTtcbiAgICBmbGF0cGlja3IuY29tcGFyZURhdGVzID0gY29tcGFyZURhdGVzO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgalF1ZXJ5LmZuLmZsYXRwaWNrciA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiBfZmxhdHBpY2tyKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIERhdGUucHJvdG90eXBlLmZwX2luY3IgPSBmdW5jdGlvbiAoZGF5cykge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy5nZXRGdWxsWWVhcigpLCB0aGlzLmdldE1vbnRoKCksIHRoaXMuZ2V0RGF0ZSgpICsgKHR5cGVvZiBkYXlzID09PSBcInN0cmluZ1wiID8gcGFyc2VJbnQoZGF5cywgMTApIDogZGF5cykpO1xuICAgIH07XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgd2luZG93LmZsYXRwaWNrciA9IGZsYXRwaWNrcjtcbiAgICB9XG5cbiAgICByZXR1cm4gZmxhdHBpY2tyO1xuXG59KSk7XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuZGUgPSB7fSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZwID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuZmxhdHBpY2tyICE9PSB1bmRlZmluZWRcbiAgICAgID8gd2luZG93LmZsYXRwaWNrclxuICAgICAgOiB7XG4gICAgICAgICAgbDEwbnM6IHt9XG4gICAgICB9O1xuICB2YXIgR2VybWFuID0ge1xuICAgICAgd2Vla2RheXM6IHtcbiAgICAgICAgICBzaG9ydGhhbmQ6IFtcIlNvXCIsIFwiTW9cIiwgXCJEaVwiLCBcIk1pXCIsIFwiRG9cIiwgXCJGclwiLCBcIlNhXCJdLFxuICAgICAgICAgIGxvbmdoYW5kOiBbXG4gICAgICAgICAgICAgIFwiU29ubnRhZ1wiLFxuICAgICAgICAgICAgICBcIk1vbnRhZ1wiLFxuICAgICAgICAgICAgICBcIkRpZW5zdGFnXCIsXG4gICAgICAgICAgICAgIFwiTWl0dHdvY2hcIixcbiAgICAgICAgICAgICAgXCJEb25uZXJzdGFnXCIsXG4gICAgICAgICAgICAgIFwiRnJlaXRhZ1wiLFxuICAgICAgICAgICAgICBcIlNhbXN0YWdcIixcbiAgICAgICAgICBdXG4gICAgICB9LFxuICAgICAgbW9udGhzOiB7XG4gICAgICAgICAgc2hvcnRoYW5kOiBbXG4gICAgICAgICAgICAgIFwiSmFuXCIsXG4gICAgICAgICAgICAgIFwiRmViXCIsXG4gICAgICAgICAgICAgIFwiTcOkclwiLFxuICAgICAgICAgICAgICBcIkFwclwiLFxuICAgICAgICAgICAgICBcIk1haVwiLFxuICAgICAgICAgICAgICBcIkp1blwiLFxuICAgICAgICAgICAgICBcIkp1bFwiLFxuICAgICAgICAgICAgICBcIkF1Z1wiLFxuICAgICAgICAgICAgICBcIlNlcFwiLFxuICAgICAgICAgICAgICBcIk9rdFwiLFxuICAgICAgICAgICAgICBcIk5vdlwiLFxuICAgICAgICAgICAgICBcIkRlelwiLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgbG9uZ2hhbmQ6IFtcbiAgICAgICAgICAgICAgXCJKYW51YXJcIixcbiAgICAgICAgICAgICAgXCJGZWJydWFyXCIsXG4gICAgICAgICAgICAgIFwiTcOkcnpcIixcbiAgICAgICAgICAgICAgXCJBcHJpbFwiLFxuICAgICAgICAgICAgICBcIk1haVwiLFxuICAgICAgICAgICAgICBcIkp1bmlcIixcbiAgICAgICAgICAgICAgXCJKdWxpXCIsXG4gICAgICAgICAgICAgIFwiQXVndXN0XCIsXG4gICAgICAgICAgICAgIFwiU2VwdGVtYmVyXCIsXG4gICAgICAgICAgICAgIFwiT2t0b2JlclwiLFxuICAgICAgICAgICAgICBcIk5vdmVtYmVyXCIsXG4gICAgICAgICAgICAgIFwiRGV6ZW1iZXJcIixcbiAgICAgICAgICBdXG4gICAgICB9LFxuICAgICAgZmlyc3REYXlPZldlZWs6IDEsXG4gICAgICB3ZWVrQWJicmV2aWF0aW9uOiBcIktXXCIsXG4gICAgICByYW5nZVNlcGFyYXRvcjogXCIgYmlzIFwiLFxuICAgICAgc2Nyb2xsVGl0bGU6IFwiWnVtIMOEbmRlcm4gc2Nyb2xsZW5cIixcbiAgICAgIHRvZ2dsZVRpdGxlOiBcIlp1bSBVbXNjaGFsdGVuIGtsaWNrZW5cIlxuICB9O1xuICBmcC5sMTBucy5kZSA9IEdlcm1hbjtcbiAgdmFyIGRlID0gZnAubDEwbnM7XG5cbiAgZXhwb3J0cy5HZXJtYW4gPSBHZXJtYW47XG4gIGV4cG9ydHMuZGVmYXVsdCA9IGRlO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5mciA9IHt9KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZnAgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5mbGF0cGlja3IgIT09IHVuZGVmaW5lZFxuICAgICAgPyB3aW5kb3cuZmxhdHBpY2tyXG4gICAgICA6IHtcbiAgICAgICAgICBsMTBuczoge31cbiAgICAgIH07XG4gIHZhciBGcmVuY2ggPSB7XG4gICAgICBmaXJzdERheU9mV2VlazogMSxcbiAgICAgIHdlZWtkYXlzOiB7XG4gICAgICAgICAgc2hvcnRoYW5kOiBbXCJkaW1cIiwgXCJsdW5cIiwgXCJtYXJcIiwgXCJtZXJcIiwgXCJqZXVcIiwgXCJ2ZW5cIiwgXCJzYW1cIl0sXG4gICAgICAgICAgbG9uZ2hhbmQ6IFtcbiAgICAgICAgICAgICAgXCJkaW1hbmNoZVwiLFxuICAgICAgICAgICAgICBcImx1bmRpXCIsXG4gICAgICAgICAgICAgIFwibWFyZGlcIixcbiAgICAgICAgICAgICAgXCJtZXJjcmVkaVwiLFxuICAgICAgICAgICAgICBcImpldWRpXCIsXG4gICAgICAgICAgICAgIFwidmVuZHJlZGlcIixcbiAgICAgICAgICAgICAgXCJzYW1lZGlcIixcbiAgICAgICAgICBdXG4gICAgICB9LFxuICAgICAgbW9udGhzOiB7XG4gICAgICAgICAgc2hvcnRoYW5kOiBbXG4gICAgICAgICAgICAgIFwiamFudlwiLFxuICAgICAgICAgICAgICBcImbDqXZyXCIsXG4gICAgICAgICAgICAgIFwibWFyc1wiLFxuICAgICAgICAgICAgICBcImF2clwiLFxuICAgICAgICAgICAgICBcIm1haVwiLFxuICAgICAgICAgICAgICBcImp1aW5cIixcbiAgICAgICAgICAgICAgXCJqdWlsXCIsXG4gICAgICAgICAgICAgIFwiYW/Du3RcIixcbiAgICAgICAgICAgICAgXCJzZXB0XCIsXG4gICAgICAgICAgICAgIFwib2N0XCIsXG4gICAgICAgICAgICAgIFwibm92XCIsXG4gICAgICAgICAgICAgIFwiZMOpY1wiLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgbG9uZ2hhbmQ6IFtcbiAgICAgICAgICAgICAgXCJqYW52aWVyXCIsXG4gICAgICAgICAgICAgIFwiZsOpdnJpZXJcIixcbiAgICAgICAgICAgICAgXCJtYXJzXCIsXG4gICAgICAgICAgICAgIFwiYXZyaWxcIixcbiAgICAgICAgICAgICAgXCJtYWlcIixcbiAgICAgICAgICAgICAgXCJqdWluXCIsXG4gICAgICAgICAgICAgIFwianVpbGxldFwiLFxuICAgICAgICAgICAgICBcImFvw7t0XCIsXG4gICAgICAgICAgICAgIFwic2VwdGVtYnJlXCIsXG4gICAgICAgICAgICAgIFwib2N0b2JyZVwiLFxuICAgICAgICAgICAgICBcIm5vdmVtYnJlXCIsXG4gICAgICAgICAgICAgIFwiZMOpY2VtYnJlXCIsXG4gICAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIG9yZGluYWw6IGZ1bmN0aW9uIChudGgpIHtcbiAgICAgICAgICBpZiAobnRoID4gMSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgcmV0dXJuIFwiZXJcIjtcbiAgICAgIH0sXG4gICAgICByYW5nZVNlcGFyYXRvcjogXCIgYXUgXCIsXG4gICAgICB3ZWVrQWJicmV2aWF0aW9uOiBcIlNlbVwiLFxuICAgICAgc2Nyb2xsVGl0bGU6IFwiRMOpZmlsZXIgcG91ciBhdWdtZW50ZXIgbGEgdmFsZXVyXCIsXG4gICAgICB0b2dnbGVUaXRsZTogXCJDbGlxdWVyIHBvdXIgYmFzY3VsZXJcIlxuICB9O1xuICBmcC5sMTBucy5mciA9IEZyZW5jaDtcbiAgdmFyIGZyID0gZnAubDEwbnM7XG5cbiAgZXhwb3J0cy5GcmVuY2ggPSBGcmVuY2g7XG4gIGV4cG9ydHMuZGVmYXVsdCA9IGZyO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5pdCA9IHt9KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZnAgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5mbGF0cGlja3IgIT09IHVuZGVmaW5lZFxuICAgICAgPyB3aW5kb3cuZmxhdHBpY2tyXG4gICAgICA6IHtcbiAgICAgICAgICBsMTBuczoge31cbiAgICAgIH07XG4gIHZhciBJdGFsaWFuID0ge1xuICAgICAgd2Vla2RheXM6IHtcbiAgICAgICAgICBzaG9ydGhhbmQ6IFtcIkRvbVwiLCBcIkx1blwiLCBcIk1hclwiLCBcIk1lclwiLCBcIkdpb1wiLCBcIlZlblwiLCBcIlNhYlwiXSxcbiAgICAgICAgICBsb25naGFuZDogW1xuICAgICAgICAgICAgICBcIkRvbWVuaWNhXCIsXG4gICAgICAgICAgICAgIFwiTHVuZWTDrFwiLFxuICAgICAgICAgICAgICBcIk1hcnRlZMOsXCIsXG4gICAgICAgICAgICAgIFwiTWVyY29sZWTDrFwiLFxuICAgICAgICAgICAgICBcIkdpb3ZlZMOsXCIsXG4gICAgICAgICAgICAgIFwiVmVuZXJkw6xcIixcbiAgICAgICAgICAgICAgXCJTYWJhdG9cIixcbiAgICAgICAgICBdXG4gICAgICB9LFxuICAgICAgbW9udGhzOiB7XG4gICAgICAgICAgc2hvcnRoYW5kOiBbXG4gICAgICAgICAgICAgIFwiR2VuXCIsXG4gICAgICAgICAgICAgIFwiRmViXCIsXG4gICAgICAgICAgICAgIFwiTWFyXCIsXG4gICAgICAgICAgICAgIFwiQXByXCIsXG4gICAgICAgICAgICAgIFwiTWFnXCIsXG4gICAgICAgICAgICAgIFwiR2l1XCIsXG4gICAgICAgICAgICAgIFwiTHVnXCIsXG4gICAgICAgICAgICAgIFwiQWdvXCIsXG4gICAgICAgICAgICAgIFwiU2V0XCIsXG4gICAgICAgICAgICAgIFwiT3R0XCIsXG4gICAgICAgICAgICAgIFwiTm92XCIsXG4gICAgICAgICAgICAgIFwiRGljXCIsXG4gICAgICAgICAgXSxcbiAgICAgICAgICBsb25naGFuZDogW1xuICAgICAgICAgICAgICBcIkdlbm5haW9cIixcbiAgICAgICAgICAgICAgXCJGZWJicmFpb1wiLFxuICAgICAgICAgICAgICBcIk1hcnpvXCIsXG4gICAgICAgICAgICAgIFwiQXByaWxlXCIsXG4gICAgICAgICAgICAgIFwiTWFnZ2lvXCIsXG4gICAgICAgICAgICAgIFwiR2l1Z25vXCIsXG4gICAgICAgICAgICAgIFwiTHVnbGlvXCIsXG4gICAgICAgICAgICAgIFwiQWdvc3RvXCIsXG4gICAgICAgICAgICAgIFwiU2V0dGVtYnJlXCIsXG4gICAgICAgICAgICAgIFwiT3R0b2JyZVwiLFxuICAgICAgICAgICAgICBcIk5vdmVtYnJlXCIsXG4gICAgICAgICAgICAgIFwiRGljZW1icmVcIixcbiAgICAgICAgICBdXG4gICAgICB9LFxuICAgICAgZmlyc3REYXlPZldlZWs6IDEsXG4gICAgICBvcmRpbmFsOiBmdW5jdGlvbiAoKSB7IHJldHVybiBcIsKwXCI7IH0sXG4gICAgICByYW5nZVNlcGFyYXRvcjogXCIgYWwgXCIsXG4gICAgICB3ZWVrQWJicmV2aWF0aW9uOiBcIlNlXCIsXG4gICAgICBzY3JvbGxUaXRsZTogXCJTY3JvbGxhIHBlciBhdW1lbnRhcmVcIixcbiAgICAgIHRvZ2dsZVRpdGxlOiBcIkNsaWNjYSBwZXIgY2FtYmlhcmVcIlxuICB9O1xuICBmcC5sMTBucy5pdCA9IEl0YWxpYW47XG4gIHZhciBpdCA9IGZwLmwxMG5zO1xuXG4gIGV4cG9ydHMuSXRhbGlhbiA9IEl0YWxpYW47XG4gIGV4cG9ydHMuZGVmYXVsdCA9IGl0O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbiIsIi8qKiFcbiAqIEBmaWxlT3ZlcnZpZXcgS2lja2FzcyBsaWJyYXJ5IHRvIGNyZWF0ZSBhbmQgcGxhY2UgcG9wcGVycyBuZWFyIHRoZWlyIHJlZmVyZW5jZSBlbGVtZW50cy5cbiAqIEB2ZXJzaW9uIDEuMTIuOVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNiBGZWRlcmljbyBaaXZvbG8gYW5kIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0KGdsb2JhbC5Qb3BwZXIgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xudmFyIGxvbmdlclRpbWVvdXRCcm93c2VycyA9IFsnRWRnZScsICdUcmlkZW50JywgJ0ZpcmVmb3gnXTtcbnZhciB0aW1lb3V0RHVyYXRpb24gPSAwO1xuZm9yICh2YXIgaSA9IDA7IGkgPCBsb25nZXJUaW1lb3V0QnJvd3NlcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgaWYgKGlzQnJvd3NlciAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YobG9uZ2VyVGltZW91dEJyb3dzZXJzW2ldKSA+PSAwKSB7XG4gICAgdGltZW91dER1cmF0aW9uID0gMTtcbiAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBtaWNyb3Rhc2tEZWJvdW5jZShmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIHdpbmRvdy5Qcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxlZCA9IGZhbHNlO1xuICAgICAgZm4oKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGFza0RlYm91bmNlKGZuKSB7XG4gIHZhciBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNjaGVkdWxlZCkge1xuICAgICAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0sIHRpbWVvdXREdXJhdGlvbik7XG4gICAgfVxuICB9O1xufVxuXG52YXIgc3VwcG9ydHNNaWNyb1Rhc2tzID0gaXNCcm93c2VyICYmIHdpbmRvdy5Qcm9taXNlO1xuXG4vKipcbiogQ3JlYXRlIGEgZGVib3VuY2VkIHZlcnNpb24gb2YgYSBtZXRob2QsIHRoYXQncyBhc3luY2hyb25vdXNseSBkZWZlcnJlZFxuKiBidXQgY2FsbGVkIGluIHRoZSBtaW5pbXVtIHRpbWUgcG9zc2libGUuXG4qXG4qIEBtZXRob2RcbiogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuKiBAYXJndW1lbnQge0Z1bmN0aW9ufSBmblxuKiBAcmV0dXJucyB7RnVuY3Rpb259XG4qL1xudmFyIGRlYm91bmNlID0gc3VwcG9ydHNNaWNyb1Rhc2tzID8gbWljcm90YXNrRGVib3VuY2UgOiB0YXNrRGVib3VuY2U7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QW55fSBmdW5jdGlvblRvQ2hlY2sgLSB2YXJpYWJsZSB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IGFuc3dlciB0bzogaXMgYSBmdW5jdGlvbj9cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbihmdW5jdGlvblRvQ2hlY2spIHtcbiAgdmFyIGdldFR5cGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uVG9DaGVjayAmJiBnZXRUeXBlLnRvU3RyaW5nLmNhbGwoZnVuY3Rpb25Ub0NoZWNrKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBHZXQgQ1NTIGNvbXB1dGVkIHByb3BlcnR5IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50LCBwcm9wZXJ0eSkge1xuICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICB2YXIgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbiAgcmV0dXJuIHByb3BlcnR5ID8gY3NzW3Byb3BlcnR5XSA6IGNzcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXJlbnROb2RlIG9yIHRoZSBob3N0IG9mIHRoZSBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICByZXR1cm4gZWxlbWVudC5wYXJlbnROb2RlIHx8IGVsZW1lbnQuaG9zdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzY3JvbGxpbmcgcGFyZW50IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBzY3JvbGwgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChlbGVtZW50KSB7XG4gIC8vIFJldHVybiBib2R5LCBgZ2V0U2Nyb2xsYCB3aWxsIHRha2UgY2FyZSB0byBnZXQgdGhlIGNvcnJlY3QgYHNjcm9sbFRvcGAgZnJvbSBpdFxuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgfVxuXG4gIHN3aXRjaCAoZWxlbWVudC5ub2RlTmFtZSkge1xuICAgIGNhc2UgJ0hUTUwnOlxuICAgIGNhc2UgJ0JPRFknOlxuICAgICAgcmV0dXJuIGVsZW1lbnQub3duZXJEb2N1bWVudC5ib2R5O1xuICAgIGNhc2UgJyNkb2N1bWVudCc6XG4gICAgICByZXR1cm4gZWxlbWVudC5ib2R5O1xuICB9XG5cbiAgLy8gRmlyZWZveCB3YW50IHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG5cbiAgdmFyIF9nZXRTdHlsZUNvbXB1dGVkUHJvcCA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50KSxcbiAgICAgIG92ZXJmbG93ID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93WCxcbiAgICAgIG92ZXJmbG93WSA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvd1k7XG5cbiAgaWYgKC8oYXV0b3xzY3JvbGwpLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKSkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuIGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvZmZzZXQgcGFyZW50IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBvZmZzZXQgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gIHZhciBvZmZzZXRQYXJlbnQgPSBlbGVtZW50ICYmIGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuICB2YXIgbm9kZU5hbWUgPSBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50Lm5vZGVOYW1lO1xuXG4gIGlmICghbm9kZU5hbWUgfHwgbm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH1cblxuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICAvLyAub2Zmc2V0UGFyZW50IHdpbGwgcmV0dXJuIHRoZSBjbG9zZXN0IFREIG9yIFRBQkxFIGluIGNhc2VcbiAgLy8gbm8gb2Zmc2V0UGFyZW50IGlzIHByZXNlbnQsIEkgaGF0ZSB0aGlzIGpvYi4uLlxuICBpZiAoWydURCcsICdUQUJMRSddLmluZGV4T2Yob2Zmc2V0UGFyZW50Lm5vZGVOYW1lKSAhPT0gLTEgJiYgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KG9mZnNldFBhcmVudCwgJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG4gICAgcmV0dXJuIGdldE9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQpO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldFBhcmVudDtcbn1cblxuZnVuY3Rpb24gaXNPZmZzZXRDb250YWluZXIoZWxlbWVudCkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBub2RlTmFtZSA9PT0gJ0hUTUwnIHx8IGdldE9mZnNldFBhcmVudChlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKSA9PT0gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgcm9vdCBub2RlIChkb2N1bWVudCwgc2hhZG93RE9NIHJvb3QpIG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm5zIHtFbGVtZW50fSByb290IG5vZGVcbiAqL1xuZnVuY3Rpb24gZ2V0Um9vdChub2RlKSB7XG4gIGlmIChub2RlLnBhcmVudE5vZGUgIT09IG51bGwpIHtcbiAgICByZXR1cm4gZ2V0Um9vdChub2RlLnBhcmVudE5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIG9mZnNldCBwYXJlbnQgY29tbW9uIHRvIHRoZSB0d28gcHJvdmlkZWQgbm9kZXNcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudDFcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudDJcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBjb21tb24gb2Zmc2V0IHBhcmVudFxuICovXG5mdW5jdGlvbiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQxLCBlbGVtZW50Mikge1xuICAvLyBUaGlzIGNoZWNrIGlzIG5lZWRlZCB0byBhdm9pZCBlcnJvcnMgaW4gY2FzZSBvbmUgb2YgdGhlIGVsZW1lbnRzIGlzbid0IGRlZmluZWQgZm9yIGFueSByZWFzb25cbiAgaWYgKCFlbGVtZW50MSB8fCAhZWxlbWVudDEubm9kZVR5cGUgfHwgIWVsZW1lbnQyIHx8ICFlbGVtZW50Mi5ub2RlVHlwZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICAvLyBIZXJlIHdlIG1ha2Ugc3VyZSB0byBnaXZlIGFzIFwic3RhcnRcIiB0aGUgZWxlbWVudCB0aGF0IGNvbWVzIGZpcnN0IGluIHRoZSBET01cbiAgdmFyIG9yZGVyID0gZWxlbWVudDEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZWxlbWVudDIpICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkc7XG4gIHZhciBzdGFydCA9IG9yZGVyID8gZWxlbWVudDEgOiBlbGVtZW50MjtcbiAgdmFyIGVuZCA9IG9yZGVyID8gZWxlbWVudDIgOiBlbGVtZW50MTtcblxuICAvLyBHZXQgY29tbW9uIGFuY2VzdG9yIGNvbnRhaW5lclxuICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICByYW5nZS5zZXRTdGFydChzdGFydCwgMCk7XG4gIHJhbmdlLnNldEVuZChlbmQsIDApO1xuICB2YXIgY29tbW9uQW5jZXN0b3JDb250YWluZXIgPSByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcblxuICAvLyBCb3RoIG5vZGVzIGFyZSBpbnNpZGUgI2RvY3VtZW50XG5cbiAgaWYgKGVsZW1lbnQxICE9PSBjb21tb25BbmNlc3RvckNvbnRhaW5lciAmJiBlbGVtZW50MiAhPT0gY29tbW9uQW5jZXN0b3JDb250YWluZXIgfHwgc3RhcnQuY29udGFpbnMoZW5kKSkge1xuICAgIGlmIChpc09mZnNldENvbnRhaW5lcihjb21tb25BbmNlc3RvckNvbnRhaW5lcikpIHtcbiAgICAgIHJldHVybiBjb21tb25BbmNlc3RvckNvbnRhaW5lcjtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0T2Zmc2V0UGFyZW50KGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKTtcbiAgfVxuXG4gIC8vIG9uZSBvZiB0aGUgbm9kZXMgaXMgaW5zaWRlIHNoYWRvd0RPTSwgZmluZCB3aGljaCBvbmVcbiAgdmFyIGVsZW1lbnQxcm9vdCA9IGdldFJvb3QoZWxlbWVudDEpO1xuICBpZiAoZWxlbWVudDFyb290Lmhvc3QpIHtcbiAgICByZXR1cm4gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MXJvb3QuaG9zdCwgZWxlbWVudDIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQxLCBnZXRSb290KGVsZW1lbnQyKS5ob3N0KTtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIHNjcm9sbCB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudCBpbiB0aGUgZ2l2ZW4gc2lkZSAodG9wIGFuZCBsZWZ0KVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAYXJndW1lbnQge1N0cmluZ30gc2lkZSBgdG9wYCBvciBgbGVmdGBcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGFtb3VudCBvZiBzY3JvbGxlZCBwaXhlbHNcbiAqL1xuZnVuY3Rpb24gZ2V0U2Nyb2xsKGVsZW1lbnQpIHtcbiAgdmFyIHNpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICd0b3AnO1xuXG4gIHZhciB1cHBlclNpZGUgPSBzaWRlID09PSAndG9wJyA/ICdzY3JvbGxUb3AnIDogJ3Njcm9sbExlZnQnO1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICB2YXIgaHRtbCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgdmFyIHNjcm9sbGluZ0VsZW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB8fCBodG1sO1xuICAgIHJldHVybiBzY3JvbGxpbmdFbGVtZW50W3VwcGVyU2lkZV07XG4gIH1cblxuICByZXR1cm4gZWxlbWVudFt1cHBlclNpZGVdO1xufVxuXG4vKlxuICogU3VtIG9yIHN1YnRyYWN0IHRoZSBlbGVtZW50IHNjcm9sbCB2YWx1ZXMgKGxlZnQgYW5kIHRvcCkgZnJvbSBhIGdpdmVuIHJlY3Qgb2JqZWN0XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge09iamVjdH0gcmVjdCAtIFJlY3Qgb2JqZWN0IHlvdSB3YW50IHRvIGNoYW5nZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIFRoZSBlbGVtZW50IGZyb20gdGhlIGZ1bmN0aW9uIHJlYWRzIHRoZSBzY3JvbGwgdmFsdWVzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHN1YnRyYWN0IC0gc2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gc3VidHJhY3QgdGhlIHNjcm9sbCB2YWx1ZXNcbiAqIEByZXR1cm4ge09iamVjdH0gcmVjdCAtIFRoZSBtb2RpZmllciByZWN0IG9iamVjdFxuICovXG5mdW5jdGlvbiBpbmNsdWRlU2Nyb2xsKHJlY3QsIGVsZW1lbnQpIHtcbiAgdmFyIHN1YnRyYWN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICB2YXIgc2Nyb2xsVG9wID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICd0b3AnKTtcbiAgdmFyIHNjcm9sbExlZnQgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ2xlZnQnKTtcbiAgdmFyIG1vZGlmaWVyID0gc3VidHJhY3QgPyAtMSA6IDE7XG4gIHJlY3QudG9wICs9IHNjcm9sbFRvcCAqIG1vZGlmaWVyO1xuICByZWN0LmJvdHRvbSArPSBzY3JvbGxUb3AgKiBtb2RpZmllcjtcbiAgcmVjdC5sZWZ0ICs9IHNjcm9sbExlZnQgKiBtb2RpZmllcjtcbiAgcmVjdC5yaWdodCArPSBzY3JvbGxMZWZ0ICogbW9kaWZpZXI7XG4gIHJldHVybiByZWN0O1xufVxuXG4vKlxuICogSGVscGVyIHRvIGRldGVjdCBib3JkZXJzIG9mIGEgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtDU1NTdHlsZURlY2xhcmF0aW9ufSBzdHlsZXNcbiAqIFJlc3VsdCBvZiBgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5YCBvbiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IGF4aXMgLSBgeGAgb3IgYHlgXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGJvcmRlcnMgLSBUaGUgYm9yZGVycyBzaXplIG9mIHRoZSBnaXZlbiBheGlzXG4gKi9cblxuZnVuY3Rpb24gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCBheGlzKSB7XG4gIHZhciBzaWRlQSA9IGF4aXMgPT09ICd4JyA/ICdMZWZ0JyA6ICdUb3AnO1xuICB2YXIgc2lkZUIgPSBzaWRlQSA9PT0gJ0xlZnQnID8gJ1JpZ2h0JyA6ICdCb3R0b20nO1xuXG4gIHJldHVybiBwYXJzZUZsb2F0KHN0eWxlc1snYm9yZGVyJyArIHNpZGVBICsgJ1dpZHRoJ10sIDEwKSArIHBhcnNlRmxvYXQoc3R5bGVzWydib3JkZXInICsgc2lkZUIgKyAnV2lkdGgnXSwgMTApO1xufVxuXG4vKipcbiAqIFRlbGxzIGlmIHlvdSBhcmUgcnVubmluZyBJbnRlcm5ldCBFeHBsb3JlciAxMFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHJldHVybnMge0Jvb2xlYW59IGlzSUUxMFxuICovXG52YXIgaXNJRTEwID0gdW5kZWZpbmVkO1xuXG52YXIgaXNJRTEwJDEgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChpc0lFMTAgPT09IHVuZGVmaW5lZCkge1xuICAgIGlzSUUxMCA9IG5hdmlnYXRvci5hcHBWZXJzaW9uLmluZGV4T2YoJ01TSUUgMTAnKSAhPT0gLTE7XG4gIH1cbiAgcmV0dXJuIGlzSUUxMDtcbn07XG5cbmZ1bmN0aW9uIGdldFNpemUoYXhpcywgYm9keSwgaHRtbCwgY29tcHV0ZWRTdHlsZSkge1xuICByZXR1cm4gTWF0aC5tYXgoYm9keVsnb2Zmc2V0JyArIGF4aXNdLCBib2R5WydzY3JvbGwnICsgYXhpc10sIGh0bWxbJ2NsaWVudCcgKyBheGlzXSwgaHRtbFsnb2Zmc2V0JyArIGF4aXNdLCBodG1sWydzY3JvbGwnICsgYXhpc10sIGlzSUUxMCQxKCkgPyBodG1sWydvZmZzZXQnICsgYXhpc10gKyBjb21wdXRlZFN0eWxlWydtYXJnaW4nICsgKGF4aXMgPT09ICdIZWlnaHQnID8gJ1RvcCcgOiAnTGVmdCcpXSArIGNvbXB1dGVkU3R5bGVbJ21hcmdpbicgKyAoYXhpcyA9PT0gJ0hlaWdodCcgPyAnQm90dG9tJyA6ICdSaWdodCcpXSA6IDApO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dTaXplcygpIHtcbiAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICB2YXIgaHRtbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIGNvbXB1dGVkU3R5bGUgPSBpc0lFMTAkMSgpICYmIGdldENvbXB1dGVkU3R5bGUoaHRtbCk7XG5cbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQ6IGdldFNpemUoJ0hlaWdodCcsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpLFxuICAgIHdpZHRoOiBnZXRTaXplKCdXaWR0aCcsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpXG4gIH07XG59XG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG5cblxuXG5cblxudmFyIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBHaXZlbiBlbGVtZW50IG9mZnNldHMsIGdlbmVyYXRlIGFuIG91dHB1dCBzaW1pbGFyIHRvIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IG9mZnNldHNcbiAqIEByZXR1cm5zIHtPYmplY3R9IENsaWVudFJlY3QgbGlrZSBvdXRwdXRcbiAqL1xuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdChvZmZzZXRzKSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgb2Zmc2V0cywge1xuICAgIHJpZ2h0OiBvZmZzZXRzLmxlZnQgKyBvZmZzZXRzLndpZHRoLFxuICAgIGJvdHRvbTogb2Zmc2V0cy50b3AgKyBvZmZzZXRzLmhlaWdodFxuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgYm91bmRpbmcgY2xpZW50IHJlY3Qgb2YgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7T2JqZWN0fSBjbGllbnQgcmVjdFxuICovXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgcmVjdCA9IHt9O1xuXG4gIC8vIElFMTAgMTAgRklYOiBQbGVhc2UsIGRvbid0IGFzaywgdGhlIGVsZW1lbnQgaXNuJ3RcbiAgLy8gY29uc2lkZXJlZCBpbiBET00gaW4gc29tZSBjaXJjdW1zdGFuY2VzLi4uXG4gIC8vIFRoaXMgaXNuJ3QgcmVwcm9kdWNpYmxlIGluIElFMTAgY29tcGF0aWJpbGl0eSBtb2RlIG9mIElFMTFcbiAgaWYgKGlzSUUxMCQxKCkpIHtcbiAgICB0cnkge1xuICAgICAgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgc2Nyb2xsVG9wID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICd0b3AnKTtcbiAgICAgIHZhciBzY3JvbGxMZWZ0ID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICdsZWZ0Jyk7XG4gICAgICByZWN0LnRvcCArPSBzY3JvbGxUb3A7XG4gICAgICByZWN0LmxlZnQgKz0gc2Nyb2xsTGVmdDtcbiAgICAgIHJlY3QuYm90dG9tICs9IHNjcm9sbFRvcDtcbiAgICAgIHJlY3QucmlnaHQgKz0gc2Nyb2xsTGVmdDtcbiAgICB9IGNhdGNoIChlcnIpIHt9XG4gIH0gZWxzZSB7XG4gICAgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0ge1xuICAgIGxlZnQ6IHJlY3QubGVmdCxcbiAgICB0b3A6IHJlY3QudG9wLFxuICAgIHdpZHRoOiByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0LFxuICAgIGhlaWdodDogcmVjdC5ib3R0b20gLSByZWN0LnRvcFxuICB9O1xuXG4gIC8vIHN1YnRyYWN0IHNjcm9sbGJhciBzaXplIGZyb20gc2l6ZXNcbiAgdmFyIHNpemVzID0gZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnID8gZ2V0V2luZG93U2l6ZXMoKSA6IHt9O1xuICB2YXIgd2lkdGggPSBzaXplcy53aWR0aCB8fCBlbGVtZW50LmNsaWVudFdpZHRoIHx8IHJlc3VsdC5yaWdodCAtIHJlc3VsdC5sZWZ0O1xuICB2YXIgaGVpZ2h0ID0gc2l6ZXMuaGVpZ2h0IHx8IGVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IHJlc3VsdC5ib3R0b20gLSByZXN1bHQudG9wO1xuXG4gIHZhciBob3JpelNjcm9sbGJhciA9IGVsZW1lbnQub2Zmc2V0V2lkdGggLSB3aWR0aDtcbiAgdmFyIHZlcnRTY3JvbGxiYXIgPSBlbGVtZW50Lm9mZnNldEhlaWdodCAtIGhlaWdodDtcblxuICAvLyBpZiBhbiBoeXBvdGhldGljYWwgc2Nyb2xsYmFyIGlzIGRldGVjdGVkLCB3ZSBtdXN0IGJlIHN1cmUgaXQncyBub3QgYSBgYm9yZGVyYFxuICAvLyB3ZSBtYWtlIHRoaXMgY2hlY2sgY29uZGl0aW9uYWwgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcbiAgaWYgKGhvcml6U2Nyb2xsYmFyIHx8IHZlcnRTY3JvbGxiYXIpIHtcbiAgICB2YXIgc3R5bGVzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQpO1xuICAgIGhvcml6U2Nyb2xsYmFyIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3gnKTtcbiAgICB2ZXJ0U2Nyb2xsYmFyIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3knKTtcblxuICAgIHJlc3VsdC53aWR0aCAtPSBob3JpelNjcm9sbGJhcjtcbiAgICByZXN1bHQuaGVpZ2h0IC09IHZlcnRTY3JvbGxiYXI7XG4gIH1cblxuICByZXR1cm4gZ2V0Q2xpZW50UmVjdChyZXN1bHQpO1xufVxuXG5mdW5jdGlvbiBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoY2hpbGRyZW4sIHBhcmVudCkge1xuICB2YXIgaXNJRTEwID0gaXNJRTEwJDEoKTtcbiAgdmFyIGlzSFRNTCA9IHBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnO1xuICB2YXIgY2hpbGRyZW5SZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGNoaWxkcmVuKTtcbiAgdmFyIHBhcmVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocGFyZW50KTtcbiAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChjaGlsZHJlbik7XG5cbiAgdmFyIHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShwYXJlbnQpO1xuICB2YXIgYm9yZGVyVG9wV2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlcy5ib3JkZXJUb3BXaWR0aCwgMTApO1xuICB2YXIgYm9yZGVyTGVmdFdpZHRoID0gcGFyc2VGbG9hdChzdHlsZXMuYm9yZGVyTGVmdFdpZHRoLCAxMCk7XG5cbiAgdmFyIG9mZnNldHMgPSBnZXRDbGllbnRSZWN0KHtcbiAgICB0b3A6IGNoaWxkcmVuUmVjdC50b3AgLSBwYXJlbnRSZWN0LnRvcCAtIGJvcmRlclRvcFdpZHRoLFxuICAgIGxlZnQ6IGNoaWxkcmVuUmVjdC5sZWZ0IC0gcGFyZW50UmVjdC5sZWZ0IC0gYm9yZGVyTGVmdFdpZHRoLFxuICAgIHdpZHRoOiBjaGlsZHJlblJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiBjaGlsZHJlblJlY3QuaGVpZ2h0XG4gIH0pO1xuICBvZmZzZXRzLm1hcmdpblRvcCA9IDA7XG4gIG9mZnNldHMubWFyZ2luTGVmdCA9IDA7XG5cbiAgLy8gU3VidHJhY3QgbWFyZ2lucyBvZiBkb2N1bWVudEVsZW1lbnQgaW4gY2FzZSBpdCdzIGJlaW5nIHVzZWQgYXMgcGFyZW50XG4gIC8vIHdlIGRvIHRoaXMgb25seSBvbiBIVE1MIGJlY2F1c2UgaXQncyB0aGUgb25seSBlbGVtZW50IHRoYXQgYmVoYXZlc1xuICAvLyBkaWZmZXJlbnRseSB3aGVuIG1hcmdpbnMgYXJlIGFwcGxpZWQgdG8gaXQuIFRoZSBtYXJnaW5zIGFyZSBpbmNsdWRlZCBpblxuICAvLyB0aGUgYm94IG9mIHRoZSBkb2N1bWVudEVsZW1lbnQsIGluIHRoZSBvdGhlciBjYXNlcyBub3QuXG4gIGlmICghaXNJRTEwICYmIGlzSFRNTCkge1xuICAgIHZhciBtYXJnaW5Ub3AgPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Ub3AsIDEwKTtcbiAgICB2YXIgbWFyZ2luTGVmdCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQsIDEwKTtcblxuICAgIG9mZnNldHMudG9wIC09IGJvcmRlclRvcFdpZHRoIC0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMuYm90dG9tIC09IGJvcmRlclRvcFdpZHRoIC0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMubGVmdCAtPSBib3JkZXJMZWZ0V2lkdGggLSBtYXJnaW5MZWZ0O1xuICAgIG9mZnNldHMucmlnaHQgLT0gYm9yZGVyTGVmdFdpZHRoIC0gbWFyZ2luTGVmdDtcblxuICAgIC8vIEF0dGFjaCBtYXJnaW5Ub3AgYW5kIG1hcmdpbkxlZnQgYmVjYXVzZSBpbiBzb21lIGNpcmN1bXN0YW5jZXMgd2UgbWF5IG5lZWQgdGhlbVxuICAgIG9mZnNldHMubWFyZ2luVG9wID0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMubWFyZ2luTGVmdCA9IG1hcmdpbkxlZnQ7XG4gIH1cblxuICBpZiAoaXNJRTEwID8gcGFyZW50LmNvbnRhaW5zKHNjcm9sbFBhcmVudCkgOiBwYXJlbnQgPT09IHNjcm9sbFBhcmVudCAmJiBzY3JvbGxQYXJlbnQubm9kZU5hbWUgIT09ICdCT0RZJykge1xuICAgIG9mZnNldHMgPSBpbmNsdWRlU2Nyb2xsKG9mZnNldHMsIHBhcmVudCk7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn1cblxuZnVuY3Rpb24gZ2V0Vmlld3BvcnRPZmZzZXRSZWN0UmVsYXRpdmVUb0FydGJpdHJhcnlOb2RlKGVsZW1lbnQpIHtcbiAgdmFyIGh0bWwgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgcmVsYXRpdmVPZmZzZXQgPSBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoZWxlbWVudCwgaHRtbCk7XG4gIHZhciB3aWR0aCA9IE1hdGgubWF4KGh0bWwuY2xpZW50V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApO1xuICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgoaHRtbC5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwKTtcblxuICB2YXIgc2Nyb2xsVG9wID0gZ2V0U2Nyb2xsKGh0bWwpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IGdldFNjcm9sbChodG1sLCAnbGVmdCcpO1xuXG4gIHZhciBvZmZzZXQgPSB7XG4gICAgdG9wOiBzY3JvbGxUb3AgLSByZWxhdGl2ZU9mZnNldC50b3AgKyByZWxhdGl2ZU9mZnNldC5tYXJnaW5Ub3AsXG4gICAgbGVmdDogc2Nyb2xsTGVmdCAtIHJlbGF0aXZlT2Zmc2V0LmxlZnQgKyByZWxhdGl2ZU9mZnNldC5tYXJnaW5MZWZ0LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xuXG4gIHJldHVybiBnZXRDbGllbnRSZWN0KG9mZnNldCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaXMgZml4ZWQgb3IgaXMgaW5zaWRlIGEgZml4ZWQgcGFyZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gY3VzdG9tQ29udGFpbmVyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYW5zd2VyIHRvIFwiaXNGaXhlZD9cIlxuICovXG5mdW5jdGlvbiBpc0ZpeGVkKGVsZW1lbnQpIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQsICdwb3NpdGlvbicpID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGlzRml4ZWQoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG59XG5cbi8qKlxuICogQ29tcHV0ZWQgdGhlIGJvdW5kYXJpZXMgbGltaXRzIGFuZCByZXR1cm4gdGhlbVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZlcmVuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudCAtIEVsZW1lbnQgdXNlZCB0byBkZWZpbmUgdGhlIGJvdW5kYXJpZXNcbiAqIEByZXR1cm5zIHtPYmplY3R9IENvb3JkaW5hdGVzIG9mIHRoZSBib3VuZGFyaWVzXG4gKi9cbmZ1bmN0aW9uIGdldEJvdW5kYXJpZXMocG9wcGVyLCByZWZlcmVuY2UsIHBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gIHZhciBib3VuZGFyaWVzID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgdmFyIG9mZnNldFBhcmVudCA9IGZpbmRDb21tb25PZmZzZXRQYXJlbnQocG9wcGVyLCByZWZlcmVuY2UpO1xuXG4gIC8vIEhhbmRsZSB2aWV3cG9ydCBjYXNlXG4gIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3ZpZXdwb3J0Jykge1xuICAgIGJvdW5kYXJpZXMgPSBnZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUob2Zmc2V0UGFyZW50KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBIYW5kbGUgb3RoZXIgY2FzZXMgYmFzZWQgb24gRE9NIGVsZW1lbnQgdXNlZCBhcyBib3VuZGFyaWVzXG4gICAgdmFyIGJvdW5kYXJpZXNOb2RlID0gdm9pZCAwO1xuICAgIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3Njcm9sbFBhcmVudCcpIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUocmVmZXJlbmNlKSk7XG4gICAgICBpZiAoYm91bmRhcmllc05vZGUubm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgICAgICBib3VuZGFyaWVzTm9kZSA9IHBvcHBlci5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAnd2luZG93Jykge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBwb3BwZXIub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gYm91bmRhcmllc0VsZW1lbnQ7XG4gICAgfVxuXG4gICAgdmFyIG9mZnNldHMgPSBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoYm91bmRhcmllc05vZGUsIG9mZnNldFBhcmVudCk7XG5cbiAgICAvLyBJbiBjYXNlIG9mIEhUTUwsIHdlIG5lZWQgYSBkaWZmZXJlbnQgY29tcHV0YXRpb25cbiAgICBpZiAoYm91bmRhcmllc05vZGUubm9kZU5hbWUgPT09ICdIVE1MJyAmJiAhaXNGaXhlZChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICB2YXIgX2dldFdpbmRvd1NpemVzID0gZ2V0V2luZG93U2l6ZXMoKSxcbiAgICAgICAgICBoZWlnaHQgPSBfZ2V0V2luZG93U2l6ZXMuaGVpZ2h0LFxuICAgICAgICAgIHdpZHRoID0gX2dldFdpbmRvd1NpemVzLndpZHRoO1xuXG4gICAgICBib3VuZGFyaWVzLnRvcCArPSBvZmZzZXRzLnRvcCAtIG9mZnNldHMubWFyZ2luVG9wO1xuICAgICAgYm91bmRhcmllcy5ib3R0b20gPSBoZWlnaHQgKyBvZmZzZXRzLnRvcDtcbiAgICAgIGJvdW5kYXJpZXMubGVmdCArPSBvZmZzZXRzLmxlZnQgLSBvZmZzZXRzLm1hcmdpbkxlZnQ7XG4gICAgICBib3VuZGFyaWVzLnJpZ2h0ID0gd2lkdGggKyBvZmZzZXRzLmxlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZvciBhbGwgdGhlIG90aGVyIERPTSBlbGVtZW50cywgdGhpcyBvbmUgaXMgZ29vZFxuICAgICAgYm91bmRhcmllcyA9IG9mZnNldHM7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIHBhZGRpbmdzXG4gIGJvdW5kYXJpZXMubGVmdCArPSBwYWRkaW5nO1xuICBib3VuZGFyaWVzLnRvcCArPSBwYWRkaW5nO1xuICBib3VuZGFyaWVzLnJpZ2h0IC09IHBhZGRpbmc7XG4gIGJvdW5kYXJpZXMuYm90dG9tIC09IHBhZGRpbmc7XG5cbiAgcmV0dXJuIGJvdW5kYXJpZXM7XG59XG5cbmZ1bmN0aW9uIGdldEFyZWEoX3JlZikge1xuICB2YXIgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQ7XG5cbiAgcmV0dXJuIHdpZHRoICogaGVpZ2h0O1xufVxuXG4vKipcbiAqIFV0aWxpdHkgdXNlZCB0byB0cmFuc2Zvcm0gdGhlIGBhdXRvYCBwbGFjZW1lbnQgdG8gdGhlIHBsYWNlbWVudCB3aXRoIG1vcmVcbiAqIGF2YWlsYWJsZSBzcGFjZS5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVBdXRvUGxhY2VtZW50KHBsYWNlbWVudCwgcmVmUmVjdCwgcG9wcGVyLCByZWZlcmVuY2UsIGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gIHZhciBwYWRkaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiAwO1xuXG4gIGlmIChwbGFjZW1lbnQuaW5kZXhPZignYXV0bycpID09PSAtMSkge1xuICAgIHJldHVybiBwbGFjZW1lbnQ7XG4gIH1cblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMocG9wcGVyLCByZWZlcmVuY2UsIHBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50KTtcblxuICB2YXIgcmVjdHMgPSB7XG4gICAgdG9wOiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy53aWR0aCxcbiAgICAgIGhlaWdodDogcmVmUmVjdC50b3AgLSBib3VuZGFyaWVzLnRvcFxuICAgIH0sXG4gICAgcmlnaHQ6IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLnJpZ2h0IC0gcmVmUmVjdC5yaWdodCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5oZWlnaHRcbiAgICB9LFxuICAgIGJvdHRvbToge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuYm90dG9tIC0gcmVmUmVjdC5ib3R0b21cbiAgICB9LFxuICAgIGxlZnQ6IHtcbiAgICAgIHdpZHRoOiByZWZSZWN0LmxlZnQgLSBib3VuZGFyaWVzLmxlZnQsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuaGVpZ2h0XG4gICAgfVxuICB9O1xuXG4gIHZhciBzb3J0ZWRBcmVhcyA9IE9iamVjdC5rZXlzKHJlY3RzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICBrZXk6IGtleVxuICAgIH0sIHJlY3RzW2tleV0sIHtcbiAgICAgIGFyZWE6IGdldEFyZWEocmVjdHNba2V5XSlcbiAgICB9KTtcbiAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiLmFyZWEgLSBhLmFyZWE7XG4gIH0pO1xuXG4gIHZhciBmaWx0ZXJlZEFyZWFzID0gc29ydGVkQXJlYXMuZmlsdGVyKGZ1bmN0aW9uIChfcmVmMikge1xuICAgIHZhciB3aWR0aCA9IF9yZWYyLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfcmVmMi5oZWlnaHQ7XG4gICAgcmV0dXJuIHdpZHRoID49IHBvcHBlci5jbGllbnRXaWR0aCAmJiBoZWlnaHQgPj0gcG9wcGVyLmNsaWVudEhlaWdodDtcbiAgfSk7XG5cbiAgdmFyIGNvbXB1dGVkUGxhY2VtZW50ID0gZmlsdGVyZWRBcmVhcy5sZW5ndGggPiAwID8gZmlsdGVyZWRBcmVhc1swXS5rZXkgOiBzb3J0ZWRBcmVhc1swXS5rZXk7XG5cbiAgdmFyIHZhcmlhdGlvbiA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xuXG4gIHJldHVybiBjb21wdXRlZFBsYWNlbWVudCArICh2YXJpYXRpb24gPyAnLScgKyB2YXJpYXRpb24gOiAnJyk7XG59XG5cbi8qKlxuICogR2V0IG9mZnNldHMgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gcG9wcGVyIC0gdGhlIHBvcHBlciBlbGVtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR9IHJlZmVyZW5jZSAtIHRoZSByZWZlcmVuY2UgZWxlbWVudCAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgb2Zmc2V0cyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlclxuICovXG5mdW5jdGlvbiBnZXRSZWZlcmVuY2VPZmZzZXRzKHN0YXRlLCBwb3BwZXIsIHJlZmVyZW5jZSkge1xuICB2YXIgY29tbW9uT2Zmc2V0UGFyZW50ID0gZmluZENvbW1vbk9mZnNldFBhcmVudChwb3BwZXIsIHJlZmVyZW5jZSk7XG4gIHJldHVybiBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUocmVmZXJlbmNlLCBjb21tb25PZmZzZXRQYXJlbnQpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3V0ZXIgc2l6ZXMgb2YgdGhlIGdpdmVuIGVsZW1lbnQgKG9mZnNldCBzaXplICsgbWFyZ2lucylcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgd2lkdGggYW5kIGhlaWdodCBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVyU2l6ZXMoZWxlbWVudCkge1xuICB2YXIgc3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgdmFyIHggPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Ub3ApICsgcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luQm90dG9tKTtcbiAgdmFyIHkgPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5MZWZ0KSArIHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblJpZ2h0KTtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCArIHksXG4gICAgaGVpZ2h0OiBlbGVtZW50Lm9mZnNldEhlaWdodCArIHhcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG9wcG9zaXRlIHBsYWNlbWVudCBvZiB0aGUgZ2l2ZW4gb25lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBmbGlwcGVkIHBsYWNlbWVudFxuICovXG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgdmFyIGhhc2ggPSB7IGxlZnQ6ICdyaWdodCcsIHJpZ2h0OiAnbGVmdCcsIGJvdHRvbTogJ3RvcCcsIHRvcDogJ2JvdHRvbScgfTtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IG9mZnNldHMgdG8gdGhlIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uIC0gQ1NTIHBvc2l0aW9uIHRoZSBQb3BwZXIgd2lsbCBnZXQgYXBwbGllZFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyIC0gdGhlIHBvcHBlciBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0cyAtIHRoZSByZWZlcmVuY2Ugb2Zmc2V0cyAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gKiBAcGFyYW0ge1N0cmluZ30gcGxhY2VtZW50IC0gb25lIG9mIHRoZSB2YWxpZCBwbGFjZW1lbnQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gcG9wcGVyT2Zmc2V0cyAtIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBvZmZzZXRzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGdldFBvcHBlck9mZnNldHMocG9wcGVyLCByZWZlcmVuY2VPZmZzZXRzLCBwbGFjZW1lbnQpIHtcbiAgcGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG5cbiAgLy8gR2V0IHBvcHBlciBub2RlIHNpemVzXG4gIHZhciBwb3BwZXJSZWN0ID0gZ2V0T3V0ZXJTaXplcyhwb3BwZXIpO1xuXG4gIC8vIEFkZCBwb3NpdGlvbiwgd2lkdGggYW5kIGhlaWdodCB0byBvdXIgb2Zmc2V0cyBvYmplY3RcbiAgdmFyIHBvcHBlck9mZnNldHMgPSB7XG4gICAgd2lkdGg6IHBvcHBlclJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiBwb3BwZXJSZWN0LmhlaWdodFxuICB9O1xuXG4gIC8vIGRlcGVuZGluZyBieSB0aGUgcG9wcGVyIHBsYWNlbWVudCB3ZSBoYXZlIHRvIGNvbXB1dGUgaXRzIG9mZnNldHMgc2xpZ2h0bHkgZGlmZmVyZW50bHlcbiAgdmFyIGlzSG9yaXogPSBbJ3JpZ2h0JywgJ2xlZnQnXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuICB2YXIgbWFpblNpZGUgPSBpc0hvcml6ID8gJ3RvcCcgOiAnbGVmdCc7XG4gIHZhciBzZWNvbmRhcnlTaWRlID0gaXNIb3JpeiA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgbWVhc3VyZW1lbnQgPSBpc0hvcml6ID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICB2YXIgc2Vjb25kYXJ5TWVhc3VyZW1lbnQgPSAhaXNIb3JpeiA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICBwb3BwZXJPZmZzZXRzW21haW5TaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbbWFpblNpZGVdICsgcmVmZXJlbmNlT2Zmc2V0c1ttZWFzdXJlbWVudF0gLyAyIC0gcG9wcGVyUmVjdFttZWFzdXJlbWVudF0gLyAyO1xuICBpZiAocGxhY2VtZW50ID09PSBzZWNvbmRhcnlTaWRlKSB7XG4gICAgcG9wcGVyT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gLSBwb3BwZXJSZWN0W3NlY29uZGFyeU1lYXN1cmVtZW50XTtcbiAgfSBlbHNlIHtcbiAgICBwb3BwZXJPZmZzZXRzW3NlY29uZGFyeVNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1tnZXRPcHBvc2l0ZVBsYWNlbWVudChzZWNvbmRhcnlTaWRlKV07XG4gIH1cblxuICByZXR1cm4gcG9wcGVyT2Zmc2V0cztcbn1cblxuLyoqXG4gKiBNaW1pY3MgdGhlIGBmaW5kYCBtZXRob2Qgb2YgQXJyYXlcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QXJyYXl9IGFyclxuICogQGFyZ3VtZW50IHByb3BcbiAqIEBhcmd1bWVudCB2YWx1ZVxuICogQHJldHVybnMgaW5kZXggb3IgLTFcbiAqL1xuZnVuY3Rpb24gZmluZChhcnIsIGNoZWNrKSB7XG4gIC8vIHVzZSBuYXRpdmUgZmluZCBpZiBzdXBwb3J0ZWRcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5maW5kKSB7XG4gICAgcmV0dXJuIGFyci5maW5kKGNoZWNrKTtcbiAgfVxuXG4gIC8vIHVzZSBgZmlsdGVyYCB0byBvYnRhaW4gdGhlIHNhbWUgYmVoYXZpb3Igb2YgYGZpbmRgXG4gIHJldHVybiBhcnIuZmlsdGVyKGNoZWNrKVswXTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGluZGV4IG9mIHRoZSBtYXRjaGluZyBvYmplY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QXJyYXl9IGFyclxuICogQGFyZ3VtZW50IHByb3BcbiAqIEBhcmd1bWVudCB2YWx1ZVxuICogQHJldHVybnMgaW5kZXggb3IgLTFcbiAqL1xuZnVuY3Rpb24gZmluZEluZGV4KGFyciwgcHJvcCwgdmFsdWUpIHtcbiAgLy8gdXNlIG5hdGl2ZSBmaW5kSW5kZXggaWYgc3VwcG9ydGVkXG4gIGlmIChBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KSB7XG4gICAgcmV0dXJuIGFyci5maW5kSW5kZXgoZnVuY3Rpb24gKGN1cikge1xuICAgICAgcmV0dXJuIGN1cltwcm9wXSA9PT0gdmFsdWU7XG4gICAgfSk7XG4gIH1cblxuICAvLyB1c2UgYGZpbmRgICsgYGluZGV4T2ZgIGlmIGBmaW5kSW5kZXhgIGlzbid0IHN1cHBvcnRlZFxuICB2YXIgbWF0Y2ggPSBmaW5kKGFyciwgZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmpbcHJvcF0gPT09IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIGFyci5pbmRleE9mKG1hdGNoKTtcbn1cblxuLyoqXG4gKiBMb29wIHRyb3VnaCB0aGUgbGlzdCBvZiBtb2RpZmllcnMgYW5kIHJ1biB0aGVtIGluIG9yZGVyLFxuICogZWFjaCBvZiB0aGVtIHdpbGwgdGhlbiBlZGl0IHRoZSBkYXRhIG9iamVjdC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5kcyAtIE9wdGlvbmFsIG1vZGlmaWVyIG5hbWUgdXNlZCBhcyBzdG9wcGVyXG4gKiBAcmV0dXJucyB7ZGF0YU9iamVjdH1cbiAqL1xuZnVuY3Rpb24gcnVuTW9kaWZpZXJzKG1vZGlmaWVycywgZGF0YSwgZW5kcykge1xuICB2YXIgbW9kaWZpZXJzVG9SdW4gPSBlbmRzID09PSB1bmRlZmluZWQgPyBtb2RpZmllcnMgOiBtb2RpZmllcnMuc2xpY2UoMCwgZmluZEluZGV4KG1vZGlmaWVycywgJ25hbWUnLCBlbmRzKSk7XG5cbiAgbW9kaWZpZXJzVG9SdW4uZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBpZiAobW9kaWZpZXJbJ2Z1bmN0aW9uJ10pIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgICBjb25zb2xlLndhcm4oJ2Btb2RpZmllci5mdW5jdGlvbmAgaXMgZGVwcmVjYXRlZCwgdXNlIGBtb2RpZmllci5mbmAhJyk7XG4gICAgfVxuICAgIHZhciBmbiA9IG1vZGlmaWVyWydmdW5jdGlvbiddIHx8IG1vZGlmaWVyLmZuOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgIGlmIChtb2RpZmllci5lbmFibGVkICYmIGlzRnVuY3Rpb24oZm4pKSB7XG4gICAgICAvLyBBZGQgcHJvcGVydGllcyB0byBvZmZzZXRzIHRvIG1ha2UgdGhlbSBhIGNvbXBsZXRlIGNsaWVudFJlY3Qgb2JqZWN0XG4gICAgICAvLyB3ZSBkbyB0aGlzIGJlZm9yZSBlYWNoIG1vZGlmaWVyIHRvIG1ha2Ugc3VyZSB0aGUgcHJldmlvdXMgb25lIGRvZXNuJ3RcbiAgICAgIC8vIG1lc3Mgd2l0aCB0aGVzZSB2YWx1ZXNcbiAgICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5wb3BwZXIpO1xuICAgICAgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSk7XG5cbiAgICAgIGRhdGEgPSBmbihkYXRhLCBtb2RpZmllcik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyLCBjb21wdXRpbmcgdGhlIG5ldyBvZmZzZXRzIGFuZCBhcHBseWluZ1xuICogdGhlIG5ldyBzdHlsZS48YnIgLz5cbiAqIFByZWZlciBgc2NoZWR1bGVVcGRhdGVgIG92ZXIgYHVwZGF0ZWAgYmVjYXVzZSBvZiBwZXJmb3JtYW5jZSByZWFzb25zLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiB1cGRhdGUoKSB7XG4gIC8vIGlmIHBvcHBlciBpcyBkZXN0cm95ZWQsIGRvbid0IHBlcmZvcm0gYW55IGZ1cnRoZXIgdXBkYXRlXG4gIGlmICh0aGlzLnN0YXRlLmlzRGVzdHJveWVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGRhdGEgPSB7XG4gICAgaW5zdGFuY2U6IHRoaXMsXG4gICAgc3R5bGVzOiB7fSxcbiAgICBhcnJvd1N0eWxlczoge30sXG4gICAgYXR0cmlidXRlczoge30sXG4gICAgZmxpcHBlZDogZmFsc2UsXG4gICAgb2Zmc2V0czoge31cbiAgfTtcblxuICAvLyBjb21wdXRlIHJlZmVyZW5jZSBlbGVtZW50IG9mZnNldHNcbiAgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSA9IGdldFJlZmVyZW5jZU9mZnNldHModGhpcy5zdGF0ZSwgdGhpcy5wb3BwZXIsIHRoaXMucmVmZXJlbmNlKTtcblxuICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgLy8gbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAvLyBhbmQgcmVmZXIgdG8gb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgZGF0YS5wbGFjZW1lbnQgPSBjb21wdXRlQXV0b1BsYWNlbWVudCh0aGlzLm9wdGlvbnMucGxhY2VtZW50LCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCB0aGlzLnBvcHBlciwgdGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCwgdGhpcy5vcHRpb25zLm1vZGlmaWVycy5mbGlwLnBhZGRpbmcpO1xuXG4gIC8vIHN0b3JlIHRoZSBjb21wdXRlZCBwbGFjZW1lbnQgaW5zaWRlIGBvcmlnaW5hbFBsYWNlbWVudGBcbiAgZGF0YS5vcmlnaW5hbFBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuXG4gIC8vIGNvbXB1dGUgdGhlIHBvcHBlciBvZmZzZXRzXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRQb3BwZXJPZmZzZXRzKHRoaXMucG9wcGVyLCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCBkYXRhLnBsYWNlbWVudCk7XG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXG4gIC8vIHJ1biB0aGUgbW9kaWZpZXJzXG4gIGRhdGEgPSBydW5Nb2RpZmllcnModGhpcy5tb2RpZmllcnMsIGRhdGEpO1xuXG4gIC8vIHRoZSBmaXJzdCBgdXBkYXRlYCB3aWxsIGNhbGwgYG9uQ3JlYXRlYCBjYWxsYmFja1xuICAvLyB0aGUgb3RoZXIgb25lcyB3aWxsIGNhbGwgYG9uVXBkYXRlYCBjYWxsYmFja1xuICBpZiAoIXRoaXMuc3RhdGUuaXNDcmVhdGVkKSB7XG4gICAgdGhpcy5zdGF0ZS5pc0NyZWF0ZWQgPSB0cnVlO1xuICAgIHRoaXMub3B0aW9ucy5vbkNyZWF0ZShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wdGlvbnMub25VcGRhdGUoZGF0YSk7XG4gIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgdXNlZCB0byBrbm93IGlmIHRoZSBnaXZlbiBtb2RpZmllciBpcyBlbmFibGVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTW9kaWZpZXJFbmFibGVkKG1vZGlmaWVycywgbW9kaWZpZXJOYW1lKSB7XG4gIHJldHVybiBtb2RpZmllcnMuc29tZShmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgICBlbmFibGVkID0gX3JlZi5lbmFibGVkO1xuICAgIHJldHVybiBlbmFibGVkICYmIG5hbWUgPT09IG1vZGlmaWVyTmFtZTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBwcmVmaXhlZCBzdXBwb3J0ZWQgcHJvcGVydHkgbmFtZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5IChjYW1lbENhc2UpXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBwcmVmaXhlZCBwcm9wZXJ0eSAoY2FtZWxDYXNlIG9yIFBhc2NhbENhc2UsIGRlcGVuZGluZyBvbiB0aGUgdmVuZG9yIHByZWZpeClcbiAqL1xuZnVuY3Rpb24gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKHByb3BlcnR5KSB7XG4gIHZhciBwcmVmaXhlcyA9IFtmYWxzZSwgJ21zJywgJ1dlYmtpdCcsICdNb3onLCAnTyddO1xuICB2YXIgdXBwZXJQcm9wID0gcHJvcGVydHkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIHZhciBwcmVmaXggPSBwcmVmaXhlc1tpXTtcbiAgICB2YXIgdG9DaGVjayA9IHByZWZpeCA/ICcnICsgcHJlZml4ICsgdXBwZXJQcm9wIDogcHJvcGVydHk7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudC5ib2R5LnN0eWxlW3RvQ2hlY2tdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHRvQ2hlY2s7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIERlc3Ryb3kgdGhlIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiBkZXN0cm95KCkge1xuICB0aGlzLnN0YXRlLmlzRGVzdHJveWVkID0gdHJ1ZTtcblxuICAvLyB0b3VjaCBET00gb25seSBpZiBgYXBwbHlTdHlsZWAgbW9kaWZpZXIgaXMgZW5hYmxlZFxuICBpZiAoaXNNb2RpZmllckVuYWJsZWQodGhpcy5tb2RpZmllcnMsICdhcHBseVN0eWxlJykpIHtcbiAgICB0aGlzLnBvcHBlci5yZW1vdmVBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50Jyk7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUubGVmdCA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnBvc2l0aW9uID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUudG9wID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGVbZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKV0gPSAnJztcbiAgfVxuXG4gIHRoaXMuZGlzYWJsZUV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgLy8gcmVtb3ZlIHRoZSBwb3BwZXIgaWYgdXNlciBleHBsaWNpdHkgYXNrZWQgZm9yIHRoZSBkZWxldGlvbiBvbiBkZXN0cm95XG4gIC8vIGRvIG5vdCB1c2UgYHJlbW92ZWAgYmVjYXVzZSBJRTExIGRvZXNuJ3Qgc3VwcG9ydCBpdFxuICBpZiAodGhpcy5vcHRpb25zLnJlbW92ZU9uRGVzdHJveSkge1xuICAgIHRoaXMucG9wcGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5wb3BwZXIpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIEdldCB0aGUgd2luZG93IGFzc29jaWF0ZWQgd2l0aCB0aGUgZWxlbWVudFxuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7V2luZG93fVxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3coZWxlbWVudCkge1xuICB2YXIgb3duZXJEb2N1bWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogd2luZG93O1xufVxuXG5mdW5jdGlvbiBhdHRhY2hUb1Njcm9sbFBhcmVudHMoc2Nyb2xsUGFyZW50LCBldmVudCwgY2FsbGJhY2ssIHNjcm9sbFBhcmVudHMpIHtcbiAgdmFyIGlzQm9keSA9IHNjcm9sbFBhcmVudC5ub2RlTmFtZSA9PT0gJ0JPRFknO1xuICB2YXIgdGFyZ2V0ID0gaXNCb2R5ID8gc2Nyb2xsUGFyZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgOiBzY3JvbGxQYXJlbnQ7XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBjYWxsYmFjaywgeyBwYXNzaXZlOiB0cnVlIH0pO1xuXG4gIGlmICghaXNCb2R5KSB7XG4gICAgYXR0YWNoVG9TY3JvbGxQYXJlbnRzKGdldFNjcm9sbFBhcmVudCh0YXJnZXQucGFyZW50Tm9kZSksIGV2ZW50LCBjYWxsYmFjaywgc2Nyb2xsUGFyZW50cyk7XG4gIH1cbiAgc2Nyb2xsUGFyZW50cy5wdXNoKHRhcmdldCk7XG59XG5cbi8qKlxuICogU2V0dXAgbmVlZGVkIGV2ZW50IGxpc3RlbmVycyB1c2VkIHRvIHVwZGF0ZSB0aGUgcG9wcGVyIHBvc2l0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXR1cEV2ZW50TGlzdGVuZXJzKHJlZmVyZW5jZSwgb3B0aW9ucywgc3RhdGUsIHVwZGF0ZUJvdW5kKSB7XG4gIC8vIFJlc2l6ZSBldmVudCBsaXN0ZW5lciBvbiB3aW5kb3dcbiAgc3RhdGUudXBkYXRlQm91bmQgPSB1cGRhdGVCb3VuZDtcbiAgZ2V0V2luZG93KHJlZmVyZW5jZSkuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgc3RhdGUudXBkYXRlQm91bmQsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcblxuICAvLyBTY3JvbGwgZXZlbnQgbGlzdGVuZXIgb24gc2Nyb2xsIHBhcmVudHNcbiAgdmFyIHNjcm9sbEVsZW1lbnQgPSBnZXRTY3JvbGxQYXJlbnQocmVmZXJlbmNlKTtcbiAgYXR0YWNoVG9TY3JvbGxQYXJlbnRzKHNjcm9sbEVsZW1lbnQsICdzY3JvbGwnLCBzdGF0ZS51cGRhdGVCb3VuZCwgc3RhdGUuc2Nyb2xsUGFyZW50cyk7XG4gIHN0YXRlLnNjcm9sbEVsZW1lbnQgPSBzY3JvbGxFbGVtZW50O1xuICBzdGF0ZS5ldmVudHNFbmFibGVkID0gdHJ1ZTtcblxuICByZXR1cm4gc3RhdGU7XG59XG5cbi8qKlxuICogSXQgd2lsbCBhZGQgcmVzaXplL3Njcm9sbCBldmVudHMgYW5kIHN0YXJ0IHJlY2FsY3VsYXRpbmdcbiAqIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIgZWxlbWVudCB3aGVuIHRoZXkgYXJlIHRyaWdnZXJlZC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGlmICghdGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHNldHVwRXZlbnRMaXN0ZW5lcnModGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucywgdGhpcy5zdGF0ZSwgdGhpcy5zY2hlZHVsZVVwZGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzIHVzZWQgdG8gdXBkYXRlIHRoZSBwb3BwZXIgcG9zaXRpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHJlZmVyZW5jZSwgc3RhdGUpIHtcbiAgLy8gUmVtb3ZlIHJlc2l6ZSBldmVudCBsaXN0ZW5lciBvbiB3aW5kb3dcbiAgZ2V0V2luZG93KHJlZmVyZW5jZSkucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgc3RhdGUudXBkYXRlQm91bmQpO1xuXG4gIC8vIFJlbW92ZSBzY3JvbGwgZXZlbnQgbGlzdGVuZXIgb24gc2Nyb2xsIHBhcmVudHNcbiAgc3RhdGUuc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgc3RhdGUudXBkYXRlQm91bmQpO1xuICB9KTtcblxuICAvLyBSZXNldCBzdGF0ZVxuICBzdGF0ZS51cGRhdGVCb3VuZCA9IG51bGw7XG4gIHN0YXRlLnNjcm9sbFBhcmVudHMgPSBbXTtcbiAgc3RhdGUuc2Nyb2xsRWxlbWVudCA9IG51bGw7XG4gIHN0YXRlLmV2ZW50c0VuYWJsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIEl0IHdpbGwgcmVtb3ZlIHJlc2l6ZS9zY3JvbGwgZXZlbnRzIGFuZCB3b24ndCByZWNhbGN1bGF0ZSBwb3BwZXIgcG9zaXRpb25cbiAqIHdoZW4gdGhleSBhcmUgdHJpZ2dlcmVkLiBJdCBhbHNvIHdvbid0IHRyaWdnZXIgb25VcGRhdGUgY2FsbGJhY2sgYW55bW9yZSxcbiAqIHVubGVzcyB5b3UgY2FsbCBgdXBkYXRlYCBtZXRob2QgbWFudWFsbHkuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGRpc2FibGVFdmVudExpc3RlbmVycygpIHtcbiAgaWYgKHRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCkge1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuc2NoZWR1bGVVcGRhdGUpO1xuICAgIHRoaXMuc3RhdGUgPSByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLnJlZmVyZW5jZSwgdGhpcy5zdGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUZWxscyBpZiBhIGdpdmVuIGlucHV0IGlzIGEgbnVtYmVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0geyp9IGlucHV0IHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc051bWVyaWMobikge1xuICByZXR1cm4gbiAhPT0gJycgJiYgIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xufVxuXG4vKipcbiAqIFNldCB0aGUgc3R5bGUgdG8gdGhlIGdpdmVuIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBhcHBseSB0aGUgc3R5bGUgdG9cbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBzdHlsZXNcbiAqIE9iamVjdCB3aXRoIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHNldFN0eWxlcyhlbGVtZW50LCBzdHlsZXMpIHtcbiAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgdmFyIHVuaXQgPSAnJztcbiAgICAvLyBhZGQgdW5pdCBpZiB0aGUgdmFsdWUgaXMgbnVtZXJpYyBhbmQgaXMgb25lIG9mIHRoZSBmb2xsb3dpbmdcbiAgICBpZiAoWyd3aWR0aCcsICdoZWlnaHQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10uaW5kZXhPZihwcm9wKSAhPT0gLTEgJiYgaXNOdW1lcmljKHN0eWxlc1twcm9wXSkpIHtcbiAgICAgIHVuaXQgPSAncHgnO1xuICAgIH1cbiAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gc3R5bGVzW3Byb3BdICsgdW5pdDtcbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IHRoZSBhdHRyaWJ1dGVzIHRvIHRoZSBnaXZlbiBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gYXBwbHkgdGhlIGF0dHJpYnV0ZXMgdG9cbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBzdHlsZXNcbiAqIE9iamVjdCB3aXRoIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoZWxlbWVudCwgYXR0cmlidXRlcykge1xuICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1twcm9wXTtcbiAgICBpZiAodmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShwcm9wLCBhdHRyaWJ1dGVzW3Byb3BdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhLnN0eWxlcyAtIExpc3Qgb2Ygc3R5bGUgcHJvcGVydGllcyAtIHZhbHVlcyB0byBhcHBseSB0byBwb3BwZXIgZWxlbWVudFxuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEuYXR0cmlidXRlcyAtIExpc3Qgb2YgYXR0cmlidXRlIHByb3BlcnRpZXMgLSB2YWx1ZXMgdG8gYXBwbHkgdG8gcG9wcGVyIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBzYW1lIGRhdGEgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGFwcGx5U3R5bGUoZGF0YSkge1xuICAvLyBhbnkgcHJvcGVydHkgcHJlc2VudCBpbiBgZGF0YS5zdHlsZXNgIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLFxuICAvLyBpbiB0aGlzIHdheSB3ZSBjYW4gbWFrZSB0aGUgM3JkIHBhcnR5IG1vZGlmaWVycyBhZGQgY3VzdG9tIHN0eWxlcyB0byBpdFxuICAvLyBCZSBhd2FyZSwgbW9kaWZpZXJzIGNvdWxkIG92ZXJyaWRlIHRoZSBwcm9wZXJ0aWVzIGRlZmluZWQgaW4gdGhlIHByZXZpb3VzXG4gIC8vIGxpbmVzIG9mIHRoaXMgbW9kaWZpZXIhXG4gIHNldFN0eWxlcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5zdHlsZXMpO1xuXG4gIC8vIGFueSBwcm9wZXJ0eSBwcmVzZW50IGluIGBkYXRhLmF0dHJpYnV0ZXNgIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLFxuICAvLyB0aGV5IHdpbGwgYmUgc2V0IGFzIEhUTUwgYXR0cmlidXRlcyBvZiB0aGUgZWxlbWVudFxuICBzZXRBdHRyaWJ1dGVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmF0dHJpYnV0ZXMpO1xuXG4gIC8vIGlmIGFycm93RWxlbWVudCBpcyBkZWZpbmVkIGFuZCBhcnJvd1N0eWxlcyBoYXMgc29tZSBwcm9wZXJ0aWVzXG4gIGlmIChkYXRhLmFycm93RWxlbWVudCAmJiBPYmplY3Qua2V5cyhkYXRhLmFycm93U3R5bGVzKS5sZW5ndGgpIHtcbiAgICBzZXRTdHlsZXMoZGF0YS5hcnJvd0VsZW1lbnQsIGRhdGEuYXJyb3dTdHlsZXMpO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogU2V0IHRoZSB4LXBsYWNlbWVudCBhdHRyaWJ1dGUgYmVmb3JlIGV2ZXJ5dGhpbmcgZWxzZSBiZWNhdXNlIGl0IGNvdWxkIGJlIHVzZWRcbiAqIHRvIGFkZCBtYXJnaW5zIHRvIHRoZSBwb3BwZXIgbWFyZ2lucyBuZWVkcyB0byBiZSBjYWxjdWxhdGVkIHRvIGdldCB0aGVcbiAqIGNvcnJlY3QgcG9wcGVyIG9mZnNldHMuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLm1vZGlmaWVyc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVmZXJlbmNlIC0gVGhlIHJlZmVyZW5jZSBlbGVtZW50IHVzZWQgdG8gcG9zaXRpb24gdGhlIHBvcHBlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyIC0gVGhlIEhUTUwgZWxlbWVudCB1c2VkIGFzIHBvcHBlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gUG9wcGVyLmpzIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gYXBwbHlTdHlsZU9uTG9hZChyZWZlcmVuY2UsIHBvcHBlciwgb3B0aW9ucywgbW9kaWZpZXJPcHRpb25zLCBzdGF0ZSkge1xuICAvLyBjb21wdXRlIHJlZmVyZW5jZSBlbGVtZW50IG9mZnNldHNcbiAgdmFyIHJlZmVyZW5jZU9mZnNldHMgPSBnZXRSZWZlcmVuY2VPZmZzZXRzKHN0YXRlLCBwb3BwZXIsIHJlZmVyZW5jZSk7XG5cbiAgLy8gY29tcHV0ZSBhdXRvIHBsYWNlbWVudCwgc3RvcmUgcGxhY2VtZW50IGluc2lkZSB0aGUgZGF0YSBvYmplY3QsXG4gIC8vIG1vZGlmaWVycyB3aWxsIGJlIGFibGUgdG8gZWRpdCBgcGxhY2VtZW50YCBpZiBuZWVkZWRcbiAgLy8gYW5kIHJlZmVyIHRvIG9yaWdpbmFsUGxhY2VtZW50IHRvIGtub3cgdGhlIG9yaWdpbmFsIHZhbHVlXG4gIHZhciBwbGFjZW1lbnQgPSBjb21wdXRlQXV0b1BsYWNlbWVudChvcHRpb25zLnBsYWNlbWVudCwgcmVmZXJlbmNlT2Zmc2V0cywgcG9wcGVyLCByZWZlcmVuY2UsIG9wdGlvbnMubW9kaWZpZXJzLmZsaXAuYm91bmRhcmllc0VsZW1lbnQsIG9wdGlvbnMubW9kaWZpZXJzLmZsaXAucGFkZGluZyk7XG5cbiAgcG9wcGVyLnNldEF0dHJpYnV0ZSgneC1wbGFjZW1lbnQnLCBwbGFjZW1lbnQpO1xuXG4gIC8vIEFwcGx5IGBwb3NpdGlvbmAgdG8gcG9wcGVyIGJlZm9yZSBhbnl0aGluZyBlbHNlIGJlY2F1c2VcbiAgLy8gd2l0aG91dCB0aGUgcG9zaXRpb24gYXBwbGllZCB3ZSBjYW4ndCBndWFyYW50ZWUgY29ycmVjdCBjb21wdXRhdGlvbnNcbiAgc2V0U3R5bGVzKHBvcHBlciwgeyBwb3NpdGlvbjogJ2Fic29sdXRlJyB9KTtcblxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZVN0eWxlKGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIHggPSBvcHRpb25zLngsXG4gICAgICB5ID0gb3B0aW9ucy55O1xuICB2YXIgcG9wcGVyID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcblxuICAvLyBSZW1vdmUgdGhpcyBsZWdhY3kgc3VwcG9ydCBpbiBQb3BwZXIuanMgdjJcblxuICB2YXIgbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uID0gZmluZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09ICdhcHBseVN0eWxlJztcbiAgfSkuZ3B1QWNjZWxlcmF0aW9uO1xuICBpZiAobGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IGBncHVBY2NlbGVyYXRpb25gIG9wdGlvbiBtb3ZlZCB0byBgY29tcHV0ZVN0eWxlYCBtb2RpZmllciBhbmQgd2lsbCBub3QgYmUgc3VwcG9ydGVkIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiBQb3BwZXIuanMhJyk7XG4gIH1cbiAgdmFyIGdwdUFjY2VsZXJhdGlvbiA9IGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiAhPT0gdW5kZWZpbmVkID8gbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uIDogb3B0aW9ucy5ncHVBY2NlbGVyYXRpb247XG5cbiAgdmFyIG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChkYXRhLmluc3RhbmNlLnBvcHBlcik7XG4gIHZhciBvZmZzZXRQYXJlbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCk7XG5cbiAgLy8gU3R5bGVzXG4gIHZhciBzdHlsZXMgPSB7XG4gICAgcG9zaXRpb246IHBvcHBlci5wb3NpdGlvblxuICB9O1xuXG4gIC8vIGZsb29yIHNpZGVzIHRvIGF2b2lkIGJsdXJyeSB0ZXh0XG4gIHZhciBvZmZzZXRzID0ge1xuICAgIGxlZnQ6IE1hdGguZmxvb3IocG9wcGVyLmxlZnQpLFxuICAgIHRvcDogTWF0aC5mbG9vcihwb3BwZXIudG9wKSxcbiAgICBib3R0b206IE1hdGguZmxvb3IocG9wcGVyLmJvdHRvbSksXG4gICAgcmlnaHQ6IE1hdGguZmxvb3IocG9wcGVyLnJpZ2h0KVxuICB9O1xuXG4gIHZhciBzaWRlQSA9IHggPT09ICdib3R0b20nID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgdmFyIHNpZGVCID0geSA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG5cbiAgLy8gaWYgZ3B1QWNjZWxlcmF0aW9uIGlzIHNldCB0byBgdHJ1ZWAgYW5kIHRyYW5zZm9ybSBpcyBzdXBwb3J0ZWQsXG4gIC8vICB3ZSB1c2UgYHRyYW5zbGF0ZTNkYCB0byBhcHBseSB0aGUgcG9zaXRpb24gdG8gdGhlIHBvcHBlciB3ZVxuICAvLyBhdXRvbWF0aWNhbGx5IHVzZSB0aGUgc3VwcG9ydGVkIHByZWZpeGVkIHZlcnNpb24gaWYgbmVlZGVkXG4gIHZhciBwcmVmaXhlZFByb3BlcnR5ID0gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKTtcblxuICAvLyBub3csIGxldCdzIG1ha2UgYSBzdGVwIGJhY2sgYW5kIGxvb2sgYXQgdGhpcyBjb2RlIGNsb3NlbHkgKHd0Zj8pXG4gIC8vIElmIHRoZSBjb250ZW50IG9mIHRoZSBwb3BwZXIgZ3Jvd3Mgb25jZSBpdCdzIGJlZW4gcG9zaXRpb25lZCwgaXRcbiAgLy8gbWF5IGhhcHBlbiB0aGF0IHRoZSBwb3BwZXIgZ2V0cyBtaXNwbGFjZWQgYmVjYXVzZSBvZiB0aGUgbmV3IGNvbnRlbnRcbiAgLy8gb3ZlcmZsb3dpbmcgaXRzIHJlZmVyZW5jZSBlbGVtZW50XG4gIC8vIFRvIGF2b2lkIHRoaXMgcHJvYmxlbSwgd2UgcHJvdmlkZSB0d28gb3B0aW9ucyAoeCBhbmQgeSksIHdoaWNoIGFsbG93XG4gIC8vIHRoZSBjb25zdW1lciB0byBkZWZpbmUgdGhlIG9mZnNldCBvcmlnaW4uXG4gIC8vIElmIHdlIHBvc2l0aW9uIGEgcG9wcGVyIG9uIHRvcCBvZiBhIHJlZmVyZW5jZSBlbGVtZW50LCB3ZSBjYW4gc2V0XG4gIC8vIGB4YCB0byBgdG9wYCB0byBtYWtlIHRoZSBwb3BwZXIgZ3JvdyB0b3dhcmRzIGl0cyB0b3AgaW5zdGVhZCBvZlxuICAvLyBpdHMgYm90dG9tLlxuICB2YXIgbGVmdCA9IHZvaWQgMCxcbiAgICAgIHRvcCA9IHZvaWQgMDtcbiAgaWYgKHNpZGVBID09PSAnYm90dG9tJykge1xuICAgIHRvcCA9IC1vZmZzZXRQYXJlbnRSZWN0LmhlaWdodCArIG9mZnNldHMuYm90dG9tO1xuICB9IGVsc2Uge1xuICAgIHRvcCA9IG9mZnNldHMudG9wO1xuICB9XG4gIGlmIChzaWRlQiA9PT0gJ3JpZ2h0Jykge1xuICAgIGxlZnQgPSAtb2Zmc2V0UGFyZW50UmVjdC53aWR0aCArIG9mZnNldHMucmlnaHQ7XG4gIH0gZWxzZSB7XG4gICAgbGVmdCA9IG9mZnNldHMubGVmdDtcbiAgfVxuICBpZiAoZ3B1QWNjZWxlcmF0aW9uICYmIHByZWZpeGVkUHJvcGVydHkpIHtcbiAgICBzdHlsZXNbcHJlZml4ZWRQcm9wZXJ0eV0gPSAndHJhbnNsYXRlM2QoJyArIGxlZnQgKyAncHgsICcgKyB0b3AgKyAncHgsIDApJztcbiAgICBzdHlsZXNbc2lkZUFdID0gMDtcbiAgICBzdHlsZXNbc2lkZUJdID0gMDtcbiAgICBzdHlsZXMud2lsbENoYW5nZSA9ICd0cmFuc2Zvcm0nO1xuICB9IGVsc2Uge1xuICAgIC8vIG90aHdlcmlzZSwgd2UgdXNlIHRoZSBzdGFuZGFyZCBgdG9wYCwgYGxlZnRgLCBgYm90dG9tYCBhbmQgYHJpZ2h0YCBwcm9wZXJ0aWVzXG4gICAgdmFyIGludmVydFRvcCA9IHNpZGVBID09PSAnYm90dG9tJyA/IC0xIDogMTtcbiAgICB2YXIgaW52ZXJ0TGVmdCA9IHNpZGVCID09PSAncmlnaHQnID8gLTEgOiAxO1xuICAgIHN0eWxlc1tzaWRlQV0gPSB0b3AgKiBpbnZlcnRUb3A7XG4gICAgc3R5bGVzW3NpZGVCXSA9IGxlZnQgKiBpbnZlcnRMZWZ0O1xuICAgIHN0eWxlcy53aWxsQ2hhbmdlID0gc2lkZUEgKyAnLCAnICsgc2lkZUI7XG4gIH1cblxuICAvLyBBdHRyaWJ1dGVzXG4gIHZhciBhdHRyaWJ1dGVzID0ge1xuICAgICd4LXBsYWNlbWVudCc6IGRhdGEucGxhY2VtZW50XG4gIH07XG5cbiAgLy8gVXBkYXRlIGBkYXRhYCBhdHRyaWJ1dGVzLCBzdHlsZXMgYW5kIGFycm93U3R5bGVzXG4gIGRhdGEuYXR0cmlidXRlcyA9IF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCBkYXRhLmF0dHJpYnV0ZXMpO1xuICBkYXRhLnN0eWxlcyA9IF9leHRlbmRzKHt9LCBzdHlsZXMsIGRhdGEuc3R5bGVzKTtcbiAgZGF0YS5hcnJvd1N0eWxlcyA9IF9leHRlbmRzKHt9LCBkYXRhLm9mZnNldHMuYXJyb3csIGRhdGEuYXJyb3dTdHlsZXMpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEhlbHBlciB1c2VkIHRvIGtub3cgaWYgdGhlIGdpdmVuIG1vZGlmaWVyIGRlcGVuZHMgZnJvbSBhbm90aGVyIG9uZS48YnIgLz5cbiAqIEl0IGNoZWNrcyBpZiB0aGUgbmVlZGVkIG1vZGlmaWVyIGlzIGxpc3RlZCBhbmQgZW5hYmxlZC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVycyAtIGxpc3Qgb2YgbW9kaWZpZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdGluZ05hbWUgLSBuYW1lIG9mIHJlcXVlc3RpbmcgbW9kaWZpZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0ZWROYW1lIC0gbmFtZSBvZiByZXF1ZXN0ZWQgbW9kaWZpZXJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc01vZGlmaWVyUmVxdWlyZWQobW9kaWZpZXJzLCByZXF1ZXN0aW5nTmFtZSwgcmVxdWVzdGVkTmFtZSkge1xuICB2YXIgcmVxdWVzdGluZyA9IGZpbmQobW9kaWZpZXJzLCBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBuYW1lID0gX3JlZi5uYW1lO1xuICAgIHJldHVybiBuYW1lID09PSByZXF1ZXN0aW5nTmFtZTtcbiAgfSk7XG5cbiAgdmFyIGlzUmVxdWlyZWQgPSAhIXJlcXVlc3RpbmcgJiYgbW9kaWZpZXJzLnNvbWUoZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09IHJlcXVlc3RlZE5hbWUgJiYgbW9kaWZpZXIuZW5hYmxlZCAmJiBtb2RpZmllci5vcmRlciA8IHJlcXVlc3Rpbmcub3JkZXI7XG4gIH0pO1xuXG4gIGlmICghaXNSZXF1aXJlZCkge1xuICAgIHZhciBfcmVxdWVzdGluZyA9ICdgJyArIHJlcXVlc3RpbmdOYW1lICsgJ2AnO1xuICAgIHZhciByZXF1ZXN0ZWQgPSAnYCcgKyByZXF1ZXN0ZWROYW1lICsgJ2AnO1xuICAgIGNvbnNvbGUud2FybihyZXF1ZXN0ZWQgKyAnIG1vZGlmaWVyIGlzIHJlcXVpcmVkIGJ5ICcgKyBfcmVxdWVzdGluZyArICcgbW9kaWZpZXIgaW4gb3JkZXIgdG8gd29yaywgYmUgc3VyZSB0byBpbmNsdWRlIGl0IGJlZm9yZSAnICsgX3JlcXVlc3RpbmcgKyAnIScpO1xuICB9XG4gIHJldHVybiBpc1JlcXVpcmVkO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gYXJyb3coZGF0YSwgb3B0aW9ucykge1xuICB2YXIgX2RhdGEkb2Zmc2V0cyRhcnJvdztcblxuICAvLyBhcnJvdyBkZXBlbmRzIG9uIGtlZXBUb2dldGhlciBpbiBvcmRlciB0byB3b3JrXG4gIGlmICghaXNNb2RpZmllclJlcXVpcmVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnYXJyb3cnLCAna2VlcFRvZ2V0aGVyJykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBhcnJvd0VsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQ7XG5cbiAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIGEgc3RyaW5nLCBzdXBwb3NlIGl0J3MgYSBDU1Mgc2VsZWN0b3JcbiAgaWYgKHR5cGVvZiBhcnJvd0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgYXJyb3dFbGVtZW50ID0gZGF0YS5pbnN0YW5jZS5wb3BwZXIucXVlcnlTZWxlY3RvcihhcnJvd0VsZW1lbnQpO1xuXG4gICAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIG5vdCBmb3VuZCwgZG9uJ3QgcnVuIHRoZSBtb2RpZmllclxuICAgIGlmICghYXJyb3dFbGVtZW50KSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgdGhlIGFycm93RWxlbWVudCBpc24ndCBhIHF1ZXJ5IHNlbGVjdG9yIHdlIG11c3QgY2hlY2sgdGhhdCB0aGVcbiAgICAvLyBwcm92aWRlZCBET00gbm9kZSBpcyBjaGlsZCBvZiBpdHMgcG9wcGVyIG5vZGVcbiAgICBpZiAoIWRhdGEuaW5zdGFuY2UucG9wcGVyLmNvbnRhaW5zKGFycm93RWxlbWVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybignV0FSTklORzogYGFycm93LmVsZW1lbnRgIG11c3QgYmUgY2hpbGQgb2YgaXRzIHBvcHBlciBlbGVtZW50IScpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgaXNWZXJ0aWNhbCA9IFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gIHZhciBzaWRlQ2FwaXRhbGl6ZWQgPSBpc1ZlcnRpY2FsID8gJ1RvcCcgOiAnTGVmdCc7XG4gIHZhciBzaWRlID0gc2lkZUNhcGl0YWxpemVkLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBhbHRTaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgb3BTaWRlID0gaXNWZXJ0aWNhbCA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgdmFyIGFycm93RWxlbWVudFNpemUgPSBnZXRPdXRlclNpemVzKGFycm93RWxlbWVudClbbGVuXTtcblxuICAvL1xuICAvLyBleHRlbmRzIGtlZXBUb2dldGhlciBiZWhhdmlvciBtYWtpbmcgc3VyZSB0aGUgcG9wcGVyIGFuZCBpdHNcbiAgLy8gcmVmZXJlbmNlIGhhdmUgZW5vdWdoIHBpeGVscyBpbiBjb25qdWN0aW9uXG4gIC8vXG5cbiAgLy8gdG9wL2xlZnQgc2lkZVxuICBpZiAocmVmZXJlbmNlW29wU2lkZV0gLSBhcnJvd0VsZW1lbnRTaXplIDwgcG9wcGVyW3NpZGVdKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSAtPSBwb3BwZXJbc2lkZV0gLSAocmVmZXJlbmNlW29wU2lkZV0gLSBhcnJvd0VsZW1lbnRTaXplKTtcbiAgfVxuICAvLyBib3R0b20vcmlnaHQgc2lkZVxuICBpZiAocmVmZXJlbmNlW3NpZGVdICsgYXJyb3dFbGVtZW50U2l6ZSA+IHBvcHBlcltvcFNpZGVdKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSArPSByZWZlcmVuY2Vbc2lkZV0gKyBhcnJvd0VsZW1lbnRTaXplIC0gcG9wcGVyW29wU2lkZV07XG4gIH1cbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnBvcHBlcik7XG5cbiAgLy8gY29tcHV0ZSBjZW50ZXIgb2YgdGhlIHBvcHBlclxuICB2YXIgY2VudGVyID0gcmVmZXJlbmNlW3NpZGVdICsgcmVmZXJlbmNlW2xlbl0gLyAyIC0gYXJyb3dFbGVtZW50U2l6ZSAvIDI7XG5cbiAgLy8gQ29tcHV0ZSB0aGUgc2lkZVZhbHVlIHVzaW5nIHRoZSB1cGRhdGVkIHBvcHBlciBvZmZzZXRzXG4gIC8vIHRha2UgcG9wcGVyIG1hcmdpbiBpbiBhY2NvdW50IGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSB0aGlzIGluZm8gYXZhaWxhYmxlXG4gIHZhciBjc3MgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuICB2YXIgcG9wcGVyTWFyZ2luU2lkZSA9IHBhcnNlRmxvYXQoY3NzWydtYXJnaW4nICsgc2lkZUNhcGl0YWxpemVkXSwgMTApO1xuICB2YXIgcG9wcGVyQm9yZGVyU2lkZSA9IHBhcnNlRmxvYXQoY3NzWydib3JkZXInICsgc2lkZUNhcGl0YWxpemVkICsgJ1dpZHRoJ10sIDEwKTtcbiAgdmFyIHNpZGVWYWx1ZSA9IGNlbnRlciAtIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gLSBwb3BwZXJNYXJnaW5TaWRlIC0gcG9wcGVyQm9yZGVyU2lkZTtcblxuICAvLyBwcmV2ZW50IGFycm93RWxlbWVudCBmcm9tIGJlaW5nIHBsYWNlZCBub3QgY29udGlndW91c2x5IHRvIGl0cyBwb3BwZXJcbiAgc2lkZVZhbHVlID0gTWF0aC5tYXgoTWF0aC5taW4ocG9wcGVyW2xlbl0gLSBhcnJvd0VsZW1lbnRTaXplLCBzaWRlVmFsdWUpLCAwKTtcblxuICBkYXRhLmFycm93RWxlbWVudCA9IGFycm93RWxlbWVudDtcbiAgZGF0YS5vZmZzZXRzLmFycm93ID0gKF9kYXRhJG9mZnNldHMkYXJyb3cgPSB7fSwgZGVmaW5lUHJvcGVydHkoX2RhdGEkb2Zmc2V0cyRhcnJvdywgc2lkZSwgTWF0aC5yb3VuZChzaWRlVmFsdWUpKSwgZGVmaW5lUHJvcGVydHkoX2RhdGEkb2Zmc2V0cyRhcnJvdywgYWx0U2lkZSwgJycpLCBfZGF0YSRvZmZzZXRzJGFycm93KTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG9wcG9zaXRlIHBsYWNlbWVudCB2YXJpYXRpb24gb2YgdGhlIGdpdmVuIG9uZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudCB2YXJpYXRpb25cbiAqIEByZXR1cm5zIHtTdHJpbmd9IGZsaXBwZWQgcGxhY2VtZW50IHZhcmlhdGlvblxuICovXG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVZhcmlhdGlvbih2YXJpYXRpb24pIHtcbiAgaWYgKHZhcmlhdGlvbiA9PT0gJ2VuZCcpIHtcbiAgICByZXR1cm4gJ3N0YXJ0JztcbiAgfSBlbHNlIGlmICh2YXJpYXRpb24gPT09ICdzdGFydCcpIHtcbiAgICByZXR1cm4gJ2VuZCc7XG4gIH1cbiAgcmV0dXJuIHZhcmlhdGlvbjtcbn1cblxuLyoqXG4gKiBMaXN0IG9mIGFjY2VwdGVkIHBsYWNlbWVudHMgdG8gdXNlIGFzIHZhbHVlcyBvZiB0aGUgYHBsYWNlbWVudGAgb3B0aW9uLjxiciAvPlxuICogVmFsaWQgcGxhY2VtZW50cyBhcmU6XG4gKiAtIGBhdXRvYFxuICogLSBgdG9wYFxuICogLSBgcmlnaHRgXG4gKiAtIGBib3R0b21gXG4gKiAtIGBsZWZ0YFxuICpcbiAqIEVhY2ggcGxhY2VtZW50IGNhbiBoYXZlIGEgdmFyaWF0aW9uIGZyb20gdGhpcyBsaXN0OlxuICogLSBgLXN0YXJ0YFxuICogLSBgLWVuZGBcbiAqXG4gKiBWYXJpYXRpb25zIGFyZSBpbnRlcnByZXRlZCBlYXNpbHkgaWYgeW91IHRoaW5rIG9mIHRoZW0gYXMgdGhlIGxlZnQgdG8gcmlnaHRcbiAqIHdyaXR0ZW4gbGFuZ3VhZ2VzLiBIb3Jpem9udGFsbHkgKGB0b3BgIGFuZCBgYm90dG9tYCksIGBzdGFydGAgaXMgbGVmdCBhbmQgYGVuZGBcbiAqIGlzIHJpZ2h0LjxiciAvPlxuICogVmVydGljYWxseSAoYGxlZnRgIGFuZCBgcmlnaHRgKSwgYHN0YXJ0YCBpcyB0b3AgYW5kIGBlbmRgIGlzIGJvdHRvbS5cbiAqXG4gKiBTb21lIHZhbGlkIGV4YW1wbGVzIGFyZTpcbiAqIC0gYHRvcC1lbmRgIChvbiB0b3Agb2YgcmVmZXJlbmNlLCByaWdodCBhbGlnbmVkKVxuICogLSBgcmlnaHQtc3RhcnRgIChvbiByaWdodCBvZiByZWZlcmVuY2UsIHRvcCBhbGlnbmVkKVxuICogLSBgYm90dG9tYCAob24gYm90dG9tLCBjZW50ZXJlZClcbiAqIC0gYGF1dG8tcmlnaHRgIChvbiB0aGUgc2lkZSB3aXRoIG1vcmUgc3BhY2UgYXZhaWxhYmxlLCBhbGlnbm1lbnQgZGVwZW5kcyBieSBwbGFjZW1lbnQpXG4gKlxuICogQHN0YXRpY1xuICogQHR5cGUge0FycmF5fVxuICogQGVudW0ge1N0cmluZ31cbiAqIEByZWFkb25seVxuICogQG1ldGhvZCBwbGFjZW1lbnRzXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbnZhciBwbGFjZW1lbnRzID0gWydhdXRvLXN0YXJ0JywgJ2F1dG8nLCAnYXV0by1lbmQnLCAndG9wLXN0YXJ0JywgJ3RvcCcsICd0b3AtZW5kJywgJ3JpZ2h0LXN0YXJ0JywgJ3JpZ2h0JywgJ3JpZ2h0LWVuZCcsICdib3R0b20tZW5kJywgJ2JvdHRvbScsICdib3R0b20tc3RhcnQnLCAnbGVmdC1lbmQnLCAnbGVmdCcsICdsZWZ0LXN0YXJ0J107XG5cbi8vIEdldCByaWQgb2YgYGF1dG9gIGBhdXRvLXN0YXJ0YCBhbmQgYGF1dG8tZW5kYFxudmFyIHZhbGlkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMuc2xpY2UoMyk7XG5cbi8qKlxuICogR2l2ZW4gYW4gaW5pdGlhbCBwbGFjZW1lbnQsIHJldHVybnMgYWxsIHRoZSBzdWJzZXF1ZW50IHBsYWNlbWVudHNcbiAqIGNsb2Nrd2lzZSAob3IgY291bnRlci1jbG9ja3dpc2UpLlxuICpcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnQgLSBBIHZhbGlkIHBsYWNlbWVudCAoaXQgYWNjZXB0cyB2YXJpYXRpb25zKVxuICogQGFyZ3VtZW50IHtCb29sZWFufSBjb3VudGVyIC0gU2V0IHRvIHRydWUgdG8gd2FsayB0aGUgcGxhY2VtZW50cyBjb3VudGVyY2xvY2t3aXNlXG4gKiBAcmV0dXJucyB7QXJyYXl9IHBsYWNlbWVudHMgaW5jbHVkaW5nIHRoZWlyIHZhcmlhdGlvbnNcbiAqL1xuZnVuY3Rpb24gY2xvY2t3aXNlKHBsYWNlbWVudCkge1xuICB2YXIgY291bnRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgdmFyIGluZGV4ID0gdmFsaWRQbGFjZW1lbnRzLmluZGV4T2YocGxhY2VtZW50KTtcbiAgdmFyIGFyciA9IHZhbGlkUGxhY2VtZW50cy5zbGljZShpbmRleCArIDEpLmNvbmNhdCh2YWxpZFBsYWNlbWVudHMuc2xpY2UoMCwgaW5kZXgpKTtcbiAgcmV0dXJuIGNvdW50ZXIgPyBhcnIucmV2ZXJzZSgpIDogYXJyO1xufVxuXG52YXIgQkVIQVZJT1JTID0ge1xuICBGTElQOiAnZmxpcCcsXG4gIENMT0NLV0lTRTogJ2Nsb2Nrd2lzZScsXG4gIENPVU5URVJDTE9DS1dJU0U6ICdjb3VudGVyY2xvY2t3aXNlJ1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGZsaXAoZGF0YSwgb3B0aW9ucykge1xuICAvLyBpZiBgaW5uZXJgIG1vZGlmaWVyIGlzIGVuYWJsZWQsIHdlIGNhbid0IHVzZSB0aGUgYGZsaXBgIG1vZGlmaWVyXG4gIGlmIChpc01vZGlmaWVyRW5hYmxlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2lubmVyJykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGlmIChkYXRhLmZsaXBwZWQgJiYgZGF0YS5wbGFjZW1lbnQgPT09IGRhdGEub3JpZ2luYWxQbGFjZW1lbnQpIHtcbiAgICAvLyBzZWVtcyBsaWtlIGZsaXAgaXMgdHJ5aW5nIHRvIGxvb3AsIHByb2JhYmx5IHRoZXJlJ3Mgbm90IGVub3VnaCBzcGFjZSBvbiBhbnkgb2YgdGhlIGZsaXBwYWJsZSBzaWRlc1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSwgb3B0aW9ucy5wYWRkaW5nLCBvcHRpb25zLmJvdW5kYXJpZXNFbGVtZW50KTtcblxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIHBsYWNlbWVudE9wcG9zaXRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgdmFyIHZhcmlhdGlvbiA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMV0gfHwgJyc7XG5cbiAgdmFyIGZsaXBPcmRlciA9IFtdO1xuXG4gIHN3aXRjaCAob3B0aW9ucy5iZWhhdmlvcikge1xuICAgIGNhc2UgQkVIQVZJT1JTLkZMSVA6XG4gICAgICBmbGlwT3JkZXIgPSBbcGxhY2VtZW50LCBwbGFjZW1lbnRPcHBvc2l0ZV07XG4gICAgICBicmVhaztcbiAgICBjYXNlIEJFSEFWSU9SUy5DTE9DS1dJU0U6XG4gICAgICBmbGlwT3JkZXIgPSBjbG9ja3dpc2UocGxhY2VtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQkVIQVZJT1JTLkNPVU5URVJDTE9DS1dJU0U6XG4gICAgICBmbGlwT3JkZXIgPSBjbG9ja3dpc2UocGxhY2VtZW50LCB0cnVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBmbGlwT3JkZXIgPSBvcHRpb25zLmJlaGF2aW9yO1xuICB9XG5cbiAgZmxpcE9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHN0ZXAsIGluZGV4KSB7XG4gICAgaWYgKHBsYWNlbWVudCAhPT0gc3RlcCB8fCBmbGlwT3JkZXIubGVuZ3RoID09PSBpbmRleCArIDEpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gICAgcGxhY2VtZW50T3Bwb3NpdGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuXG4gICAgdmFyIHBvcHBlck9mZnNldHMgPSBkYXRhLm9mZnNldHMucG9wcGVyO1xuICAgIHZhciByZWZPZmZzZXRzID0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZTtcblxuICAgIC8vIHVzaW5nIGZsb29yIGJlY2F1c2UgdGhlIHJlZmVyZW5jZSBvZmZzZXRzIG1heSBjb250YWluIGRlY2ltYWxzIHdlIGFyZSBub3QgZ29pbmcgdG8gY29uc2lkZXIgaGVyZVxuICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgdmFyIG92ZXJsYXBzUmVmID0gcGxhY2VtZW50ID09PSAnbGVmdCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5yaWdodCkgPiBmbG9vcihyZWZPZmZzZXRzLmxlZnQpIHx8IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLmxlZnQpIDwgZmxvb3IocmVmT2Zmc2V0cy5yaWdodCkgfHwgcGxhY2VtZW50ID09PSAndG9wJyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLmJvdHRvbSkgPiBmbG9vcihyZWZPZmZzZXRzLnRvcCkgfHwgcGxhY2VtZW50ID09PSAnYm90dG9tJyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLnRvcCkgPCBmbG9vcihyZWZPZmZzZXRzLmJvdHRvbSk7XG5cbiAgICB2YXIgb3ZlcmZsb3dzTGVmdCA9IGZsb29yKHBvcHBlck9mZnNldHMubGVmdCkgPCBmbG9vcihib3VuZGFyaWVzLmxlZnQpO1xuICAgIHZhciBvdmVyZmxvd3NSaWdodCA9IGZsb29yKHBvcHBlck9mZnNldHMucmlnaHQpID4gZmxvb3IoYm91bmRhcmllcy5yaWdodCk7XG4gICAgdmFyIG92ZXJmbG93c1RvcCA9IGZsb29yKHBvcHBlck9mZnNldHMudG9wKSA8IGZsb29yKGJvdW5kYXJpZXMudG9wKTtcbiAgICB2YXIgb3ZlcmZsb3dzQm90dG9tID0gZmxvb3IocG9wcGVyT2Zmc2V0cy5ib3R0b20pID4gZmxvb3IoYm91bmRhcmllcy5ib3R0b20pO1xuXG4gICAgdmFyIG92ZXJmbG93c0JvdW5kYXJpZXMgPSBwbGFjZW1lbnQgPT09ICdsZWZ0JyAmJiBvdmVyZmxvd3NMZWZ0IHx8IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyAmJiBvdmVyZmxvd3NSaWdodCB8fCBwbGFjZW1lbnQgPT09ICd0b3AnICYmIG92ZXJmbG93c1RvcCB8fCBwbGFjZW1lbnQgPT09ICdib3R0b20nICYmIG92ZXJmbG93c0JvdHRvbTtcblxuICAgIC8vIGZsaXAgdGhlIHZhcmlhdGlvbiBpZiByZXF1aXJlZFxuICAgIHZhciBpc1ZlcnRpY2FsID0gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgICB2YXIgZmxpcHBlZFZhcmlhdGlvbiA9ICEhb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyAmJiAoaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCBpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c1RvcCB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c0JvdHRvbSk7XG5cbiAgICBpZiAob3ZlcmxhcHNSZWYgfHwgb3ZlcmZsb3dzQm91bmRhcmllcyB8fCBmbGlwcGVkVmFyaWF0aW9uKSB7XG4gICAgICAvLyB0aGlzIGJvb2xlYW4gdG8gZGV0ZWN0IGFueSBmbGlwIGxvb3BcbiAgICAgIGRhdGEuZmxpcHBlZCA9IHRydWU7XG5cbiAgICAgIGlmIChvdmVybGFwc1JlZiB8fCBvdmVyZmxvd3NCb3VuZGFyaWVzKSB7XG4gICAgICAgIHBsYWNlbWVudCA9IGZsaXBPcmRlcltpbmRleCArIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmxpcHBlZFZhcmlhdGlvbikge1xuICAgICAgICB2YXJpYXRpb24gPSBnZXRPcHBvc2l0ZVZhcmlhdGlvbih2YXJpYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBkYXRhLnBsYWNlbWVudCA9IHBsYWNlbWVudCArICh2YXJpYXRpb24gPyAnLScgKyB2YXJpYXRpb24gOiAnJyk7XG5cbiAgICAgIC8vIHRoaXMgb2JqZWN0IGNvbnRhaW5zIGBwb3NpdGlvbmAsIHdlIHdhbnQgdG8gcHJlc2VydmUgaXQgYWxvbmcgd2l0aFxuICAgICAgLy8gYW55IGFkZGl0aW9uYWwgcHJvcGVydHkgd2UgbWF5IGFkZCBpbiB0aGUgZnV0dXJlXG4gICAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gX2V4dGVuZHMoe30sIGRhdGEub2Zmc2V0cy5wb3BwZXIsIGdldFBvcHBlck9mZnNldHMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsIGRhdGEucGxhY2VtZW50KSk7XG5cbiAgICAgIGRhdGEgPSBydW5Nb2RpZmllcnMoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGRhdGEsICdmbGlwJyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBrZWVwVG9nZXRoZXIoZGF0YSkge1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gIHZhciBpc1ZlcnRpY2FsID0gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgdmFyIHNpZGUgPSBpc1ZlcnRpY2FsID8gJ3JpZ2h0JyA6ICdib3R0b20nO1xuICB2YXIgb3BTaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgbWVhc3VyZW1lbnQgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gIGlmIChwb3BwZXJbc2lkZV0gPCBmbG9vcihyZWZlcmVuY2Vbb3BTaWRlXSkpIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW29wU2lkZV0gPSBmbG9vcihyZWZlcmVuY2Vbb3BTaWRlXSkgLSBwb3BwZXJbbWVhc3VyZW1lbnRdO1xuICB9XG4gIGlmIChwb3BwZXJbb3BTaWRlXSA+IGZsb29yKHJlZmVyZW5jZVtzaWRlXSkpIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW29wU2lkZV0gPSBmbG9vcihyZWZlcmVuY2Vbc2lkZV0pO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgY29udGFpbmluZyB2YWx1ZSArIHVuaXQgaW50byBhIHB4IHZhbHVlIG51bWJlclxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2Yge21vZGlmaWVyc35vZmZzZXR9XG4gKiBAcHJpdmF0ZVxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHN0ciAtIFZhbHVlICsgdW5pdCBzdHJpbmdcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBtZWFzdXJlbWVudCAtIGBoZWlnaHRgIG9yIGB3aWR0aGBcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzXG4gKiBAYXJndW1lbnQge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0c1xuICogQHJldHVybnMge051bWJlcnxTdHJpbmd9XG4gKiBWYWx1ZSBpbiBwaXhlbHMsIG9yIG9yaWdpbmFsIHN0cmluZyBpZiBubyB2YWx1ZXMgd2VyZSBleHRyYWN0ZWRcbiAqL1xuZnVuY3Rpb24gdG9WYWx1ZShzdHIsIG1lYXN1cmVtZW50LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzKSB7XG4gIC8vIHNlcGFyYXRlIHZhbHVlIGZyb20gdW5pdFxuICB2YXIgc3BsaXQgPSBzdHIubWF0Y2goLygoPzpcXC18XFwrKT9cXGQqXFwuP1xcZCopKC4qKS8pO1xuICB2YXIgdmFsdWUgPSArc3BsaXRbMV07XG4gIHZhciB1bml0ID0gc3BsaXRbMl07XG5cbiAgLy8gSWYgaXQncyBub3QgYSBudW1iZXIgaXQncyBhbiBvcGVyYXRvciwgSSBndWVzc1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIGlmICh1bml0LmluZGV4T2YoJyUnKSA9PT0gMCkge1xuICAgIHZhciBlbGVtZW50ID0gdm9pZCAwO1xuICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgY2FzZSAnJXAnOlxuICAgICAgICBlbGVtZW50ID0gcG9wcGVyT2Zmc2V0cztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICclJzpcbiAgICAgIGNhc2UgJyVyJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGVsZW1lbnQgPSByZWZlcmVuY2VPZmZzZXRzO1xuICAgIH1cblxuICAgIHZhciByZWN0ID0gZ2V0Q2xpZW50UmVjdChlbGVtZW50KTtcbiAgICByZXR1cm4gcmVjdFttZWFzdXJlbWVudF0gLyAxMDAgKiB2YWx1ZTtcbiAgfSBlbHNlIGlmICh1bml0ID09PSAndmgnIHx8IHVuaXQgPT09ICd2dycpIHtcbiAgICAvLyBpZiBpcyBhIHZoIG9yIHZ3LCB3ZSBjYWxjdWxhdGUgdGhlIHNpemUgYmFzZWQgb24gdGhlIHZpZXdwb3J0XG4gICAgdmFyIHNpemUgPSB2b2lkIDA7XG4gICAgaWYgKHVuaXQgPT09ICd2aCcpIHtcbiAgICAgIHNpemUgPSBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpemUgPSBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZSAvIDEwMCAqIHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIC8vIGlmIGlzIGFuIGV4cGxpY2l0IHBpeGVsIHVuaXQsIHdlIGdldCByaWQgb2YgdGhlIHVuaXQgYW5kIGtlZXAgdGhlIHZhbHVlXG4gICAgLy8gaWYgaXMgYW4gaW1wbGljaXQgdW5pdCwgaXQncyBweCwgYW5kIHdlIHJldHVybiBqdXN0IHRoZSB2YWx1ZVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGFuIGBvZmZzZXRgIHN0cmluZyB0byBleHRyYXBvbGF0ZSBgeGAgYW5kIGB5YCBudW1lcmljIG9mZnNldHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiB7bW9kaWZpZXJzfm9mZnNldH1cbiAqIEBwcml2YXRlXG4gKiBAYXJndW1lbnQge1N0cmluZ30gb2Zmc2V0XG4gKiBAYXJndW1lbnQge09iamVjdH0gcG9wcGVyT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBiYXNlUGxhY2VtZW50XG4gKiBAcmV0dXJucyB7QXJyYXl9IGEgdHdvIGNlbGxzIGFycmF5IHdpdGggeCBhbmQgeSBvZmZzZXRzIGluIG51bWJlcnNcbiAqL1xuZnVuY3Rpb24gcGFyc2VPZmZzZXQob2Zmc2V0LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzLCBiYXNlUGxhY2VtZW50KSB7XG4gIHZhciBvZmZzZXRzID0gWzAsIDBdO1xuXG4gIC8vIFVzZSBoZWlnaHQgaWYgcGxhY2VtZW50IGlzIGxlZnQgb3IgcmlnaHQgYW5kIGluZGV4IGlzIDAgb3RoZXJ3aXNlIHVzZSB3aWR0aFxuICAvLyBpbiB0aGlzIHdheSB0aGUgZmlyc3Qgb2Zmc2V0IHdpbGwgdXNlIGFuIGF4aXMgYW5kIHRoZSBzZWNvbmQgb25lXG4gIC8vIHdpbGwgdXNlIHRoZSBvdGhlciBvbmVcbiAgdmFyIHVzZUhlaWdodCA9IFsncmlnaHQnLCAnbGVmdCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gIC8vIFNwbGl0IHRoZSBvZmZzZXQgc3RyaW5nIHRvIG9idGFpbiBhIGxpc3Qgb2YgdmFsdWVzIGFuZCBvcGVyYW5kc1xuICAvLyBUaGUgcmVnZXggYWRkcmVzc2VzIHZhbHVlcyB3aXRoIHRoZSBwbHVzIG9yIG1pbnVzIHNpZ24gaW4gZnJvbnQgKCsxMCwgLTIwLCBldGMpXG4gIHZhciBmcmFnbWVudHMgPSBvZmZzZXQuc3BsaXQoLyhcXCt8XFwtKS8pLm1hcChmdW5jdGlvbiAoZnJhZykge1xuICAgIHJldHVybiBmcmFnLnRyaW0oKTtcbiAgfSk7XG5cbiAgLy8gRGV0ZWN0IGlmIHRoZSBvZmZzZXQgc3RyaW5nIGNvbnRhaW5zIGEgcGFpciBvZiB2YWx1ZXMgb3IgYSBzaW5nbGUgb25lXG4gIC8vIHRoZXkgY291bGQgYmUgc2VwYXJhdGVkIGJ5IGNvbW1hIG9yIHNwYWNlXG4gIHZhciBkaXZpZGVyID0gZnJhZ21lbnRzLmluZGV4T2YoZmluZChmcmFnbWVudHMsIGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgcmV0dXJuIGZyYWcuc2VhcmNoKC8sfFxccy8pICE9PSAtMTtcbiAgfSkpO1xuXG4gIGlmIChmcmFnbWVudHNbZGl2aWRlcl0gJiYgZnJhZ21lbnRzW2RpdmlkZXJdLmluZGV4T2YoJywnKSA9PT0gLTEpIHtcbiAgICBjb25zb2xlLndhcm4oJ09mZnNldHMgc2VwYXJhdGVkIGJ5IHdoaXRlIHNwYWNlKHMpIGFyZSBkZXByZWNhdGVkLCB1c2UgYSBjb21tYSAoLCkgaW5zdGVhZC4nKTtcbiAgfVxuXG4gIC8vIElmIGRpdmlkZXIgaXMgZm91bmQsIHdlIGRpdmlkZSB0aGUgbGlzdCBvZiB2YWx1ZXMgYW5kIG9wZXJhbmRzIHRvIGRpdmlkZVxuICAvLyB0aGVtIGJ5IG9mc2V0IFggYW5kIFkuXG4gIHZhciBzcGxpdFJlZ2V4ID0gL1xccyosXFxzKnxcXHMrLztcbiAgdmFyIG9wcyA9IGRpdmlkZXIgIT09IC0xID8gW2ZyYWdtZW50cy5zbGljZSgwLCBkaXZpZGVyKS5jb25jYXQoW2ZyYWdtZW50c1tkaXZpZGVyXS5zcGxpdChzcGxpdFJlZ2V4KVswXV0pLCBbZnJhZ21lbnRzW2RpdmlkZXJdLnNwbGl0KHNwbGl0UmVnZXgpWzFdXS5jb25jYXQoZnJhZ21lbnRzLnNsaWNlKGRpdmlkZXIgKyAxKSldIDogW2ZyYWdtZW50c107XG5cbiAgLy8gQ29udmVydCB0aGUgdmFsdWVzIHdpdGggdW5pdHMgdG8gYWJzb2x1dGUgcGl4ZWxzIHRvIGFsbG93IG91ciBjb21wdXRhdGlvbnNcbiAgb3BzID0gb3BzLm1hcChmdW5jdGlvbiAob3AsIGluZGV4KSB7XG4gICAgLy8gTW9zdCBvZiB0aGUgdW5pdHMgcmVseSBvbiB0aGUgb3JpZW50YXRpb24gb2YgdGhlIHBvcHBlclxuICAgIHZhciBtZWFzdXJlbWVudCA9IChpbmRleCA9PT0gMSA/ICF1c2VIZWlnaHQgOiB1c2VIZWlnaHQpID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgIHZhciBtZXJnZVdpdGhQcmV2aW91cyA9IGZhbHNlO1xuICAgIHJldHVybiBvcFxuICAgIC8vIFRoaXMgYWdncmVnYXRlcyBhbnkgYCtgIG9yIGAtYCBzaWduIHRoYXQgYXJlbid0IGNvbnNpZGVyZWQgb3BlcmF0b3JzXG4gICAgLy8gZS5nLjogMTAgKyArNSA9PiBbMTAsICssICs1XVxuICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIGlmIChhW2EubGVuZ3RoIC0gMV0gPT09ICcnICYmIFsnKycsICctJ10uaW5kZXhPZihiKSAhPT0gLTEpIHtcbiAgICAgICAgYVthLmxlbmd0aCAtIDFdID0gYjtcbiAgICAgICAgbWVyZ2VXaXRoUHJldmlvdXMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0gZWxzZSBpZiAobWVyZ2VXaXRoUHJldmlvdXMpIHtcbiAgICAgICAgYVthLmxlbmd0aCAtIDFdICs9IGI7XG4gICAgICAgIG1lcmdlV2l0aFByZXZpb3VzID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICAgICAgfVxuICAgIH0sIFtdKVxuICAgIC8vIEhlcmUgd2UgY29udmVydCB0aGUgc3RyaW5nIHZhbHVlcyBpbnRvIG51bWJlciB2YWx1ZXMgKGluIHB4KVxuICAgIC5tYXAoZnVuY3Rpb24gKHN0cikge1xuICAgICAgcmV0dXJuIHRvVmFsdWUoc3RyLCBtZWFzdXJlbWVudCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIExvb3AgdHJvdWdoIHRoZSBvZmZzZXRzIGFycmF5cyBhbmQgZXhlY3V0ZSB0aGUgb3BlcmF0aW9uc1xuICBvcHMuZm9yRWFjaChmdW5jdGlvbiAob3AsIGluZGV4KSB7XG4gICAgb3AuZm9yRWFjaChmdW5jdGlvbiAoZnJhZywgaW5kZXgyKSB7XG4gICAgICBpZiAoaXNOdW1lcmljKGZyYWcpKSB7XG4gICAgICAgIG9mZnNldHNbaW5kZXhdICs9IGZyYWcgKiAob3BbaW5kZXgyIC0gMV0gPT09ICctJyA/IC0xIDogMSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gb2Zmc2V0cztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAYXJndW1lbnQge051bWJlcnxTdHJpbmd9IG9wdGlvbnMub2Zmc2V0PTBcbiAqIFRoZSBvZmZzZXQgdmFsdWUgYXMgZGVzY3JpYmVkIGluIHRoZSBtb2RpZmllciBkZXNjcmlwdGlvblxuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBvZmZzZXQoZGF0YSwgX3JlZikge1xuICB2YXIgb2Zmc2V0ID0gX3JlZi5vZmZzZXQ7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudCxcbiAgICAgIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG5cbiAgdmFyIG9mZnNldHMgPSB2b2lkIDA7XG4gIGlmIChpc051bWVyaWMoK29mZnNldCkpIHtcbiAgICBvZmZzZXRzID0gWytvZmZzZXQsIDBdO1xuICB9IGVsc2Uge1xuICAgIG9mZnNldHMgPSBwYXJzZU9mZnNldChvZmZzZXQsIHBvcHBlciwgcmVmZXJlbmNlLCBiYXNlUGxhY2VtZW50KTtcbiAgfVxuXG4gIGlmIChiYXNlUGxhY2VtZW50ID09PSAnbGVmdCcpIHtcbiAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLmxlZnQgLT0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAncmlnaHQnKSB7XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ3RvcCcpIHtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci50b3AgLT0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAnYm90dG9tJykge1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzFdO1xuICB9XG5cbiAgZGF0YS5wb3BwZXIgPSBwb3BwZXI7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBwcmV2ZW50T3ZlcmZsb3coZGF0YSwgb3B0aW9ucykge1xuICB2YXIgYm91bmRhcmllc0VsZW1lbnQgPSBvcHRpb25zLmJvdW5kYXJpZXNFbGVtZW50IHx8IGdldE9mZnNldFBhcmVudChkYXRhLmluc3RhbmNlLnBvcHBlcik7XG5cbiAgLy8gSWYgb2Zmc2V0UGFyZW50IGlzIHRoZSByZWZlcmVuY2UgZWxlbWVudCwgd2UgcmVhbGx5IHdhbnQgdG9cbiAgLy8gZ28gb25lIHN0ZXAgdXAgYW5kIHVzZSB0aGUgbmV4dCBvZmZzZXRQYXJlbnQgYXMgcmVmZXJlbmNlIHRvXG4gIC8vIGF2b2lkIHRvIG1ha2UgdGhpcyBtb2RpZmllciBjb21wbGV0ZWx5IHVzZWxlc3MgYW5kIGxvb2sgbGlrZSBicm9rZW5cbiAgaWYgKGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlID09PSBib3VuZGFyaWVzRWxlbWVudCkge1xuICAgIGJvdW5kYXJpZXNFbGVtZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGJvdW5kYXJpZXNFbGVtZW50KTtcbiAgfVxuXG4gIHZhciBib3VuZGFyaWVzID0gZ2V0Qm91bmRhcmllcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5pbnN0YW5jZS5yZWZlcmVuY2UsIG9wdGlvbnMucGFkZGluZywgYm91bmRhcmllc0VsZW1lbnQpO1xuICBvcHRpb25zLmJvdW5kYXJpZXMgPSBib3VuZGFyaWVzO1xuXG4gIHZhciBvcmRlciA9IG9wdGlvbnMucHJpb3JpdHk7XG4gIHZhciBwb3BwZXIgPSBkYXRhLm9mZnNldHMucG9wcGVyO1xuXG4gIHZhciBjaGVjayA9IHtcbiAgICBwcmltYXJ5OiBmdW5jdGlvbiBwcmltYXJ5KHBsYWNlbWVudCkge1xuICAgICAgdmFyIHZhbHVlID0gcG9wcGVyW3BsYWNlbWVudF07XG4gICAgICBpZiAocG9wcGVyW3BsYWNlbWVudF0gPCBib3VuZGFyaWVzW3BsYWNlbWVudF0gJiYgIW9wdGlvbnMuZXNjYXBlV2l0aFJlZmVyZW5jZSkge1xuICAgICAgICB2YWx1ZSA9IE1hdGgubWF4KHBvcHBlcltwbGFjZW1lbnRdLCBib3VuZGFyaWVzW3BsYWNlbWVudF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KHt9LCBwbGFjZW1lbnQsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNlY29uZGFyeTogZnVuY3Rpb24gc2Vjb25kYXJ5KHBsYWNlbWVudCkge1xuICAgICAgdmFyIG1haW5TaWRlID0gcGxhY2VtZW50ID09PSAncmlnaHQnID8gJ2xlZnQnIDogJ3RvcCc7XG4gICAgICB2YXIgdmFsdWUgPSBwb3BwZXJbbWFpblNpZGVdO1xuICAgICAgaWYgKHBvcHBlcltwbGFjZW1lbnRdID4gYm91bmRhcmllc1twbGFjZW1lbnRdICYmICFvcHRpb25zLmVzY2FwZVdpdGhSZWZlcmVuY2UpIHtcbiAgICAgICAgdmFsdWUgPSBNYXRoLm1pbihwb3BwZXJbbWFpblNpZGVdLCBib3VuZGFyaWVzW3BsYWNlbWVudF0gLSAocGxhY2VtZW50ID09PSAncmlnaHQnID8gcG9wcGVyLndpZHRoIDogcG9wcGVyLmhlaWdodCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KHt9LCBtYWluU2lkZSwgdmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICBvcmRlci5mb3JFYWNoKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICB2YXIgc2lkZSA9IFsnbGVmdCcsICd0b3AnXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xID8gJ3ByaW1hcnknIDogJ3NlY29uZGFyeSc7XG4gICAgcG9wcGVyID0gX2V4dGVuZHMoe30sIHBvcHBlciwgY2hlY2tbc2lkZV0ocGxhY2VtZW50KSk7XG4gIH0pO1xuXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBwb3BwZXI7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIHNoaWZ0KGRhdGEpIHtcbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgc2hpZnR2YXJpYXRpb24gPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcblxuICAvLyBpZiBzaGlmdCBzaGlmdHZhcmlhdGlvbiBpcyBzcGVjaWZpZWQsIHJ1biB0aGUgbW9kaWZpZXJcbiAgaWYgKHNoaWZ0dmFyaWF0aW9uKSB7XG4gICAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlLFxuICAgICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcjtcblxuICAgIHZhciBpc1ZlcnRpY2FsID0gWydib3R0b20nLCAndG9wJ10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG4gICAgdmFyIHNpZGUgPSBpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCc7XG4gICAgdmFyIG1lYXN1cmVtZW50ID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcblxuICAgIHZhciBzaGlmdE9mZnNldHMgPSB7XG4gICAgICBzdGFydDogZGVmaW5lUHJvcGVydHkoe30sIHNpZGUsIHJlZmVyZW5jZVtzaWRlXSksXG4gICAgICBlbmQ6IGRlZmluZVByb3BlcnR5KHt9LCBzaWRlLCByZWZlcmVuY2Vbc2lkZV0gKyByZWZlcmVuY2VbbWVhc3VyZW1lbnRdIC0gcG9wcGVyW21lYXN1cmVtZW50XSlcbiAgICB9O1xuXG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IF9leHRlbmRzKHt9LCBwb3BwZXIsIHNoaWZ0T2Zmc2V0c1tzaGlmdHZhcmlhdGlvbl0pO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBoaWRlKGRhdGEpIHtcbiAgaWYgKCFpc01vZGlmaWVyUmVxdWlyZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdoaWRlJywgJ3ByZXZlbnRPdmVyZmxvdycpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgcmVmUmVjdCA9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2U7XG4gIHZhciBib3VuZCA9IGZpbmQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIHJldHVybiBtb2RpZmllci5uYW1lID09PSAncHJldmVudE92ZXJmbG93JztcbiAgfSkuYm91bmRhcmllcztcblxuICBpZiAocmVmUmVjdC5ib3R0b20gPCBib3VuZC50b3AgfHwgcmVmUmVjdC5sZWZ0ID4gYm91bmQucmlnaHQgfHwgcmVmUmVjdC50b3AgPiBib3VuZC5ib3R0b20gfHwgcmVmUmVjdC5yaWdodCA8IGJvdW5kLmxlZnQpIHtcbiAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBET00gYWNjZXNzIGlmIHZpc2liaWxpdHkgaGFzbid0IGNoYW5nZWRcbiAgICBpZiAoZGF0YS5oaWRlID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBkYXRhLmhpZGUgPSB0cnVlO1xuICAgIGRhdGEuYXR0cmlidXRlc1sneC1vdXQtb2YtYm91bmRhcmllcyddID0gJyc7XG4gIH0gZWxzZSB7XG4gICAgLy8gQXZvaWQgdW5uZWNlc3NhcnkgRE9NIGFjY2VzcyBpZiB2aXNpYmlsaXR5IGhhc24ndCBjaGFuZ2VkXG4gICAgaWYgKGRhdGEuaGlkZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGRhdGEuaGlkZSA9IGZhbHNlO1xuICAgIGRhdGEuYXR0cmlidXRlc1sneC1vdXQtb2YtYm91bmRhcmllcyddID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gaW5uZXIoZGF0YSkge1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgaXNIb3JpeiA9IFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gIHZhciBzdWJ0cmFjdExlbmd0aCA9IFsndG9wJywgJ2xlZnQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID09PSAtMTtcblxuICBwb3BwZXJbaXNIb3JpeiA/ICdsZWZ0JyA6ICd0b3AnXSA9IHJlZmVyZW5jZVtiYXNlUGxhY2VtZW50XSAtIChzdWJ0cmFjdExlbmd0aCA/IHBvcHBlcltpc0hvcml6ID8gJ3dpZHRoJyA6ICdoZWlnaHQnXSA6IDApO1xuXG4gIGRhdGEucGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QocG9wcGVyKTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBNb2RpZmllciBmdW5jdGlvbiwgZWFjaCBtb2RpZmllciBjYW4gaGF2ZSBhIGZ1bmN0aW9uIG9mIHRoaXMgdHlwZSBhc3NpZ25lZFxuICogdG8gaXRzIGBmbmAgcHJvcGVydHkuPGJyIC8+XG4gKiBUaGVzZSBmdW5jdGlvbnMgd2lsbCBiZSBjYWxsZWQgb24gZWFjaCB1cGRhdGUsIHRoaXMgbWVhbnMgdGhhdCB5b3UgbXVzdFxuICogbWFrZSBzdXJlIHRoZXkgYXJlIHBlcmZvcm1hbnQgZW5vdWdoIHRvIGF2b2lkIHBlcmZvcm1hbmNlIGJvdHRsZW5lY2tzLlxuICpcbiAqIEBmdW5jdGlvbiBNb2RpZmllckZuXG4gKiBAYXJndW1lbnQge2RhdGFPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge2RhdGFPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuXG4vKipcbiAqIE1vZGlmaWVycyBhcmUgcGx1Z2lucyB1c2VkIHRvIGFsdGVyIHRoZSBiZWhhdmlvciBvZiB5b3VyIHBvcHBlcnMuPGJyIC8+XG4gKiBQb3BwZXIuanMgdXNlcyBhIHNldCBvZiA5IG1vZGlmaWVycyB0byBwcm92aWRlIGFsbCB0aGUgYmFzaWMgZnVuY3Rpb25hbGl0aWVzXG4gKiBuZWVkZWQgYnkgdGhlIGxpYnJhcnkuXG4gKlxuICogVXN1YWxseSB5b3UgZG9uJ3Qgd2FudCB0byBvdmVycmlkZSB0aGUgYG9yZGVyYCwgYGZuYCBhbmQgYG9uTG9hZGAgcHJvcHMuXG4gKiBBbGwgdGhlIG90aGVyIHByb3BlcnRpZXMgYXJlIGNvbmZpZ3VyYXRpb25zIHRoYXQgY291bGQgYmUgdHdlYWtlZC5cbiAqIEBuYW1lc3BhY2UgbW9kaWZpZXJzXG4gKi9cbnZhciBtb2RpZmllcnMgPSB7XG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIHNoaWZ0IHRoZSBwb3BwZXIgb24gdGhlIHN0YXJ0IG9yIGVuZCBvZiBpdHMgcmVmZXJlbmNlXG4gICAqIGVsZW1lbnQuPGJyIC8+XG4gICAqIEl0IHdpbGwgcmVhZCB0aGUgdmFyaWF0aW9uIG9mIHRoZSBgcGxhY2VtZW50YCBwcm9wZXJ0eS48YnIgLz5cbiAgICogSXQgY2FuIGJlIG9uZSBlaXRoZXIgYC1lbmRgIG9yIGAtc3RhcnRgLlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgc2hpZnQ6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MTAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAxMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBzaGlmdFxuICB9LFxuXG4gIC8qKlxuICAgKiBUaGUgYG9mZnNldGAgbW9kaWZpZXIgY2FuIHNoaWZ0IHlvdXIgcG9wcGVyIG9uIGJvdGggaXRzIGF4aXMuXG4gICAqXG4gICAqIEl0IGFjY2VwdHMgdGhlIGZvbGxvd2luZyB1bml0czpcbiAgICogLSBgcHhgIG9yIHVuaXRsZXNzLCBpbnRlcnByZXRlZCBhcyBwaXhlbHNcbiAgICogLSBgJWAgb3IgYCVyYCwgcGVyY2VudGFnZSByZWxhdGl2ZSB0byB0aGUgbGVuZ3RoIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudFxuICAgKiAtIGAlcGAsIHBlcmNlbnRhZ2UgcmVsYXRpdmUgdG8gdGhlIGxlbmd0aCBvZiB0aGUgcG9wcGVyIGVsZW1lbnRcbiAgICogLSBgdndgLCBDU1Mgdmlld3BvcnQgd2lkdGggdW5pdFxuICAgKiAtIGB2aGAsIENTUyB2aWV3cG9ydCBoZWlnaHQgdW5pdFxuICAgKlxuICAgKiBGb3IgbGVuZ3RoIGlzIGludGVuZGVkIHRoZSBtYWluIGF4aXMgcmVsYXRpdmUgdG8gdGhlIHBsYWNlbWVudCBvZiB0aGUgcG9wcGVyLjxiciAvPlxuICAgKiBUaGlzIG1lYW5zIHRoYXQgaWYgdGhlIHBsYWNlbWVudCBpcyBgdG9wYCBvciBgYm90dG9tYCwgdGhlIGxlbmd0aCB3aWxsIGJlIHRoZVxuICAgKiBgd2lkdGhgLiBJbiBjYXNlIG9mIGBsZWZ0YCBvciBgcmlnaHRgLCBpdCB3aWxsIGJlIHRoZSBoZWlnaHQuXG4gICAqXG4gICAqIFlvdSBjYW4gcHJvdmlkZSBhIHNpbmdsZSB2YWx1ZSAoYXMgYE51bWJlcmAgb3IgYFN0cmluZ2ApLCBvciBhIHBhaXIgb2YgdmFsdWVzXG4gICAqIGFzIGBTdHJpbmdgIGRpdmlkZWQgYnkgYSBjb21tYSBvciBvbmUgKG9yIG1vcmUpIHdoaXRlIHNwYWNlcy48YnIgLz5cbiAgICogVGhlIGxhdHRlciBpcyBhIGRlcHJlY2F0ZWQgbWV0aG9kIGJlY2F1c2UgaXQgbGVhZHMgdG8gY29uZnVzaW9uIGFuZCB3aWxsIGJlXG4gICAqIHJlbW92ZWQgaW4gdjIuPGJyIC8+XG4gICAqIEFkZGl0aW9uYWxseSwgaXQgYWNjZXB0cyBhZGRpdGlvbnMgYW5kIHN1YnRyYWN0aW9ucyBiZXR3ZWVuIGRpZmZlcmVudCB1bml0cy5cbiAgICogTm90ZSB0aGF0IG11bHRpcGxpY2F0aW9ucyBhbmQgZGl2aXNpb25zIGFyZW4ndCBzdXBwb3J0ZWQuXG4gICAqXG4gICAqIFZhbGlkIGV4YW1wbGVzIGFyZTpcbiAgICogYGBgXG4gICAqIDEwXG4gICAqICcxMCUnXG4gICAqICcxMCwgMTAnXG4gICAqICcxMCUsIDEwJ1xuICAgKiAnMTAgKyAxMCUnXG4gICAqICcxMCAtIDV2aCArIDMlJ1xuICAgKiAnLTEwcHggKyA1dmgsIDVweCAtIDYlJ1xuICAgKiBgYGBcbiAgICogPiAqKk5CKio6IElmIHlvdSBkZXNpcmUgdG8gYXBwbHkgb2Zmc2V0cyB0byB5b3VyIHBvcHBlcnMgaW4gYSB3YXkgdGhhdCBtYXkgbWFrZSB0aGVtIG92ZXJsYXBcbiAgICogPiB3aXRoIHRoZWlyIHJlZmVyZW5jZSBlbGVtZW50LCB1bmZvcnR1bmF0ZWx5LCB5b3Ugd2lsbCBoYXZlIHRvIGRpc2FibGUgdGhlIGBmbGlwYCBtb2RpZmllci5cbiAgICogPiBNb3JlIG9uIHRoaXMgW3JlYWRpbmcgdGhpcyBpc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL0ZlelZyYXN0YS9wb3BwZXIuanMvaXNzdWVzLzM3MylcbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIG9mZnNldDoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0yMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDIwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IG9mZnNldCxcbiAgICAvKiogQHByb3Age051bWJlcnxTdHJpbmd9IG9mZnNldD0wXG4gICAgICogVGhlIG9mZnNldCB2YWx1ZSBhcyBkZXNjcmliZWQgaW4gdGhlIG1vZGlmaWVyIGRlc2NyaXB0aW9uXG4gICAgICovXG4gICAgb2Zmc2V0OiAwXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gcHJldmVudCB0aGUgcG9wcGVyIGZyb20gYmVpbmcgcG9zaXRpb25lZCBvdXRzaWRlIHRoZSBib3VuZGFyeS5cbiAgICpcbiAgICogQW4gc2NlbmFyaW8gZXhpc3RzIHdoZXJlIHRoZSByZWZlcmVuY2UgaXRzZWxmIGlzIG5vdCB3aXRoaW4gdGhlIGJvdW5kYXJpZXMuPGJyIC8+XG4gICAqIFdlIGNhbiBzYXkgaXQgaGFzIFwiZXNjYXBlZCB0aGUgYm91bmRhcmllc1wiIOKAlCBvciBqdXN0IFwiZXNjYXBlZFwiLjxiciAvPlxuICAgKiBJbiB0aGlzIGNhc2Ugd2UgbmVlZCB0byBkZWNpZGUgd2hldGhlciB0aGUgcG9wcGVyIHNob3VsZCBlaXRoZXI6XG4gICAqXG4gICAqIC0gZGV0YWNoIGZyb20gdGhlIHJlZmVyZW5jZSBhbmQgcmVtYWluIFwidHJhcHBlZFwiIGluIHRoZSBib3VuZGFyaWVzLCBvclxuICAgKiAtIGlmIGl0IHNob3VsZCBpZ25vcmUgdGhlIGJvdW5kYXJ5IGFuZCBcImVzY2FwZSB3aXRoIGl0cyByZWZlcmVuY2VcIlxuICAgKlxuICAgKiBXaGVuIGBlc2NhcGVXaXRoUmVmZXJlbmNlYCBpcyBzZXQgdG9gdHJ1ZWAgYW5kIHJlZmVyZW5jZSBpcyBjb21wbGV0ZWx5XG4gICAqIG91dHNpZGUgaXRzIGJvdW5kYXJpZXMsIHRoZSBwb3BwZXIgd2lsbCBvdmVyZmxvdyAob3IgY29tcGxldGVseSBsZWF2ZSlcbiAgICogdGhlIGJvdW5kYXJpZXMgaW4gb3JkZXIgdG8gcmVtYWluIGF0dGFjaGVkIHRvIHRoZSBlZGdlIG9mIHRoZSByZWZlcmVuY2UuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBwcmV2ZW50T3ZlcmZsb3c6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MzAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAzMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBwcmV2ZW50T3ZlcmZsb3csXG4gICAgLyoqXG4gICAgICogQHByb3Age0FycmF5fSBbcHJpb3JpdHk9WydsZWZ0JywncmlnaHQnLCd0b3AnLCdib3R0b20nXV1cbiAgICAgKiBQb3BwZXIgd2lsbCB0cnkgdG8gcHJldmVudCBvdmVyZmxvdyBmb2xsb3dpbmcgdGhlc2UgcHJpb3JpdGllcyBieSBkZWZhdWx0LFxuICAgICAqIHRoZW4sIGl0IGNvdWxkIG92ZXJmbG93IG9uIHRoZSBsZWZ0IGFuZCBvbiB0b3Agb2YgdGhlIGBib3VuZGFyaWVzRWxlbWVudGBcbiAgICAgKi9cbiAgICBwcmlvcml0eTogWydsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nXSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7bnVtYmVyfSBwYWRkaW5nPTVcbiAgICAgKiBBbW91bnQgb2YgcGl4ZWwgdXNlZCB0byBkZWZpbmUgYSBtaW5pbXVtIGRpc3RhbmNlIGJldHdlZW4gdGhlIGJvdW5kYXJpZXNcbiAgICAgKiBhbmQgdGhlIHBvcHBlciB0aGlzIG1ha2VzIHN1cmUgdGhlIHBvcHBlciBoYXMgYWx3YXlzIGEgbGl0dGxlIHBhZGRpbmdcbiAgICAgKiBiZXR3ZWVuIHRoZSBlZGdlcyBvZiBpdHMgY29udGFpbmVyXG4gICAgICovXG4gICAgcGFkZGluZzogNSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7U3RyaW5nfEhUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudD0nc2Nyb2xsUGFyZW50J1xuICAgICAqIEJvdW5kYXJpZXMgdXNlZCBieSB0aGUgbW9kaWZpZXIsIGNhbiBiZSBgc2Nyb2xsUGFyZW50YCwgYHdpbmRvd2AsXG4gICAgICogYHZpZXdwb3J0YCBvciBhbnkgRE9NIGVsZW1lbnQuXG4gICAgICovXG4gICAgYm91bmRhcmllc0VsZW1lbnQ6ICdzY3JvbGxQYXJlbnQnXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gbWFrZSBzdXJlIHRoZSByZWZlcmVuY2UgYW5kIGl0cyBwb3BwZXIgc3RheSBuZWFyIGVhY2hvdGhlcnNcbiAgICogd2l0aG91dCBsZWF2aW5nIGFueSBnYXAgYmV0d2VlbiB0aGUgdHdvLiBFeHBlY2lhbGx5IHVzZWZ1bCB3aGVuIHRoZSBhcnJvdyBpc1xuICAgKiBlbmFibGVkIGFuZCB5b3Ugd2FudCB0byBhc3N1cmUgaXQgdG8gcG9pbnQgdG8gaXRzIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBJdCBjYXJlcyBvbmx5IGFib3V0IHRoZSBmaXJzdCBheGlzLCB5b3UgY2FuIHN0aWxsIGhhdmUgcG9wcGVycyB3aXRoIG1hcmdpblxuICAgKiBiZXR3ZWVuIHRoZSBwb3BwZXIgYW5kIGl0cyByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGtlZXBUb2dldGhlcjoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj00MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDQwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGtlZXBUb2dldGhlclxuICB9LFxuXG4gIC8qKlxuICAgKiBUaGlzIG1vZGlmaWVyIGlzIHVzZWQgdG8gbW92ZSB0aGUgYGFycm93RWxlbWVudGAgb2YgdGhlIHBvcHBlciB0byBtYWtlXG4gICAqIHN1cmUgaXQgaXMgcG9zaXRpb25lZCBiZXR3ZWVuIHRoZSByZWZlcmVuY2UgZWxlbWVudCBhbmQgaXRzIHBvcHBlciBlbGVtZW50LlxuICAgKiBJdCB3aWxsIHJlYWQgdGhlIG91dGVyIHNpemUgb2YgdGhlIGBhcnJvd0VsZW1lbnRgIG5vZGUgdG8gZGV0ZWN0IGhvdyBtYW55XG4gICAqIHBpeGVscyBvZiBjb25qdWN0aW9uIGFyZSBuZWVkZWQuXG4gICAqXG4gICAqIEl0IGhhcyBubyBlZmZlY3QgaWYgbm8gYGFycm93RWxlbWVudGAgaXMgcHJvdmlkZWQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBhcnJvdzoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj01MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDUwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGFycm93LFxuICAgIC8qKiBAcHJvcCB7U3RyaW5nfEhUTUxFbGVtZW50fSBlbGVtZW50PSdbeC1hcnJvd10nIC0gU2VsZWN0b3Igb3Igbm9kZSB1c2VkIGFzIGFycm93ICovXG4gICAgZWxlbWVudDogJ1t4LWFycm93XSdcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBmbGlwIHRoZSBwb3BwZXIncyBwbGFjZW1lbnQgd2hlbiBpdCBzdGFydHMgdG8gb3ZlcmxhcCBpdHNcbiAgICogcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqXG4gICAqIFJlcXVpcmVzIHRoZSBgcHJldmVudE92ZXJmbG93YCBtb2RpZmllciBiZWZvcmUgaXQgaW4gb3JkZXIgdG8gd29yay5cbiAgICpcbiAgICogKipOT1RFOioqIHRoaXMgbW9kaWZpZXIgd2lsbCBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgdXBkYXRlIGN5Y2xlIGFuZCB3aWxsXG4gICAqIHJlc3RhcnQgaXQgaWYgaXQgZGV0ZWN0cyB0aGUgbmVlZCB0byBmbGlwIHRoZSBwbGFjZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBmbGlwOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTYwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNjAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogZmxpcCxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7U3RyaW5nfEFycmF5fSBiZWhhdmlvcj0nZmxpcCdcbiAgICAgKiBUaGUgYmVoYXZpb3IgdXNlZCB0byBjaGFuZ2UgdGhlIHBvcHBlcidzIHBsYWNlbWVudC4gSXQgY2FuIGJlIG9uZSBvZlxuICAgICAqIGBmbGlwYCwgYGNsb2Nrd2lzZWAsIGBjb3VudGVyY2xvY2t3aXNlYCBvciBhbiBhcnJheSB3aXRoIGEgbGlzdCBvZiB2YWxpZFxuICAgICAqIHBsYWNlbWVudHMgKHdpdGggb3B0aW9uYWwgdmFyaWF0aW9ucykuXG4gICAgICovXG4gICAgYmVoYXZpb3I6ICdmbGlwJyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7bnVtYmVyfSBwYWRkaW5nPTVcbiAgICAgKiBUaGUgcG9wcGVyIHdpbGwgZmxpcCBpZiBpdCBoaXRzIHRoZSBlZGdlcyBvZiB0aGUgYGJvdW5kYXJpZXNFbGVtZW50YFxuICAgICAqL1xuICAgIHBhZGRpbmc6IDUsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQ9J3ZpZXdwb3J0J1xuICAgICAqIFRoZSBlbGVtZW50IHdoaWNoIHdpbGwgZGVmaW5lIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBwb3BwZXIgcG9zaXRpb24sXG4gICAgICogdGhlIHBvcHBlciB3aWxsIG5ldmVyIGJlIHBsYWNlZCBvdXRzaWRlIG9mIHRoZSBkZWZpbmVkIGJvdW5kYXJpZXNcbiAgICAgKiAoZXhjZXB0IGlmIGtlZXBUb2dldGhlciBpcyBlbmFibGVkKVxuICAgICAqL1xuICAgIGJvdW5kYXJpZXNFbGVtZW50OiAndmlld3BvcnQnXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gbWFrZSB0aGUgcG9wcGVyIGZsb3cgdG93YXJkIHRoZSBpbm5lciBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEJ5IGRlZmF1bHQsIHdoZW4gdGhpcyBtb2RpZmllciBpcyBkaXNhYmxlZCwgdGhlIHBvcHBlciB3aWxsIGJlIHBsYWNlZCBvdXRzaWRlXG4gICAqIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGlubmVyOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTcwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNzAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD1mYWxzZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogZmFsc2UsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBpbm5lclxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIGhpZGUgdGhlIHBvcHBlciB3aGVuIGl0cyByZWZlcmVuY2UgZWxlbWVudCBpcyBvdXRzaWRlIG9mIHRoZVxuICAgKiBwb3BwZXIgYm91bmRhcmllcy4gSXQgd2lsbCBzZXQgYSBgeC1vdXQtb2YtYm91bmRhcmllc2AgYXR0cmlidXRlIHdoaWNoIGNhblxuICAgKiBiZSB1c2VkIHRvIGhpZGUgd2l0aCBhIENTUyBzZWxlY3RvciB0aGUgcG9wcGVyIHdoZW4gaXRzIHJlZmVyZW5jZSBpc1xuICAgKiBvdXQgb2YgYm91bmRhcmllcy5cbiAgICpcbiAgICogUmVxdWlyZXMgdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIG1vZGlmaWVyIGJlZm9yZSBpdCBpbiBvcmRlciB0byB3b3JrLlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgaGlkZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj04MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDgwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGhpZGVcbiAgfSxcblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIHN0eWxlIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIgZWxlbWVudCB0byBnZXRzXG4gICAqIHByb3Blcmx5IHBvc2l0aW9uZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIG1vZGlmaWVyIHdpbGwgbm90IHRvdWNoIHRoZSBET00sIGl0IGp1c3QgcHJlcGFyZXMgdGhlIHN0eWxlc1xuICAgKiBzbyB0aGF0IGBhcHBseVN0eWxlYCBtb2RpZmllciBjYW4gYXBwbHkgaXQuIFRoaXMgc2VwYXJhdGlvbiBpcyB1c2VmdWxcbiAgICogaW4gY2FzZSB5b3UgbmVlZCB0byByZXBsYWNlIGBhcHBseVN0eWxlYCB3aXRoIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uLlxuICAgKlxuICAgKiBUaGlzIG1vZGlmaWVyIGhhcyBgODUwYCBhcyBgb3JkZXJgIHZhbHVlIHRvIG1haW50YWluIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICogd2l0aCBwcmV2aW91cyB2ZXJzaW9ucyBvZiBQb3BwZXIuanMuIEV4cGVjdCB0aGUgbW9kaWZpZXJzIG9yZGVyaW5nIG1ldGhvZFxuICAgKiB0byBjaGFuZ2UgaW4gZnV0dXJlIG1ham9yIHZlcnNpb25zIG9mIHRoZSBsaWJyYXJ5LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgY29tcHV0ZVN0eWxlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTg1MCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogODUwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogY29tcHV0ZVN0eWxlLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtCb29sZWFufSBncHVBY2NlbGVyYXRpb249dHJ1ZVxuICAgICAqIElmIHRydWUsIGl0IHVzZXMgdGhlIENTUyAzZCB0cmFuc2Zvcm1hdGlvbiB0byBwb3NpdGlvbiB0aGUgcG9wcGVyLlxuICAgICAqIE90aGVyd2lzZSwgaXQgd2lsbCB1c2UgdGhlIGB0b3BgIGFuZCBgbGVmdGAgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBncHVBY2NlbGVyYXRpb246IHRydWUsXG4gICAgLyoqXG4gICAgICogQHByb3Age3N0cmluZ30gW3g9J2JvdHRvbSddXG4gICAgICogV2hlcmUgdG8gYW5jaG9yIHRoZSBYIGF4aXMgKGBib3R0b21gIG9yIGB0b3BgKS4gQUtBIFggb2Zmc2V0IG9yaWdpbi5cbiAgICAgKiBDaGFuZ2UgdGhpcyBpZiB5b3VyIHBvcHBlciBzaG91bGQgZ3JvdyBpbiBhIGRpcmVjdGlvbiBkaWZmZXJlbnQgZnJvbSBgYm90dG9tYFxuICAgICAqL1xuICAgIHg6ICdib3R0b20nLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtzdHJpbmd9IFt4PSdsZWZ0J11cbiAgICAgKiBXaGVyZSB0byBhbmNob3IgdGhlIFkgYXhpcyAoYGxlZnRgIG9yIGByaWdodGApLiBBS0EgWSBvZmZzZXQgb3JpZ2luLlxuICAgICAqIENoYW5nZSB0aGlzIGlmIHlvdXIgcG9wcGVyIHNob3VsZCBncm93IGluIGEgZGlyZWN0aW9uIGRpZmZlcmVudCBmcm9tIGByaWdodGBcbiAgICAgKi9cbiAgICB5OiAncmlnaHQnXG4gIH0sXG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIGNvbXB1dGVkIHN0eWxlcyB0byB0aGUgcG9wcGVyIGVsZW1lbnQuXG4gICAqXG4gICAqIEFsbCB0aGUgRE9NIG1hbmlwdWxhdGlvbnMgYXJlIGxpbWl0ZWQgdG8gdGhpcyBtb2RpZmllci4gVGhpcyBpcyB1c2VmdWwgaW4gY2FzZVxuICAgKiB5b3Ugd2FudCB0byBpbnRlZ3JhdGUgUG9wcGVyLmpzIGluc2lkZSBhIGZyYW1ld29yayBvciB2aWV3IGxpYnJhcnkgYW5kIHlvdVxuICAgKiB3YW50IHRvIGRlbGVnYXRlIGFsbCB0aGUgRE9NIG1hbmlwdWxhdGlvbnMgdG8gaXQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBpZiB5b3UgZGlzYWJsZSB0aGlzIG1vZGlmaWVyLCB5b3UgbXVzdCBtYWtlIHN1cmUgdGhlIHBvcHBlciBlbGVtZW50XG4gICAqIGhhcyBpdHMgcG9zaXRpb24gc2V0IHRvIGBhYnNvbHV0ZWAgYmVmb3JlIFBvcHBlci5qcyBjYW4gZG8gaXRzIHdvcmshXG4gICAqXG4gICAqIEp1c3QgZGlzYWJsZSB0aGlzIG1vZGlmaWVyIGFuZCBkZWZpbmUgeW91IG93biB0byBhY2hpZXZlIHRoZSBkZXNpcmVkIGVmZmVjdC5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGFwcGx5U3R5bGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9OTAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA5MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBhcHBseVN0eWxlLFxuICAgIC8qKiBAcHJvcCB7RnVuY3Rpb259ICovXG4gICAgb25Mb2FkOiBhcHBseVN0eWxlT25Mb2FkLFxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS4xMC4wLCB0aGUgcHJvcGVydHkgbW92ZWQgdG8gYGNvbXB1dGVTdHlsZWAgbW9kaWZpZXJcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZ3B1QWNjZWxlcmF0aW9uPXRydWVcbiAgICAgKiBJZiB0cnVlLCBpdCB1c2VzIHRoZSBDU1MgM2QgdHJhbnNmb3JtYXRpb24gdG8gcG9zaXRpb24gdGhlIHBvcHBlci5cbiAgICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgdXNlIHRoZSBgdG9wYCBhbmQgYGxlZnRgIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiB1bmRlZmluZWRcbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgYGRhdGFPYmplY3RgIGlzIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgaW5mb3JtYXRpb25zIHVzZWQgYnkgUG9wcGVyLmpzXG4gKiB0aGlzIG9iamVjdCBnZXQgcGFzc2VkIHRvIG1vZGlmaWVycyBhbmQgdG8gdGhlIGBvbkNyZWF0ZWAgYW5kIGBvblVwZGF0ZWAgY2FsbGJhY2tzLlxuICogQG5hbWUgZGF0YU9iamVjdFxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuaW5zdGFuY2UgVGhlIFBvcHBlci5qcyBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGRhdGEucGxhY2VtZW50IFBsYWNlbWVudCBhcHBsaWVkIHRvIHBvcHBlclxuICogQHByb3BlcnR5IHtTdHJpbmd9IGRhdGEub3JpZ2luYWxQbGFjZW1lbnQgUGxhY2VtZW50IG9yaWdpbmFsbHkgZGVmaW5lZCBvbiBpbml0XG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRhdGEuZmxpcHBlZCBUcnVlIGlmIHBvcHBlciBoYXMgYmVlbiBmbGlwcGVkIGJ5IGZsaXAgbW9kaWZpZXJcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGF0YS5oaWRlIFRydWUgaWYgdGhlIHJlZmVyZW5jZSBlbGVtZW50IGlzIG91dCBvZiBib3VuZGFyaWVzLCB1c2VmdWwgdG8ga25vdyB3aGVuIHRvIGhpZGUgdGhlIHBvcHBlci5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IGRhdGEuYXJyb3dFbGVtZW50IE5vZGUgdXNlZCBhcyBhcnJvdyBieSBhcnJvdyBtb2RpZmllclxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuc3R5bGVzIEFueSBDU1MgcHJvcGVydHkgZGVmaW5lZCBoZXJlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLCBpdCBleHBlY3RzIHRoZSBKYXZhU2NyaXB0IG5vbWVuY2xhdHVyZSAoZWcuIGBtYXJnaW5Cb3R0b21gKVxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuYXJyb3dTdHlsZXMgQW55IENTUyBwcm9wZXJ0eSBkZWZpbmVkIGhlcmUgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIgYXJyb3csIGl0IGV4cGVjdHMgdGhlIEphdmFTY3JpcHQgbm9tZW5jbGF0dXJlIChlZy4gYG1hcmdpbkJvdHRvbWApXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5ib3VuZGFyaWVzIE9mZnNldHMgb2YgdGhlIHBvcHBlciBib3VuZGFyaWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzIFRoZSBtZWFzdXJlbWVudHMgb2YgcG9wcGVyLCByZWZlcmVuY2UgYW5kIGFycm93IGVsZW1lbnRzLlxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5wb3BwZXIgYHRvcGAsIGBsZWZ0YCwgYHdpZHRoYCwgYGhlaWdodGAgdmFsdWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSBgdG9wYCwgYGxlZnRgLCBgd2lkdGhgLCBgaGVpZ2h0YCB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMuYXJyb3ddIGB0b3BgIGFuZCBgbGVmdGAgb2Zmc2V0cywgb25seSBvbmUgb2YgdGhlbSB3aWxsIGJlIGRpZmZlcmVudCBmcm9tIDBcbiAqL1xuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucyBwcm92aWRlZCB0byBQb3BwZXIuanMgY29uc3RydWN0b3IuPGJyIC8+XG4gKiBUaGVzZSBjYW4gYmUgb3ZlcnJpZGVuIHVzaW5nIHRoZSBgb3B0aW9uc2AgYXJndW1lbnQgb2YgUG9wcGVyLmpzLjxiciAvPlxuICogVG8gb3ZlcnJpZGUgYW4gb3B0aW9uLCBzaW1wbHkgcGFzcyBhcyAzcmQgYXJndW1lbnQgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWVcbiAqIHN0cnVjdHVyZSBvZiB0aGlzIG9iamVjdCwgZXhhbXBsZTpcbiAqIGBgYFxuICogbmV3IFBvcHBlcihyZWYsIHBvcCwge1xuICogICBtb2RpZmllcnM6IHtcbiAqICAgICBwcmV2ZW50T3ZlcmZsb3c6IHsgZW5hYmxlZDogZmFsc2UgfVxuICogICB9XG4gKiB9KVxuICogYGBgXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHN0YXRpY1xuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG52YXIgRGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBQb3BwZXIncyBwbGFjZW1lbnRcbiAgICogQHByb3Age1BvcHBlci5wbGFjZW1lbnRzfSBwbGFjZW1lbnQ9J2JvdHRvbSdcbiAgICovXG4gIHBsYWNlbWVudDogJ2JvdHRvbScsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgZXZlbnRzIChyZXNpemUsIHNjcm9sbCkgYXJlIGluaXRpYWxseSBlbmFibGVkXG4gICAqIEBwcm9wIHtCb29sZWFufSBldmVudHNFbmFibGVkPXRydWVcbiAgICovXG4gIGV2ZW50c0VuYWJsZWQ6IHRydWUsXG5cbiAgLyoqXG4gICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgcmVtb3ZlIHRoZSBwb3BwZXIgd2hlblxuICAgKiB5b3UgY2FsbCB0aGUgYGRlc3Ryb3lgIG1ldGhvZC5cbiAgICogQHByb3Age0Jvb2xlYW59IHJlbW92ZU9uRGVzdHJveT1mYWxzZVxuICAgKi9cbiAgcmVtb3ZlT25EZXN0cm95OiBmYWxzZSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHBvcHBlciBpcyBjcmVhdGVkLjxiciAvPlxuICAgKiBCeSBkZWZhdWx0LCBpcyBzZXQgdG8gbm8tb3AuPGJyIC8+XG4gICAqIEFjY2VzcyBQb3BwZXIuanMgaW5zdGFuY2Ugd2l0aCBgZGF0YS5pbnN0YW5jZWAuXG4gICAqIEBwcm9wIHtvbkNyZWF0ZX1cbiAgICovXG4gIG9uQ3JlYXRlOiBmdW5jdGlvbiBvbkNyZWF0ZSgpIHt9LFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBjYWxsZWQgd2hlbiB0aGUgcG9wcGVyIGlzIHVwZGF0ZWQsIHRoaXMgY2FsbGJhY2sgaXMgbm90IGNhbGxlZFxuICAgKiBvbiB0aGUgaW5pdGlhbGl6YXRpb24vY3JlYXRpb24gb2YgdGhlIHBvcHBlciwgYnV0IG9ubHkgb24gc3Vic2VxdWVudFxuICAgKiB1cGRhdGVzLjxiciAvPlxuICAgKiBCeSBkZWZhdWx0LCBpcyBzZXQgdG8gbm8tb3AuPGJyIC8+XG4gICAqIEFjY2VzcyBQb3BwZXIuanMgaW5zdGFuY2Ugd2l0aCBgZGF0YS5pbnN0YW5jZWAuXG4gICAqIEBwcm9wIHtvblVwZGF0ZX1cbiAgICovXG4gIG9uVXBkYXRlOiBmdW5jdGlvbiBvblVwZGF0ZSgpIHt9LFxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIG1vZGlmaWVycyB1c2VkIHRvIG1vZGlmeSB0aGUgb2Zmc2V0cyBiZWZvcmUgdGhleSBhcmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLlxuICAgKiBUaGV5IHByb3ZpZGUgbW9zdCBvZiB0aGUgZnVuY3Rpb25hbGl0aWVzIG9mIFBvcHBlci5qc1xuICAgKiBAcHJvcCB7bW9kaWZpZXJzfVxuICAgKi9cbiAgbW9kaWZpZXJzOiBtb2RpZmllcnNcbn07XG5cbi8qKlxuICogQGNhbGxiYWNrIG9uQ3JlYXRlXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBvblVwZGF0ZVxuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKi9cblxuLy8gVXRpbHNcbi8vIE1ldGhvZHNcbnZhciBQb3BwZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgUG9wcGVyLmpzIGluc3RhbmNlXG4gICAqIEBjbGFzcyBQb3BwZXJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxyZWZlcmVuY2VPYmplY3R9IHJlZmVyZW5jZSAtIFRoZSByZWZlcmVuY2UgZWxlbWVudCB1c2VkIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyIC0gVGhlIEhUTUwgZWxlbWVudCB1c2VkIGFzIHBvcHBlci5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBZb3VyIGN1c3RvbSBvcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBvbmVzIGRlZmluZWQgaW4gW0RlZmF1bHRzXSgjZGVmYXVsdHMpXG4gICAqIEByZXR1cm4ge09iamVjdH0gaW5zdGFuY2UgLSBUaGUgZ2VuZXJhdGVkIFBvcHBlci5qcyBpbnN0YW5jZVxuICAgKi9cbiAgZnVuY3Rpb24gUG9wcGVyKHJlZmVyZW5jZSwgcG9wcGVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQb3BwZXIpO1xuXG4gICAgdGhpcy5zY2hlZHVsZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX3RoaXMudXBkYXRlKTtcbiAgICB9O1xuXG4gICAgLy8gbWFrZSB1cGRhdGUoKSBkZWJvdW5jZWQsIHNvIHRoYXQgaXQgb25seSBydW5zIGF0IG1vc3Qgb25jZS1wZXItdGlja1xuICAgIHRoaXMudXBkYXRlID0gZGVib3VuY2UodGhpcy51cGRhdGUuYmluZCh0aGlzKSk7XG5cbiAgICAvLyB3aXRoIHt9IHdlIGNyZWF0ZSBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgb3B0aW9ucyBpbnNpZGUgaXRcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgUG9wcGVyLkRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgIC8vIGluaXQgc3RhdGVcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgaXNEZXN0cm95ZWQ6IGZhbHNlLFxuICAgICAgaXNDcmVhdGVkOiBmYWxzZSxcbiAgICAgIHNjcm9sbFBhcmVudHM6IFtdXG4gICAgfTtcblxuICAgIC8vIGdldCByZWZlcmVuY2UgYW5kIHBvcHBlciBlbGVtZW50cyAoYWxsb3cgalF1ZXJ5IHdyYXBwZXJzKVxuICAgIHRoaXMucmVmZXJlbmNlID0gcmVmZXJlbmNlICYmIHJlZmVyZW5jZS5qcXVlcnkgPyByZWZlcmVuY2VbMF0gOiByZWZlcmVuY2U7XG4gICAgdGhpcy5wb3BwZXIgPSBwb3BwZXIgJiYgcG9wcGVyLmpxdWVyeSA/IHBvcHBlclswXSA6IHBvcHBlcjtcblxuICAgIC8vIERlZXAgbWVyZ2UgbW9kaWZpZXJzIG9wdGlvbnNcbiAgICB0aGlzLm9wdGlvbnMubW9kaWZpZXJzID0ge307XG4gICAgT2JqZWN0LmtleXMoX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cy5tb2RpZmllcnMsIG9wdGlvbnMubW9kaWZpZXJzKSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgX3RoaXMub3B0aW9ucy5tb2RpZmllcnNbbmFtZV0gPSBfZXh0ZW5kcyh7fSwgUG9wcGVyLkRlZmF1bHRzLm1vZGlmaWVyc1tuYW1lXSB8fCB7fSwgb3B0aW9ucy5tb2RpZmllcnMgPyBvcHRpb25zLm1vZGlmaWVyc1tuYW1lXSA6IHt9KTtcbiAgICB9KTtcblxuICAgIC8vIFJlZmFjdG9yaW5nIG1vZGlmaWVycycgbGlzdCAoT2JqZWN0ID0+IEFycmF5KVxuICAgIHRoaXMubW9kaWZpZXJzID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zLm1vZGlmaWVycykubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICBuYW1lOiBuYW1lXG4gICAgICB9LCBfdGhpcy5vcHRpb25zLm1vZGlmaWVyc1tuYW1lXSk7XG4gICAgfSlcbiAgICAvLyBzb3J0IHRoZSBtb2RpZmllcnMgYnkgb3JkZXJcbiAgICAuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEub3JkZXIgLSBiLm9yZGVyO1xuICAgIH0pO1xuXG4gICAgLy8gbW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgY29kZSB3aGVuIFBvcHBlci5qcyBnZXQgaW5pdGVkXG4gICAgLy8gc3VjaCBjb2RlIGlzIGV4ZWN1dGVkIGluIHRoZSBzYW1lIG9yZGVyIG9mIGl0cyBtb2RpZmllclxuICAgIC8vIHRoZXkgY291bGQgYWRkIG5ldyBwcm9wZXJ0aWVzIHRvIHRoZWlyIG9wdGlvbnMgY29uZmlndXJhdGlvblxuICAgIC8vIEJFIEFXQVJFOiBkb24ndCBhZGQgb3B0aW9ucyB0byBgb3B0aW9ucy5tb2RpZmllcnMubmFtZWAgYnV0IHRvIGBtb2RpZmllck9wdGlvbnNgIVxuICAgIHRoaXMubW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyT3B0aW9ucykge1xuICAgICAgaWYgKG1vZGlmaWVyT3B0aW9ucy5lbmFibGVkICYmIGlzRnVuY3Rpb24obW9kaWZpZXJPcHRpb25zLm9uTG9hZCkpIHtcbiAgICAgICAgbW9kaWZpZXJPcHRpb25zLm9uTG9hZChfdGhpcy5yZWZlcmVuY2UsIF90aGlzLnBvcHBlciwgX3RoaXMub3B0aW9ucywgbW9kaWZpZXJPcHRpb25zLCBfdGhpcy5zdGF0ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBmaXJlIHRoZSBmaXJzdCB1cGRhdGUgdG8gcG9zaXRpb24gdGhlIHBvcHBlciBpbiB0aGUgcmlnaHQgcGxhY2VcbiAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgdmFyIGV2ZW50c0VuYWJsZWQgPSB0aGlzLm9wdGlvbnMuZXZlbnRzRW5hYmxlZDtcbiAgICBpZiAoZXZlbnRzRW5hYmxlZCkge1xuICAgICAgLy8gc2V0dXAgZXZlbnQgbGlzdGVuZXJzLCB0aGV5IHdpbGwgdGFrZSBjYXJlIG9mIHVwZGF0ZSB0aGUgcG9zaXRpb24gaW4gc3BlY2lmaWMgc2l0dWF0aW9uc1xuICAgICAgdGhpcy5lbmFibGVFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCA9IGV2ZW50c0VuYWJsZWQ7XG4gIH1cblxuICAvLyBXZSBjYW4ndCB1c2UgY2xhc3MgcHJvcGVydGllcyBiZWNhdXNlIHRoZXkgZG9uJ3QgZ2V0IGxpc3RlZCBpbiB0aGVcbiAgLy8gY2xhc3MgcHJvdG90eXBlIGFuZCBicmVhayBzdHVmZiBsaWtlIFNpbm9uIHN0dWJzXG5cblxuICBjcmVhdGVDbGFzcyhQb3BwZXIsIFt7XG4gICAga2V5OiAndXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlJCQxKCkge1xuICAgICAgcmV0dXJuIHVwZGF0ZS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95JCQxKCkge1xuICAgICAgcmV0dXJuIGRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdlbmFibGVFdmVudExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZUV2ZW50TGlzdGVuZXJzJCQxKCkge1xuICAgICAgcmV0dXJuIGVuYWJsZUV2ZW50TGlzdGVuZXJzLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGlzYWJsZUV2ZW50TGlzdGVuZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZUV2ZW50TGlzdGVuZXJzJCQxKCkge1xuICAgICAgcmV0dXJuIGRpc2FibGVFdmVudExpc3RlbmVycy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlIGFuIHVwZGF0ZSwgaXQgd2lsbCBydW4gb24gdGhlIG5leHQgVUkgdXBkYXRlIGF2YWlsYWJsZVxuICAgICAqIEBtZXRob2Qgc2NoZWR1bGVVcGRhdGVcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIENvbGxlY3Rpb24gb2YgdXRpbGl0aWVzIHVzZWZ1bCB3aGVuIHdyaXRpbmcgY3VzdG9tIG1vZGlmaWVycy5cbiAgICAgKiBTdGFydGluZyBmcm9tIHZlcnNpb24gMS43LCB0aGlzIG1ldGhvZCBpcyBhdmFpbGFibGUgb25seSBpZiB5b3VcbiAgICAgKiBpbmNsdWRlIGBwb3BwZXItdXRpbHMuanNgIGJlZm9yZSBgcG9wcGVyLmpzYC5cbiAgICAgKlxuICAgICAqICoqREVQUkVDQVRJT04qKjogVGhpcyB3YXkgdG8gYWNjZXNzIFBvcHBlclV0aWxzIGlzIGRlcHJlY2F0ZWRcbiAgICAgKiBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHYyISBVc2UgdGhlIFBvcHBlclV0aWxzIG1vZHVsZSBkaXJlY3RseSBpbnN0ZWFkLlxuICAgICAqIER1ZSB0byB0aGUgaGlnaCBpbnN0YWJpbGl0eSBvZiB0aGUgbWV0aG9kcyBjb250YWluZWQgaW4gVXRpbHMsIHdlIGNhbid0XG4gICAgICogZ3VhcmFudGVlIHRoZW0gdG8gZm9sbG93IHNlbXZlci4gVXNlIHRoZW0gYXQgeW91ciBvd24gcmlzayFcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS44XG4gICAgICogQG1lbWJlciBVdGlsc1xuICAgICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICAgKi9cblxuICB9XSk7XG4gIHJldHVybiBQb3BwZXI7XG59KCk7XG5cbi8qKlxuICogVGhlIGByZWZlcmVuY2VPYmplY3RgIGlzIGFuIG9iamVjdCB0aGF0IHByb3ZpZGVzIGFuIGludGVyZmFjZSBjb21wYXRpYmxlIHdpdGggUG9wcGVyLmpzXG4gKiBhbmQgbGV0cyB5b3UgdXNlIGl0IGFzIHJlcGxhY2VtZW50IG9mIGEgcmVhbCBET00gbm9kZS48YnIgLz5cbiAqIFlvdSBjYW4gdXNlIHRoaXMgbWV0aG9kIHRvIHBvc2l0aW9uIGEgcG9wcGVyIHJlbGF0aXZlbHkgdG8gYSBzZXQgb2YgY29vcmRpbmF0ZXNcbiAqIGluIGNhc2UgeW91IGRvbid0IGhhdmUgYSBET00gbm9kZSB0byB1c2UgYXMgcmVmZXJlbmNlLlxuICpcbiAqIGBgYFxuICogbmV3IFBvcHBlcihyZWZlcmVuY2VPYmplY3QsIHBvcHBlck5vZGUpO1xuICogYGBgXG4gKlxuICogTkI6IFRoaXMgZmVhdHVyZSBpc24ndCBzdXBwb3J0ZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTBcbiAqIEBuYW1lIHJlZmVyZW5jZU9iamVjdFxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZGF0YS5nZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc2V0IG9mIGNvb3JkaW5hdGVzIGNvbXBhdGlibGUgd2l0aCB0aGUgbmF0aXZlIGBnZXRCb3VuZGluZ0NsaWVudFJlY3RgIG1ldGhvZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhLmNsaWVudFdpZHRoXG4gKiBBbiBFUzYgZ2V0dGVyIHRoYXQgd2lsbCByZXR1cm4gdGhlIHdpZHRoIG9mIHRoZSB2aXJ0dWFsIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGEuY2xpZW50SGVpZ2h0XG4gKiBBbiBFUzYgZ2V0dGVyIHRoYXQgd2lsbCByZXR1cm4gdGhlIGhlaWdodCBvZiB0aGUgdmlydHVhbCByZWZlcmVuY2UgZWxlbWVudC5cbiAqL1xuXG5cblBvcHBlci5VdGlscyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbCkuUG9wcGVyVXRpbHM7XG5Qb3BwZXIucGxhY2VtZW50cyA9IHBsYWNlbWVudHM7XG5Qb3BwZXIuRGVmYXVsdHMgPSBEZWZhdWx0cztcblxucmV0dXJuIFBvcHBlcjtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvcHBlci5qcy5tYXBcbiIsIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBnbG9iYWwsIGRlZmluZSwgU3lzdGVtLCBSZWZsZWN0LCBQcm9taXNlICovXHJcbnZhciBfX2V4dGVuZHM7XHJcbnZhciBfX2Fzc2lnbjtcclxudmFyIF9fcmVzdDtcclxudmFyIF9fZGVjb3JhdGU7XHJcbnZhciBfX3BhcmFtO1xyXG52YXIgX19tZXRhZGF0YTtcclxudmFyIF9fYXdhaXRlcjtcclxudmFyIF9fZ2VuZXJhdG9yO1xyXG52YXIgX19leHBvcnRTdGFyO1xyXG52YXIgX192YWx1ZXM7XHJcbnZhciBfX3JlYWQ7XHJcbnZhciBfX3NwcmVhZDtcclxudmFyIF9fYXdhaXQ7XHJcbnZhciBfX2FzeW5jR2VuZXJhdG9yO1xyXG52YXIgX19hc3luY0RlbGVnYXRvcjtcclxudmFyIF9fYXN5bmNWYWx1ZXM7XHJcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdDtcclxuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XHJcbiAgICB2YXIgcm9vdCA9IHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0eXBlb2YgdGhpcyA9PT0gXCJvYmplY3RcIiA/IHRoaXMgOiB7fTtcclxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShcInRzbGliXCIsIFtcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChleHBvcnRzKSB7IGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCwgY3JlYXRlRXhwb3J0ZXIoZXhwb3J0cykpKTsgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCwgY3JlYXRlRXhwb3J0ZXIobW9kdWxlLmV4cG9ydHMpKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUV4cG9ydGVyKGV4cG9ydHMsIHByZXZpb3VzKSB7XHJcbiAgICAgICAgaWYgKGV4cG9ydHMgIT09IHJvb3QpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpZCwgdikgeyByZXR1cm4gZXhwb3J0c1tpZF0gPSBwcmV2aW91cyA/IHByZXZpb3VzKGlkLCB2KSA6IHY7IH07XHJcbiAgICB9XHJcbn0pXHJcbihmdW5jdGlvbiAoZXhwb3J0ZXIpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG5cclxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcblxyXG4gICAgX19yZXN0ID0gZnVuY3Rpb24gKHMsIGUpIHtcclxuICAgICAgICB2YXIgdCA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgICAgICB0W3BdID0gc1twXTtcclxuICAgICAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIGlmIChlLmluZGV4T2YocFtpXSkgPCAwKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZGVjb3JhdGUgPSBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgICAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgICAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3BhcmFtID0gZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX21ldGFkYXRhID0gZnVuY3Rpb24gKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxuICAgIH07XHJcblxyXG4gICAgX19hd2FpdGVyID0gZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZ2VuZXJhdG9yID0gZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgICAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZXhwb3J0U3RhciA9IGZ1bmN0aW9uIChtLCBleHBvcnRzKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3ZhbHVlcyA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcclxuICAgICAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgX19yZWFkID0gZnVuY3Rpb24gKG8sIG4pIHtcclxuICAgICAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICAgICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgICAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFyO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3NwcmVhZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgICAgIHJldHVybiBhcjtcclxuICAgIH07XHJcblxyXG4gICAgX19hd2FpdCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXN5bmNHZW5lcmF0b3IgPSBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgICAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICAgICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jRGVsZWdhdG9yID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICB2YXIgaSwgcDtcclxuICAgICAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpZiAob1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jVmFsdWVzID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl07XHJcbiAgICAgICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fbWFrZVRlbXBsYXRlT2JqZWN0ID0gZnVuY3Rpb24gKGNvb2tlZCwgcmF3KSB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgICAgICByZXR1cm4gY29va2VkO1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRlcihcIl9fZXh0ZW5kc1wiLCBfX2V4dGVuZHMpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2Fzc2lnblwiLCBfX2Fzc2lnbik7XHJcbiAgICBleHBvcnRlcihcIl9fcmVzdFwiLCBfX3Jlc3QpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2RlY29yYXRlXCIsIF9fZGVjb3JhdGUpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3BhcmFtXCIsIF9fcGFyYW0pO1xyXG4gICAgZXhwb3J0ZXIoXCJfX21ldGFkYXRhXCIsIF9fbWV0YWRhdGEpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2F3YWl0ZXJcIiwgX19hd2FpdGVyKTtcclxuICAgIGV4cG9ydGVyKFwiX19nZW5lcmF0b3JcIiwgX19nZW5lcmF0b3IpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2V4cG9ydFN0YXJcIiwgX19leHBvcnRTdGFyKTtcclxuICAgIGV4cG9ydGVyKFwiX192YWx1ZXNcIiwgX192YWx1ZXMpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3JlYWRcIiwgX19yZWFkKTtcclxuICAgIGV4cG9ydGVyKFwiX19zcHJlYWRcIiwgX19zcHJlYWQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2F3YWl0XCIsIF9fYXdhaXQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2FzeW5jR2VuZXJhdG9yXCIsIF9fYXN5bmNHZW5lcmF0b3IpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2FzeW5jRGVsZWdhdG9yXCIsIF9fYXN5bmNEZWxlZ2F0b3IpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2FzeW5jVmFsdWVzXCIsIF9fYXN5bmNWYWx1ZXMpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX21ha2VUZW1wbGF0ZU9iamVjdFwiLCBfX21ha2VUZW1wbGF0ZU9iamVjdCk7XHJcbn0pO1xyXG4iXX0=
;